diff --git a/analyze.json b/analyze.json
index a4d38f8f0bd4f6ddc43e859eb39a82f702e800aa..66f374b59de0f454e6d3002a305e7099b5074d7f 100644
--- a/analyze.json
+++ b/analyze.json
@@ -5,7 +5,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/announcer.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/announcer.tsx"
       },
       "name": "MediaAnnouncer",
       "displayName": "MediaAnnouncer",
@@ -33,7 +33,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/audio-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/audio-layout.tsx"
       },
       "name": "DefaultAudioLayout",
       "displayName": "DefaultAudioLayout",
@@ -299,7 +299,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/audio-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/audio-layout.tsx"
       },
       "name": "AudioLayout",
       "displayName": "AudioLayout"
@@ -307,7 +307,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/audio-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/audio-layout.tsx"
       },
       "name": "DefaultAudioMenus",
       "displayName": "DefaultAudioMenus",
@@ -326,7 +326,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/audio-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/audio-layout.tsx"
       },
       "name": "DefaultAudioTitle",
       "displayName": "DefaultAudioTitle"
@@ -334,7 +334,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/audio-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/audio-layout.tsx"
       },
       "name": "AudioTitle",
       "displayName": "AudioTitle",
@@ -361,7 +361,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/announcer.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/announcer.tsx"
       },
       "name": "DefaultAnnouncer",
       "displayName": "DefaultAnnouncer"
@@ -369,7 +369,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultPlayButton",
       "displayName": "DefaultPlayButton",
@@ -388,7 +388,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultMuteButton",
       "displayName": "DefaultMuteButton",
@@ -414,7 +414,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultCaptionButton",
       "displayName": "DefaultCaptionButton",
@@ -433,7 +433,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultPIPButton",
       "displayName": "DefaultPIPButton",
@@ -452,7 +452,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultFullscreenButton",
       "displayName": "DefaultFullscreenButton",
@@ -471,7 +471,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultSeekButton",
       "displayName": "DefaultSeekButton",
@@ -498,7 +498,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultAirPlayButton",
       "displayName": "DefaultAirPlayButton",
@@ -517,7 +517,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultGoogleCastButton",
       "displayName": "DefaultGoogleCastButton",
@@ -536,7 +536,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultLiveButton",
       "displayName": "DefaultLiveButton"
@@ -544,7 +544,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/buttons.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/buttons.tsx"
       },
       "name": "DefaultDownloadButton",
       "displayName": "DefaultDownloadButton"
@@ -552,7 +552,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/captions.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/captions.tsx"
       },
       "name": "DefaultCaptions",
       "displayName": "DefaultCaptions"
@@ -560,7 +560,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/controls.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/controls.tsx"
       },
       "name": "DefaultControlsSpacer",
       "displayName": "DefaultControlsSpacer"
@@ -568,7 +568,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/keyboard-display.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/keyboard-display.tsx"
       },
       "name": "DefaultKeyboardDisplay",
       "displayName": "DefaultKeyboardDisplay",
@@ -603,7 +603,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/accessibility-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/accessibility-menu.tsx"
       },
       "name": "DefaultAccessibilityMenu",
       "displayName": "DefaultAccessibilityMenu",
@@ -622,7 +622,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/accessibility-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/accessibility-menu.tsx"
       },
       "name": "DefaultAnnouncementsMenuCheckbox",
       "displayName": "DefaultAnnouncementsMenuCheckbox"
@@ -630,7 +630,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/accessibility-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/accessibility-menu.tsx"
       },
       "name": "DefaultKeyboardAnimationsMenuCheckbox",
       "displayName": "DefaultKeyboardAnimationsMenuCheckbox"
@@ -638,7 +638,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/audio-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/audio-menu.tsx"
       },
       "name": "DefaultAudioMenu",
       "displayName": "DefaultAudioMenu",
@@ -657,7 +657,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/audio-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/audio-menu.tsx"
       },
       "name": "DefaultAudioBoostMenuSection",
       "displayName": "DefaultAudioBoostMenuSection"
@@ -665,7 +665,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/audio-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/audio-menu.tsx"
       },
       "name": "DefaultAudioGainSlider",
       "displayName": "DefaultAudioGainSlider"
@@ -673,7 +673,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/audio-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/audio-menu.tsx"
       },
       "name": "DefaultAudioTracksMenu",
       "displayName": "DefaultAudioTracksMenu"
@@ -681,7 +681,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/captions-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/captions-menu.tsx"
       },
       "name": "DefaultCaptionMenu",
       "displayName": "DefaultCaptionMenu",
@@ -700,7 +700,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/chapters-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/chapters-menu.tsx"
       },
       "name": "DefaultChaptersMenu",
       "displayName": "DefaultChaptersMenu",
@@ -743,7 +743,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultFontMenu",
       "displayName": "DefaultFontMenu"
@@ -751,7 +751,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultFontFamilyMenu",
       "displayName": "DefaultFontFamilyMenu"
@@ -759,7 +759,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultFontSizeSlider",
       "displayName": "DefaultFontSizeSlider"
@@ -767,7 +767,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultTextColorInput",
       "displayName": "DefaultTextColorInput"
@@ -775,7 +775,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultTextOpacitySlider",
       "displayName": "DefaultTextOpacitySlider"
@@ -783,7 +783,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultTextShadowMenu",
       "displayName": "DefaultTextShadowMenu"
@@ -791,7 +791,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultTextBgInput",
       "displayName": "DefaultTextBgInput"
@@ -799,7 +799,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultTextBgOpacitySlider",
       "displayName": "DefaultTextBgOpacitySlider"
@@ -807,7 +807,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultDisplayBgInput",
       "displayName": "DefaultDisplayBgInput"
@@ -815,7 +815,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultDisplayBgOpacitySlider",
       "displayName": "DefaultDisplayBgOpacitySlider"
@@ -823,7 +823,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultFontSetting",
       "displayName": "DefaultFontSetting",
@@ -832,7 +832,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultFontRadioGroup",
       "displayName": "DefaultFontRadioGroup",
@@ -895,7 +895,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/font-menu.tsx"
       },
       "name": "DefaultResetMenuItem",
       "displayName": "DefaultResetMenuItem"
@@ -903,7 +903,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/items/menu-checkbox.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/items/menu-checkbox.tsx"
       },
       "name": "DefaultMenuCheckbox",
       "displayName": "DefaultMenuCheckbox",
@@ -974,7 +974,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/items/menu-items.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/items/menu-items.tsx"
       },
       "name": "DefaultMenuSection",
       "displayName": "DefaultMenuSection",
@@ -1009,7 +1009,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/items/menu-items.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/items/menu-items.tsx"
       },
       "name": "DefaultMenuButton",
       "displayName": "DefaultMenuButton",
@@ -1052,7 +1052,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/items/menu-items.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/items/menu-items.tsx"
       },
       "name": "DefaultMenuItem",
       "displayName": "DefaultMenuItem",
@@ -1079,7 +1079,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/items/menu-items.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/items/menu-items.tsx"
       },
       "name": "DefaultMenuRadioGroup",
       "displayName": "DefaultMenuRadioGroup",
@@ -1126,7 +1126,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/items/menu-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/items/menu-slider.tsx"
       },
       "name": "DefaultMenuSliderItem",
       "displayName": "DefaultMenuSliderItem",
@@ -1193,7 +1193,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/items/menu-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/items/menu-slider.tsx"
       },
       "name": "DefaultSliderParts",
       "displayName": "DefaultSliderParts"
@@ -1201,7 +1201,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/items/menu-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/items/menu-slider.tsx"
       },
       "name": "DefaultSliderSteps",
       "displayName": "DefaultSliderSteps"
@@ -1209,7 +1209,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
       },
       "name": "DefaultPlaybackMenu",
       "displayName": "DefaultPlaybackMenu",
@@ -1228,7 +1228,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
       },
       "name": "DefaultLoopMenuCheckbox",
       "displayName": "DefaultLoopMenuCheckbox"
@@ -1236,7 +1236,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
       },
       "name": "DefaultAutoQualityMenuCheckbox",
       "displayName": "DefaultAutoQualityMenuCheckbox"
@@ -1244,7 +1244,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
       },
       "name": "DefaultQualityMenuSection",
       "displayName": "DefaultQualityMenuSection"
@@ -1252,7 +1252,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
       },
       "name": "DefaultQualitySlider",
       "displayName": "DefaultQualitySlider"
@@ -1260,14 +1260,14 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
       },
       "name": "DefaultSpeedMenuSection"
     },
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/playback-menu.tsx"
       },
       "name": "DefaultSpeedSlider",
       "displayName": "DefaultSpeedSlider"
@@ -1275,7 +1275,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/menus/settings-menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/menus/settings-menu.tsx"
       },
       "name": "DefaultSettingsMenu",
       "displayName": "DefaultSettingsMenu",
@@ -1318,7 +1318,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/sliders.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/sliders.tsx"
       },
       "name": "DefaultVolumePopup",
       "displayName": "DefaultVolumePopup",
@@ -1353,7 +1353,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/sliders.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/sliders.tsx"
       },
       "name": "DefaultVolumeSlider",
       "displayName": "DefaultVolumeSlider",
@@ -1382,7 +1382,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/sliders.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/sliders.tsx"
       },
       "name": "DefaultTimeSlider",
       "displayName": "DefaultTimeSlider"
@@ -1390,7 +1390,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/time.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/time.tsx"
       },
       "name": "DefaultTimeGroup",
       "displayName": "DefaultTimeGroup",
@@ -1409,7 +1409,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/time.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/time.tsx"
       },
       "name": "DefaultTimeInfo",
       "displayName": "DefaultTimeInfo",
@@ -1428,7 +1428,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/time.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/time.tsx"
       },
       "name": "DefaultTimeInvert",
       "displayName": "DefaultTimeInvert",
@@ -1447,7 +1447,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/title.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/title.tsx"
       },
       "name": "DefaultTitle",
       "displayName": "DefaultTitle"
@@ -1455,7 +1455,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/ui/tooltip.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/ui/tooltip.tsx"
       },
       "name": "DefaultTooltip",
       "displayName": "DefaultTooltip",
@@ -1490,7 +1490,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultVideoLayout",
       "displayName": "DefaultVideoLayout",
@@ -1756,7 +1756,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "VideoLayout",
       "displayName": "VideoLayout",
@@ -1765,7 +1765,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultVideoLargeLayout",
       "displayName": "DefaultVideoLargeLayout"
@@ -1773,7 +1773,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultVideoSmallLayout",
       "displayName": "DefaultVideoSmallLayout"
@@ -1781,7 +1781,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultVideoStartDuration",
       "displayName": "DefaultVideoStartDuration"
@@ -1789,7 +1789,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultVideoGestures",
       "displayName": "DefaultVideoGestures"
@@ -1797,7 +1797,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultBufferingIndicator",
       "displayName": "DefaultBufferingIndicator"
@@ -1805,7 +1805,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultVideoMenus",
       "displayName": "DefaultVideoMenus",
@@ -1824,7 +1824,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultVideoLoadLayout",
       "displayName": "DefaultVideoLoadLayout"
@@ -1832,7 +1832,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/default/video-layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/default/video-layout.tsx"
       },
       "name": "DefaultVideoKeyboardDisplay",
       "displayName": "DefaultVideoKeyboardDisplay"
@@ -1840,7 +1840,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrLayout",
       "displayName": "PlyrLayout",
@@ -2008,7 +2008,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrAudioLayout",
       "displayName": "PlyrAudioLayout"
@@ -2016,7 +2016,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrVideoLayout",
       "displayName": "PlyrVideoLayout"
@@ -2024,7 +2024,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrPlayLargeButton",
       "displayName": "PlyrPlayLargeButton"
@@ -2032,7 +2032,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrPreviewScrubbing",
       "displayName": "PlyrPreviewScrubbing"
@@ -2040,7 +2040,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrPoster",
       "displayName": "PlyrPoster"
@@ -2048,7 +2048,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrAudioControls",
       "displayName": "PlyrAudioControls"
@@ -2056,7 +2056,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrVideoControls",
       "displayName": "PlyrVideoControls"
@@ -2064,7 +2064,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrAirPlayButton",
       "displayName": "PlyrAirPlayButton"
@@ -2072,7 +2072,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrCaptionsButton",
       "displayName": "PlyrCaptionsButton"
@@ -2080,7 +2080,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrFullscreenButton",
       "displayName": "PlyrFullscreenButton"
@@ -2088,7 +2088,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrPIPButton",
       "displayName": "PlyrPIPButton"
@@ -2096,7 +2096,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrMuteButton",
       "displayName": "PlyrMuteButton"
@@ -2104,7 +2104,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrPlayButton",
       "displayName": "PlyrPlayButton"
@@ -2112,7 +2112,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrRestartButton",
       "displayName": "PlyrRestartButton"
@@ -2120,7 +2120,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrFastForwardButton",
       "displayName": "PlyrFastForwardButton"
@@ -2128,7 +2128,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrRewindButton",
       "displayName": "PlyrRewindButton"
@@ -2136,7 +2136,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrTimeSlider",
       "displayName": "PlyrTimeSlider"
@@ -2144,7 +2144,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrVolumeSlider",
       "displayName": "PlyrVolumeSlider"
@@ -2152,7 +2152,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrVolume",
       "displayName": "PlyrVolume",
@@ -2171,7 +2171,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrCurrentTime",
       "displayName": "PlyrCurrentTime"
@@ -2179,7 +2179,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrDuration",
       "displayName": "PlyrDuration"
@@ -2187,7 +2187,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrDownloadButton",
       "displayName": "PlyrDownloadButton"
@@ -2195,7 +2195,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrGestures",
       "displayName": "PlyrGestures"
@@ -2203,7 +2203,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrCaptions",
       "displayName": "PlyrCaptions"
@@ -2211,7 +2211,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrSettings",
       "displayName": "PlyrSettings"
@@ -2219,7 +2219,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrMenuButton",
       "displayName": "PlyrMenuButton",
@@ -2262,7 +2262,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrMenu",
       "displayName": "PlyrMenu",
@@ -2305,7 +2305,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrAudioMenu",
       "displayName": "PlyrAudioMenu"
@@ -2313,7 +2313,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrSpeedMenu",
       "displayName": "PlyrSpeedMenu"
@@ -2321,7 +2321,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrCaptionsMenu",
       "displayName": "PlyrCaptionsMenu"
@@ -2329,7 +2329,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/layouts/plyr/layout.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/layouts/plyr/layout.tsx"
       },
       "name": "PlyrQualityMenu",
       "displayName": "PlyrQualityMenu"
@@ -2337,7 +2337,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/player.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/player.tsx"
       },
       "name": "MediaPlayer",
       "displayName": "MediaPlayer",
@@ -2407,7 +2407,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/primitives/nodes.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/primitives/nodes.tsx"
       },
       "name": "Primitive",
       "propsType": "Primitives"
@@ -2415,7 +2415,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/primitives/slot.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/primitives/slot.tsx"
       },
       "namespace": "Slot",
       "name": "Slot",
@@ -2443,7 +2443,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/primitives/slot.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/primitives/slot.tsx"
       },
       "name": "SlotClone",
       "displayName": "SlotClone",
@@ -2469,7 +2469,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/primitives/slot.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/primitives/slot.tsx"
       },
       "namespace": "Slot",
       "name": "Slottable",
@@ -2488,7 +2488,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/provider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/provider.tsx"
       },
       "name": "MediaProvider",
       "displayName": "MediaProvider",
@@ -2551,7 +2551,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/provider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/provider.tsx"
       },
       "name": "MediaOutlet",
       "displayName": "MediaOutlet",
@@ -2586,7 +2586,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/text-track.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/text-track.tsx"
       },
       "name": "Track",
       "displayName": "Track",
@@ -2765,7 +2765,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/airplay-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/airplay-button.tsx"
       },
       "name": "AirPlayButton",
       "displayName": "AirPlayButton",
@@ -2816,7 +2816,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/caption-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/caption-button.tsx"
       },
       "name": "CaptionButton",
       "displayName": "CaptionButton",
@@ -2863,7 +2863,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/fullscreen-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/fullscreen-button.tsx"
       },
       "name": "FullscreenButton",
       "displayName": "FullscreenButton",
@@ -2914,7 +2914,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/google-cast-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/google-cast-button.tsx"
       },
       "name": "GoogleCastButton",
       "displayName": "GoogleCastButton",
@@ -2965,7 +2965,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/live-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/live-button.tsx"
       },
       "name": "LiveButton",
       "displayName": "LiveButton",
@@ -3012,7 +3012,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/mute-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/mute-button.tsx"
       },
       "name": "MuteButton",
       "displayName": "MuteButton",
@@ -3059,7 +3059,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/pip-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/pip-button.tsx"
       },
       "name": "PIPButton",
       "displayName": "PIPButton",
@@ -3110,7 +3110,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/play-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/play-button.tsx"
       },
       "name": "PlayButton",
       "displayName": "PlayButton",
@@ -3157,7 +3157,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/seek-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/seek-button.tsx"
       },
       "name": "SeekButton",
       "displayName": "SeekButton",
@@ -3204,7 +3204,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/buttons/toggle-button.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/buttons/toggle-button.tsx"
       },
       "name": "ToggleButton",
       "displayName": "ToggleButton",
@@ -3251,7 +3251,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/caption.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/caption.tsx"
       },
       "name": "Root",
       "displayName": "Caption",
@@ -3286,7 +3286,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/caption.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/caption.tsx"
       },
       "name": "Text",
       "displayName": "CaptionText",
@@ -3313,7 +3313,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/captions.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/captions.tsx"
       },
       "name": "Captions",
       "displayName": "Captions",
@@ -3360,7 +3360,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/chapter-title.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/chapter-title.tsx"
       },
       "name": "ChapterTitle",
       "displayName": "ChapterTitle",
@@ -3407,7 +3407,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/controls.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/controls.tsx"
       },
       "namespace": "Controls",
       "name": "Root",
@@ -3455,7 +3455,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/controls.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/controls.tsx"
       },
       "namespace": "Controls",
       "name": "Group",
@@ -3503,7 +3503,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/gesture.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/gesture.tsx"
       },
       "name": "Gesture",
       "displayName": "Gesture",
@@ -3550,12 +3550,12 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/menu.tsx"
       },
       "namespace": "Menu",
       "exports": [
         {
-          "file": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/radio-group",
+          "file": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/radio-group",
           "alias": {
             "Root": "RadioGroup",
             "Item": "Radio",
@@ -3609,7 +3609,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/menu.tsx"
       },
       "namespace": "Menu",
       "name": "Button",
@@ -3657,7 +3657,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/menu.tsx"
       },
       "namespace": "Menu",
       "name": "Portal",
@@ -3705,7 +3705,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/menu.tsx"
       },
       "namespace": "Menu",
       "name": "Items",
@@ -3753,7 +3753,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/menu.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/menu.tsx"
       },
       "namespace": "Menu",
       "name": "Item",
@@ -3801,7 +3801,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/poster.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/poster.tsx"
       },
       "name": "Poster",
       "displayName": "Poster",
@@ -3857,7 +3857,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/poster.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/poster.tsx"
       },
       "name": "PosterImg",
       "displayName": "PosterImg",
@@ -3899,7 +3899,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/radio-group.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/radio-group.tsx"
       },
       "namespace": "RadioGroup",
       "name": "Root",
@@ -3947,7 +3947,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/radio-group.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/radio-group.tsx"
       },
       "namespace": "RadioGroup",
       "name": "Item",
@@ -3995,12 +3995,12 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/audio-gain-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/audio-gain-slider.tsx"
       },
       "namespace": "AudioGainSlider",
       "exports": [
         {
-          "file": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider"
+          "file": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider"
         }
       ],
       "name": "Root",
@@ -4048,12 +4048,12 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/quality-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/quality-slider.tsx"
       },
       "namespace": "QualitySlider",
       "exports": [
         {
-          "file": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider"
+          "file": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider"
         }
       ],
       "name": "Root",
@@ -4101,7 +4101,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider.tsx"
       },
       "namespace": "Slider",
       "name": "Root",
@@ -4149,7 +4149,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider.tsx"
       },
       "namespace": "Slider",
       "name": "Thumb",
@@ -4184,7 +4184,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider.tsx"
       },
       "namespace": "Slider",
       "name": "Track",
@@ -4219,7 +4219,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider.tsx"
       },
       "namespace": "Slider",
       "name": "TrackFill",
@@ -4254,7 +4254,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider.tsx"
       },
       "namespace": "Slider",
       "name": "Preview",
@@ -4302,7 +4302,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider.tsx"
       },
       "namespace": "Slider",
       "name": "Value",
@@ -4350,7 +4350,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider.tsx"
       },
       "namespace": "Slider",
       "name": "Steps",
@@ -4393,12 +4393,12 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/speed-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/speed-slider.tsx"
       },
       "namespace": "SpeedSlider",
       "exports": [
         {
-          "file": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider"
+          "file": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider"
         }
       ],
       "name": "Root",
@@ -4446,12 +4446,12 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/time-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/time-slider.tsx"
       },
       "namespace": "TimeSlider",
       "exports": [
         {
-          "file": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider"
+          "file": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider"
         }
       ],
       "name": "Root",
@@ -4499,7 +4499,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/time-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/time-slider.tsx"
       },
       "namespace": "TimeSlider",
       "name": "Chapters",
@@ -4539,7 +4539,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/time-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/time-slider.tsx"
       },
       "name": "ChapterTracks",
       "displayName": "SliderChapterTracks",
@@ -4566,7 +4566,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/time-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/time-slider.tsx"
       },
       "namespace": "TimeSlider",
       "name": "ChapterTitle",
@@ -4601,7 +4601,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/time-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/time-slider.tsx"
       },
       "namespace": "TimeSlider",
       "name": "Progress",
@@ -4636,7 +4636,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/time-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/time-slider.tsx"
       },
       "name": "ThumbnailRoot",
       "displayName": "SliderThumbnail",
@@ -4683,7 +4683,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/time-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/time-slider.tsx"
       },
       "namespace": "TimeSlider",
       "name": "Video",
@@ -4731,7 +4731,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/time-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/time-slider.tsx"
       },
       "name": "VideoProvider",
       "displayName": "SliderVideoProvider",
@@ -4765,12 +4765,12 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/volume-slider.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/volume-slider.tsx"
       },
       "namespace": "VolumeSlider",
       "exports": [
         {
-          "file": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/sliders/slider"
+          "file": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/sliders/slider"
         }
       ],
       "name": "Root",
@@ -4818,7 +4818,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/spinner.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/spinner.tsx"
       },
       "namespace": "Spinner",
       "name": "Root",
@@ -4857,7 +4857,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/spinner.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/spinner.tsx"
       },
       "namespace": "Spinner",
       "name": "Track",
@@ -4874,7 +4874,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/spinner.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/spinner.tsx"
       },
       "namespace": "Spinner",
       "name": "TrackFill",
@@ -4902,7 +4902,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/thumbnail.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/thumbnail.tsx"
       },
       "namespace": "Thumbnail",
       "name": "Root",
@@ -4950,7 +4950,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/thumbnail.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/thumbnail.tsx"
       },
       "namespace": "Thumbnail",
       "name": "Img",
@@ -4986,7 +4986,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/time.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/time.tsx"
       },
       "name": "Time",
       "displayName": "Time",
@@ -5033,7 +5033,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/time.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/time.tsx"
       },
       "name": "TimeText",
       "displayName": "TimeText",
@@ -5067,7 +5067,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/title.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/title.tsx"
       },
       "name": "Title",
       "displayName": "Title",
@@ -5105,7 +5105,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/tooltip.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/tooltip.tsx"
       },
       "namespace": "Tooltip",
       "name": "Root",
@@ -5148,7 +5148,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/tooltip.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/tooltip.tsx"
       },
       "namespace": "Tooltip",
       "name": "Trigger",
@@ -5196,7 +5196,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/components/ui/tooltip.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/components/ui/tooltip.tsx"
       },
       "namespace": "Tooltip",
       "name": "Content",
@@ -5244,7 +5244,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/providers/remotion/ui/context.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/providers/remotion/ui/context.tsx"
       },
       "name": "RemotionContextProvider",
       "displayName": "RemotionContextProvider",
@@ -5311,7 +5311,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/providers/remotion/ui/poster.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/providers/remotion/ui/poster.tsx"
       },
       "name": "RemotionPoster",
       "displayName": "RemotionPoster",
@@ -5400,7 +5400,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/providers/remotion/ui/slider-thumbnail.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/providers/remotion/ui/slider-thumbnail.tsx"
       },
       "name": "RemotionSliderThumbnail",
       "displayName": "RemotionSliderThumbnail",
@@ -5476,7 +5476,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/providers/remotion/ui/thumbnail.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/providers/remotion/ui/thumbnail.tsx"
       },
       "name": "RemotionThumbnail",
       "displayName": "RemotionThumbnail",
@@ -5561,7 +5561,7 @@
     {
       "type": "react",
       "file": {
-        "path": "/Users/v.rahim.alwer/Desktop/Projects/vidstack/packages/react/src/providers/remotion/ui/thumbnail.tsx"
+        "path": "/Users/kaho/open-source/vidstack-player/packages/react/src/providers/remotion/ui/thumbnail.tsx"
       },
       "name": "RemotionThumbnailUI",
       "displayName": "RemotionThumbnailUI",
diff --git a/dev/chunks/vidstack-Dpb_iHia.js b/dev/chunks/vidstack-3QSvMQEj.js
similarity index 99%
rename from dev/chunks/vidstack-Dpb_iHia.js
rename to dev/chunks/vidstack-3QSvMQEj.js
index 32120e4a6f082468ea82a6483a4f152f453769f1..a680ad02cea307db49f26041fd8c76b171aee279 100644
--- a/dev/chunks/vidstack-Dpb_iHia.js
+++ b/dev/chunks/vidstack-3QSvMQEj.js
@@ -2,8 +2,8 @@
 
 import * as React from 'react';
 import { createReactComponent, composeRefs, listenEvent, useReactScope, scoped, signal, computed, effect, EventsController, useSignal } from './vidstack-CH225ns1.js';
-import { Primitive, MediaAnnouncerInstance, ControlsInstance, ControlsGroupInstance, TooltipInstance, TooltipTriggerInstance, TooltipContentInstance, GoogleCastButtonInstance, QualitySliderInstance, AudioGainSliderInstance, SpeedSliderInstance, useMediaState, watchActiveTextTrack, CaptionsInstance, formatTime, formatSpokenTime } from './vidstack-tCTk_Mpr.js';
-import { sliderCallbacks, Preview, Steps, Thumb, Track as Track$1, TrackFill as TrackFill$1, Value, useMediaContext } from './vidstack-DM21n8Pk.js';
+import { Primitive, MediaAnnouncerInstance, ControlsInstance, ControlsGroupInstance, TooltipInstance, TooltipTriggerInstance, TooltipContentInstance, GoogleCastButtonInstance, QualitySliderInstance, AudioGainSliderInstance, SpeedSliderInstance, useMediaState, watchActiveTextTrack, CaptionsInstance, formatTime, formatSpokenTime } from './vidstack-DlEFWAGb.js';
+import { sliderCallbacks, Preview, Steps, Thumb, Track as Track$1, TrackFill as TrackFill$1, Value, useMediaContext } from './vidstack-Bn2Qk0ao.js';
 
 const MediaAnnouncerBridge = createReactComponent(MediaAnnouncerInstance, {
   events: ["onChange"]
diff --git a/dev/chunks/vidstack-BI_qiU6Y.js b/dev/chunks/vidstack-6DJOXxBa.js
similarity index 97%
rename from dev/chunks/vidstack-BI_qiU6Y.js
rename to dev/chunks/vidstack-6DJOXxBa.js
index 6353135fa39451d9e89ed41e4eb5dbc567614ff8..3cadcb3d77c614389cf6a5adb1ff500b28b00a5e 100644
--- a/dev/chunks/vidstack-BI_qiU6Y.js
+++ b/dev/chunks/vidstack-6DJOXxBa.js
@@ -1,7 +1,7 @@
 "use client"
 
 import { scoped } from './vidstack-CH225ns1.js';
-import { HTMLMediaProvider, HTMLAirPlayAdapter } from './vidstack-tCTk_Mpr.js';
+import { HTMLMediaProvider, HTMLAirPlayAdapter } from './vidstack-BdoOxmTD.js';
 import 'react';
 import '@floating-ui/dom';
 
diff --git a/dev/chunks/vidstack-BM8_lxar.js b/dev/chunks/vidstack-B34LMCPL.js
similarity index 99%
rename from dev/chunks/vidstack-BM8_lxar.js
rename to dev/chunks/vidstack-B34LMCPL.js
index 96a8b28494f9baadcc6fc73437f4fa218f4561be..d1bd9489b5483a8f7c069a59a785eeeaa6176286 100644
--- a/dev/chunks/vidstack-BM8_lxar.js
+++ b/dev/chunks/vidstack-B34LMCPL.js
@@ -1,8 +1,8 @@
 "use client"
 
 import { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from './vidstack-CH225ns1.js';
-import { ListSymbol, TimeRange, RAFLoop } from './vidstack-tCTk_Mpr.js';
-import { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-DnVfQIbh.js';
+import { ListSymbol, TimeRange, RAFLoop } from './vidstack-MAWt6ODZ.js';
+import { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-Bk4a1y2Y.js';
 import 'react';
 import '@floating-ui/dom';
 
diff --git a/dev/chunks/vidstack-DeDlc57T.js b/dev/chunks/vidstack-B6V3Risw.js
similarity index 98%
rename from dev/chunks/vidstack-DeDlc57T.js
rename to dev/chunks/vidstack-B6V3Risw.js
index b323c7901b671a4a4c375e786a88b6b91e697a49..d908c2836af977528356802382a79bba67b6a1e5 100644
--- a/dev/chunks/vidstack-DeDlc57T.js
+++ b/dev/chunks/vidstack-B6V3Risw.js
@@ -1,8 +1,8 @@
 "use client"
 
 import { createScope, signal, effect, isString, deferredPromise, isObject, isNumber, isBoolean } from './vidstack-CH225ns1.js';
-import { preconnect, TimeRange } from './vidstack-tCTk_Mpr.js';
-import { EmbedProvider } from './vidstack-DBVMDgDR.js';
+import { preconnect, TimeRange } from './vidstack-BdoOxmTD.js';
+import { EmbedProvider } from './vidstack-saV39v1d.js';
 import { resolveYouTubeVideoId } from './vidstack-Zc3I7oOd.js';
 import 'react';
 import '@floating-ui/dom';
diff --git a/dev/chunks/vidstack-hrlhZeuZ.js b/dev/chunks/vidstack-BEf59GM5.js
similarity index 99%
rename from dev/chunks/vidstack-hrlhZeuZ.js
rename to dev/chunks/vidstack-BEf59GM5.js
index 7374bd1802d4151de312984557f9ac712ec79570..49b7526b7fa1afd92e0413f389cd18f602f802a1 100644
--- a/dev/chunks/vidstack-hrlhZeuZ.js
+++ b/dev/chunks/vidstack-BEf59GM5.js
@@ -4,7 +4,7 @@ import * as React from 'react';
 import { createDisposalBin, listenEvent, isNumber, isUndefined, isNull, isNil, createScope, signal, peek, effect, tick, isFunction, useSignal, deferredPromise } from './vidstack-CH225ns1.js';
 import { Composition, Internals } from 'remotion';
 import { RemotionLayoutEngine, REMOTION_PROVIDER_ID, RemotionContextProvider, ErrorBoundary } from '../player/vidstack-remotion.js';
-import { isRemotionSrc, TimeRange } from './vidstack-tCTk_Mpr.js';
+import { isRemotionSrc, TimeRange } from './vidstack-BdoOxmTD.js';
 import { NoReactInternals } from 'remotion/no-react';
 import './vidstack-CaBvbWDV.js';
 import '@floating-ui/dom';
diff --git a/dev/chunks/vidstack-BHkwyNav.js b/dev/chunks/vidstack-BHkwyNav.js
new file mode 100644
index 0000000000000000000000000000000000000000..ce0cd7f13043998a82152dc972b6dc20ab963553
--- /dev/null
+++ b/dev/chunks/vidstack-BHkwyNav.js
@@ -0,0 +1,375 @@
+"use client"
+
+import * as React from 'react';
+import { createReactComponent, composeRefs, listenEvent, useReactScope, scoped, signal, computed, effect, EventsController, useSignal } from './vidstack-CH225ns1.js';
+import { Primitive, MediaAnnouncerInstance, ControlsInstance, ControlsGroupInstance, TooltipInstance, TooltipTriggerInstance, TooltipContentInstance, GoogleCastButtonInstance, QualitySliderInstance, AudioGainSliderInstance, SpeedSliderInstance, useMediaState, watchActiveTextTrack, CaptionsInstance, formatTime, formatSpokenTime } from './vidstack-MAWt6ODZ.js';
+import { sliderCallbacks, Preview, Steps, Thumb, Track as Track$1, TrackFill as TrackFill$1, Value, useMediaContext } from './vidstack-DEqI2Hy1.js';
+
+const MediaAnnouncerBridge = createReactComponent(MediaAnnouncerInstance, {
+  events: ["onChange"]
+});
+const MediaAnnouncer = React.forwardRef(
+  ({ style, children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(MediaAnnouncerBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        style: { display: "contents", ...style },
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+MediaAnnouncer.displayName = "MediaAnnouncer";
+
+const ControlsBridge = createReactComponent(ControlsInstance);
+const Root$5 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ControlsBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Root$5.displayName = "Controls";
+const ControlsGroupBridge = createReactComponent(ControlsGroupInstance);
+const Group = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ControlsGroupBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Group.displayName = "ControlsGroup";
+
+var controls = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Group: Group,
+  Root: Root$5
+});
+
+const TooltipBridge = createReactComponent(TooltipInstance);
+function Root$4({ children, ...props }) {
+  return /* @__PURE__ */ React.createElement(TooltipBridge, { ...props }, children);
+}
+Root$4.displayName = "Tooltip";
+const TriggerBridge = createReactComponent(TooltipTriggerInstance);
+const Trigger = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(TriggerBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Trigger.displayName = "TooltipTrigger";
+const ContentBridge = createReactComponent(TooltipContentInstance);
+const Content = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(ContentBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Content.displayName = "TooltipContent";
+
+var tooltip = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Content: Content,
+  Root: Root$4,
+  Trigger: Trigger
+});
+
+const GoogleCastButtonBridge = createReactComponent(GoogleCastButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const GoogleCastButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(GoogleCastButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+GoogleCastButton.displayName = "GoogleCastButton";
+
+const QualitySliderBridge = createReactComponent(QualitySliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$3 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(QualitySliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$3.displayName = "QualitySlider";
+
+var qualitySlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$3,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const AudioGainSliderBridge = createReactComponent(AudioGainSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$2 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(AudioGainSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$2.displayName = "AudioGainSlider";
+
+var audioGainSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$2,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const SpeedSliderBridge = createReactComponent(SpeedSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$1 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SpeedSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$1.displayName = "SpeedSlider";
+
+var speedSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$1,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const Title = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const $title = useMediaState("title");
+  return /* @__PURE__ */ React.createElement(Primitive.span, { ...props, ref: forwardRef }, $title, children);
+});
+Title.displayName = "Title";
+
+function useActiveTextCues(track) {
+  const [activeCues, setActiveCues] = React.useState([]);
+  React.useEffect(() => {
+    if (!track) {
+      setActiveCues([]);
+      return;
+    }
+    function onCuesChange() {
+      if (track) setActiveCues(track.activeCues);
+    }
+    onCuesChange();
+    return listenEvent(track, "cue-change", onCuesChange);
+  }, [track]);
+  return activeCues;
+}
+
+function useActiveTextTrack(kind) {
+  const media = useMediaContext(), [track, setTrack] = React.useState(null);
+  React.useEffect(() => {
+    return watchActiveTextTrack(media.textTracks, kind, setTrack);
+  }, [kind]);
+  return track;
+}
+
+function useChapterTitle() {
+  const $track = useActiveTextTrack("chapters"), $cues = useActiveTextCues($track);
+  return $cues[0]?.text || "";
+}
+
+const ChapterTitle = React.forwardRef(
+  ({ defaultText = "", children, ...props }, forwardRef) => {
+    const $chapterTitle = useChapterTitle();
+    return /* @__PURE__ */ React.createElement(Primitive.span, { ...props, ref: forwardRef }, $chapterTitle || defaultText, children);
+  }
+);
+ChapterTitle.displayName = "ChapterTitle";
+
+const CaptionsBridge = createReactComponent(CaptionsInstance);
+const Captions = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(CaptionsBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Captions.displayName = "Captions";
+
+const Root = React.forwardRef(
+  ({ size = 96, children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(
+      "svg",
+      {
+        width: size,
+        height: size,
+        fill: "none",
+        viewBox: "0 0 120 120",
+        "aria-hidden": "true",
+        "data-part": "root",
+        ...props,
+        ref: forwardRef
+      },
+      children
+    );
+  }
+);
+const Track = React.forwardRef(
+  ({ width = 8, children, ...props }, ref) => /* @__PURE__ */ React.createElement(
+    "circle",
+    {
+      cx: "60",
+      cy: "60",
+      r: "54",
+      stroke: "currentColor",
+      strokeWidth: width,
+      "data-part": "track",
+      ...props,
+      ref
+    },
+    children
+  )
+);
+const TrackFill = React.forwardRef(
+  ({ width = 8, fillPercent = 50, children, ...props }, ref) => /* @__PURE__ */ React.createElement(
+    "circle",
+    {
+      cx: "60",
+      cy: "60",
+      r: "54",
+      stroke: "currentColor",
+      pathLength: "100",
+      strokeWidth: width,
+      strokeDasharray: 100,
+      strokeDashoffset: 100 - fillPercent,
+      "data-part": "track-fill",
+      ...props,
+      ref
+    },
+    children
+  )
+);
+
+var spinner = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Root: Root,
+  Track: Track,
+  TrackFill: TrackFill
+});
+
+function createSignal(initialValue, deps = []) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(() => signal(initialValue), scope), [scope, ...deps]);
+}
+function createComputed(compute, deps = []) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(() => computed(compute), scope), [scope, ...deps]);
+}
+function createEffect(compute, deps = []) {
+  const scope = useReactScope();
+  React.useEffect(() => scoped(() => effect(compute), scope), [scope, ...deps]);
+}
+function useScoped(compute) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(compute, scope), [scope]);
+}
+
+function useTextCues(track) {
+  const [cues, setCues] = React.useState([]);
+  React.useEffect(() => {
+    if (!track) return;
+    function onCuesChange() {
+      if (track) setCues([...track.cues]);
+    }
+    const events = new EventsController(track).add("add-cue", onCuesChange).add("remove-cue", onCuesChange);
+    onCuesChange();
+    return () => {
+      setCues([]);
+      events.abort();
+    };
+  }, [track]);
+  return cues;
+}
+
+function useChapterOptions() {
+  const media = useMediaContext(), track = useActiveTextTrack("chapters"), cues = useTextCues(track), $startTime = useSignal(media.$state.seekableStart), $endTime = useSignal(media.$state.seekableEnd);
+  useActiveTextCues(track);
+  return React.useMemo(() => {
+    const options = track ? cues.filter((cue) => cue.startTime <= $endTime && cue.endTime >= $startTime).map((cue, i) => {
+      let currentRef = null, stopProgressEffect;
+      return {
+        cue,
+        label: cue.text,
+        value: i.toString(),
+        startTimeText: formatTime(Math.max(0, cue.startTime - $startTime)),
+        durationText: formatSpokenTime(
+          Math.min($endTime, cue.endTime) - Math.max($startTime, cue.startTime)
+        ),
+        get selected() {
+          return cue === track.activeCues[0];
+        },
+        setProgressVar(ref) {
+          if (!ref || cue !== track.activeCues[0]) {
+            stopProgressEffect?.();
+            stopProgressEffect = void 0;
+            ref?.style.setProperty("--progress", "0%");
+            currentRef = null;
+            return;
+          }
+          if (currentRef === ref) return;
+          currentRef = ref;
+          stopProgressEffect?.();
+          stopProgressEffect = effect(() => {
+            const { realCurrentTime } = media.$state, time = realCurrentTime(), cueStartTime = Math.max($startTime, cue.startTime), duration = Math.min($endTime, cue.endTime) - cueStartTime, progress = Math.max(0, time - cueStartTime) / duration * 100;
+            ref.style.setProperty("--progress", progress.toFixed(3) + "%");
+          });
+        },
+        select(trigger) {
+          media.remote.seek(cue.startTime - $startTime, trigger);
+        }
+      };
+    }) : [];
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const index = options.findIndex((option) => option.selected);
+        return (index >= 0 ? index : 0).toString();
+      }
+    });
+    return options;
+  }, [cues, $startTime, $endTime]);
+}
+
+export { Captions, ChapterTitle, Content, GoogleCastButton, Group, MediaAnnouncer, Root$4 as Root, Root$2 as Root$1, Root$3 as Root$2, Root$1 as Root$3, Root$5 as Root$4, Root as Root$5, Title, Track, TrackFill, Trigger, audioGainSlider, controls, createComputed, createEffect, createSignal, qualitySlider, speedSlider, spinner, tooltip, useActiveTextCues, useActiveTextTrack, useChapterOptions, useChapterTitle, useScoped, useTextCues };
diff --git a/dev/chunks/vidstack-B6cpIZaB.js b/dev/chunks/vidstack-BJ2PnLPJ.js
similarity index 99%
rename from dev/chunks/vidstack-B6cpIZaB.js
rename to dev/chunks/vidstack-BJ2PnLPJ.js
index 6e7ec00d577c7b54b920bf9777b6e4da638a3460..3475ab1ef6e0a7d8b541044928037da1050ccd4c 100644
--- a/dev/chunks/vidstack-B6cpIZaB.js
+++ b/dev/chunks/vidstack-BJ2PnLPJ.js
@@ -1,7 +1,7 @@
 "use client"
 
 import { peek, listenEvent, effect, DOMEvent, isString, camelToKebabCase, isUndefined, isFunction } from './vidstack-CH225ns1.js';
-import { QualitySymbol, RAFLoop, TextTrack, TextTrackSymbol, ListSymbol, IS_CHROME, coerceToError, loadScript, VideoProvider, isHLSSupported, preconnect } from './vidstack-tCTk_Mpr.js';
+import { QualitySymbol, RAFLoop, TextTrack, TextTrackSymbol, ListSymbol, IS_CHROME, coerceToError, loadScript, VideoProvider, isHLSSupported, preconnect } from './vidstack-DlEFWAGb.js';
 import 'react';
 import '@floating-ui/dom';
 
diff --git a/dev/chunks/vidstack-LkorjYNN.js b/dev/chunks/vidstack-BV8aou1h.js
similarity index 99%
rename from dev/chunks/vidstack-LkorjYNN.js
rename to dev/chunks/vidstack-BV8aou1h.js
index 7350eaac3b198a785783b3f539e8c3f042f8b982..0a6e0f13b4701b7a0de77cb934f0a9b57ce3c7a0 100644
--- a/dev/chunks/vidstack-LkorjYNN.js
+++ b/dev/chunks/vidstack-BV8aou1h.js
@@ -1,8 +1,8 @@
 "use client"
 
 import { createScope, signal, effect, peek, isString, deferredPromise, listenEvent, isArray } from './vidstack-CH225ns1.js';
-import { TimeRange, RAFLoop, preconnect, ListSymbol, TextTrack, QualitySymbol } from './vidstack-tCTk_Mpr.js';
-import { EmbedProvider } from './vidstack-DBVMDgDR.js';
+import { TimeRange, RAFLoop, preconnect, ListSymbol, TextTrack, QualitySymbol } from './vidstack-MAWt6ODZ.js';
+import { EmbedProvider } from './vidstack-fXdyeRpg.js';
 import { resolveVimeoVideoId, getVimeoVideoInfo } from './vidstack-krOAtKMi.js';
 import 'react';
 import '@floating-ui/dom';
diff --git a/dev/chunks/vidstack-Bl9rvtRZ.js b/dev/chunks/vidstack-BWXzG2Z3.js
similarity index 99%
rename from dev/chunks/vidstack-Bl9rvtRZ.js
rename to dev/chunks/vidstack-BWXzG2Z3.js
index 346bfdea81041ef7b5a8ea94e5dfe0022a2efcf3..1b5036ba3db3828fe8c57b508ec6a225813fb8db 100644
--- a/dev/chunks/vidstack-Bl9rvtRZ.js
+++ b/dev/chunks/vidstack-BWXzG2Z3.js
@@ -2,10 +2,10 @@
 
 import * as React from 'react';
 import { useSignal, isBoolean, composeRefs, uppercaseFirstChar, isUndefined, isString, signal, camelToKebabCase, onDispose, scoped, keysOf, effect, isArray, isKeyboardClick, listenEvent, toggleClass, useContext } from './vidstack-CH225ns1.js';
-import { createComputed, createSignal, MediaAnnouncer, Root, Trigger, Content, GoogleCastButton, Captions, useChapterOptions, Root$1 as Root$5, Root$2 as Root$6, Root$3 as Root$7, useScoped, Root$4 as Root$a, Group, useChapterTitle, createEffect, useActiveTextTrack, ChapterTitle as ChapterTitle$1, Title, Root$5 as Root$b, Track as Track$1, TrackFill as TrackFill$1 } from './vidstack-Dpb_iHia.js';
-import { useColorSchemePreference, useActive, useResizeObserver, useLayoutName, useTransitionActive } from './vidstack-CXTsWYwn.js';
-import { useMediaContext, MuteButton, PlayButton, CaptionButton, PIPButton, FullscreenButton, SeekButton, AirPlayButton, LiveButton, appendParamsToURL, Items, Root$3 as Root$1, Item, Root as Root$2, Img, Root$2 as Root$3, Button, Portal, Track, TrackFill, Thumb, Steps, useMediaPlayer, Root$5 as Root$4, useAudioOptions, useCaptionOptions, Root$4 as Root$8, Preview, Value, Root$1 as Root$9, Chapters, Progress, Thumbnail, ChapterTitle, Time, Gesture } from './vidstack-DM21n8Pk.js';
-import { useMediaState, isTrackCaptionKind, getDownloadFile, isRemotionSrc, IS_SERVER, useMediaContext as useMediaContext$1, sortVideoQualities, Primitive, mediaContext } from './vidstack-tCTk_Mpr.js';
+import { createComputed, createSignal, MediaAnnouncer, Root, Trigger, Content, GoogleCastButton, Captions, useChapterOptions, Root$1 as Root$5, Root$2 as Root$6, Root$3 as Root$7, useScoped, Root$4 as Root$a, Group, useChapterTitle, createEffect, useActiveTextTrack, ChapterTitle as ChapterTitle$1, Title, Root$5 as Root$b, Track as Track$1, TrackFill as TrackFill$1 } from './vidstack-3QSvMQEj.js';
+import { useColorSchemePreference, useActive, useResizeObserver, useLayoutName, useTransitionActive } from './vidstack-C4ZyuPZU.js';
+import { useMediaContext, MuteButton, PlayButton, CaptionButton, PIPButton, FullscreenButton, SeekButton, AirPlayButton, LiveButton, appendParamsToURL, Items, Root$3 as Root$1, Item, Root as Root$2, Img, Root$2 as Root$3, Button, Portal, Track, TrackFill, Thumb, Steps, useMediaPlayer, Root$5 as Root$4, useAudioOptions, useCaptionOptions, Root$4 as Root$8, Preview, Value, Root$1 as Root$9, Chapters, Progress, Thumbnail, ChapterTitle, Time, Gesture } from './vidstack-Bn2Qk0ao.js';
+import { useMediaState, isTrackCaptionKind, getDownloadFile, isRemotionSrc, IS_SERVER, useMediaContext as useMediaContext$1, sortVideoQualities, Primitive, mediaContext } from './vidstack-DlEFWAGb.js';
 import { flushSync } from 'react-dom';
 import { RemotionThumbnail, RemotionSliderThumbnail } from './vidstack-CaBvbWDV.js';
 
diff --git a/dev/chunks/vidstack-BdoOxmTD.js b/dev/chunks/vidstack-BdoOxmTD.js
new file mode 100644
index 0000000000000000000000000000000000000000..5a3af05cdf4c5d5069958842a2f9e6674906b0db
--- /dev/null
+++ b/dev/chunks/vidstack-BdoOxmTD.js
@@ -0,0 +1,11679 @@
+"use client"
+
+import * as React from 'react';
+import { isString, isNumber, isFunction, isUndefined, waitTimeout, isArray, isBoolean, isNull, deferredPromise, listenEvent, scoped, getScope, EventsTarget, DOMEvent, State, fscreen, tick, createContext, useContext, Component, functionThrottle, setAttribute, effect, isTouchEvent, isDOMNode, EventsController, isKeyboardClick, setStyle, onDispose, untrack, functionDebounce, ViewController, signal, peek, isKeyboardEvent, isNil, createScope, camelToKebabCase, waitIdlePeriod, prop, method, provideContext, animationFrameThrottle, uppercaseFirstChar, computed, noop, ariaBool as ariaBool$1, isWriteSignal, hasProvidedContext, isObject, useState, r, wasEnterKeyPressed, isPointerEvent, isMouseEvent, kebabToCamelCase, composeRefs, useStateContext, useSignal, useSignalRecord } from './vidstack-CH225ns1.js';
+import { autoUpdate, computePosition, flip, shift } from '@floating-ui/dom';
+
+function isVideoQualitySrc(src) {
+  return !isString(src) && "width" in src && "height" in src && isNumber(src.width) && isNumber(src.height);
+}
+
+const IS_SERVER = typeof document === "undefined";
+
+const UA = IS_SERVER ? "" : navigator?.userAgent.toLowerCase() || "";
+const IS_IOS = !IS_SERVER && /iphone|ipad|ipod|ios|crios|fxios/i.test(UA);
+const IS_IPHONE = !IS_SERVER && /(iphone|ipod)/gi.test(navigator?.platform || "");
+const IS_CHROME = !IS_SERVER && !!window.chrome;
+const IS_SAFARI = !IS_SERVER && (!!window.safari || IS_IOS);
+function canOrientScreen() {
+  return canRotateScreen() && isFunction(screen.orientation.unlock);
+}
+function canRotateScreen() {
+  return !IS_SERVER && !isUndefined(window.screen.orientation) && !isUndefined(window.screen.orientation.lock);
+}
+function canPlayAudioType(audio, type) {
+  if (IS_SERVER) return false;
+  if (!audio) audio = document.createElement("audio");
+  return audio.canPlayType(type).length > 0;
+}
+function canPlayVideoType(video, type) {
+  if (IS_SERVER) return false;
+  if (!video) video = document.createElement("video");
+  return video.canPlayType(type).length > 0;
+}
+function canPlayHLSNatively(video) {
+  if (IS_SERVER) return false;
+  if (!video) video = document.createElement("video");
+  return video.canPlayType("application/vnd.apple.mpegurl").length > 0;
+}
+function canUsePictureInPicture(video) {
+  if (IS_SERVER) return false;
+  return !!document.pictureInPictureEnabled && !video?.disablePictureInPicture;
+}
+function canUseVideoPresentation(video) {
+  if (IS_SERVER) return false;
+  return isFunction(video?.webkitSupportsPresentationMode) && isFunction(video?.webkitSetPresentationMode);
+}
+async function canChangeVolume() {
+  const video = document.createElement("video");
+  video.volume = 0.5;
+  await waitTimeout(0);
+  return video.volume === 0.5;
+}
+function getMediaSource() {
+  return IS_SERVER ? void 0 : window?.ManagedMediaSource ?? window?.MediaSource ?? window?.WebKitMediaSource;
+}
+function getSourceBuffer() {
+  return IS_SERVER ? void 0 : window?.SourceBuffer ?? window?.WebKitSourceBuffer;
+}
+function isHLSSupported() {
+  if (IS_SERVER) return false;
+  const MediaSource = getMediaSource();
+  if (isUndefined(MediaSource)) return false;
+  const isTypeSupported = MediaSource && isFunction(MediaSource.isTypeSupported) && MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
+  const SourceBuffer = getSourceBuffer();
+  const isSourceBufferValid = isUndefined(SourceBuffer) || !isUndefined(SourceBuffer.prototype) && isFunction(SourceBuffer.prototype.appendBuffer) && isFunction(SourceBuffer.prototype.remove);
+  return !!isTypeSupported && !!isSourceBufferValid;
+}
+function isDASHSupported() {
+  return isHLSSupported();
+}
+
+class TimeRange {
+  #ranges;
+  get length() {
+    return this.#ranges.length;
+  }
+  constructor(start, end) {
+    if (isArray(start)) {
+      this.#ranges = start;
+    } else if (!isUndefined(start) && !isUndefined(end)) {
+      this.#ranges = [[start, end]];
+    } else {
+      this.#ranges = [];
+    }
+  }
+  start(index) {
+    throwIfEmpty(this.#ranges.length);
+    throwIfOutOfRange("start", index, this.#ranges.length - 1);
+    return this.#ranges[index][0] ?? Infinity;
+  }
+  end(index) {
+    throwIfEmpty(this.#ranges.length);
+    throwIfOutOfRange("end", index, this.#ranges.length - 1);
+    return this.#ranges[index][1] ?? Infinity;
+  }
+}
+function getTimeRangesStart(range) {
+  if (!range.length) return null;
+  let min = range.start(0);
+  for (let i = 1; i < range.length; i++) {
+    const value = range.start(i);
+    if (value < min) min = value;
+  }
+  return min;
+}
+function getTimeRangesEnd(range) {
+  if (!range.length) return null;
+  let max = range.end(0);
+  for (let i = 1; i < range.length; i++) {
+    const value = range.end(i);
+    if (value > max) max = value;
+  }
+  return max;
+}
+function throwIfEmpty(length) {
+  if (!length) throw new Error("`TimeRanges` object is empty." );
+}
+function throwIfOutOfRange(fnName, index, end) {
+  if (!isNumber(index) || index < 0 || index > end) {
+    throw new Error(
+      `Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${end}).`
+    );
+  }
+}
+function normalizeTimeIntervals(intervals) {
+  if (intervals.length <= 1) {
+    return intervals;
+  }
+  intervals.sort((a, b) => a[0] - b[0]);
+  let normalized = [], current = intervals[0];
+  for (let i = 1; i < intervals.length; i++) {
+    const next = intervals[i];
+    if (current[1] >= next[0] - 1) {
+      current = [current[0], Math.max(current[1], next[1])];
+    } else {
+      normalized.push(current);
+      current = next;
+    }
+  }
+  normalized.push(current);
+  return normalized;
+}
+function updateTimeIntervals(intervals, interval, value) {
+  let start = interval[0], end = interval[1];
+  if (value < start) {
+    return [value, -1];
+  } else if (value === start) {
+    return interval;
+  } else if (start === -1) {
+    interval[0] = value;
+    return interval;
+  } else if (value > start) {
+    interval[1] = value;
+    if (end === -1) intervals.push(interval);
+  }
+  normalizeTimeIntervals(intervals);
+  return interval;
+}
+
+const AUDIO_EXTENSIONS = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx|flac)($|\?)/i;
+const AUDIO_TYPES = /* @__PURE__ */ new Set([
+  "audio/mpeg",
+  "audio/ogg",
+  "audio/3gp",
+  "audio/mp3",
+  "audio/webm",
+  "audio/flac",
+  "audio/m4a",
+  "audio/m4b",
+  "audio/mp4a",
+  "audio/mp4"
+]);
+const VIDEO_EXTENSIONS = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i;
+const VIDEO_TYPES = /* @__PURE__ */ new Set([
+  "video/mp4",
+  "video/webm",
+  "video/3gp",
+  "video/ogg",
+  "video/avi",
+  "video/mpeg"
+]);
+const HLS_VIDEO_EXTENSIONS = /\.(m3u8)($|\?)/i;
+const DASH_VIDEO_EXTENSIONS = /\.(mpd)($|\?)/i;
+const HLS_VIDEO_TYPES = /* @__PURE__ */ new Set([
+  // Apple sanctioned
+  "application/vnd.apple.mpegurl",
+  // Apple sanctioned for backwards compatibility
+  "audio/mpegurl",
+  // Very common
+  "audio/x-mpegurl",
+  // Very common
+  "application/x-mpegurl",
+  // Included for completeness
+  "video/x-mpegurl",
+  "video/mpegurl",
+  "application/mpegurl"
+]);
+const DASH_VIDEO_TYPES = /* @__PURE__ */ new Set(["application/dash+xml"]);
+function isAudioSrc({ src, type }) {
+  return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
+}
+function isVideoSrc(src) {
+  return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && (IS_SERVER || canPlayHLSNatively()) : src.type === "video/object";
+}
+function isHLSSrc({ src, type }) {
+  return isString(src) && HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type);
+}
+function isDASHSrc({ src, type }) {
+  return isString(src) && DASH_VIDEO_EXTENSIONS.test(src) || DASH_VIDEO_TYPES.has(type);
+}
+function canGoogleCastSrc(src) {
+  return isString(src.src) && (isAudioSrc(src) || isVideoSrc(src) || isHLSSrc(src));
+}
+function isMediaStream(src) {
+  return !IS_SERVER && typeof window.MediaStream !== "undefined" && src instanceof window.MediaStream;
+}
+
+function appendParamsToURL(baseUrl, params) {
+  const url = new URL(baseUrl);
+  for (const key of Object.keys(params)) {
+    url.searchParams.set(key, params[key] + "");
+  }
+  return url.toString();
+}
+function preconnect(url, rel = "preconnect") {
+  if (IS_SERVER) return false;
+  const exists = document.querySelector(`link[href="${url}"]`);
+  if (!isNull(exists)) return true;
+  const link = document.createElement("link");
+  link.rel = rel;
+  link.href = url;
+  link.crossOrigin = "true";
+  document.head.append(link);
+  return true;
+}
+const pendingRequests = {};
+function loadScript(src) {
+  if (pendingRequests[src]) return pendingRequests[src].promise;
+  const promise = deferredPromise(), exists = document.querySelector(`script[src="${src}"]`);
+  if (!isNull(exists)) {
+    promise.resolve();
+    return promise.promise;
+  }
+  pendingRequests[src] = promise;
+  const script = document.createElement("script");
+  script.src = src;
+  script.onload = () => {
+    promise.resolve();
+    delete pendingRequests[src];
+  };
+  script.onerror = () => {
+    promise.reject();
+    delete pendingRequests[src];
+  };
+  setTimeout(() => document.head.append(script), 0);
+  return promise.promise;
+}
+function getRequestCredentials(crossOrigin) {
+  return crossOrigin === "use-credentials" ? "include" : isString(crossOrigin) ? "same-origin" : void 0;
+}
+function getDownloadFile({
+  title,
+  src,
+  download
+}) {
+  const url = isBoolean(download) || download === "" ? src.src : isString(download) ? download : download?.url;
+  if (!isValidFileDownload({ url, src, download })) return null;
+  return {
+    url,
+    name: !isBoolean(download) && !isString(download) && download?.filename || title.toLowerCase() || "media"
+  };
+}
+function isValidFileDownload({
+  url,
+  src,
+  download
+}) {
+  return isString(url) && (download && download !== true || isAudioSrc(src) || isVideoSrc(src));
+}
+
+const CROSS_ORIGIN = Symbol("TEXT_TRACK_CROSS_ORIGIN" ), READY_STATE = Symbol("TEXT_TRACK_READY_STATE" ), UPDATE_ACTIVE_CUES = Symbol("TEXT_TRACK_UPDATE_ACTIVE_CUES" ), CAN_LOAD = Symbol("TEXT_TRACK_CAN_LOAD" ), ON_MODE_CHANGE = Symbol("TEXT_TRACK_ON_MODE_CHANGE" ), NATIVE = Symbol("TEXT_TRACK_NATIVE" ), NATIVE_HLS = Symbol("TEXT_TRACK_NATIVE_HLS" );
+const TextTrackSymbol = {
+  crossOrigin: CROSS_ORIGIN,
+  readyState: READY_STATE,
+  updateActiveCues: UPDATE_ACTIVE_CUES,
+  canLoad: CAN_LOAD,
+  onModeChange: ON_MODE_CHANGE,
+  native: NATIVE,
+  nativeHLS: NATIVE_HLS
+};
+
+function findActiveCue(cues, time) {
+  for (let i = 0, len = cues.length; i < len; i++) {
+    if (isCueActive(cues[i], time)) return cues[i];
+  }
+  return null;
+}
+function isCueActive(cue, time) {
+  return time >= cue.startTime && time < cue.endTime;
+}
+function watchActiveTextTrack(tracks, kind, onChange) {
+  let currentTrack = null, scope = getScope();
+  function onModeChange() {
+    const kinds = isString(kind) ? [kind] : kind, track = tracks.toArray().find((track2) => kinds.includes(track2.kind) && track2.mode === "showing");
+    if (track === currentTrack) return;
+    if (!track) {
+      onChange(null);
+      currentTrack = null;
+      return;
+    }
+    if (track.readyState == 2) {
+      onChange(track);
+    } else {
+      onChange(null);
+      scoped(() => {
+        const off = listenEvent(
+          track,
+          "load",
+          () => {
+            onChange(track);
+            off();
+          },
+          { once: true }
+        );
+      }, scope);
+    }
+    currentTrack = track;
+  }
+  onModeChange();
+  return listenEvent(tracks, "mode-change", onModeChange);
+}
+function watchCueTextChange(tracks, kind, callback) {
+  watchActiveTextTrack(tracks, kind, (track) => {
+    if (!track) {
+      callback("");
+      return;
+    }
+    const onCueChange = () => {
+      const activeCue = track?.activeCues[0];
+      callback(activeCue?.text || "");
+    };
+    onCueChange();
+    listenEvent(track, "cue-change", onCueChange);
+  });
+}
+
+class TextTrack extends EventsTarget {
+  static createId(track) {
+    return `vds-${track.type}-${track.kind}-${track.src ?? track.label ?? "?"}`;
+  }
+  src;
+  content;
+  type;
+  encoding;
+  id = "";
+  label = "";
+  language = "";
+  kind;
+  default = false;
+  #canLoad = false;
+  #currentTime = 0;
+  #mode = "disabled";
+  #metadata = {};
+  #regions = [];
+  #cues = [];
+  #activeCues = [];
+  /** @internal */
+  [TextTrackSymbol.readyState] = 0;
+  /** @internal */
+  [TextTrackSymbol.crossOrigin];
+  /** @internal */
+  [TextTrackSymbol.onModeChange] = null;
+  /** @internal */
+  [TextTrackSymbol.native] = null;
+  get metadata() {
+    return this.#metadata;
+  }
+  get regions() {
+    return this.#regions;
+  }
+  get cues() {
+    return this.#cues;
+  }
+  get activeCues() {
+    return this.#activeCues;
+  }
+  /**
+   * - 0: Not Loading
+   * - 1: Loading
+   * - 2: Ready
+   * - 3: Error
+   */
+  get readyState() {
+    return this[TextTrackSymbol.readyState];
+  }
+  get mode() {
+    return this.#mode;
+  }
+  set mode(mode) {
+    this.setMode(mode);
+  }
+  constructor(init) {
+    super();
+    for (const prop of Object.keys(init)) this[prop] = init[prop];
+    if (!this.type) this.type = "vtt";
+    if (!IS_SERVER && init.content) {
+      this.#parseContent(init);
+    } else if (!init.src) {
+      this[TextTrackSymbol.readyState] = 2;
+    }
+    if (isTrackCaptionKind(this) && !this.label) {
+      console.warn(`[vidstack] captions text track created without label: \`${this.src}\``);
+    }
+  }
+  addCue(cue, trigger) {
+    let i = 0, length = this.#cues.length;
+    for (i = 0; i < length; i++) if (cue.endTime <= this.#cues[i].startTime) break;
+    if (i === length) this.#cues.push(cue);
+    else this.#cues.splice(i, 0, cue);
+    if (!(cue instanceof TextTrackCue)) {
+      this[TextTrackSymbol.native]?.track.addCue(cue);
+    }
+    this.dispatchEvent(new DOMEvent("add-cue", { detail: cue, trigger }));
+    if (isCueActive(cue, this.#currentTime)) {
+      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+    }
+  }
+  removeCue(cue, trigger) {
+    const index = this.#cues.indexOf(cue);
+    if (index >= 0) {
+      const isActive = this.#activeCues.includes(cue);
+      this.#cues.splice(index, 1);
+      this[TextTrackSymbol.native]?.track.removeCue(cue);
+      this.dispatchEvent(new DOMEvent("remove-cue", { detail: cue, trigger }));
+      if (isActive) {
+        this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+      }
+    }
+  }
+  setMode(mode, trigger) {
+    if (this.#mode === mode) return;
+    this.#mode = mode;
+    if (mode === "disabled") {
+      this.#activeCues = [];
+      this.#activeCuesChanged();
+    } else if (this.readyState === 2) {
+      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+    } else {
+      this.#load();
+    }
+    this.dispatchEvent(new DOMEvent("mode-change", { detail: this, trigger }));
+    this[TextTrackSymbol.onModeChange]?.();
+  }
+  /** @internal */
+  [TextTrackSymbol.updateActiveCues](currentTime, trigger) {
+    this.#currentTime = currentTime;
+    if (this.mode === "disabled" || !this.#cues.length) return;
+    const activeCues = [];
+    for (let i = 0, length = this.#cues.length; i < length; i++) {
+      const cue = this.#cues[i];
+      if (isCueActive(cue, currentTime)) activeCues.push(cue);
+    }
+    let changed = activeCues.length !== this.#activeCues.length;
+    if (!changed) {
+      for (let i = 0; i < activeCues.length; i++) {
+        if (!this.#activeCues.includes(activeCues[i])) {
+          changed = true;
+          break;
+        }
+      }
+    }
+    this.#activeCues = activeCues;
+    if (changed) this.#activeCuesChanged(trigger);
+  }
+  /** @internal */
+  [TextTrackSymbol.canLoad]() {
+    this.#canLoad = true;
+    if (this.#mode !== "disabled") this.#load();
+  }
+  #parseContent(init) {
+    import('media-captions').then(({ parseText, VTTCue, VTTRegion }) => {
+      if (!isString(init.content) || init.type === "json") {
+        this.#parseJSON(init.content, VTTCue, VTTRegion);
+        if (this.readyState !== 3) this.#ready();
+      } else {
+        parseText(init.content, { type: init.type }).then(({ cues, regions }) => {
+          this.#cues = cues;
+          this.#regions = regions;
+          this.#ready();
+        });
+      }
+    });
+  }
+  async #load() {
+    if (!this.#canLoad || this[TextTrackSymbol.readyState] > 0) return;
+    this[TextTrackSymbol.readyState] = 1;
+    this.dispatchEvent(new DOMEvent("load-start"));
+    if (!this.src) {
+      this.#ready();
+      return;
+    }
+    try {
+      const { parseResponse, VTTCue, VTTRegion } = await import('media-captions'), crossOrigin = this[TextTrackSymbol.crossOrigin]?.();
+      const response = fetch(this.src, {
+        headers: this.type === "json" ? { "Content-Type": "application/json" } : void 0,
+        credentials: getRequestCredentials(crossOrigin)
+      });
+      if (this.type === "json") {
+        this.#parseJSON(await (await response).text(), VTTCue, VTTRegion);
+      } else if (this.type === "lrc") {
+        const buffer = await response.then((r) => r.arrayBuffer());
+        let content = new TextDecoder("utf-8").decode(buffer);
+        if (/�/.test(content))
+          content = new TextDecoder("gbk").decode(buffer);
+        this.#parseLRC(content, VTTCue);
+      } else {
+        const { errors, metadata, regions, cues } = await parseResponse(response, {
+          type: this.type,
+          encoding: this.encoding
+        });
+        if (errors[0]?.code === 0) {
+          throw errors[0];
+        } else {
+          this.#metadata = metadata;
+          this.#regions = regions;
+          this.#cues = cues;
+        }
+      }
+      this.#ready();
+    } catch (error) {
+      this.#error(error);
+    }
+  }
+  #ready() {
+    this[TextTrackSymbol.readyState] = 2;
+    if (!this.src || this.type !== "vtt") {
+      const native = this[TextTrackSymbol.native];
+      if (native && !native.managed) {
+        for (const cue of this.#cues) native.track.addCue(cue);
+      }
+    }
+    const loadEvent = new DOMEvent("load");
+    this[TextTrackSymbol.updateActiveCues](this.#currentTime, loadEvent);
+    this.dispatchEvent(loadEvent);
+  }
+  #error(error) {
+    this[TextTrackSymbol.readyState] = 3;
+    this.dispatchEvent(new DOMEvent("error", { detail: error }));
+  }
+  #parseLRC(content, VTTCue) {
+    try {
+      const { cues } = parseLRCCaptionsFile(content, VTTCue);
+      this.#cues = cues;
+    } catch (error) {
+      {
+        console.error(`[vidstack] failed to parse LRC captions at: \`${this.src}\`
+
+`, error);
+      }
+      this.#error(error);
+    }
+  }
+  #parseJSON(json, VTTCue, VTTRegion) {
+    try {
+      const { regions, cues } = parseJSONCaptionsFile(json, VTTCue, VTTRegion);
+      this.#regions = regions;
+      this.#cues = cues;
+    } catch (error) {
+      {
+        console.error(`[vidstack] failed to parse JSON captions at: \`${this.src}\`
+
+`, error);
+      }
+      this.#error(error);
+    }
+  }
+  #activeCuesChanged(trigger) {
+    this.dispatchEvent(new DOMEvent("cue-change", { trigger }));
+  }
+}
+const captionRE = /captions|subtitles/;
+function isTrackCaptionKind(track) {
+  return captionRE.test(track.kind);
+}
+function parseLRCCaptionsFile(content, Cue) {
+  const lines = content.trim().split("\n");
+  const cues = [];
+  const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
+  const computedTime = (times) => +(parseInt(times[0]) * 60) + parseInt(times[1]) + parseInt(times[2].padEnd(3, "0")) / 1e3;
+  for (let i = 0; i < lines.length; i++) {
+    const line = lines[i];
+    const match = timeRegex.exec(line);
+    if (match) {
+      const [fullMatch, minutes, seconds, milliseconds] = match;
+      const text = line.slice(fullMatch.length).trim();
+      const startTime = computedTime([minutes, seconds, milliseconds]);
+      let endTime = startTime + 5;
+      for (let j = i + 1; j < lines.length; j++) {
+        const nextMatch = timeRegex.exec(lines[j]);
+        if (nextMatch) {
+          endTime = computedTime([nextMatch[1], nextMatch[2], nextMatch[3]]);
+          break;
+        }
+      }
+      const cue = new Cue(startTime, endTime, text);
+      cues.push(cue);
+    }
+  }
+  return { cues };
+}
+function parseJSONCaptionsFile(json, Cue, Region) {
+  const content = isString(json) ? JSON.parse(json) : json;
+  let regions = [], cues = [];
+  if (content.regions && Region) {
+    regions = content.regions.map((region) => Object.assign(new Region(), region));
+  }
+  if (content.cues || isArray(content)) {
+    cues = (isArray(content) ? content : content.cues).filter((content2) => isNumber(content2.startTime) && isNumber(content2.endTime)).map((cue) => Object.assign(new Cue(0, 0, ""), cue));
+  }
+  return { regions, cues };
+}
+
+const mediaState = new State({
+  artist: "",
+  artwork: null,
+  audioTrack: null,
+  audioTracks: [],
+  autoPlay: false,
+  autoPlayError: null,
+  audioGain: null,
+  buffered: new TimeRange(),
+  canLoad: false,
+  canLoadPoster: false,
+  canFullscreen: false,
+  canOrientScreen: canOrientScreen(),
+  canPictureInPicture: false,
+  canPlay: false,
+  clipStartTime: 0,
+  clipEndTime: 0,
+  controls: false,
+  get iOSControls() {
+    return IS_IPHONE && this.mediaType === "video" && (!this.playsInline || !fscreen.fullscreenEnabled && this.fullscreen);
+  },
+  get nativeControls() {
+    return this.controls || this.iOSControls;
+  },
+  controlsVisible: false,
+  get controlsHidden() {
+    return !this.controlsVisible;
+  },
+  crossOrigin: null,
+  ended: false,
+  error: null,
+  fullscreen: false,
+  get loop() {
+    return this.providedLoop || this.userPrefersLoop;
+  },
+  logLevel: "warn" ,
+  mediaType: "unknown",
+  muted: false,
+  paused: true,
+  played: new TimeRange(),
+  playing: false,
+  playsInline: false,
+  pictureInPicture: false,
+  preload: "metadata",
+  playbackRate: 1,
+  qualities: [],
+  quality: null,
+  autoQuality: false,
+  canSetQuality: true,
+  canSetPlaybackRate: true,
+  canSetVolume: false,
+  canSetAudioGain: false,
+  seekable: new TimeRange(),
+  seeking: false,
+  source: { src: "", type: "" },
+  sources: [],
+  started: false,
+  textTracks: [],
+  textTrack: null,
+  get hasCaptions() {
+    return this.textTracks.filter(isTrackCaptionKind).length > 0;
+  },
+  volume: 1,
+  waiting: false,
+  realCurrentTime: 0,
+  get currentTime() {
+    return this.ended ? this.duration : this.clipStartTime > 0 ? Math.max(0, Math.min(this.realCurrentTime - this.clipStartTime, this.duration)) : this.realCurrentTime;
+  },
+  providedDuration: -1,
+  intrinsicDuration: 0,
+  get duration() {
+    return this.seekableWindow;
+  },
+  get title() {
+    return this.providedTitle || this.inferredTitle;
+  },
+  get poster() {
+    return this.providedPoster || this.inferredPoster;
+  },
+  get viewType() {
+    return this.providedViewType !== "unknown" ? this.providedViewType : this.inferredViewType;
+  },
+  get streamType() {
+    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
+  },
+  get currentSrc() {
+    return this.source;
+  },
+  get bufferedStart() {
+    const start = getTimeRangesStart(this.buffered) ?? 0;
+    return Math.max(start, this.clipStartTime);
+  },
+  get bufferedEnd() {
+    const end = getTimeRangesEnd(this.buffered) ?? 0;
+    return Math.min(this.seekableEnd, Math.max(0, end - this.clipStartTime));
+  },
+  get bufferedWindow() {
+    return Math.max(0, this.bufferedEnd - this.bufferedStart);
+  },
+  get seekableStart() {
+    if (this.isLiveDVR && this.liveDVRWindow > 0) {
+      return Math.max(0, this.seekableEnd - this.liveDVRWindow);
+    }
+    const start = getTimeRangesStart(this.seekable) ?? 0;
+    return Math.max(start, this.clipStartTime);
+  },
+  get seekableEnd() {
+    if (this.providedDuration > 0) return this.providedDuration;
+    const end = this.liveSyncPosition > 0 ? this.liveSyncPosition : this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
+    return this.clipEndTime > 0 ? Math.min(this.clipEndTime, end) : end;
+  },
+  get seekableWindow() {
+    const window = this.seekableEnd - this.seekableStart;
+    return !isNaN(window) ? Math.max(0, window) : Infinity;
+  },
+  // ~~ remote playback ~~
+  canAirPlay: false,
+  canGoogleCast: false,
+  remotePlaybackState: "disconnected",
+  remotePlaybackType: "none",
+  remotePlaybackLoader: null,
+  remotePlaybackInfo: null,
+  get isAirPlayConnected() {
+    return this.remotePlaybackType === "airplay" && this.remotePlaybackState === "connected";
+  },
+  get isGoogleCastConnected() {
+    return this.remotePlaybackType === "google-cast" && this.remotePlaybackState === "connected";
+  },
+  // ~~ responsive design ~~
+  pointer: "fine",
+  orientation: "landscape",
+  width: 0,
+  height: 0,
+  mediaWidth: 0,
+  mediaHeight: 0,
+  lastKeyboardAction: null,
+  // ~~ user props ~~
+  userBehindLiveEdge: false,
+  // ~~ live props ~~
+  liveEdgeTolerance: 10,
+  minLiveDVRWindow: 60,
+  get canSeek() {
+    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.duration) && (!this.isLiveDVR || this.duration >= this.liveDVRWindow);
+  },
+  get live() {
+    return this.streamType.includes("live") || !Number.isFinite(this.duration);
+  },
+  get liveEdgeStart() {
+    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, this.seekableEnd - this.liveEdgeTolerance) : 0;
+  },
+  get liveEdge() {
+    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
+  },
+  get liveEdgeWindow() {
+    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
+  },
+  get isLiveDVR() {
+    return /:dvr/.test(this.streamType);
+  },
+  get liveDVRWindow() {
+    return Math.max(this.inferredLiveDVRWindow, this.minLiveDVRWindow);
+  },
+  // ~~ internal props ~~
+  autoPlaying: false,
+  providedTitle: "",
+  inferredTitle: "",
+  providedLoop: false,
+  userPrefersLoop: false,
+  providedPoster: "",
+  inferredPoster: "",
+  inferredViewType: "unknown",
+  providedViewType: "unknown",
+  providedStreamType: "unknown",
+  inferredStreamType: "unknown",
+  liveSyncPosition: null,
+  inferredLiveDVRWindow: 0,
+  savedState: null
+});
+const RESET_ON_SRC_QUALITY_CHANGE = /* @__PURE__ */ new Set([
+  "autoPlayError",
+  "autoPlaying",
+  "buffered",
+  "canPlay",
+  "error",
+  "paused",
+  "played",
+  "playing",
+  "seekable",
+  "seeking",
+  "waiting"
+]);
+const RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
+  ...RESET_ON_SRC_QUALITY_CHANGE,
+  "ended",
+  "inferredPoster",
+  "inferredStreamType",
+  "inferredTitle",
+  "intrinsicDuration",
+  "inferredLiveDVRWindow",
+  "liveSyncPosition",
+  "realCurrentTime",
+  "savedState",
+  "started",
+  "userBehindLiveEdge"
+]);
+function softResetMediaState($media, isSourceQualityChange = false) {
+  const filter = isSourceQualityChange ? RESET_ON_SRC_QUALITY_CHANGE : RESET_ON_SRC_CHANGE;
+  mediaState.reset($media, (prop) => filter.has(prop));
+  tick();
+}
+function boundTime(time, store) {
+  const clippedTime = time + store.clipStartTime(), isStart = Math.floor(time) === Math.floor(store.seekableStart()), isEnd = Math.floor(clippedTime) === Math.floor(store.seekableEnd());
+  if (isStart) {
+    return store.seekableStart();
+  }
+  if (isEnd) {
+    return store.seekableEnd();
+  }
+  if (store.isLiveDVR() && store.liveDVRWindow() > 0 && clippedTime < store.seekableEnd() - store.liveDVRWindow()) {
+    return store.bufferedStart();
+  }
+  return Math.min(Math.max(store.seekableStart() + 0.1, clippedTime), store.seekableEnd() - 0.1);
+}
+
+const mediaContext = createContext();
+function useMediaContext() {
+  return useContext(mediaContext);
+}
+
+const GROUPED_LOG = Symbol("GROUPED_LOG" );
+class GroupedLog {
+  constructor(logger, level, title, root, parent) {
+    this.logger = logger;
+    this.level = level;
+    this.title = title;
+    this.root = root;
+    this.parent = parent;
+  }
+  [GROUPED_LOG] = true;
+  logs = [];
+  log(...data) {
+    this.logs.push({ data });
+    return this;
+  }
+  labelledLog(label, ...data) {
+    this.logs.push({ label, data });
+    return this;
+  }
+  groupStart(title) {
+    return new GroupedLog(this.logger, this.level, title, this.root ?? this, this);
+  }
+  groupEnd() {
+    this.parent?.logs.push(this);
+    return this.parent ?? this;
+  }
+  dispatch() {
+    return this.logger.dispatch(this.level, this.root ?? this);
+  }
+}
+function isGroupedLog(data) {
+  return !!data?.[GROUPED_LOG];
+}
+
+class Logger {
+  #target = null;
+  error(...data) {
+    return this.dispatch("error", ...data);
+  }
+  warn(...data) {
+    return this.dispatch("warn", ...data);
+  }
+  info(...data) {
+    return this.dispatch("info", ...data);
+  }
+  debug(...data) {
+    return this.dispatch("debug", ...data);
+  }
+  errorGroup(title) {
+    return new GroupedLog(this, "error", title);
+  }
+  warnGroup(title) {
+    return new GroupedLog(this, "warn", title);
+  }
+  infoGroup(title) {
+    return new GroupedLog(this, "info", title);
+  }
+  debugGroup(title) {
+    return new GroupedLog(this, "debug", title);
+  }
+  setTarget(newTarget) {
+    this.#target = newTarget;
+  }
+  dispatch(level, ...data) {
+    return this.#target?.dispatchEvent(
+      new DOMEvent("vds-log", {
+        bubbles: true,
+        composed: true,
+        detail: { level, data }
+      })
+    ) || false;
+  }
+}
+
+class MediaRemoteControl {
+  #target = null;
+  #player = null;
+  #prevTrackIndex = -1;
+  #logger;
+  constructor(logger = new Logger() ) {
+    this.#logger = logger;
+  }
+  /**
+   * Set the target from which to dispatch media requests events from. The events should bubble
+   * up from this target to the player element.
+   *
+   * @example
+   * ```ts
+   * const button = document.querySelector('button');
+   * remote.setTarget(button);
+   * ```
+   */
+  setTarget(target) {
+    this.#target = target;
+    this.#logger?.setTarget(target);
+  }
+  /**
+   * Returns the current player element. This method will attempt to find the player by
+   * searching up from either the given `target` or default target set via `remote.setTarget`.
+   *
+   * @example
+   * ```ts
+   * const player = remote.getPlayer();
+   * ```
+   */
+  getPlayer(target) {
+    if (this.#player) return this.#player;
+    (target ?? this.#target)?.dispatchEvent(
+      new DOMEvent("find-media-player", {
+        detail: (player) => void (this.#player = player),
+        bubbles: true,
+        composed: true
+      })
+    );
+    return this.#player;
+  }
+  /**
+   * Set the current player element so the remote can support toggle methods such as
+   * `togglePaused` as they rely on the current media state.
+   */
+  setPlayer(player) {
+    this.#player = player;
+  }
+  /**
+   * Dispatch a request to start the media loading process. This will only work if the media
+   * player has been initialized with a custom loading strategy `load="custom">`.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoading(trigger) {
+    this.#dispatchRequest("media-start-loading", trigger);
+  }
+  /**
+   * Dispatch a request to start the poster loading process. This will only work if the media
+   * player has been initialized with a custom poster loading strategy `posterLoad="custom">`.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoadingPoster(trigger) {
+    this.#dispatchRequest("media-poster-start-loading", trigger);
+  }
+  /**
+   * Dispatch a request to connect to AirPlay.
+   *
+   * @see {@link https://www.apple.com/au/airplay}
+   */
+  requestAirPlay(trigger) {
+    this.#dispatchRequest("media-airplay-request", trigger);
+  }
+  /**
+   * Dispatch a request to connect to Google Cast.
+   *
+   * @see {@link https://developers.google.com/cast/docs/overview}
+   */
+  requestGoogleCast(trigger) {
+    this.#dispatchRequest("media-google-cast-request", trigger);
+  }
+  /**
+   * Dispatch a request to begin/resume media playback.
+   */
+  play(trigger) {
+    this.#dispatchRequest("media-play-request", trigger);
+  }
+  /**
+   * Dispatch a request to pause media playback.
+   */
+  pause(trigger) {
+    this.#dispatchRequest("media-pause-request", trigger);
+  }
+  /**
+   * Dispatch a request to set the media volume to mute (0).
+   */
+  mute(trigger) {
+    this.#dispatchRequest("media-mute-request", trigger);
+  }
+  /**
+   * Dispatch a request to unmute the media volume and set it back to it's previous state.
+   */
+  unmute(trigger) {
+    this.#dispatchRequest("media-unmute-request", trigger);
+  }
+  /**
+   * Dispatch a request to enter fullscreen.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  enterFullscreen(target, trigger) {
+    this.#dispatchRequest("media-enter-fullscreen-request", trigger, target);
+  }
+  /**
+   * Dispatch a request to exit fullscreen.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  exitFullscreen(target, trigger) {
+    this.#dispatchRequest("media-exit-fullscreen-request", trigger, target);
+  }
+  /**
+   * Dispatch a request to lock the screen orientation.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/screen-orientation#remote-control}
+   */
+  lockScreenOrientation(lockType, trigger) {
+    this.#dispatchRequest("media-orientation-lock-request", trigger, lockType);
+  }
+  /**
+   * Dispatch a request to unlock the screen orientation.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/screen-orientation#remote-control}
+   */
+  unlockScreenOrientation(trigger) {
+    this.#dispatchRequest("media-orientation-unlock-request", trigger);
+  }
+  /**
+   * Dispatch a request to enter picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  enterPictureInPicture(trigger) {
+    this.#dispatchRequest("media-enter-pip-request", trigger);
+  }
+  /**
+   * Dispatch a request to exit picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  exitPictureInPicture(trigger) {
+    this.#dispatchRequest("media-exit-pip-request", trigger);
+  }
+  /**
+   * Notify the media player that a seeking process is happening and to seek to the given `time`.
+   */
+  seeking(time, trigger) {
+    this.#dispatchRequest("media-seeking-request", trigger, time);
+  }
+  /**
+   * Notify the media player that a seeking operation has completed and to seek to the given `time`.
+   * This is generally called after a series of `remote.seeking()` calls.
+   */
+  seek(time, trigger) {
+    this.#dispatchRequest("media-seek-request", trigger, time);
+  }
+  seekToLiveEdge(trigger) {
+    this.#dispatchRequest("media-live-edge-request", trigger);
+  }
+  /**
+   * Dispatch a request to update the length of the media in seconds.
+   *
+   * @example
+   * ```ts
+   * remote.changeDuration(100); // 100 seconds
+   * ```
+   */
+  changeDuration(duration, trigger) {
+    this.#dispatchRequest("media-duration-change-request", trigger, duration);
+  }
+  /**
+   * Dispatch a request to update the clip start time. This is the time at which media playback
+   * should start at.
+   *
+   * @example
+   * ```ts
+   * remote.changeClipStart(100); // start at 100 seconds
+   * ```
+   */
+  changeClipStart(startTime, trigger) {
+    this.#dispatchRequest("media-clip-start-change-request", trigger, startTime);
+  }
+  /**
+   * Dispatch a request to update the clip end time. This is the time at which media playback
+   * should end at.
+   *
+   * @example
+   * ```ts
+   * remote.changeClipEnd(100); // end at 100 seconds
+   * ```
+   */
+  changeClipEnd(endTime, trigger) {
+    this.#dispatchRequest("media-clip-end-change-request", trigger, endTime);
+  }
+  /**
+   * Dispatch a request to update the media volume to the given `volume` level which is a value
+   * between 0 and 1.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/audio-gain#remote-control}
+   * @example
+   * ```ts
+   * remote.changeVolume(0); // 0%
+   * remote.changeVolume(0.05); // 5%
+   * remote.changeVolume(0.5); // 50%
+   * remote.changeVolume(0.75); // 70%
+   * remote.changeVolume(1); // 100%
+   * ```
+   */
+  changeVolume(volume, trigger) {
+    this.#dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
+  }
+  /**
+   * Dispatch a request to change the current audio track.
+   *
+   * @example
+   * ```ts
+   * remote.changeAudioTrack(1); // track at index 1
+   * ```
+   */
+  changeAudioTrack(index, trigger) {
+    this.#dispatchRequest("media-audio-track-change-request", trigger, index);
+  }
+  /**
+   * Dispatch a request to change the video quality. The special value `-1` represents auto quality
+   * selection.
+   *
+   * @example
+   * ```ts
+   * remote.changeQuality(-1); // auto
+   * remote.changeQuality(1); // quality at index 1
+   * ```
+   */
+  changeQuality(index, trigger) {
+    this.#dispatchRequest("media-quality-change-request", trigger, index);
+  }
+  /**
+   * Request auto quality selection.
+   */
+  requestAutoQuality(trigger) {
+    this.changeQuality(-1, trigger);
+  }
+  /**
+   * Dispatch a request to change the mode of the text track at the given index.
+   *
+   * @example
+   * ```ts
+   * remote.changeTextTrackMode(1, 'showing'); // track at index 1
+   * ```
+   */
+  changeTextTrackMode(index, mode, trigger) {
+    this.#dispatchRequest("media-text-track-change-request", trigger, {
+      index,
+      mode
+    });
+  }
+  /**
+   * Dispatch a request to change the media playback rate.
+   *
+   * @example
+   * ```ts
+   * remote.changePlaybackRate(0.5); // Half the normal speed
+   * remote.changePlaybackRate(1); // Normal speed
+   * remote.changePlaybackRate(1.5); // 50% faster than normal
+   * remote.changePlaybackRate(2); // Double the normal speed
+   * ```
+   */
+  changePlaybackRate(rate, trigger) {
+    this.#dispatchRequest("media-rate-change-request", trigger, rate);
+  }
+  /**
+   * Dispatch a request to change the media audio gain.
+   *
+   * @example
+   * ```ts
+   * remote.changeAudioGain(1); // Disable audio gain
+   * remote.changeAudioGain(1.5); // 50% louder
+   * remote.changeAudioGain(2); // 100% louder
+   * ```
+   */
+  changeAudioGain(gain, trigger) {
+    this.#dispatchRequest("media-audio-gain-change-request", trigger, gain);
+  }
+  /**
+   * Dispatch a request to resume idle tracking on controls.
+   */
+  resumeControls(trigger) {
+    this.#dispatchRequest("media-resume-controls-request", trigger);
+  }
+  /**
+   * Dispatch a request to pause controls idle tracking. Pausing tracking will result in the
+   * controls being visible until `remote.resumeControls()` is called. This method
+   * is generally used when building custom controls and you'd like to prevent the UI from
+   * disappearing.
+   *
+   * @example
+   * ```ts
+   * // Prevent controls hiding while menu is being interacted with.
+   * function onSettingsOpen() {
+   *   remote.pauseControls();
+   * }
+   *
+   * function onSettingsClose() {
+   *   remote.resumeControls();
+   * }
+   * ```
+   */
+  pauseControls(trigger) {
+    this.#dispatchRequest("media-pause-controls-request", trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media playback state.
+   */
+  togglePaused(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.togglePaused.name);
+      return;
+    }
+    if (player.state.paused) this.play(trigger);
+    else this.pause(trigger);
+  }
+  /**
+   * Dispatch a request to toggle the controls visibility.
+   */
+  toggleControls(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.toggleControls.name);
+      return;
+    }
+    if (!player.controls.showing) {
+      player.controls.show(0, trigger);
+    } else {
+      player.controls.hide(0, trigger);
+    }
+  }
+  /**
+   * Dispatch a request to toggle the media muted state.
+   */
+  toggleMuted(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.toggleMuted.name);
+      return;
+    }
+    if (player.state.muted) this.unmute(trigger);
+    else this.mute(trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media fullscreen state.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  toggleFullscreen(target, trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.toggleFullscreen.name);
+      return;
+    }
+    if (player.state.fullscreen) this.exitFullscreen(target, trigger);
+    else this.enterFullscreen(target, trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  togglePictureInPicture(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.togglePictureInPicture.name);
+      return;
+    }
+    if (player.state.pictureInPicture) this.exitPictureInPicture(trigger);
+    else this.enterPictureInPicture(trigger);
+  }
+  /**
+   * Show captions.
+   */
+  showCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.showCaptions.name);
+      return;
+    }
+    let tracks = player.state.textTracks, index = this.#prevTrackIndex;
+    if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
+      index = -1;
+    }
+    if (index === -1) {
+      index = tracks.findIndex((track) => isTrackCaptionKind(track) && track.default);
+    }
+    if (index === -1) {
+      index = tracks.findIndex((track) => isTrackCaptionKind(track));
+    }
+    if (index >= 0) this.changeTextTrackMode(index, "showing", trigger);
+    this.#prevTrackIndex = -1;
+  }
+  /**
+   * Turn captions off.
+   */
+  disableCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.disableCaptions.name);
+      return;
+    }
+    const tracks = player.state.textTracks, track = player.state.textTrack;
+    if (track) {
+      const index = tracks.indexOf(track);
+      this.changeTextTrackMode(index, "disabled", trigger);
+      this.#prevTrackIndex = index;
+    }
+  }
+  /**
+   * Dispatch a request to toggle the current captions mode.
+   */
+  toggleCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.toggleCaptions.name);
+      return;
+    }
+    if (player.state.textTrack) {
+      this.disableCaptions();
+    } else {
+      this.showCaptions();
+    }
+  }
+  userPrefersLoopChange(prefersLoop, trigger) {
+    this.#dispatchRequest("media-user-loop-change-request", trigger, prefersLoop);
+  }
+  #dispatchRequest(type, trigger, detail) {
+    const request = new DOMEvent(type, {
+      bubbles: true,
+      composed: true,
+      cancelable: true,
+      detail,
+      trigger
+    });
+    let target = trigger?.target || null;
+    if (target && target instanceof Component) target = target.el;
+    const shouldUsePlayer = !target || target === document || target === window || target === document.body || this.#player?.el && target instanceof Node && !this.#player.el.contains(target);
+    target = shouldUsePlayer ? this.#target ?? this.getPlayer()?.el : target ?? this.#target;
+    {
+      this.#logger?.debugGroup(`\u{1F4E8} dispatching \`${type}\``).labelledLog("Target", target).labelledLog("Player", this.#player).labelledLog("Request Event", request).labelledLog("Trigger Event", trigger).dispatch();
+    }
+    if (this.#player) {
+      if (type === "media-play-request" && !this.#player.state.canLoad) {
+        target?.dispatchEvent(request);
+      } else {
+        this.#player.canPlayQueue.enqueue(type, () => target?.dispatchEvent(request));
+      }
+    } else {
+      target?.dispatchEvent(request);
+    }
+  }
+  #noPlayerWarning(method) {
+    {
+      console.warn(
+        `[vidstack] attempted to call \`MediaRemoteControl.${method}\`() that requires player but failed because remote could not find a parent player element from target`
+      );
+    }
+  }
+}
+
+class LocalMediaStorage {
+  playerId = "vds-player";
+  mediaId = null;
+  #data = {
+    volume: null,
+    muted: null,
+    audioGain: null,
+    time: null,
+    lang: null,
+    captions: null,
+    rate: null,
+    quality: null
+  };
+  async getVolume() {
+    return this.#data.volume;
+  }
+  async setVolume(volume) {
+    this.#data.volume = volume;
+    this.save();
+  }
+  async getMuted() {
+    return this.#data.muted;
+  }
+  async setMuted(muted) {
+    this.#data.muted = muted;
+    this.save();
+  }
+  async getTime() {
+    return this.#data.time;
+  }
+  async setTime(time, ended) {
+    const shouldClear = time < 0;
+    this.#data.time = !shouldClear ? time : null;
+    if (shouldClear || ended) this.saveTime();
+    else this.saveTimeThrottled();
+  }
+  async getLang() {
+    return this.#data.lang;
+  }
+  async setLang(lang) {
+    this.#data.lang = lang;
+    this.save();
+  }
+  async getCaptions() {
+    return this.#data.captions;
+  }
+  async setCaptions(enabled) {
+    this.#data.captions = enabled;
+    this.save();
+  }
+  async getPlaybackRate() {
+    return this.#data.rate;
+  }
+  async setPlaybackRate(rate) {
+    this.#data.rate = rate;
+    this.save();
+  }
+  async getAudioGain() {
+    return this.#data.audioGain;
+  }
+  async setAudioGain(gain) {
+    this.#data.audioGain = gain;
+    this.save();
+  }
+  async getVideoQuality() {
+    return this.#data.quality;
+  }
+  async setVideoQuality(quality) {
+    this.#data.quality = quality;
+    this.save();
+  }
+  onChange(src, mediaId, playerId = "vds-player") {
+    const savedData = playerId ? localStorage.getItem(playerId) : null, savedTime = mediaId ? localStorage.getItem(mediaId) : null;
+    this.playerId = playerId;
+    this.mediaId = mediaId;
+    this.#data = {
+      volume: null,
+      muted: null,
+      audioGain: null,
+      lang: null,
+      captions: null,
+      rate: null,
+      quality: null,
+      ...savedData ? JSON.parse(savedData) : {},
+      time: savedTime ? +savedTime : null
+    };
+  }
+  save() {
+    if (IS_SERVER || !this.playerId) return;
+    const data = JSON.stringify({ ...this.#data, time: void 0 });
+    localStorage.setItem(this.playerId, data);
+  }
+  saveTimeThrottled = functionThrottle(this.saveTime.bind(this), 1e3);
+  saveTime() {
+    if (IS_SERVER || !this.mediaId) return;
+    const data = (this.#data.time ?? 0).toString();
+    localStorage.setItem(this.mediaId, data);
+  }
+}
+
+const ADD = Symbol("LIST_ADD" ), REMOVE = Symbol("LIST_REMOVE" ), RESET = Symbol("LIST_RESET" ), SELECT = Symbol("LIST_SELECT" ), READONLY = Symbol("LIST_READONLY" ), SET_READONLY = Symbol("LIST_SET_READONLY" ), ON_RESET = Symbol("LIST_ON_RESET" ), ON_REMOVE = Symbol("LIST_ON_REMOVE" ), ON_USER_SELECT = Symbol("LIST_ON_USER_SELECT" );
+const ListSymbol = {
+  add: ADD,
+  remove: REMOVE,
+  reset: RESET,
+  select: SELECT,
+  readonly: READONLY,
+  setReadonly: SET_READONLY,
+  onReset: ON_RESET,
+  onRemove: ON_REMOVE,
+  onUserSelect: ON_USER_SELECT
+};
+
+class List extends EventsTarget {
+  items = [];
+  /** @internal */
+  [ListSymbol.readonly] = false;
+  get length() {
+    return this.items.length;
+  }
+  get readonly() {
+    return this[ListSymbol.readonly];
+  }
+  /**
+   * Returns the index of the first occurrence of the given item, or -1 if it is not present.
+   */
+  indexOf(item) {
+    return this.items.indexOf(item);
+  }
+  /**
+   * Returns an item matching the given `id`, or `null` if not present.
+   */
+  getById(id) {
+    if (id === "") return null;
+    return this.items.find((item) => item.id === id) ?? null;
+  }
+  /**
+   * Transform list to an array.
+   */
+  toArray() {
+    return [...this.items];
+  }
+  [Symbol.iterator]() {
+    return this.items.values();
+  }
+  /** @internal */
+  [ListSymbol.add](item, trigger) {
+    const index = this.items.length;
+    if (!("" + index in this)) {
+      Object.defineProperty(this, index, {
+        get() {
+          return this.items[index];
+        }
+      });
+    }
+    if (this.items.includes(item)) return;
+    this.items.push(item);
+    this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
+  }
+  /** @internal */
+  [ListSymbol.remove](item, trigger) {
+    const index = this.items.indexOf(item);
+    if (index >= 0) {
+      this[ListSymbol.onRemove]?.(item, trigger);
+      this.items.splice(index, 1);
+      this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
+    }
+  }
+  /** @internal */
+  [ListSymbol.reset](trigger) {
+    for (const item of [...this.items]) this[ListSymbol.remove](item, trigger);
+    this.items = [];
+    this[ListSymbol.setReadonly](false, trigger);
+    this[ListSymbol.onReset]?.();
+  }
+  /** @internal */
+  [ListSymbol.setReadonly](readonly, trigger) {
+    if (this[ListSymbol.readonly] === readonly) return;
+    this[ListSymbol.readonly] = readonly;
+    this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
+  }
+}
+
+const SELECTED = Symbol("SELECTED" );
+class SelectList extends List {
+  get selected() {
+    return this.items.find((item) => item.selected) ?? null;
+  }
+  get selectedIndex() {
+    return this.items.findIndex((item) => item.selected);
+  }
+  /** @internal */
+  [ListSymbol.onRemove](item, trigger) {
+    this[ListSymbol.select](item, false, trigger);
+  }
+  /** @internal */
+  [ListSymbol.add](item, trigger) {
+    item[SELECTED] = false;
+    Object.defineProperty(item, "selected", {
+      get() {
+        return this[SELECTED];
+      },
+      set: (selected) => {
+        if (this.readonly) return;
+        this[ListSymbol.onUserSelect]?.();
+        this[ListSymbol.select](item, selected);
+      }
+    });
+    super[ListSymbol.add](item, trigger);
+  }
+  /** @internal */
+  [ListSymbol.select](item, selected, trigger) {
+    if (selected === item?.[SELECTED]) return;
+    const prev = this.selected;
+    if (item) item[SELECTED] = selected;
+    const changed = !selected ? prev === item : prev !== item;
+    if (changed) {
+      if (prev) prev[SELECTED] = false;
+      this.dispatchEvent(
+        new DOMEvent("change", {
+          detail: {
+            prev,
+            current: this.selected
+          },
+          trigger
+        })
+      );
+    }
+  }
+}
+
+class AudioTrackList extends SelectList {
+}
+
+function round(num, decimalPlaces = 2) {
+  return Number(num.toFixed(decimalPlaces));
+}
+function getNumberOfDecimalPlaces(num) {
+  return String(num).split(".")[1]?.length ?? 0;
+}
+function clampNumber(min, value, max) {
+  return Math.max(min, Math.min(max, value));
+}
+
+function isEventInside(el, event) {
+  const target = event.composedPath()[0];
+  return isDOMNode(target) && el.contains(target);
+}
+const rafJobs = /* @__PURE__ */ new Set();
+if (!IS_SERVER) {
+  let processJobs = function() {
+    for (const job of rafJobs) {
+      try {
+        job();
+      } catch (e) {
+        console.error(`[vidstack] failed job:
+
+${e}`);
+      }
+    }
+    window.requestAnimationFrame(processJobs);
+  };
+  processJobs();
+}
+function scheduleRafJob(job) {
+  rafJobs.add(job);
+  return () => rafJobs.delete(job);
+}
+function setAttributeIfEmpty(target, name, value) {
+  if (!target.hasAttribute(name)) target.setAttribute(name, value);
+}
+function setARIALabel(target, $label) {
+  if (target.hasAttribute("aria-label") || target.hasAttribute("data-no-label")) return;
+  if (!isFunction($label)) {
+    setAttribute(target, "aria-label", $label);
+    return;
+  }
+  function updateAriaDescription() {
+    setAttribute(target, "aria-label", $label());
+  }
+  if (IS_SERVER) updateAriaDescription();
+  else effect(updateAriaDescription);
+}
+function isElementVisible(el) {
+  const style = getComputedStyle(el);
+  return style.display !== "none" && parseInt(style.opacity) > 0;
+}
+function checkVisibility(el) {
+  return !!el && ("checkVisibility" in el ? el.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true }) : isElementVisible(el));
+}
+function observeVisibility(el, callback) {
+  return scheduleRafJob(() => callback(checkVisibility(el)));
+}
+function isElementParent(owner, node, test) {
+  while (node) {
+    if (node === owner) {
+      return true;
+    } else if (test?.(node)) {
+      break;
+    } else {
+      node = node.parentElement;
+    }
+  }
+  return false;
+}
+function onPress(target, handler) {
+  return new EventsController(target).add("pointerup", (event) => {
+    if (event.button === 0 && !event.defaultPrevented) handler(event);
+  }).add("keydown", (event) => {
+    if (isKeyboardClick(event)) handler(event);
+  });
+}
+function isTouchPinchEvent(event) {
+  return isTouchEvent(event) && (event.touches.length > 1 || event.changedTouches.length > 1);
+}
+function requestScopedAnimationFrame(callback) {
+  if (IS_SERVER) return callback();
+  let scope = getScope(), id = window.requestAnimationFrame(() => {
+    scoped(callback, scope);
+    id = -1;
+  });
+  return () => void window.cancelAnimationFrame(id);
+}
+function autoPlacement(el, trigger, placement, {
+  offsetVarName,
+  xOffset,
+  yOffset,
+  ...options
+}) {
+  if (!el) return;
+  const floatingPlacement = placement.replace(" ", "-").replace("-center", "");
+  setStyle(el, "visibility", !trigger ? "hidden" : null);
+  if (!trigger) return;
+  let isTop = placement.includes("top");
+  const negateX = (x) => placement.includes("left") ? `calc(-1 * ${x})` : x, negateY = (y) => isTop ? `calc(-1 * ${y})` : y;
+  return autoUpdate(trigger, el, () => {
+    computePosition(trigger, el, {
+      placement: floatingPlacement,
+      middleware: [
+        ...options.middleware ?? [],
+        flip({ fallbackAxisSideDirection: "start", crossAxis: false }),
+        shift()
+      ],
+      ...options
+    }).then(({ x, y, middlewareData }) => {
+      const hasFlipped = !!middlewareData.flip?.index;
+      isTop = placement.includes(hasFlipped ? "bottom" : "top");
+      el.setAttribute(
+        "data-placement",
+        hasFlipped ? placement.startsWith("top") ? placement.replace("top", "bottom") : placement.replace("bottom", "top") : placement
+      );
+      Object.assign(el.style, {
+        top: `calc(${y + "px"} + ${negateY(
+          yOffset ? yOffset + "px" : `var(--${offsetVarName}-y-offset, 0px)`
+        )})`,
+        left: `calc(${x + "px"} + ${negateX(
+          xOffset ? xOffset + "px" : `var(--${offsetVarName}-x-offset, 0px)`
+        )})`
+      });
+    });
+  });
+}
+function hasAnimation(el) {
+  const styles = getComputedStyle(el);
+  return styles.animationName !== "none";
+}
+function isHTMLElement(el) {
+  return el instanceof HTMLElement;
+}
+
+class NativeTextRenderer {
+  priority = 0;
+  #display = true;
+  #video = null;
+  #track = null;
+  #tracks = /* @__PURE__ */ new Set();
+  canRender(_, video) {
+    return !!video;
+  }
+  attach(video) {
+    this.#video = video;
+    if (video) video.textTracks.onchange = this.#onChange.bind(this);
+  }
+  addTrack(track) {
+    this.#tracks.add(track);
+    this.#attachTrack(track);
+  }
+  removeTrack(track) {
+    track[TextTrackSymbol.native]?.remove?.();
+    track[TextTrackSymbol.native] = null;
+    this.#tracks.delete(track);
+  }
+  changeTrack(track) {
+    const current = track?.[TextTrackSymbol.native];
+    if (current && current.track.mode !== "showing") {
+      current.track.mode = "showing";
+    }
+    this.#track = track;
+  }
+  setDisplay(display) {
+    this.#display = display;
+    this.#onChange();
+  }
+  detach() {
+    if (this.#video) this.#video.textTracks.onchange = null;
+    for (const track of this.#tracks) this.removeTrack(track);
+    this.#tracks.clear();
+    this.#video = null;
+    this.#track = null;
+  }
+  #attachTrack(track) {
+    if (!this.#video) return;
+    const el = track[TextTrackSymbol.native] ??= this.#createTrackElement(track);
+    if (isHTMLElement(el)) {
+      this.#video.append(el);
+      el.track.mode = el.default ? "showing" : "disabled";
+    }
+  }
+  #createTrackElement(track) {
+    const el = document.createElement("track"), isDefault = track.default || track.mode === "showing", isSupported = track.src && track.type === "vtt";
+    el.id = track.id;
+    el.src = isSupported ? track.src : "";
+    el.label = track.label;
+    el.kind = track.kind;
+    el.default = isDefault;
+    track.language && (el.srclang = track.language);
+    if (isDefault && !isSupported) {
+      this.#copyCues(track, el.track);
+    }
+    return el;
+  }
+  #copyCues(track, native) {
+    if (track.src && track.type === "vtt" || native.cues?.length) return;
+    for (const cue of track.cues) native.addCue(cue);
+  }
+  #onChange(event) {
+    for (const track of this.#tracks) {
+      const native = track[TextTrackSymbol.native];
+      if (!native) continue;
+      if (!this.#display) {
+        native.track.mode = native.managed ? "hidden" : "disabled";
+        continue;
+      }
+      const isShowing = native.track.mode === "showing";
+      if (isShowing) this.#copyCues(track, native.track);
+      track.setMode(isShowing ? "showing" : "disabled", event);
+    }
+  }
+}
+
+class TextRenderers {
+  #video = null;
+  #textTracks;
+  #renderers = [];
+  #media;
+  #nativeDisplay = false;
+  #nativeRenderer = null;
+  #customRenderer = null;
+  constructor(media) {
+    this.#media = media;
+    const textTracks = media.textTracks;
+    this.#textTracks = textTracks;
+    effect(this.#watchControls.bind(this));
+    onDispose(this.#detach.bind(this));
+    new EventsController(textTracks).add("add", this.#onAddTrack.bind(this)).add("remove", this.#onRemoveTrack.bind(this)).add("mode-change", this.#update.bind(this));
+  }
+  #watchControls() {
+    const { nativeControls } = this.#media.$state;
+    this.#nativeDisplay = nativeControls();
+    this.#update();
+  }
+  add(renderer) {
+    this.#renderers.push(renderer);
+    untrack(this.#update.bind(this));
+  }
+  remove(renderer) {
+    renderer.detach();
+    this.#renderers.splice(this.#renderers.indexOf(renderer), 1);
+    untrack(this.#update.bind(this));
+  }
+  /** @internal */
+  attachVideo(video) {
+    requestAnimationFrame(() => {
+      this.#video = video;
+      if (video) {
+        this.#nativeRenderer = new NativeTextRenderer();
+        this.#nativeRenderer.attach(video);
+        for (const track of this.#textTracks) this.#addNativeTrack(track);
+      }
+      this.#update();
+    });
+  }
+  #addNativeTrack(track) {
+    if (!isTrackCaptionKind(track)) return;
+    this.#nativeRenderer?.addTrack(track);
+  }
+  #removeNativeTrack(track) {
+    if (!isTrackCaptionKind(track)) return;
+    this.#nativeRenderer?.removeTrack(track);
+  }
+  #onAddTrack(event) {
+    this.#addNativeTrack(event.detail);
+  }
+  #onRemoveTrack(event) {
+    this.#removeNativeTrack(event.detail);
+  }
+  #update() {
+    const currentTrack = this.#textTracks.selected;
+    if (this.#video && (this.#nativeDisplay || currentTrack?.[TextTrackSymbol.nativeHLS])) {
+      this.#customRenderer?.changeTrack(null);
+      this.#nativeRenderer?.setDisplay(true);
+      this.#nativeRenderer?.changeTrack(currentTrack);
+      return;
+    }
+    this.#nativeRenderer?.setDisplay(false);
+    this.#nativeRenderer?.changeTrack(null);
+    if (!currentTrack) {
+      this.#customRenderer?.changeTrack(null);
+      return;
+    }
+    const customRenderer = this.#renderers.sort((a, b) => a.priority - b.priority).find((renderer) => renderer.canRender(currentTrack, this.#video));
+    if (this.#customRenderer !== customRenderer) {
+      this.#customRenderer?.detach();
+      customRenderer?.attach(this.#video);
+      this.#customRenderer = customRenderer ?? null;
+    }
+    customRenderer?.changeTrack(currentTrack);
+  }
+  #detach() {
+    this.#nativeRenderer?.detach();
+    this.#nativeRenderer = null;
+    this.#customRenderer?.detach();
+    this.#customRenderer = null;
+  }
+}
+
+class TextTrackList extends List {
+  #canLoad = false;
+  #defaults = {};
+  #storage = null;
+  #preferredLang = null;
+  /** @internal */
+  [TextTrackSymbol.crossOrigin];
+  constructor() {
+    super();
+  }
+  get selected() {
+    const track = this.items.find((t) => t.mode === "showing" && isTrackCaptionKind(t));
+    return track ?? null;
+  }
+  get selectedIndex() {
+    const selected = this.selected;
+    return selected ? this.indexOf(selected) : -1;
+  }
+  get preferredLang() {
+    return this.#preferredLang;
+  }
+  set preferredLang(lang) {
+    this.#preferredLang = lang;
+    this.#saveLang(lang);
+  }
+  add(init, trigger) {
+    const isTrack = init instanceof TextTrack, track = isTrack ? init : new TextTrack(init), kind = init.kind === "captions" || init.kind === "subtitles" ? "captions" : init.kind;
+    if (this.#defaults[kind] && init.default) delete init.default;
+    track.addEventListener("mode-change", this.#onTrackModeChangeBind);
+    this[ListSymbol.add](track, trigger);
+    track[TextTrackSymbol.crossOrigin] = this[TextTrackSymbol.crossOrigin];
+    if (this.#canLoad) track[TextTrackSymbol.canLoad]();
+    if (init.default) this.#defaults[kind] = track;
+    this.#selectTracks();
+    return this;
+  }
+  remove(track, trigger) {
+    this.#pendingRemoval = track;
+    if (!this.items.includes(track)) return;
+    if (track === this.#defaults[track.kind]) delete this.#defaults[track.kind];
+    track.mode = "disabled";
+    track[TextTrackSymbol.onModeChange] = null;
+    track.removeEventListener("mode-change", this.#onTrackModeChangeBind);
+    this[ListSymbol.remove](track, trigger);
+    this.#pendingRemoval = null;
+    return this;
+  }
+  clear(trigger) {
+    for (const track of [...this.items]) {
+      this.remove(track, trigger);
+    }
+    return this;
+  }
+  getByKind(kind) {
+    const kinds = Array.isArray(kind) ? kind : [kind];
+    return this.items.filter((track) => kinds.includes(track.kind));
+  }
+  /** @internal */
+  [TextTrackSymbol.canLoad]() {
+    if (this.#canLoad) return;
+    for (const track of this.items) track[TextTrackSymbol.canLoad]();
+    this.#canLoad = true;
+    this.#selectTracks();
+  }
+  #selectTracks = functionDebounce(async () => {
+    if (!this.#canLoad) return;
+    if (!this.#preferredLang && this.#storage) {
+      this.#preferredLang = await this.#storage.getLang();
+    }
+    const showCaptions = await this.#storage?.getCaptions(), kinds = [
+      ["captions", "subtitles"],
+      "chapters",
+      "descriptions",
+      "metadata"
+    ];
+    for (const kind of kinds) {
+      const tracks = this.getByKind(kind);
+      if (tracks.find((t) => t.mode === "showing")) continue;
+      const preferredTrack = this.#preferredLang ? tracks.find((track2) => track2.language === this.#preferredLang) : null;
+      const defaultTrack = isArray(kind) ? this.#defaults[kind.find((kind2) => this.#defaults[kind2]) || ""] : this.#defaults[kind];
+      const track = preferredTrack ?? defaultTrack, isCaptionsKind = track && isTrackCaptionKind(track);
+      if (track && (!isCaptionsKind || showCaptions !== false)) {
+        track.mode = "showing";
+        if (isCaptionsKind) this.#saveCaptionsTrack(track);
+      }
+    }
+  }, 300);
+  #pendingRemoval = null;
+  #onTrackModeChangeBind = this.#onTrackModeChange.bind(this);
+  #onTrackModeChange(event) {
+    const track = event.detail;
+    if (this.#storage && isTrackCaptionKind(track) && track !== this.#pendingRemoval) {
+      this.#saveCaptionsTrack(track);
+    }
+    if (track.mode === "showing") {
+      const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
+      for (const t of this.items) {
+        if (t.mode === "showing" && t != track && kinds.includes(t.kind)) {
+          t.mode = "disabled";
+        }
+      }
+    }
+    this.dispatchEvent(
+      new DOMEvent("mode-change", {
+        detail: event.detail,
+        trigger: event
+      })
+    );
+  }
+  #saveCaptionsTrack(track) {
+    if (track.mode !== "disabled") {
+      this.#saveLang(track.language);
+    }
+    this.#storage?.setCaptions?.(track.mode === "showing");
+  }
+  #saveLang(lang) {
+    this.#storage?.setLang?.(this.#preferredLang = lang);
+  }
+  setStorage(storage) {
+    this.#storage = storage;
+  }
+}
+
+const SET_AUTO = Symbol("SET_AUTO_QUALITY" ), ENABLE_AUTO = Symbol("ENABLE_AUTO_QUALITY" );
+const QualitySymbol = {
+  setAuto: SET_AUTO,
+  enableAuto: ENABLE_AUTO
+};
+
+class VideoQualityList extends SelectList {
+  #auto = false;
+  /**
+   * Configures quality switching:
+   *
+   * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
+   * request if any, flush the whole buffer, and fetch fragment matching with current position
+   * and requested quality level.
+   *
+   * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
+   * already buffered next fragment.
+   *
+   * - `load`: Set quality level for next loaded fragment.
+   *
+   * @see {@link https://www.vidstack.io/docs/player/api/video-quality#switch}
+   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
+   */
+  switch = "current";
+  /**
+   * Whether automatic quality selection is enabled.
+   */
+  get auto() {
+    return this.#auto || this.readonly;
+  }
+  /** @internal */
+  [QualitySymbol.enableAuto];
+  /** @internal */
+  [ListSymbol.onUserSelect]() {
+    this[QualitySymbol.setAuto](false);
+  }
+  /** @internal */
+  [ListSymbol.onReset](trigger) {
+    this[QualitySymbol.enableAuto] = void 0;
+    this[QualitySymbol.setAuto](false, trigger);
+  }
+  /**
+   * Request automatic quality selection (if supported). This will be a no-op if the list is
+   * `readonly` as that already implies auto-selection.
+   */
+  autoSelect(trigger) {
+    if (this.readonly || this.#auto || !this[QualitySymbol.enableAuto]) return;
+    this[QualitySymbol.enableAuto]?.(trigger);
+    this[QualitySymbol.setAuto](true, trigger);
+  }
+  getBySrc(src) {
+    return this.items.find((quality) => quality.src === src);
+  }
+  /** @internal */
+  [QualitySymbol.setAuto](auto, trigger) {
+    if (this.#auto === auto) return;
+    this.#auto = auto;
+    this.dispatchEvent(
+      new DOMEvent("auto-change", {
+        detail: auto,
+        trigger
+      })
+    );
+  }
+}
+
+function sortVideoQualities(qualities, desc) {
+  return [...qualities].sort(desc ? compareVideoQualityDesc : compareVideoQualityAsc);
+}
+function compareVideoQualityAsc(a, b) {
+  return a.height === b.height ? (a.bitrate ?? 0) - (b.bitrate ?? 0) : a.height - b.height;
+}
+function compareVideoQualityDesc(a, b) {
+  return b.height === a.height ? (b.bitrate ?? 0) - (a.bitrate ?? 0) : b.height - a.height;
+}
+
+function isAudioProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "AUDIO";
+}
+function isVideoProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "VIDEO";
+}
+function isHLSProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "HLS";
+}
+function isDASHProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "DASH";
+}
+function isYouTubeProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "YOUTUBE";
+}
+function isVimeoProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "VIMEO";
+}
+function isGoogleCastProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "GOOGLE_CAST";
+}
+function isHTMLAudioElement(element) {
+  return !IS_SERVER && element instanceof HTMLAudioElement;
+}
+function isHTMLVideoElement(element) {
+  return !IS_SERVER && element instanceof HTMLVideoElement;
+}
+function isHTMLMediaElement(element) {
+  return isHTMLAudioElement(element) || isHTMLVideoElement(element);
+}
+function isHTMLIFrameElement(element) {
+  return !IS_SERVER && element instanceof HTMLIFrameElement;
+}
+
+class MediaPlayerController extends ViewController {
+}
+
+const MEDIA_KEY_SHORTCUTS = {
+  togglePaused: "k Space",
+  toggleMuted: "m",
+  toggleFullscreen: "f",
+  togglePictureInPicture: "i",
+  toggleCaptions: "c",
+  seekBackward: "j J ArrowLeft",
+  seekForward: "l L ArrowRight",
+  volumeUp: "ArrowUp",
+  volumeDown: "ArrowDown",
+  speedUp: ">",
+  slowDown: "<"
+};
+const MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Ctrl"]), BUTTON_SELECTORS = 'button, [role="button"]', IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"], [role="timer"]';
+class MediaKeyboardController extends MediaPlayerController {
+  #media;
+  constructor(media) {
+    super();
+    this.#media = media;
+  }
+  onConnect() {
+    effect(this.#onTargetChange.bind(this));
+  }
+  #onTargetChange() {
+    const { keyDisabled, keyTarget } = this.$props;
+    if (keyDisabled()) return;
+    const target = keyTarget() === "player" ? this.el : document, $active = signal(false);
+    if (target === this.el) {
+      new EventsController(this.el).add("focusin", () => $active.set(true)).add("focusout", (event) => {
+        if (!this.el.contains(event.target)) $active.set(false);
+      });
+    } else {
+      if (!peek($active)) $active.set(document.querySelector("[data-media-player]") === this.el);
+      listenEvent(document, "focusin", (event) => {
+        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
+        if (activePlayer !== void 0) $active.set(this.el === activePlayer);
+      });
+    }
+    effect(() => {
+      if (!$active()) return;
+      new EventsController(target).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("keydown", this.#onPreventVideoKeys.bind(this), { capture: true });
+    });
+  }
+  #onKeyUp(event) {
+    const focusedEl = document.activeElement;
+    if (!event.key || !this.$state.canSeek() || focusedEl?.matches(IGNORE_SELECTORS)) {
+      return;
+    }
+    let { method, value } = this.#getMatchingMethod(event);
+    if (!isString(value) && !isArray(value)) {
+      value?.onKeyUp?.({
+        event,
+        player: this.#media.player,
+        remote: this.#media.remote
+      });
+      value?.callback?.(event, this.#media.remote);
+      return;
+    }
+    if (method?.startsWith("seek")) {
+      event.preventDefault();
+      event.stopPropagation();
+      if (this.#timeSlider) {
+        this.#forwardTimeKeyboardEvent(event, method === "seekForward");
+        this.#timeSlider = null;
+      } else {
+        this.#media.remote.seek(this.#seekTotal, event);
+        this.#seekTotal = void 0;
+      }
+    }
+    if (method?.startsWith("volume")) {
+      const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
+      volumeSlider?.dispatchEvent(
+        new KeyboardEvent("keyup", {
+          key: method === "volumeUp" ? "Up" : "Down",
+          shiftKey: event.shiftKey,
+          trigger: event
+        })
+      );
+    }
+  }
+  #onKeyDown(event) {
+    if (!event.key || MODIFIER_KEYS.has(event.key)) return;
+    const focusedEl = document.activeElement;
+    if (focusedEl?.matches(IGNORE_SELECTORS) || isKeyboardClick(event) && focusedEl?.matches(BUTTON_SELECTORS)) {
+      return;
+    }
+    let { method, value } = this.#getMatchingMethod(event), isNumberPress = !event.metaKey && /^[0-9]$/.test(event.key);
+    if (!isString(value) && !isArray(value) && !isNumberPress) {
+      value?.onKeyDown?.({
+        event,
+        player: this.#media.player,
+        remote: this.#media.remote
+      });
+      value?.callback?.(event, this.#media.remote);
+      return;
+    }
+    if (!method && isNumberPress) {
+      event.preventDefault();
+      event.stopPropagation();
+      this.#media.remote.seek(this.$state.duration() / 10 * Number(event.key), event);
+      return;
+    }
+    if (!method) return;
+    event.preventDefault();
+    event.stopPropagation();
+    switch (method) {
+      case "seekForward":
+      case "seekBackward":
+        this.#seeking(event, method, method === "seekForward");
+        break;
+      case "volumeUp":
+      case "volumeDown":
+        const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
+        if (volumeSlider) {
+          volumeSlider.dispatchEvent(
+            new KeyboardEvent("keydown", {
+              key: method === "volumeUp" ? "Up" : "Down",
+              shiftKey: event.shiftKey,
+              trigger: event
+            })
+          );
+        } else {
+          const value2 = event.shiftKey ? 0.1 : 0.05;
+          this.#media.remote.changeVolume(
+            this.$state.volume() + (method === "volumeUp" ? +value2 : -value2),
+            event
+          );
+        }
+        break;
+      case "toggleFullscreen":
+        this.#media.remote.toggleFullscreen("prefer-media", event);
+        break;
+      case "speedUp":
+      case "slowDown":
+        const playbackRate = this.$state.playbackRate();
+        this.#media.remote.changePlaybackRate(
+          Math.max(0.25, Math.min(2, playbackRate + (method === "speedUp" ? 0.25 : -0.25))),
+          event
+        );
+        break;
+      default:
+        this.#media.remote[method]?.(event);
+    }
+    this.$state.lastKeyboardAction.set({
+      action: method,
+      event
+    });
+  }
+  #onPreventVideoKeys(event) {
+    if (isHTMLMediaElement(event.target) && this.#getMatchingMethod(event).method) {
+      event.preventDefault();
+    }
+  }
+  #getMatchingMethod(event) {
+    const keyShortcuts = {
+      ...this.$props.keyShortcuts(),
+      ...this.#media.ariaKeys
+    };
+    const method = Object.keys(keyShortcuts).find((method2) => {
+      const value = keyShortcuts[method2], keys = isArray(value) ? value.join(" ") : isString(value) ? value : value?.keys;
+      const combinations = (isArray(keys) ? keys : keys?.split(" "))?.map(
+        (key) => replaceSymbolKeys(key).replace(/Control/g, "Ctrl").split("+")
+      );
+      return combinations?.some((combo) => {
+        const modifierKeys = new Set(combo.filter((key) => MODIFIER_KEYS.has(key)));
+        for (const modKey of MODIFIER_KEYS) {
+          const modKeyProp = modKey.toLowerCase() + "Key";
+          if (!modifierKeys.has(modKey) && event[modKeyProp]) {
+            return false;
+          }
+        }
+        return combo.every((key) => {
+          return MODIFIER_KEYS.has(key) ? event[key.toLowerCase() + "Key"] : event.key === key.replace("Space", " ");
+        });
+      });
+    });
+    return {
+      method,
+      value: method ? keyShortcuts[method] : null
+    };
+  }
+  #seekTotal;
+  #calcSeekAmount(event, type) {
+    const seekBy = event.shiftKey ? 10 : 5;
+    return this.#seekTotal = Math.max(
+      0,
+      Math.min(
+        (this.#seekTotal ?? this.$state.currentTime()) + (type === "seekForward" ? +seekBy : -seekBy),
+        this.$state.duration()
+      )
+    );
+  }
+  #timeSlider = null;
+  #forwardTimeKeyboardEvent(event, forward) {
+    this.#timeSlider?.dispatchEvent(
+      new KeyboardEvent(event.type, {
+        key: !forward ? "Left" : "Right",
+        shiftKey: event.shiftKey,
+        trigger: event
+      })
+    );
+  }
+  #seeking(event, type, forward) {
+    if (!this.$state.canSeek()) return;
+    if (!this.#timeSlider) {
+      this.#timeSlider = this.el.querySelector("[data-media-time-slider]");
+    }
+    if (this.#timeSlider) {
+      this.#forwardTimeKeyboardEvent(event, forward);
+    } else {
+      this.#media.remote.seeking(this.#calcSeekAmount(event, type), event);
+    }
+  }
+}
+const SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
+function replaceSymbolKeys(key) {
+  return key.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
+}
+
+class ARIAKeyShortcuts extends ViewController {
+  #shortcut;
+  constructor(shortcut) {
+    super();
+    this.#shortcut = shortcut;
+  }
+  onAttach(el) {
+    const { $props, ariaKeys } = useMediaContext(), keys = el.getAttribute("aria-keyshortcuts");
+    if (keys) {
+      ariaKeys[this.#shortcut] = keys;
+      if (!IS_SERVER) {
+        onDispose(() => {
+          delete ariaKeys[this.#shortcut];
+        });
+      }
+      return;
+    }
+    const shortcuts = $props.keyShortcuts()[this.#shortcut];
+    if (shortcuts) {
+      const keys2 = isArray(shortcuts) ? shortcuts.join(" ") : isString(shortcuts) ? shortcuts : shortcuts?.keys;
+      el.setAttribute("aria-keyshortcuts", isArray(keys2) ? keys2.join(" ") : keys2);
+    }
+  }
+}
+
+class MediaControls extends MediaPlayerController {
+  #idleTimer = -2;
+  #pausedTracking = false;
+  #hideOnMouseLeave = signal(false);
+  #isMouseOutside = signal(false);
+  #focusedItem = null;
+  #canIdle = signal(true);
+  /**
+   * The default amount of delay in milliseconds while media playback is progressing without user
+   * activity to indicate an idle state (i.e., hide controls).
+   *
+   * @defaultValue 2000
+   */
+  defaultDelay = 2e3;
+  /**
+   * Whether controls can hide after a delay in user interaction. If this is false, controls will
+   * not hide and be user controlled.
+   */
+  get canIdle() {
+    return this.#canIdle();
+  }
+  set canIdle(canIdle) {
+    this.#canIdle.set(canIdle);
+  }
+  /**
+   * Whether controls visibility should be toggled when the mouse enters and leaves the player
+   * container.
+   *
+   * @defaultValue false
+   */
+  get hideOnMouseLeave() {
+    const { hideControlsOnMouseLeave } = this.$props;
+    return this.#hideOnMouseLeave() || hideControlsOnMouseLeave();
+  }
+  set hideOnMouseLeave(hide) {
+    this.#hideOnMouseLeave.set(hide);
+  }
+  /**
+   * Whether media controls are currently visible.
+   */
+  get showing() {
+    return this.$state.controlsVisible();
+  }
+  /**
+   * Show controls.
+   */
+  show(delay = 0, trigger) {
+    this.#clearIdleTimer();
+    if (!this.#pausedTracking) {
+      this.#changeVisibility(true, delay, trigger);
+    }
+  }
+  /**
+   * Hide controls.
+   */
+  hide(delay = this.defaultDelay, trigger) {
+    this.#clearIdleTimer();
+    if (!this.#pausedTracking) {
+      this.#changeVisibility(false, delay, trigger);
+    }
+  }
+  /**
+   * Whether all idle tracking on controls should be paused until resumed again.
+   */
+  pause(trigger) {
+    this.#pausedTracking = true;
+    this.#clearIdleTimer();
+    this.#changeVisibility(true, 0, trigger);
+  }
+  resume(trigger) {
+    this.#pausedTracking = false;
+    if (this.$state.paused()) return;
+    this.#changeVisibility(false, this.defaultDelay, trigger);
+  }
+  onConnect() {
+    effect(this.#init.bind(this));
+  }
+  #init() {
+    const { viewType } = this.$state;
+    if (!this.el || !this.#canIdle()) return;
+    if (viewType() === "audio") {
+      this.show();
+      return;
+    }
+    effect(this.#watchMouse.bind(this));
+    effect(this.#watchPaused.bind(this));
+    const onPlay = this.#onPlay.bind(this), onPause = this.#onPause.bind(this), onEnd = this.#onEnd.bind(this);
+    new EventsController(this.el).add("can-play", (event) => this.show(0, event)).add("play", onPlay).add("pause", onPause).add("end", onEnd).add("auto-play-fail", onPause);
+  }
+  #watchMouse() {
+    if (!this.el) return;
+    const { started, pointer, paused } = this.$state;
+    if (!started() || pointer() !== "fine") return;
+    const events = new EventsController(this.el), shouldHideOnMouseLeave = this.hideOnMouseLeave;
+    if (!shouldHideOnMouseLeave || !this.#isMouseOutside()) {
+      effect(() => {
+        if (!paused()) events.add("pointermove", this.#onStopIdle.bind(this));
+      });
+    }
+    if (shouldHideOnMouseLeave) {
+      events.add("mouseenter", this.#onMouseEnter.bind(this)).add("mouseleave", this.#onMouseLeave.bind(this));
+    }
+  }
+  #watchPaused() {
+    const { paused, started, autoPlayError } = this.$state;
+    if (paused() || autoPlayError() && !started()) return;
+    const onStopIdle = this.#onStopIdle.bind(this);
+    effect(() => {
+      if (!this.el) return;
+      const pointer = this.$state.pointer(), isTouch = pointer === "coarse", events = new EventsController(this.el), eventTypes = [isTouch ? "touchend" : "pointerup", "keydown"];
+      for (const eventType of eventTypes) {
+        events.add(eventType, onStopIdle, { passive: false });
+      }
+    });
+  }
+  #onPlay(event) {
+    if (event.triggers.hasType("ended")) return;
+    this.show(0, event);
+    this.hide(void 0, event);
+  }
+  #onPause(event) {
+    this.show(0, event);
+  }
+  #onEnd(event) {
+    const { loop } = this.$state;
+    if (loop()) this.hide(0, event);
+  }
+  #onMouseEnter(event) {
+    this.#isMouseOutside.set(false);
+    this.show(0, event);
+    this.hide(void 0, event);
+  }
+  #onMouseLeave(event) {
+    this.#isMouseOutside.set(true);
+    this.hide(0, event);
+  }
+  #clearIdleTimer() {
+    window.clearTimeout(this.#idleTimer);
+    this.#idleTimer = -1;
+  }
+  #onStopIdle(event) {
+    if (
+      // @ts-expect-error
+      event.MEDIA_GESTURE || this.#pausedTracking || isTouchPinchEvent(event)
+    ) {
+      return;
+    }
+    if (isKeyboardEvent(event)) {
+      if (event.key === "Escape") {
+        this.el?.focus();
+        this.#focusedItem = null;
+      } else if (this.#focusedItem) {
+        event.preventDefault();
+        requestAnimationFrame(() => {
+          this.#focusedItem?.focus();
+          this.#focusedItem = null;
+        });
+      }
+    }
+    this.show(0, event);
+    this.hide(this.defaultDelay, event);
+  }
+  #changeVisibility(visible, delay, trigger) {
+    if (delay === 0) {
+      this.#onChange(visible, trigger);
+      return;
+    }
+    this.#idleTimer = window.setTimeout(() => {
+      if (!this.scope) return;
+      this.#onChange(visible && !this.#pausedTracking, trigger);
+    }, delay);
+  }
+  #onChange(visible, trigger) {
+    if (this.$state.controlsVisible() === visible) return;
+    this.$state.controlsVisible.set(visible);
+    if (!visible && document.activeElement && this.el?.contains(document.activeElement)) {
+      this.#focusedItem = document.activeElement;
+      requestAnimationFrame(() => {
+        this.el?.focus({ preventScroll: true });
+      });
+    }
+    this.dispatch("controls-change", {
+      detail: visible,
+      trigger
+    });
+  }
+}
+
+const CAN_FULLSCREEN = fscreen.fullscreenEnabled;
+class FullscreenController extends ViewController {
+  /**
+   * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be
+   * listened to globally on the document so we need to know if they relate to the current host
+   * element or not.
+   */
+  #listening = false;
+  #active = false;
+  get active() {
+    return this.#active;
+  }
+  get supported() {
+    return CAN_FULLSCREEN;
+  }
+  onConnect() {
+    new EventsController(fscreen).add("fullscreenchange", this.#onChange.bind(this)).add("fullscreenerror", this.#onError.bind(this));
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  async #onDisconnect() {
+    if (CAN_FULLSCREEN) await this.exit();
+  }
+  #onChange(event) {
+    const active = isFullscreen(this.el);
+    if (active === this.#active) return;
+    if (!active) this.#listening = false;
+    this.#active = active;
+    this.dispatch("fullscreen-change", { detail: active, trigger: event });
+  }
+  #onError(event) {
+    if (!this.#listening) return;
+    this.dispatch("fullscreen-error", { detail: null, trigger: event });
+    this.#listening = false;
+  }
+  async enter() {
+    try {
+      this.#listening = true;
+      if (!this.el || isFullscreen(this.el)) return;
+      assertFullscreenAPI();
+      return fscreen.requestFullscreen(this.el);
+    } catch (error) {
+      this.#listening = false;
+      throw error;
+    }
+  }
+  async exit() {
+    if (!this.el || !isFullscreen(this.el)) return;
+    assertFullscreenAPI();
+    return fscreen.exitFullscreen();
+  }
+}
+function canFullscreen() {
+  return CAN_FULLSCREEN;
+}
+function isFullscreen(host) {
+  if (fscreen.fullscreenElement === host) return true;
+  try {
+    return host.matches(
+      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
+      fscreen.fullscreenPseudoClass
+    );
+  } catch (error) {
+    return false;
+  }
+}
+function assertFullscreenAPI() {
+  if (CAN_FULLSCREEN) return;
+  throw Error(
+    "[vidstack] fullscreen API is not enabled or supported in this environment" 
+  );
+}
+
+class ScreenOrientationController extends ViewController {
+  #type = signal(this.#getScreenOrientation());
+  #locked = signal(false);
+  #currentLock;
+  /**
+   * The current screen orientation type.
+   *
+   * @signal
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
+   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
+   */
+  get type() {
+    return this.#type();
+  }
+  /**
+   * Whether the screen orientation is currently locked.
+   *
+   * @signal
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
+   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
+   */
+  get locked() {
+    return this.#locked();
+  }
+  /**
+   * Whether the viewport is in a portrait orientation.
+   *
+   * @signal
+   */
+  get portrait() {
+    return this.#type().startsWith("portrait");
+  }
+  /**
+   * Whether the viewport is in a landscape orientation.
+   *
+   * @signal
+   */
+  get landscape() {
+    return this.#type().startsWith("landscape");
+  }
+  /**
+   * Whether the native Screen Orientation API is available.
+   */
+  static supported = canOrientScreen();
+  /**
+   * Whether the native Screen Orientation API is available.
+   */
+  get supported() {
+    return ScreenOrientationController.supported;
+  }
+  onConnect() {
+    if (this.supported) {
+      listenEvent(screen.orientation, "change", this.#onOrientationChange.bind(this));
+    } else {
+      const query = window.matchMedia("(orientation: landscape)");
+      query.onchange = this.#onOrientationChange.bind(this);
+      onDispose(() => query.onchange = null);
+    }
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  async #onDisconnect() {
+    if (this.supported && this.#locked()) await this.unlock();
+  }
+  #onOrientationChange(event) {
+    this.#type.set(this.#getScreenOrientation());
+    this.dispatch("orientation-change", {
+      detail: {
+        orientation: peek(this.#type),
+        lock: this.#currentLock
+      },
+      trigger: event
+    });
+  }
+  /**
+   * Locks the orientation of the screen to the desired orientation type using the
+   * Screen Orientation API.
+   *
+   * @param lockType - The screen lock orientation type.
+   * @throws Error - If screen orientation API is unavailable.
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
+   * @see {@link https://w3c.github.io/screen-orientation}
+   */
+  async lock(lockType) {
+    if (peek(this.#locked) || this.#currentLock === lockType) return;
+    this.#assertScreenOrientationAPI();
+    await screen.orientation.lock(lockType);
+    this.#locked.set(true);
+    this.#currentLock = lockType;
+  }
+  /**
+   * Unlocks the orientation of the screen to it's default state using the Screen Orientation
+   * API. This method will throw an error if the API is unavailable.
+   *
+   * @throws Error - If screen orientation API is unavailable.
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
+   * @see {@link https://w3c.github.io/screen-orientation}
+   */
+  async unlock() {
+    if (!peek(this.#locked)) return;
+    this.#assertScreenOrientationAPI();
+    this.#currentLock = void 0;
+    await screen.orientation.unlock();
+    this.#locked.set(false);
+  }
+  #assertScreenOrientationAPI() {
+    if (this.supported) return;
+    throw Error(
+      "[vidstack] screen orientation API is not available" 
+    );
+  }
+  #getScreenOrientation() {
+    if (IS_SERVER) return "portrait-primary";
+    if (this.supported) return window.screen.orientation.type;
+    return window.innerWidth >= window.innerHeight ? "landscape-primary" : "portrait-primary";
+  }
+}
+
+class AudioProviderLoader {
+  name = "audio";
+  target;
+  canPlay(src) {
+    if (!isAudioSrc(src)) return false;
+    return IS_SERVER || !isString(src.src) || src.type === "?" || canPlayAudioType(this.target, src.type);
+  }
+  mediaType() {
+    return "audio";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load audio provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<audio>` element was not found - did you forget to include `<media-provider>`?"
+      );
+    }
+    return new (await import('./vidstack-6DJOXxBa.js')).AudioProvider(this.target, ctx);
+  }
+}
+
+class VideoProviderLoader {
+  name = "video";
+  target;
+  canPlay(src) {
+    if (!isVideoSrc(src)) return false;
+    return IS_SERVER || !isString(src.src) || src.type === "?" || canPlayVideoType(this.target, src.type);
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load video provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<video>` element was not found - did you forget to include media provider?"
+      );
+    }
+    return new (await Promise.resolve().then(function () { return provider$1; })).VideoProvider(this.target, ctx);
+  }
+}
+
+class HLSProviderLoader extends VideoProviderLoader {
+  static supported = isHLSSupported();
+  name = "hls";
+  canPlay(src) {
+    return HLSProviderLoader.supported && isHLSSrc(src);
+  }
+  async load(context) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load hls provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<video>` element was not found - did you forget to include `<media-provider>`?"
+      );
+    }
+    return new (await import('./vidstack-GkDbnYKN.js')).HLSProvider(this.target, context);
+  }
+}
+
+let audioContext = null, gainNodes = [], elAudioSources = [];
+function getOrCreateAudioCtx() {
+  return audioContext ??= new AudioContext();
+}
+function createGainNode() {
+  const audioCtx = getOrCreateAudioCtx(), gainNode = audioCtx.createGain();
+  gainNode.connect(audioCtx.destination);
+  gainNodes.push(gainNode);
+  return gainNode;
+}
+function createElementSource(el, gainNode) {
+  const audioCtx = getOrCreateAudioCtx(), src = audioCtx.createMediaElementSource(el);
+  if (gainNode) {
+    src.connect(gainNode);
+  }
+  elAudioSources.push(src);
+  return src;
+}
+function destroyGainNode(node) {
+  const idx = gainNodes.indexOf(node);
+  if (idx !== -1) {
+    gainNodes.splice(idx, 1);
+    node.disconnect();
+    freeAudioCtxWhenAllResourcesFreed();
+  }
+}
+function destroyElementSource(src) {
+  const idx = elAudioSources.indexOf(src);
+  if (idx !== -1) {
+    elAudioSources.splice(idx, 1);
+    src.disconnect();
+    freeAudioCtxWhenAllResourcesFreed();
+  }
+}
+function freeAudioCtxWhenAllResourcesFreed() {
+  if (audioContext && gainNodes.length === 0 && elAudioSources.length === 0) {
+    audioContext.close().then(() => {
+      audioContext = null;
+    });
+  }
+}
+
+class AudioGain {
+  #media;
+  #onChange;
+  #gainNode = null;
+  #srcAudioNode = null;
+  get currentGain() {
+    return this.#gainNode?.gain?.value ?? null;
+  }
+  get supported() {
+    return true;
+  }
+  constructor(media, onChange) {
+    this.#media = media;
+    this.#onChange = onChange;
+  }
+  setGain(gain) {
+    const currGain = this.currentGain;
+    if (gain === this.currentGain) {
+      return;
+    }
+    if (gain === 1 && currGain !== 1) {
+      this.removeGain();
+      return;
+    }
+    if (!this.#gainNode) {
+      this.#gainNode = createGainNode();
+      if (this.#srcAudioNode) {
+        this.#srcAudioNode.connect(this.#gainNode);
+      }
+    }
+    if (!this.#srcAudioNode) {
+      this.#srcAudioNode = createElementSource(this.#media, this.#gainNode);
+    }
+    this.#gainNode.gain.value = gain;
+    this.#onChange(gain);
+  }
+  removeGain() {
+    if (!this.#gainNode) return;
+    if (this.#srcAudioNode) {
+      this.#srcAudioNode.connect(getOrCreateAudioCtx().destination);
+    }
+    this.#destroyGainNode();
+    this.#onChange(null);
+  }
+  destroy() {
+    this.#destroySrcNode();
+    this.#destroyGainNode();
+  }
+  #destroySrcNode() {
+    if (!this.#srcAudioNode) return;
+    try {
+      destroyElementSource(this.#srcAudioNode);
+    } catch (e) {
+    } finally {
+      this.#srcAudioNode = null;
+    }
+  }
+  #destroyGainNode() {
+    if (!this.#gainNode) return;
+    try {
+      destroyGainNode(this.#gainNode);
+    } catch (e) {
+    } finally {
+      this.#gainNode = null;
+    }
+  }
+}
+
+const PAGE_EVENTS = ["focus", "blur", "visibilitychange", "pageshow", "pagehide"];
+class PageVisibility {
+  #state = signal(determinePageState());
+  #visibility = signal(IS_SERVER ? "visible" : document.visibilityState);
+  #safariBeforeUnloadTimeout;
+  connect() {
+    const events = new EventsController(window), handlePageEvent = this.#handlePageEvent.bind(this);
+    for (const eventType of PAGE_EVENTS) {
+      events.add(eventType, handlePageEvent);
+    }
+    if (IS_SAFARI) {
+      events.add("beforeunload", (event) => {
+        this.#safariBeforeUnloadTimeout = setTimeout(() => {
+          if (!(event.defaultPrevented || event.returnValue.length > 0)) {
+            this.#state.set("hidden");
+            this.#visibility.set("hidden");
+          }
+        }, 0);
+      });
+    }
+  }
+  /**
+   * The current page state. Important to note we only account for a subset of page states, as
+   * the rest aren't valuable to the player at the moment.
+   *
+   * - **active:** A page is in the active state if it is visible and has input focus.
+   * - **passive:** A page is in the passive state if it is visible and does not have input focus.
+   * - **hidden:** A page is in the hidden state if it is not visible.
+   *
+   * @see https://developers.google.com/web/updates/2018/07/page-lifecycle-api#states
+   */
+  get pageState() {
+    return this.#state();
+  }
+  /**
+   * The current document visibility state.
+   *
+   * - **visible:** The page content may be at least partially visible. In practice, this means that
+   * the page is the foreground tab of a non-minimized window.
+   * - **hidden:** The page content is not visible to the user. In practice this means that the
+   * document is either a background tab or part of a minimized window, or the OS screen lock is
+   * active.
+   *
+   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState
+   */
+  get visibility() {
+    return this.#visibility();
+  }
+  #handlePageEvent(event) {
+    if (IS_SAFARI) window.clearTimeout(this.#safariBeforeUnloadTimeout);
+    if (event.type !== "blur" || this.#state() === "active") {
+      this.#state.set(determinePageState(event));
+      this.#visibility.set(document.visibilityState == "hidden" ? "hidden" : "visible");
+    }
+  }
+}
+function determinePageState(event) {
+  if (IS_SERVER) return "hidden";
+  if (event?.type === "blur" || document.visibilityState === "hidden") return "hidden";
+  if (document.hasFocus()) return "active";
+  return "passive";
+}
+
+class RAFLoop {
+  #id;
+  #callback;
+  constructor(callback) {
+    this.#callback = callback;
+  }
+  start() {
+    if (!isUndefined(this.#id)) return;
+    this.#loop();
+  }
+  stop() {
+    if (isNumber(this.#id)) window.cancelAnimationFrame(this.#id);
+    this.#id = void 0;
+  }
+  #loop() {
+    this.#id = window.requestAnimationFrame(() => {
+      if (isUndefined(this.#id)) return;
+      this.#callback();
+      this.#loop();
+    });
+  }
+}
+
+class HTMLMediaEvents {
+  #provider;
+  #ctx;
+  #waiting = false;
+  #attachedLoadStart = false;
+  #attachedCanPlay = false;
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #pageVisibility = new PageVisibility();
+  #events;
+  get #media() {
+    return this.#provider.media;
+  }
+  constructor(provider, ctx) {
+    this.#provider = provider;
+    this.#ctx = ctx;
+    this.#events = new EventsController(provider.media);
+    this.#attachInitialListeners();
+    this.#pageVisibility.connect();
+    effect(this.#attachTimeUpdate.bind(this));
+    onDispose(this.#onDispose.bind(this));
+  }
+  #onDispose() {
+    this.#attachedLoadStart = false;
+    this.#attachedCanPlay = false;
+    this.#timeRAF.stop();
+    this.#events.abort();
+    this.#devHandlers?.clear();
+  }
+  /**
+   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
+   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
+   * resolve that by retrieving time updates in a request animation frame loop.
+   */
+  #lastSeenTime = 0;
+  #seekedTo = -1;
+  #onAnimationFrame() {
+    const newTime = this.#media.currentTime;
+    const didStutter = IS_SAFARI && newTime - this.#seekedTo < 0.35;
+    if (!didStutter && this.#lastSeenTime !== newTime) {
+      this.#updateCurrentTime(newTime);
+      this.#lastSeenTime = newTime;
+    }
+  }
+  #attachInitialListeners() {
+    {
+      this.#ctx.logger?.info("attaching initial listeners");
+    }
+    this.#attachEventListener("loadstart", this.#onLoadStart);
+    this.#attachEventListener("abort", this.#onAbort);
+    this.#attachEventListener("emptied", this.#onEmptied);
+    this.#attachEventListener("error", this.#onError);
+    this.#attachEventListener("volumechange", this.#onVolumeChange);
+    this.#ctx.logger?.debug("attached initial media event listeners");
+  }
+  #attachLoadStartListeners() {
+    if (this.#attachedLoadStart) return;
+    {
+      this.#ctx.logger?.info("attaching load start listeners");
+    }
+    this.#attachEventListener("loadeddata", this.#onLoadedData);
+    this.#attachEventListener("loadedmetadata", this.#onLoadedMetadata);
+    this.#attachEventListener("canplay", this.#onCanPlay);
+    this.#attachEventListener("canplaythrough", this.#onCanPlayThrough);
+    this.#attachEventListener("durationchange", this.#onDurationChange);
+    this.#attachEventListener("play", this.#onPlay);
+    this.#attachEventListener("progress", this.#onProgress);
+    this.#attachEventListener("stalled", this.#onStalled);
+    this.#attachEventListener("suspend", this.#onSuspend);
+    this.#attachEventListener("ratechange", this.#onRateChange);
+    this.#attachedLoadStart = true;
+  }
+  #attachCanPlayListeners() {
+    if (this.#attachedCanPlay) return;
+    {
+      this.#ctx.logger?.info("attaching can play listeners");
+    }
+    this.#attachEventListener("pause", this.#onPause);
+    this.#attachEventListener("playing", this.#onPlaying);
+    this.#attachEventListener("seeked", this.#onSeeked);
+    this.#attachEventListener("seeking", this.#onSeeking);
+    this.#attachEventListener("ended", this.#onEnded);
+    this.#attachEventListener("waiting", this.#onWaiting);
+    this.#attachedCanPlay = true;
+  }
+  #devHandlers = /* @__PURE__ */ new Map() ;
+  #handleDevEvent = this.#onDevEvent.bind(this) ;
+  #attachEventListener(eventType, handler) {
+    this.#devHandlers.set(eventType, handler);
+    this.#events.add(eventType, this.#handleDevEvent );
+  }
+  #onDevEvent(event2) {
+    this.#ctx.logger?.debugGroup(`\u{1F4FA} provider fired \`${event2.type}\``).labelledLog("Provider", this.#provider).labelledLog("Event", event2).labelledLog("Media Store", { ...this.#ctx.$state }).dispatch();
+    this.#devHandlers.get(event2.type)?.call(this, event2);
+  }
+  #updateCurrentTime(time, trigger) {
+    const newTime = Math.min(time, this.#ctx.$state.seekableEnd());
+    this.#ctx.notify("time-change", newTime, trigger);
+  }
+  #onLoadStart(event2) {
+    if (this.#media.networkState === 3) {
+      this.#onAbort(event2);
+      return;
+    }
+    this.#attachLoadStartListeners();
+    this.#ctx.notify("load-start", void 0, event2);
+  }
+  #onAbort(event2) {
+    this.#ctx.notify("abort", void 0, event2);
+  }
+  #onEmptied() {
+    this.#ctx.notify("emptied", void 0, event);
+  }
+  #onLoadedData(event2) {
+    this.#ctx.notify("loaded-data", void 0, event2);
+  }
+  #onLoadedMetadata(event2) {
+    this.#lastSeenTime = 0;
+    this.#seekedTo = -1;
+    this.#attachCanPlayListeners();
+    this.#ctx.notify("loaded-metadata", void 0, event2);
+    if (IS_IOS || IS_SAFARI && isHLSSrc(this.#ctx.$state.source())) {
+      this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
+    }
+  }
+  #getCanPlayDetail() {
+    return {
+      provider: peek(this.#ctx.$provider),
+      duration: this.#media.duration,
+      buffered: this.#media.buffered,
+      seekable: this.#media.seekable
+    };
+  }
+  #onPlay(event2) {
+    if (!this.#ctx.$state.canPlay) return;
+    this.#ctx.notify("play", void 0, event2);
+  }
+  #onPause(event2) {
+    if (this.#media.readyState === 1 && !this.#waiting) return;
+    this.#waiting = false;
+    this.#timeRAF.stop();
+    this.#ctx.notify("pause", void 0, event2);
+  }
+  #onCanPlay(event2) {
+    this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
+  }
+  #onCanPlayThrough(event2) {
+    if (this.#ctx.$state.started()) return;
+    this.#ctx.notify("can-play-through", this.#getCanPlayDetail(), event2);
+  }
+  #onPlaying(event2) {
+    if (this.#media.paused) return;
+    this.#waiting = false;
+    this.#ctx.notify("playing", void 0, event2);
+    this.#timeRAF.start();
+  }
+  #onStalled(event2) {
+    this.#ctx.notify("stalled", void 0, event2);
+    if (this.#media.readyState < 3) {
+      this.#waiting = true;
+      this.#ctx.notify("waiting", void 0, event2);
+    }
+  }
+  #onWaiting(event2) {
+    if (this.#media.readyState < 3) {
+      this.#waiting = true;
+      this.#ctx.notify("waiting", void 0, event2);
+    }
+  }
+  #onEnded(event2) {
+    this.#timeRAF.stop();
+    this.#updateCurrentTime(this.#media.duration, event2);
+    this.#ctx.notify("end", void 0, event2);
+    if (this.#ctx.$state.loop()) {
+      const hasCustomControls = isNil(this.#media.controls);
+      if (hasCustomControls) this.#media.controls = false;
+    }
+  }
+  #attachTimeUpdate() {
+    const isPaused = this.#ctx.$state.paused(), isPageHidden = this.#pageVisibility.visibility === "hidden", shouldListenToTimeUpdates = isPaused || isPageHidden;
+    if (shouldListenToTimeUpdates) {
+      listenEvent(this.#media, "timeupdate", this.#onTimeUpdate.bind(this));
+    }
+  }
+  #onTimeUpdate(event2) {
+    this.#updateCurrentTime(this.#media.currentTime, event2);
+  }
+  #onDurationChange(event2) {
+    if (this.#ctx.$state.ended()) {
+      this.#updateCurrentTime(this.#media.duration, event2);
+    }
+    this.#ctx.notify("duration-change", this.#media.duration, event2);
+  }
+  #onVolumeChange(event2) {
+    const detail = {
+      volume: this.#media.volume,
+      muted: this.#media.muted
+    };
+    this.#ctx.notify("volume-change", detail, event2);
+  }
+  #onSeeked(event2) {
+    this.#seekedTo = this.#media.currentTime;
+    this.#updateCurrentTime(this.#media.currentTime, event2);
+    this.#ctx.notify("seeked", this.#media.currentTime, event2);
+    if (Math.trunc(this.#media.currentTime) === Math.trunc(this.#media.duration) && getNumberOfDecimalPlaces(this.#media.duration) > getNumberOfDecimalPlaces(this.#media.currentTime)) {
+      this.#updateCurrentTime(this.#media.duration, event2);
+      if (!this.#media.ended) {
+        this.#ctx.player.dispatch(
+          new DOMEvent("media-play-request", {
+            trigger: event2
+          })
+        );
+      }
+    }
+  }
+  #onSeeking(event2) {
+    this.#ctx.notify("seeking", this.#media.currentTime, event2);
+  }
+  #onProgress(event2) {
+    const detail = {
+      buffered: this.#media.buffered,
+      seekable: this.#media.seekable
+    };
+    this.#ctx.notify("progress", detail, event2);
+  }
+  #onSuspend(event2) {
+    this.#ctx.notify("suspend", void 0, event2);
+  }
+  #onRateChange(event2) {
+    this.#ctx.notify("rate-change", this.#media.playbackRate, event2);
+  }
+  #onError(event2) {
+    const error = this.#media.error;
+    if (!error) return;
+    const detail = {
+      message: error.message,
+      code: error.code,
+      mediaError: error
+    };
+    this.#ctx.notify("error", detail, event2);
+  }
+}
+
+class NativeAudioTracks {
+  #provider;
+  #ctx;
+  get #nativeTracks() {
+    return this.#provider.media.audioTracks;
+  }
+  constructor(provider, ctx) {
+    this.#provider = provider;
+    this.#ctx = ctx;
+    this.#nativeTracks.onaddtrack = this.#onAddNativeTrack.bind(this);
+    this.#nativeTracks.onremovetrack = this.#onRemoveNativeTrack.bind(this);
+    this.#nativeTracks.onchange = this.#onChangeNativeTrack.bind(this);
+    listenEvent(this.#ctx.audioTracks, "change", this.#onChangeTrack.bind(this));
+  }
+  #onAddNativeTrack(event) {
+    const nativeTrack = event.track;
+    if (nativeTrack.label === "") return;
+    const id = nativeTrack.id.toString() || `native-audio-${this.#ctx.audioTracks.length}`, audioTrack = {
+      id,
+      label: nativeTrack.label,
+      language: nativeTrack.language,
+      kind: nativeTrack.kind,
+      selected: false
+    };
+    this.#ctx.audioTracks[ListSymbol.add](audioTrack, event);
+    if (nativeTrack.enabled) audioTrack.selected = true;
+  }
+  #onRemoveNativeTrack(event) {
+    const track = this.#ctx.audioTracks.getById(event.track.id);
+    if (track) this.#ctx.audioTracks[ListSymbol.remove](track, event);
+  }
+  #onChangeNativeTrack(event) {
+    let enabledTrack = this.#getEnabledNativeTrack();
+    if (!enabledTrack) return;
+    const track = this.#ctx.audioTracks.getById(enabledTrack.id);
+    if (track) this.#ctx.audioTracks[ListSymbol.select](track, true, event);
+  }
+  #getEnabledNativeTrack() {
+    return Array.from(this.#nativeTracks).find((track) => track.enabled);
+  }
+  #onChangeTrack(event) {
+    const { current } = event.detail;
+    if (!current) return;
+    const track = this.#nativeTracks.getTrackById(current.id);
+    if (track) {
+      const prev = this.#getEnabledNativeTrack();
+      if (prev) prev.enabled = false;
+      track.enabled = true;
+    }
+  }
+}
+
+class HTMLMediaProvider {
+  constructor(media, ctx) {
+    this.media = media;
+    this.ctx = ctx;
+    this.audioGain = new AudioGain(media, (gain) => {
+      this.ctx.notify("audio-gain-change", gain);
+    });
+  }
+  scope = createScope();
+  currentSrc = null;
+  audioGain;
+  setup() {
+    new HTMLMediaEvents(this, this.ctx);
+    if ("audioTracks" in this.media) new NativeAudioTracks(this, this.ctx);
+    onDispose(() => {
+      this.audioGain.destroy();
+      this.media.srcObject = null;
+      this.media.removeAttribute("src");
+      for (const source of this.media.querySelectorAll("source")) source.remove();
+      this.media.load();
+    });
+  }
+  get type() {
+    return "";
+  }
+  setPlaybackRate(rate) {
+    this.media.playbackRate = rate;
+  }
+  async play() {
+    return this.media.play();
+  }
+  async pause() {
+    return this.media.pause();
+  }
+  setMuted(muted) {
+    this.media.muted = muted;
+  }
+  setVolume(volume) {
+    this.media.volume = volume;
+  }
+  setCurrentTime(time) {
+    this.media.currentTime = time;
+  }
+  setPlaysInline(inline) {
+    setAttribute(this.media, "playsinline", inline);
+  }
+  async loadSource({ src, type }, preload) {
+    this.media.preload = preload || "";
+    if (isMediaStream(src)) {
+      this.removeSource();
+      this.media.srcObject = src;
+    } else {
+      this.media.srcObject = null;
+      if (isString(src)) {
+        if (type !== "?") {
+          this.appendSource({ src, type });
+        } else {
+          this.removeSource();
+          this.media.src = this.#appendMediaFragment(src);
+        }
+      } else {
+        this.removeSource();
+        this.media.src = window.URL.createObjectURL(src);
+      }
+    }
+    this.media.load();
+    this.currentSrc = { src, type };
+  }
+  /**
+   * Append source so it works when requesting AirPlay since hls.js will remove it.
+   */
+  appendSource(src, defaultType) {
+    const prevSource = this.media.querySelector("source[data-vds]"), source = prevSource ?? document.createElement("source");
+    setAttribute(source, "src", this.#appendMediaFragment(src.src));
+    setAttribute(source, "type", src.type !== "?" ? src.type : defaultType);
+    setAttribute(source, "data-vds", "");
+    if (!prevSource) this.media.append(source);
+  }
+  removeSource() {
+    this.media.querySelector("source[data-vds]")?.remove();
+  }
+  #appendMediaFragment(src) {
+    const { clipStartTime, clipEndTime } = this.ctx.$state, startTime = clipStartTime(), endTime = clipEndTime();
+    if (startTime > 0 && endTime > 0) {
+      return `${src}#t=${startTime},${endTime}`;
+    } else if (startTime > 0) {
+      return `${src}#t=${startTime}`;
+    } else if (endTime > 0) {
+      return `${src}#t=0,${endTime}`;
+    }
+    return src;
+  }
+}
+
+class HTMLRemotePlaybackAdapter {
+  #media;
+  #ctx;
+  #state;
+  #supported = signal(false);
+  get supported() {
+    return this.#supported();
+  }
+  constructor(media, ctx) {
+    this.#media = media;
+    this.#ctx = ctx;
+    this.#setup();
+  }
+  #setup() {
+    if (IS_SERVER || !this.#media?.remote || !this.canPrompt) return;
+    this.#media.remote.watchAvailability((available) => {
+      this.#supported.set(available);
+    }).catch(() => {
+      this.#supported.set(false);
+    });
+    effect(this.#watchSupported.bind(this));
+  }
+  #watchSupported() {
+    if (!this.#supported()) return;
+    const events = ["connecting", "connect", "disconnect"], onStateChange = this.#onStateChange.bind(this);
+    onStateChange();
+    listenEvent(this.#media, "playing", onStateChange);
+    const remoteEvents = new EventsController(this.#media.remote);
+    for (const type of events) {
+      remoteEvents.add(type, onStateChange);
+    }
+  }
+  async prompt() {
+    if (!this.supported) throw Error("Not supported on this platform.");
+    if (this.type === "airplay" && this.#media.webkitShowPlaybackTargetPicker) {
+      return this.#media.webkitShowPlaybackTargetPicker();
+    }
+    return this.#media.remote.prompt();
+  }
+  #onStateChange(event) {
+    const state = this.#media.remote.state;
+    if (state === this.#state) return;
+    const detail = { type: this.type, state };
+    this.#ctx.notify("remote-playback-change", detail, event);
+    this.#state = state;
+  }
+}
+class HTMLAirPlayAdapter extends HTMLRemotePlaybackAdapter {
+  type = "airplay";
+  get canPrompt() {
+    return "WebKitPlaybackTargetAvailabilityEvent" in window;
+  }
+}
+
+class NativeHLSTextTracks {
+  #video;
+  #ctx;
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+    video.textTracks.onaddtrack = this.#onAddTrack.bind(this);
+    onDispose(this.#onDispose.bind(this));
+  }
+  #onAddTrack(event) {
+    const nativeTrack = event.track;
+    if (!nativeTrack || findTextTrackElement(this.#video, nativeTrack)) return;
+    const track = new TextTrack({
+      id: nativeTrack.id,
+      kind: nativeTrack.kind,
+      label: nativeTrack.label ?? "",
+      language: nativeTrack.language,
+      type: "vtt"
+    });
+    track[TextTrackSymbol.native] = { track: nativeTrack };
+    track[TextTrackSymbol.readyState] = 2;
+    track[TextTrackSymbol.nativeHLS] = true;
+    let lastIndex = 0;
+    const onCueChange = (event2) => {
+      if (!nativeTrack.cues) return;
+      for (let i = lastIndex; i < nativeTrack.cues.length; i++) {
+        track.addCue(nativeTrack.cues[i], event2);
+        lastIndex++;
+      }
+    };
+    onCueChange(event);
+    nativeTrack.oncuechange = onCueChange;
+    this.#ctx.textTracks.add(track, event);
+    track.setMode(nativeTrack.mode, event);
+  }
+  #onDispose() {
+    this.#video.textTracks.onaddtrack = null;
+    for (const track of this.#ctx.textTracks) {
+      const nativeTrack = track[TextTrackSymbol.native]?.track;
+      if (nativeTrack?.oncuechange) nativeTrack.oncuechange = null;
+    }
+  }
+}
+function findTextTrackElement(video, track) {
+  return Array.from(video.children).find((el) => el.track === track);
+}
+
+class VideoPictureInPicture {
+  #video;
+  #media;
+  constructor(video, media) {
+    this.#video = video;
+    this.#media = media;
+    new EventsController(video).add("enterpictureinpicture", this.#onEnter.bind(this)).add("leavepictureinpicture", this.#onExit.bind(this));
+  }
+  get active() {
+    return document.pictureInPictureElement === this.#video;
+  }
+  get supported() {
+    return canUsePictureInPicture(this.#video);
+  }
+  async enter() {
+    return this.#video.requestPictureInPicture();
+  }
+  exit() {
+    return document.exitPictureInPicture();
+  }
+  #onEnter(event) {
+    this.#onChange(true, event);
+  }
+  #onExit(event) {
+    this.#onChange(false, event);
+  }
+  #onChange = (active, event) => {
+    this.#media.notify("picture-in-picture-change", active, event);
+  };
+}
+
+class VideoPresentation {
+  #video;
+  #media;
+  #mode = "inline";
+  get mode() {
+    return this.#mode;
+  }
+  constructor(video, media) {
+    this.#video = video;
+    this.#media = media;
+    listenEvent(video, "webkitpresentationmodechanged", this.#onModeChange.bind(this));
+  }
+  get supported() {
+    return canUseVideoPresentation(this.#video);
+  }
+  async setPresentationMode(mode) {
+    if (this.#mode === mode) return;
+    this.#video.webkitSetPresentationMode(mode);
+  }
+  #onModeChange(event) {
+    const prevMode = this.#mode;
+    this.#mode = this.#video.webkitPresentationMode;
+    {
+      this.#media.logger?.infoGroup("presentation mode change").labelledLog("Mode", this.#mode).labelledLog("Event", event).dispatch();
+    }
+    this.#media.player?.dispatch(
+      new DOMEvent("video-presentation-change", {
+        detail: this.#mode,
+        trigger: event
+      })
+    );
+    ["fullscreen", "picture-in-picture"].forEach((type) => {
+      if (this.#mode === type || prevMode === type) {
+        this.#media.notify(`${type}-change`, this.#mode === type, event);
+      }
+    });
+  }
+}
+class FullscreenPresentationAdapter {
+  #presentation;
+  get active() {
+    return this.#presentation.mode === "fullscreen";
+  }
+  get supported() {
+    return this.#presentation.supported;
+  }
+  constructor(presentation) {
+    this.#presentation = presentation;
+  }
+  async enter() {
+    this.#presentation.setPresentationMode("fullscreen");
+  }
+  async exit() {
+    this.#presentation.setPresentationMode("inline");
+  }
+}
+class PIPPresentationAdapter {
+  #presentation;
+  get active() {
+    return this.#presentation.mode === "picture-in-picture";
+  }
+  get supported() {
+    return this.#presentation.supported;
+  }
+  constructor(presentation) {
+    this.#presentation = presentation;
+  }
+  async enter() {
+    this.#presentation.setPresentationMode("picture-in-picture");
+  }
+  async exit() {
+    this.#presentation.setPresentationMode("inline");
+  }
+}
+
+class VideoProvider extends HTMLMediaProvider {
+  $$PROVIDER_TYPE = "VIDEO";
+  get type() {
+    return "video";
+  }
+  airPlay;
+  fullscreen;
+  pictureInPicture;
+  constructor(video, ctx) {
+    super(video, ctx);
+    scoped(() => {
+      this.airPlay = new HTMLAirPlayAdapter(video, ctx);
+      if (canUseVideoPresentation(video)) {
+        const presentation = new VideoPresentation(video, ctx);
+        this.fullscreen = new FullscreenPresentationAdapter(presentation);
+        this.pictureInPicture = new PIPPresentationAdapter(presentation);
+      } else if (canUsePictureInPicture(video)) {
+        this.pictureInPicture = new VideoPictureInPicture(video, ctx);
+      }
+    }, this.scope);
+  }
+  setup() {
+    super.setup();
+    if (canPlayHLSNatively(this.video)) {
+      new NativeHLSTextTracks(this.video, this.ctx);
+    }
+    this.ctx.textRenderers.attachVideo(this.video);
+    onDispose(() => {
+      this.ctx.textRenderers.attachVideo(null);
+    });
+    if (this.type === "video") this.ctx.notify("provider-setup", this);
+  }
+  /**
+   * The native HTML `<video>` element.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement}
+   */
+  get video() {
+    return this.media;
+  }
+}
+
+var provider$1 = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  VideoProvider: VideoProvider
+});
+
+function getLangName(langCode) {
+  try {
+    const displayNames = new Intl.DisplayNames(navigator.languages, { type: "language" });
+    const languageName = displayNames.of(langCode);
+    return languageName ?? null;
+  } catch (err) {
+    return null;
+  }
+}
+
+const toDOMEventType = (type) => `dash-${camelToKebabCase(type)}`;
+class DASHController {
+  #video;
+  #ctx;
+  #instance = null;
+  #callbacks = /* @__PURE__ */ new Set();
+  #stopLiveSync = null;
+  config = {};
+  get instance() {
+    return this.#instance;
+  }
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+  }
+  setup(ctor) {
+    this.#instance = ctor().create();
+    const dispatcher = this.#dispatchDASHEvent.bind(this);
+    for (const event of Object.values(ctor.events)) this.#instance.on(event, dispatcher);
+    this.#instance.on(ctor.events.ERROR, this.#onError.bind(this));
+    for (const callback of this.#callbacks) callback(this.#instance);
+    this.#ctx.player.dispatch("dash-instance", {
+      detail: this.#instance
+    });
+    this.#instance.initialize(this.#video, void 0, false);
+    this.#instance.updateSettings({
+      streaming: {
+        text: {
+          // Disabling text rendering by dash.
+          defaultEnabled: false,
+          dispatchForManualRendering: true
+        },
+        buffer: {
+          /// Enables buffer replacement when switching bitrates for faster switching.
+          fastSwitchEnabled: true
+        }
+      },
+      ...this.config
+    });
+    this.#instance.on(ctor.events.FRAGMENT_LOADING_STARTED, this.#onFragmentLoadStart.bind(this));
+    this.#instance.on(
+      ctor.events.FRAGMENT_LOADING_COMPLETED,
+      this.#onFragmentLoadComplete.bind(this)
+    );
+    this.#instance.on(ctor.events.MANIFEST_LOADED, this.#onManifestLoaded.bind(this));
+    this.#instance.on(ctor.events.QUALITY_CHANGE_RENDERED, this.#onQualityChange.bind(this));
+    this.#instance.on(ctor.events.TEXT_TRACKS_ADDED, this.#onTextTracksAdded.bind(this));
+    this.#instance.on(ctor.events.TRACK_CHANGE_RENDERED, this.#onTrackChange.bind(this));
+    this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
+    listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
+    listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
+    this.#stopLiveSync = effect(this.#liveSync.bind(this));
+  }
+  #createDOMEvent(event) {
+    return new DOMEvent(toDOMEventType(event.type), { detail: event });
+  }
+  #liveSync() {
+    if (!this.#ctx.$state.live()) return;
+    const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
+    raf.start();
+    return raf.stop.bind(raf);
+  }
+  #liveSyncPosition() {
+    if (!this.#instance) return;
+    const position = this.#instance.duration() - this.#instance.time();
+    this.#ctx.$state.liveSyncPosition.set(!isNaN(position) ? position : Infinity);
+  }
+  #dispatchDASHEvent(event) {
+    this.#ctx.player?.dispatch(this.#createDOMEvent(event));
+  }
+  #currentTrack = null;
+  #cueTracker = {};
+  #onTextFragmentLoaded(event) {
+    const native = this.#currentTrack?.[TextTrackSymbol.native], cues = (native?.track).cues;
+    if (!native || !cues) return;
+    const id = this.#currentTrack.id, startIndex = this.#cueTracker[id] ?? 0, trigger = this.#createDOMEvent(event);
+    for (let i = startIndex; i < cues.length; i++) {
+      const cue = cues[i];
+      if (!cue.positionAlign) cue.positionAlign = "auto";
+      this.#currentTrack.addCue(cue, trigger);
+    }
+    this.#cueTracker[id] = cues.length;
+  }
+  #onTextTracksAdded(event) {
+    if (!this.#instance) return;
+    const data = event.tracks, nativeTextTracks = [...this.#video.textTracks].filter((track) => "manualMode" in track), trigger = this.#createDOMEvent(event);
+    for (let i = 0; i < nativeTextTracks.length; i++) {
+      const textTrackInfo = data[i], nativeTextTrack = nativeTextTracks[i];
+      const id = `dash-${textTrackInfo.kind}-${i}`, track = new TextTrack({
+        id,
+        label: textTrackInfo?.label ?? textTrackInfo.labels.find((t) => t.text)?.text ?? (textTrackInfo?.lang && getLangName(textTrackInfo.lang)) ?? textTrackInfo?.lang ?? void 0,
+        language: textTrackInfo.lang ?? void 0,
+        kind: textTrackInfo.kind,
+        default: textTrackInfo.defaultTrack
+      });
+      track[TextTrackSymbol.native] = {
+        managed: true,
+        track: nativeTextTrack
+      };
+      track[TextTrackSymbol.readyState] = 2;
+      track[TextTrackSymbol.onModeChange] = () => {
+        if (!this.#instance) return;
+        if (track.mode === "showing") {
+          this.#instance.setTextTrack(i);
+          this.#currentTrack = track;
+        } else {
+          this.#instance.setTextTrack(-1);
+          this.#currentTrack = null;
+        }
+      };
+      this.#ctx.textTracks.add(track, trigger);
+    }
+  }
+  #onTrackChange(event) {
+    const { mediaType, newMediaInfo } = event;
+    if (mediaType === "audio") {
+      const track = this.#ctx.audioTracks.getById(`dash-audio-${newMediaInfo.index}`);
+      if (track) {
+        const trigger = this.#createDOMEvent(event);
+        this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
+      }
+    }
+  }
+  #onQualityChange(event) {
+    if (event.mediaType !== "video") return;
+    const quality = this.#ctx.qualities[event.newQuality];
+    if (quality) {
+      const trigger = this.#createDOMEvent(event);
+      this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+  }
+  #onManifestLoaded(event) {
+    if (this.#ctx.$state.canPlay() || !this.#instance) return;
+    const { type, mediaPresentationDuration } = event.data, trigger = this.#createDOMEvent(event);
+    this.#ctx.notify("stream-type-change", type !== "static" ? "live" : "on-demand", trigger);
+    this.#ctx.notify("duration-change", mediaPresentationDuration, trigger);
+    this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
+    const media = this.#instance.getVideoElement();
+    const videoQualities = this.#instance.getTracksForTypeFromManifest(
+      "video",
+      event.data
+    );
+    const supportedVideoMimeType = [...new Set(videoQualities.map((e) => e.mimeType))].find(
+      (type2) => type2 && canPlayVideoType(media, type2)
+    );
+    const videoQuality = videoQualities.filter(
+      (track) => supportedVideoMimeType === track.mimeType
+    )[0];
+    let audioTracks = this.#instance.getTracksForTypeFromManifest(
+      "audio",
+      event.data
+    );
+    const supportedAudioMimeType = [...new Set(audioTracks.map((e) => e.mimeType))].find(
+      (type2) => type2 && canPlayAudioType(media, type2)
+    );
+    audioTracks = audioTracks.filter((track) => supportedAudioMimeType === track.mimeType);
+    videoQuality.bitrateList.forEach((bitrate, index) => {
+      const quality = {
+        id: bitrate.id?.toString() ?? `dash-bitrate-${index}`,
+        width: bitrate.width ?? 0,
+        height: bitrate.height ?? 0,
+        bitrate: bitrate.bandwidth ?? 0,
+        codec: videoQuality.codec,
+        index
+      };
+      this.#ctx.qualities[ListSymbol.add](quality, trigger);
+    });
+    if (isNumber(videoQuality.index)) {
+      const quality = this.#ctx.qualities[videoQuality.index];
+      if (quality) this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+    audioTracks.forEach((audioTrack, index) => {
+      const matchingLabel = audioTrack.labels.find((label2) => {
+        return navigator.languages.some((language) => {
+          return label2.lang && language.toLowerCase().startsWith(label2.lang.toLowerCase());
+        });
+      });
+      const label = matchingLabel || audioTrack.labels[0];
+      const localTrack = {
+        id: `dash-audio-${audioTrack?.index}`,
+        label: label?.text ?? (audioTrack.lang && getLangName(audioTrack.lang)) ?? audioTrack.lang ?? "",
+        language: audioTrack.lang ?? "",
+        kind: "main",
+        mimeType: audioTrack.mimeType,
+        codec: audioTrack.codec,
+        index
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
+    });
+    media.dispatchEvent(new DOMEvent("canplay", { trigger }));
+  }
+  #onError(event) {
+    const { type: eventType, error: data } = event;
+    {
+      this.#ctx.logger?.errorGroup(`[vidstack] DASH error \`${data.message}\``).labelledLog("Media Element", this.#video).labelledLog("DASH Instance", this.#instance).labelledLog("Event Type", eventType).labelledLog("Data", data).labelledLog("Src", peek(this.#ctx.$state.source)).labelledLog("Media Store", { ...this.#ctx.$state }).dispatch();
+    }
+    switch (data.code) {
+      case 27:
+        this.#onNetworkError(data);
+        break;
+      default:
+        this.#onFatalError(data);
+        break;
+    }
+  }
+  #onFragmentLoadStart() {
+    if (this.#retryLoadingTimer >= 0) this.#clearRetryTimer();
+  }
+  #onFragmentLoadComplete(event) {
+    const mediaType = event.mediaType;
+    if (mediaType === "text") {
+      requestAnimationFrame(this.#onTextFragmentLoaded.bind(this, event));
+    }
+  }
+  #retryLoadingTimer = -1;
+  #onNetworkError(error) {
+    this.#clearRetryTimer();
+    this.#instance?.play();
+    this.#retryLoadingTimer = window.setTimeout(() => {
+      this.#retryLoadingTimer = -1;
+      this.#onFatalError(error);
+    }, 5e3);
+  }
+  #clearRetryTimer() {
+    clearTimeout(this.#retryLoadingTimer);
+    this.#retryLoadingTimer = -1;
+  }
+  #onFatalError(error) {
+    this.#ctx.notify("error", {
+      message: error.message ?? "",
+      code: 1,
+      error
+    });
+  }
+  #enableAutoQuality() {
+    this.#switchAutoBitrate("video", true);
+    const { qualities } = this.#ctx;
+    this.#instance?.setQualityFor("video", qualities.selectedIndex, true);
+  }
+  #switchAutoBitrate(type, auto) {
+    this.#instance?.updateSettings({
+      streaming: { abr: { autoSwitchBitrate: { [type]: auto } } }
+    });
+  }
+  #onUserQualityChange() {
+    const { qualities } = this.#ctx;
+    if (!this.#instance || qualities.auto || !qualities.selected) return;
+    this.#switchAutoBitrate("video", false);
+    this.#instance.setQualityFor("video", qualities.selectedIndex, qualities.switch === "current");
+    if (IS_CHROME) {
+      this.#video.currentTime = this.#video.currentTime;
+    }
+  }
+  #onUserAudioChange() {
+    if (!this.#instance) return;
+    const { audioTracks } = this.#ctx, selectedTrack = this.#instance.getTracksFor("audio").find(
+      (track) => audioTracks.selected && audioTracks.selected.id === `dash-audio-${track.index}`
+    );
+    if (selectedTrack) this.#instance.setCurrentTrack(selectedTrack);
+  }
+  #reset() {
+    this.#clearRetryTimer();
+    this.#currentTrack = null;
+    this.#cueTracker = {};
+  }
+  onInstance(callback) {
+    this.#callbacks.add(callback);
+    return () => this.#callbacks.delete(callback);
+  }
+  loadSource(src) {
+    this.#reset();
+    if (!isString(src.src)) return;
+    this.#instance?.attachSource(src.src);
+  }
+  destroy() {
+    this.#reset();
+    this.#instance?.destroy();
+    this.#instance = null;
+    this.#stopLiveSync?.();
+    this.#stopLiveSync = null;
+    this.#ctx?.logger?.info("\u{1F3D7}\uFE0F Destroyed DASH instance");
+  }
+}
+
+function coerceToError(error) {
+  return error instanceof Error ? error : Error(typeof error === "string" ? error : JSON.stringify(error));
+}
+function assert(condition, message) {
+  if (!condition) {
+    throw Error(message || "Assertion failed.");
+  }
+}
+
+class DASHLibLoader {
+  #lib;
+  #ctx;
+  #callback;
+  constructor(lib, ctx, callback) {
+    this.#lib = lib;
+    this.#ctx = ctx;
+    this.#callback = callback;
+    this.#startLoading();
+  }
+  async #startLoading() {
+    this.#ctx.logger?.info("\u{1F3D7}\uFE0F Loading DASH Library");
+    const callbacks = {
+      onLoadStart: this.#onLoadStart.bind(this),
+      onLoaded: this.#onLoaded.bind(this),
+      onLoadError: this.#onLoadError.bind(this)
+    };
+    let ctor = await loadDASHScript(this.#lib, callbacks);
+    if (isUndefined(ctor) && !isString(this.#lib)) ctor = await importDASH(this.#lib, callbacks);
+    if (!ctor) return null;
+    if (!window.dashjs.supportsMediaSource()) {
+      const message = "[vidstack] `dash.js` is not supported in this environment";
+      this.#ctx.logger?.error(message);
+      this.#ctx.player.dispatch(new DOMEvent("dash-unsupported"));
+      this.#ctx.notify("error", { message, code: 4 });
+      return null;
+    }
+    return ctor;
+  }
+  #onLoadStart() {
+    {
+      this.#ctx.logger?.infoGroup("Starting to load `dash.js`").labelledLog("URL", this.#lib).dispatch();
+    }
+    this.#ctx.player.dispatch(new DOMEvent("dash-lib-load-start"));
+  }
+  #onLoaded(ctor) {
+    {
+      this.#ctx.logger?.infoGroup("Loaded `dash.js`").labelledLog("Library", this.#lib).labelledLog("Constructor", ctor).dispatch();
+    }
+    this.#ctx.player.dispatch(
+      new DOMEvent("dash-lib-loaded", {
+        detail: ctor
+      })
+    );
+    this.#callback(ctor);
+  }
+  #onLoadError(e) {
+    const error = coerceToError(e);
+    {
+      this.#ctx.logger?.errorGroup("[vidstack] Failed to load `dash.js`").labelledLog("Library", this.#lib).labelledLog("Error", e).dispatch();
+    }
+    this.#ctx.player.dispatch(
+      new DOMEvent("dash-lib-load-error", {
+        detail: error
+      })
+    );
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 4,
+      error
+    });
+  }
+}
+async function importDASH(loader, callbacks = {}) {
+  if (isUndefined(loader)) return void 0;
+  callbacks.onLoadStart?.();
+  if (isDASHConstructor(loader)) {
+    callbacks.onLoaded?.(loader);
+    return loader;
+  }
+  if (isDASHNamespace(loader)) {
+    const ctor = loader.MediaPlayer;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  }
+  try {
+    const ctor = (await loader())?.default;
+    if (isDASHNamespace(ctor)) {
+      callbacks.onLoaded?.(ctor.MediaPlayer);
+      return ctor.MediaPlayer;
+    }
+    if (ctor) {
+      callbacks.onLoaded?.(ctor);
+    } else {
+      throw Error(
+        true ? "[vidstack] failed importing `dash.js`. Dynamic import returned invalid object." : ""
+      );
+    }
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+async function loadDASHScript(src, callbacks = {}) {
+  if (!isString(src)) return void 0;
+  callbacks.onLoadStart?.();
+  try {
+    await loadScript(src);
+    if (!isFunction(window.dashjs.MediaPlayer)) {
+      throw Error(
+        true ? "[vidstack] failed loading `dash.js`. Could not find a valid `Dash` constructor on window" : ""
+      );
+    }
+    const ctor = window.dashjs.MediaPlayer;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+function isDASHConstructor(value) {
+  return value && value.prototype && value.prototype !== Function;
+}
+function isDASHNamespace(value) {
+  return value && "MediaPlayer" in value;
+}
+
+const JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
+class DASHProvider extends VideoProvider {
+  $$PROVIDER_TYPE = "DASH";
+  #ctor = null;
+  #controller = new DASHController(this.video, this.ctx);
+  /**
+   * The `dash.js` constructor.
+   */
+  get ctor() {
+    return this.#ctor;
+  }
+  /**
+   * The current `dash.js` instance.
+   */
+  get instance() {
+    return this.#controller.instance;
+  }
+  /**
+   * Whether `dash.js` is supported in this environment.
+   */
+  static supported = isDASHSupported();
+  get type() {
+    return "dash";
+  }
+  get canLiveSync() {
+    return true;
+  }
+  #library = `${JS_DELIVR_CDN}/npm/dashjs@4.7.4/dist/dash${".all.debug.js" }`;
+  /**
+   * The `dash.js` configuration object.
+   *
+   * @see {@link https://cdn.dashjs.org/latest/jsdoc/module-Settings.html}
+   */
+  get config() {
+    return this.#controller.config;
+  }
+  set config(config) {
+    this.#controller.config = config;
+  }
+  /**
+   * The `dash.js` constructor (supports dynamic imports) or a URL of where it can be found.
+   *
+   * @defaultValue `https://cdn.jsdelivr.net/npm/dashjs@4.7.4/dist/dash.all.min.js`
+   */
+  get library() {
+    return this.#library;
+  }
+  set library(library) {
+    this.#library = library;
+  }
+  preconnect() {
+    if (!isString(this.#library)) return;
+    preconnect(this.#library);
+  }
+  setup() {
+    super.setup();
+    new DASHLibLoader(this.#library, this.ctx, (ctor) => {
+      this.#ctor = ctor;
+      this.#controller.setup(ctor);
+      this.ctx.notify("provider-setup", this);
+      const src = peek(this.ctx.$state.source);
+      if (src) this.loadSource(src);
+    });
+  }
+  async loadSource(src, preload) {
+    if (!isString(src.src)) {
+      this.removeSource();
+      return;
+    }
+    this.media.preload = preload || "";
+    this.appendSource(src, "application/x-mpegurl");
+    this.#controller.loadSource(src);
+    this.currentSrc = src;
+  }
+  /**
+   * The given callback is invoked when a new `dash.js` instance is created and right before it's
+   * attached to media.
+   */
+  onInstance(callback) {
+    const instance = this.#controller.instance;
+    if (instance) callback(instance);
+    return this.#controller.onInstance(callback);
+  }
+  destroy() {
+    this.#controller.destroy();
+  }
+}
+
+var provider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  DASHProvider: DASHProvider
+});
+
+class DASHProviderLoader extends VideoProviderLoader {
+  static supported = isDASHSupported();
+  name = "dash";
+  canPlay(src) {
+    return DASHProviderLoader.supported && isDASHSrc(src);
+  }
+  async load(context) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load dash provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<video>` element was not found - did you forget to include `<media-provider>`?"
+      );
+    }
+    return new (await Promise.resolve().then(function () { return provider; })).DASHProvider(this.target, context);
+  }
+}
+
+class VimeoProviderLoader {
+  name = "vimeo";
+  target;
+  preconnect() {
+    const connections = [
+      "https://i.vimeocdn.com",
+      "https://f.vimeocdn.com",
+      "https://fresnel.vimeocdn.com"
+    ];
+    for (const url of connections) {
+      preconnect(url);
+    }
+  }
+  canPlay(src) {
+    return isString(src.src) && src.type === "video/vimeo";
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load vimeo provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<iframe>` element was not found - did you forget to include media provider?"
+      );
+    }
+    return new (await import('./vidstack-DRj2Nonb.js')).VimeoProvider(this.target, ctx);
+  }
+  async loadPoster(src, ctx, abort) {
+    const { resolveVimeoVideoId, getVimeoVideoInfo } = await import('./vidstack-krOAtKMi.js');
+    if (!isString(src.src)) return null;
+    const { videoId, hash } = resolveVimeoVideoId(src.src);
+    if (videoId) {
+      return getVimeoVideoInfo(videoId, abort, hash).then((info) => info ? info.poster : null);
+    }
+    return null;
+  }
+}
+
+class YouTubeProviderLoader {
+  name = "youtube";
+  target;
+  preconnect() {
+    const connections = [
+      // Botguard script.
+      "https://www.google.com",
+      // Posters.
+      "https://i.ytimg.com",
+      // Ads.
+      "https://googleads.g.doubleclick.net",
+      "https://static.doubleclick.net"
+    ];
+    for (const url of connections) {
+      preconnect(url);
+    }
+  }
+  canPlay(src) {
+    return isString(src.src) && src.type === "video/youtube";
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load youtube provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<iframe>` element was not found - did you forget to include media provider?"
+      );
+    }
+    return new (await import('./vidstack-B6V3Risw.js')).YouTubeProvider(this.target, ctx);
+  }
+  async loadPoster(src, ctx, abort) {
+    const { findYouTubePoster, resolveYouTubeVideoId } = await import('./vidstack-Zc3I7oOd.js');
+    const videoId = isString(src.src) && resolveYouTubeVideoId(src.src);
+    if (videoId) return findYouTubePoster(videoId, abort);
+    return null;
+  }
+}
+
+function padNumberWithZeroes(num, expectedLength) {
+  const str = String(num);
+  const actualLength = str.length;
+  const shouldPad = actualLength < expectedLength;
+  if (shouldPad) {
+    const padLength = expectedLength - actualLength;
+    const padding = `0`.repeat(padLength);
+    return `${padding}${num}`;
+  }
+  return str;
+}
+function parseTime(duration) {
+  const hours = Math.trunc(duration / 3600);
+  const minutes = Math.trunc(duration % 3600 / 60);
+  const seconds = Math.trunc(duration % 60);
+  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
+  return {
+    hours,
+    minutes,
+    seconds,
+    fraction
+  };
+}
+function formatTime(duration, { padHrs = null, padMins = null, showHrs = false, showMs = false } = {}) {
+  const { hours, minutes, seconds, fraction } = parseTime(duration), paddedHours = padHrs ? padNumberWithZeroes(hours, 2) : hours, paddedMinutes = padMins || isNull(padMins) && duration >= 3600 ? padNumberWithZeroes(minutes, 2) : minutes, paddedSeconds = padNumberWithZeroes(seconds, 2), paddedMs = showMs && fraction > 0 ? `.${String(fraction).replace(/^0?\./, "")}` : "", time = `${paddedMinutes}:${paddedSeconds}${paddedMs}`;
+  return hours > 0 || showHrs ? `${paddedHours}:${time}` : time;
+}
+function formatSpokenTime(duration) {
+  const spokenParts = [];
+  const { hours, minutes, seconds } = parseTime(duration);
+  if (hours > 0) {
+    spokenParts.push(`${hours} hour`);
+  }
+  if (minutes > 0) {
+    spokenParts.push(`${minutes} min`);
+  }
+  if (seconds > 0 || spokenParts.length === 0) {
+    spokenParts.push(`${seconds} sec`);
+  }
+  return spokenParts.join(" ");
+}
+
+const MEDIA_ATTRIBUTES = Symbol("MEDIA_ATTRIBUTES" );
+const mediaAttributes = [
+  "autoPlay",
+  "canAirPlay",
+  "canFullscreen",
+  "canGoogleCast",
+  "canLoad",
+  "canLoadPoster",
+  "canPictureInPicture",
+  "canPlay",
+  "canSeek",
+  "ended",
+  "fullscreen",
+  "isAirPlayConnected",
+  "isGoogleCastConnected",
+  "live",
+  "liveEdge",
+  "loop",
+  "mediaType",
+  "muted",
+  "paused",
+  "pictureInPicture",
+  "playing",
+  "playsInline",
+  "remotePlaybackState",
+  "remotePlaybackType",
+  "seeking",
+  "started",
+  "streamType",
+  "viewType",
+  "waiting"
+];
+
+const mediaPlayerProps = {
+  artist: "",
+  artwork: null,
+  autoplay: false,
+  autoPlay: false,
+  clipStartTime: 0,
+  clipEndTime: 0,
+  controls: false,
+  currentTime: 0,
+  crossorigin: null,
+  crossOrigin: null,
+  duration: -1,
+  fullscreenOrientation: "landscape",
+  googleCast: {},
+  load: "visible",
+  posterLoad: "visible",
+  logLevel: "warn" ,
+  loop: false,
+  muted: false,
+  paused: true,
+  playsinline: false,
+  playsInline: false,
+  playbackRate: 1,
+  poster: "",
+  preload: "metadata",
+  preferNativeHLS: false,
+  src: "",
+  title: "",
+  controlsDelay: 2e3,
+  hideControlsOnMouseLeave: false,
+  viewType: "unknown",
+  streamType: "unknown",
+  volume: 1,
+  liveEdgeTolerance: 10,
+  minLiveDVRWindow: 60,
+  keyDisabled: false,
+  keyTarget: "player",
+  keyShortcuts: MEDIA_KEY_SHORTCUTS,
+  storage: null
+};
+
+const MEDIA_EVENTS = [
+  "abort",
+  "can-play",
+  "can-play-through",
+  "duration-change",
+  "emptied",
+  "ended",
+  "error",
+  "fullscreen-change",
+  "loaded-data",
+  "loaded-metadata",
+  "load-start",
+  "media-type-change",
+  "pause",
+  "play",
+  "playing",
+  "progress",
+  "seeked",
+  "seeking",
+  "source-change",
+  "sources-change",
+  "stalled",
+  "started",
+  "suspend",
+  "stream-type-change",
+  "replay",
+  // time-change,
+  // 'time-update',
+  "view-type-change",
+  "volume-change",
+  "waiting"
+] ;
+class MediaEventsLogger extends MediaPlayerController {
+  #media;
+  constructor(media) {
+    super();
+    this.#media = media;
+  }
+  onConnect(el) {
+    const events = new EventsController(el), handler = this.#onMediaEvent.bind(this);
+    for (const eventType of MEDIA_EVENTS) {
+      events.add(eventType, handler);
+    }
+  }
+  #onMediaEvent(event) {
+    this.#media.logger?.debugGroup(`\u{1F4E1} dispatching \`${event.type}\``).labelledLog("Media Store", { ...this.$state }).labelledLog("Event", event).dispatch();
+  }
+}
+
+class MediaLoadController extends MediaPlayerController {
+  #type;
+  #callback;
+  constructor(type, callback) {
+    super();
+    this.#type = type;
+    this.#callback = callback;
+  }
+  async onAttach(el) {
+    if (IS_SERVER) return;
+    const load = this.$props[this.#type]();
+    if (load === "eager") {
+      requestAnimationFrame(this.#callback);
+    } else if (load === "idle") {
+      waitIdlePeriod(this.#callback);
+    } else if (load === "visible") {
+      let dispose, observer = new IntersectionObserver((entries) => {
+        if (!this.scope) return;
+        if (entries[0].isIntersecting) {
+          dispose?.();
+          dispose = void 0;
+          this.#callback();
+        }
+      });
+      observer.observe(el);
+      dispose = onDispose(() => observer.disconnect());
+    }
+  }
+}
+
+let seenAutoplayWarning = false;
+class MediaPlayerDelegate {
+  #handle;
+  #media;
+  constructor(handle, media) {
+    this.#handle = handle;
+    this.#media = media;
+  }
+  notify(type, ...init) {
+    if (IS_SERVER) return;
+    this.#handle(
+      new DOMEvent(type, {
+        detail: init?.[0],
+        trigger: init?.[1]
+      })
+    );
+  }
+  async ready(info, trigger) {
+    if (IS_SERVER) return;
+    return untrack(async () => {
+      const { logger } = this.#media, {
+        autoPlay,
+        canPlay,
+        started,
+        duration,
+        seekable,
+        buffered,
+        remotePlaybackInfo,
+        playsInline,
+        savedState,
+        source
+      } = this.#media.$state;
+      if (canPlay()) return;
+      const detail = {
+        duration: info?.duration ?? duration(),
+        seekable: info?.seekable ?? seekable(),
+        buffered: info?.buffered ?? buffered(),
+        provider: this.#media.$provider()
+      };
+      this.notify("can-play", detail, trigger);
+      tick();
+      {
+        logger?.infoGroup("-~-~-~-~-~-~- \u2705 MEDIA READY -~-~-~-~-~-~-").labelledLog("Media", this.#media).labelledLog("Trigger Event", trigger).dispatch();
+      }
+      let provider = this.#media.$provider(), { storage, qualities } = this.#media, { muted, volume, clipStartTime, playbackRate } = this.#media.$props;
+      await storage?.onLoad?.(source());
+      const savedPlaybackTime = savedState()?.currentTime, savedPausedState = savedState()?.paused, storageTime = await storage?.getTime(), startTime = savedPlaybackTime ?? storageTime ?? clipStartTime(), shouldAutoPlay = savedPausedState === false || savedPausedState !== true && !started() && autoPlay();
+      if (provider) {
+        provider.setVolume(await storage?.getVolume() ?? volume());
+        provider.setMuted(muted() || !!await storage?.getMuted());
+        const audioGain = await storage?.getAudioGain() ?? 1;
+        if (audioGain > 1) provider.audioGain?.setGain?.(audioGain);
+        provider.setPlaybackRate?.(await storage?.getPlaybackRate() ?? playbackRate());
+        provider.setPlaysInline?.(playsInline());
+        if (startTime > 0) provider.setCurrentTime(startTime);
+      }
+      const prefQuality = await storage?.getVideoQuality();
+      if (prefQuality && qualities.length) {
+        let currentQuality = null, currentScore = Infinity;
+        for (const quality of qualities) {
+          const score = Math.abs(prefQuality.width - quality.width) + Math.abs(prefQuality.height - quality.height) + (prefQuality.bitrate ? Math.abs(prefQuality.bitrate - (quality.bitrate ?? 0)) : 0);
+          if (score < currentScore) {
+            currentQuality = quality;
+            currentScore = score;
+          }
+        }
+        if (currentQuality) currentQuality.selected = true;
+      }
+      if (canPlay() && shouldAutoPlay) {
+        await this.#attemptAutoplay(trigger);
+      } else if (storageTime && storageTime > 0) {
+        this.notify("started", void 0, trigger);
+      }
+      remotePlaybackInfo.set(null);
+    });
+  }
+  async #attemptAutoplay(trigger) {
+    const {
+      player,
+      $state: { autoPlaying, muted }
+    } = this.#media;
+    autoPlaying.set(true);
+    const attemptEvent = new DOMEvent("auto-play-attempt", { trigger });
+    try {
+      await player.play(attemptEvent);
+    } catch (error) {
+      if (!seenAutoplayWarning) {
+        const muteMsg = !muted() ? " Attempting with volume muted will most likely resolve the issue." : "";
+        this.#media.logger?.errorGroup("[vidstack] auto-play request failed").labelledLog(
+          "Message",
+          `Autoplay was requested but failed most likely due to browser autoplay policies.${muteMsg}`
+        ).labelledLog("Trigger Event", trigger).labelledLog("Error", error).labelledLog("See", "https://developer.chrome.com/blog/autoplay").dispatch();
+        seenAutoplayWarning = true;
+      }
+    }
+  }
+}
+
+class Queue {
+  #queue = /* @__PURE__ */ new Map();
+  /**
+   * Queue the given `item` under the given `key` to be processed at a later time by calling
+   * `serve(key)`.
+   */
+  enqueue(key, item) {
+    this.#queue.set(key, item);
+  }
+  /**
+   * Process item in queue for the given `key`.
+   */
+  serve(key) {
+    const value = this.peek(key);
+    this.#queue.delete(key);
+    return value;
+  }
+  /**
+   * Peek at item in queue for the given `key`.
+   */
+  peek(key) {
+    return this.#queue.get(key);
+  }
+  /**
+   * Removes queued item under the given `key`.
+   */
+  delete(key) {
+    this.#queue.delete(key);
+  }
+  /**
+   * Clear all items in the queue.
+   */
+  clear() {
+    this.#queue.clear();
+  }
+}
+
+class RequestQueue {
+  #serving = false;
+  #pending = deferredPromise();
+  #queue = /* @__PURE__ */ new Map();
+  /**
+   * The number of callbacks that are currently in queue.
+   */
+  get size() {
+    return this.#queue.size;
+  }
+  /**
+   * Whether items in the queue are being served immediately, otherwise they're queued to
+   * be processed later.
+   */
+  get isServing() {
+    return this.#serving;
+  }
+  /**
+   * Waits for the queue to be flushed (ie: start serving).
+   */
+  async waitForFlush() {
+    if (this.#serving) return;
+    await this.#pending.promise;
+  }
+  /**
+   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
+   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
+   * then the callback will be invoked immediately.
+   *
+   * @param key - Uniquely identifies this callback so duplicates are ignored.
+   * @param callback - The function to call when this item in the queue is being served.
+   */
+  enqueue(key, callback) {
+    if (this.#serving) {
+      callback();
+      return;
+    }
+    this.#queue.delete(key);
+    this.#queue.set(key, callback);
+  }
+  /**
+   * Invokes the callback with the given `key` in the queue (if it exists).
+   */
+  serve(key) {
+    this.#queue.get(key)?.();
+    this.#queue.delete(key);
+  }
+  /**
+   * Flush all queued items and start serving future requests immediately until `stop()` is called.
+   */
+  start() {
+    this.#flush();
+    this.#serving = true;
+    if (this.#queue.size > 0) this.#flush();
+  }
+  /**
+   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
+   */
+  stop() {
+    this.#serving = false;
+  }
+  /**
+   * Stop serving requests, empty the request queue, and release any promises waiting for the
+   * queue to flush.
+   */
+  reset() {
+    this.stop();
+    this.#queue.clear();
+    this.#release();
+  }
+  #flush() {
+    for (const key of this.#queue.keys()) this.serve(key);
+    this.#release();
+  }
+  #release() {
+    this.#pending.resolve();
+    this.#pending = deferredPromise();
+  }
+}
+
+class MediaRequestManager extends MediaPlayerController {
+  #stateMgr;
+  #request;
+  #media;
+  controls;
+  #fullscreen;
+  #orientation;
+  #$provider;
+  #providerQueue = new RequestQueue();
+  constructor(stateMgr, request, media) {
+    super();
+    this.#stateMgr = stateMgr;
+    this.#request = request;
+    this.#media = media;
+    this.#$provider = media.$provider;
+    this.controls = new MediaControls();
+    this.#fullscreen = new FullscreenController();
+    this.#orientation = new ScreenOrientationController();
+  }
+  onAttach() {
+    this.listen("fullscreen-change", this.#onFullscreenChange.bind(this));
+  }
+  onConnect(el) {
+    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), events = new EventsController(el), handleRequest = this.#handleRequest.bind(this);
+    for (const name of names) {
+      if (name.startsWith("media-")) {
+        events.add(name, handleRequest);
+      }
+    }
+    this.#attachLoadPlayListener();
+    effect(this.#watchProvider.bind(this));
+    effect(this.#watchControlsDelayChange.bind(this));
+    effect(this.#watchAudioGainSupport.bind(this));
+    effect(this.#watchAirPlaySupport.bind(this));
+    effect(this.#watchGoogleCastSupport.bind(this));
+    effect(this.#watchFullscreenSupport.bind(this));
+    effect(this.#watchPiPSupport.bind(this));
+  }
+  onDestroy() {
+    try {
+      const destroyEvent = this.createEvent("destroy"), { pictureInPicture, fullscreen } = this.$state;
+      if (fullscreen()) this.exitFullscreen("prefer-media", destroyEvent);
+      if (pictureInPicture()) this.exitPictureInPicture(destroyEvent);
+    } catch (e) {
+    }
+    this.#providerQueue.reset();
+  }
+  #attachLoadPlayListener() {
+    const { load } = this.$props, { canLoad } = this.$state;
+    if (load() !== "play" || canLoad()) return;
+    const off = this.listen("media-play-request", (event) => {
+      this.#handleLoadPlayStrategy(event);
+      off();
+    });
+  }
+  #watchProvider() {
+    const provider = this.#$provider(), canPlay = this.$state.canPlay();
+    if (provider && canPlay) {
+      this.#providerQueue.start();
+    }
+    return () => {
+      this.#providerQueue.stop();
+    };
+  }
+  #handleRequest(event) {
+    event.stopPropagation();
+    if (event.defaultPrevented) return;
+    {
+      this.#media.logger?.infoGroup(`\u{1F4EC} received \`${event.type}\``).labelledLog("Request", event).dispatch();
+    }
+    if (!this[event.type]) return;
+    if (peek(this.#$provider)) {
+      this[event.type](event);
+    } else {
+      this.#providerQueue.enqueue(event.type, () => {
+        if (peek(this.#$provider)) this[event.type](event);
+      });
+    }
+  }
+  async play(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, paused, autoPlaying } = this.$state;
+    if (this.#handleLoadPlayStrategy(trigger)) return;
+    if (!peek(paused)) return;
+    if (trigger) this.#request.queue.enqueue("media-play-request", trigger);
+    const isAutoPlaying = peek(autoPlaying);
+    try {
+      const provider = peek(this.#$provider);
+      throwIfNotReadyForPlayback(provider, peek(canPlay));
+      return await provider.play();
+    } catch (error) {
+      this.#logError("play request failed", error, trigger);
+      const errorEvent = this.createEvent("play-fail", {
+        detail: coerceToError(error),
+        trigger
+      });
+      errorEvent.autoPlay = isAutoPlaying;
+      this.#stateMgr.handle(errorEvent);
+      throw error;
+    }
+  }
+  #handleLoadPlayStrategy(trigger) {
+    const { load } = this.$props, { canLoad } = this.$state;
+    if (load() === "play" && !canLoad()) {
+      const event = this.createEvent("media-start-loading", { trigger });
+      this.dispatchEvent(event);
+      this.#providerQueue.enqueue("media-play-request", async () => {
+        try {
+          await this.play(event);
+        } catch (error) {
+        }
+      });
+      return true;
+    }
+    return false;
+  }
+  async pause(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, paused } = this.$state;
+    if (peek(paused)) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-pause-request", trigger);
+    }
+    try {
+      const provider = peek(this.#$provider);
+      throwIfNotReadyForPlayback(provider, peek(canPlay));
+      return await provider.pause();
+    } catch (error) {
+      this.#request.queue.delete("media-pause-request");
+      {
+        this.#logError("pause request failed", error, trigger);
+      }
+      throw error;
+    }
+  }
+  setAudioGain(gain, trigger) {
+    const { audioGain, canSetAudioGain } = this.$state;
+    if (audioGain() === gain) return;
+    const provider = this.#$provider();
+    if (!provider?.audioGain || !canSetAudioGain()) {
+      throw Error("[vidstack] audio gain api not available");
+    }
+    if (trigger) {
+      this.#request.queue.enqueue("media-audio-gain-change-request", trigger);
+    }
+    provider.audioGain.setGain(gain);
+  }
+  seekToLiveEdge(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, live, liveEdge, canSeek, liveSyncPosition, seekableEnd, userBehindLiveEdge } = this.$state;
+    userBehindLiveEdge.set(false);
+    if (peek(() => !live() || liveEdge() || !canSeek())) return;
+    const provider = peek(this.#$provider);
+    throwIfNotReadyForPlayback(provider, peek(canPlay));
+    if (trigger) this.#request.queue.enqueue("media-seek-request", trigger);
+    const end = seekableEnd() - 2;
+    provider.setCurrentTime(Math.min(end, liveSyncPosition() ?? end));
+  }
+  #wasPIPActive = false;
+  async enterFullscreen(target = "prefer-media", trigger) {
+    if (IS_SERVER) return;
+    const adapter = this.#getFullscreenAdapter(target);
+    throwIfFullscreenNotSupported(target, adapter);
+    if (adapter.active) return;
+    if (peek(this.$state.pictureInPicture)) {
+      this.#wasPIPActive = true;
+      await this.exitPictureInPicture(trigger);
+    }
+    if (trigger) {
+      this.#request.queue.enqueue("media-enter-fullscreen-request", trigger);
+    }
+    return adapter.enter();
+  }
+  async exitFullscreen(target = "prefer-media", trigger) {
+    if (IS_SERVER) return;
+    const adapter = this.#getFullscreenAdapter(target);
+    throwIfFullscreenNotSupported(target, adapter);
+    if (!adapter.active) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-exit-fullscreen-request", trigger);
+    }
+    try {
+      const result = await adapter.exit();
+      if (this.#wasPIPActive && peek(this.$state.canPictureInPicture)) {
+        await this.enterPictureInPicture();
+      }
+      return result;
+    } finally {
+      this.#wasPIPActive = false;
+    }
+  }
+  #getFullscreenAdapter(target) {
+    const provider = peek(this.#$provider);
+    return target === "prefer-media" && this.#fullscreen.supported || target === "media" ? this.#fullscreen : provider?.fullscreen;
+  }
+  async enterPictureInPicture(trigger) {
+    if (IS_SERVER) return;
+    this.#throwIfPIPNotSupported();
+    if (this.$state.pictureInPicture()) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-enter-pip-request", trigger);
+    }
+    return await this.#$provider().pictureInPicture.enter();
+  }
+  async exitPictureInPicture(trigger) {
+    if (IS_SERVER) return;
+    this.#throwIfPIPNotSupported();
+    if (!this.$state.pictureInPicture()) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-exit-pip-request", trigger);
+    }
+    return await this.#$provider().pictureInPicture.exit();
+  }
+  #throwIfPIPNotSupported() {
+    if (this.$state.canPictureInPicture()) return;
+    throw Error(
+      `[vidstack] picture-in-picture is not currently available` 
+    );
+  }
+  #watchControlsDelayChange() {
+    this.controls.defaultDelay = this.$props.controlsDelay();
+  }
+  #watchAudioGainSupport() {
+    const { canSetAudioGain } = this.$state, supported = !!this.#$provider()?.audioGain?.supported;
+    canSetAudioGain.set(supported);
+  }
+  #watchAirPlaySupport() {
+    const { canAirPlay } = this.$state, supported = !!this.#$provider()?.airPlay?.supported;
+    canAirPlay.set(supported);
+  }
+  #watchGoogleCastSupport() {
+    const { canGoogleCast, source } = this.$state, supported = IS_CHROME && !IS_IOS && canGoogleCastSrc(source());
+    canGoogleCast.set(supported);
+  }
+  #watchFullscreenSupport() {
+    const { canFullscreen } = this.$state, supported = this.#fullscreen.supported || !!this.#$provider()?.fullscreen?.supported;
+    canFullscreen.set(supported);
+  }
+  #watchPiPSupport() {
+    const { canPictureInPicture } = this.$state, supported = !!this.#$provider()?.pictureInPicture?.supported;
+    canPictureInPicture.set(supported);
+  }
+  async ["media-airplay-request"](event) {
+    try {
+      await this.requestAirPlay(event);
+    } catch (error) {
+    }
+  }
+  async requestAirPlay(trigger) {
+    try {
+      const adapter = this.#$provider()?.airPlay;
+      if (!adapter?.supported) {
+        throw Error(true ? "AirPlay adapter not available on provider." : "No AirPlay adapter.");
+      }
+      if (trigger) {
+        this.#request.queue.enqueue("media-airplay-request", trigger);
+      }
+      return await adapter.prompt();
+    } catch (error) {
+      this.#request.queue.delete("media-airplay-request");
+      {
+        this.#logError("airplay request failed", error, trigger);
+      }
+      throw error;
+    }
+  }
+  async ["media-google-cast-request"](event) {
+    try {
+      await this.requestGoogleCast(event);
+    } catch (error) {
+    }
+  }
+  #googleCastLoader;
+  async requestGoogleCast(trigger) {
+    try {
+      const { canGoogleCast } = this.$state;
+      if (!peek(canGoogleCast)) {
+        const error = Error(
+          true ? "Google Cast not available on this platform." : "Cast not available."
+        );
+        error.code = "CAST_NOT_AVAILABLE";
+        throw error;
+      }
+      preconnect("https://www.gstatic.com");
+      if (!this.#googleCastLoader) {
+        const $module = await import('./vidstack-DSyHdZcv.js').then(function (n) { return n.loader; });
+        this.#googleCastLoader = new $module.GoogleCastLoader();
+      }
+      await this.#googleCastLoader.prompt(this.#media);
+      if (trigger) {
+        this.#request.queue.enqueue("media-google-cast-request", trigger);
+      }
+      const isConnecting = peek(this.$state.remotePlaybackState) !== "disconnected";
+      if (isConnecting) {
+        this.$state.savedState.set({
+          paused: peek(this.$state.paused),
+          currentTime: peek(this.$state.currentTime)
+        });
+      }
+      this.$state.remotePlaybackLoader.set(isConnecting ? this.#googleCastLoader : null);
+    } catch (error) {
+      this.#request.queue.delete("media-google-cast-request");
+      {
+        this.#logError("google cast request failed", error, trigger);
+      }
+      throw error;
+    }
+  }
+  ["media-clip-start-change-request"](event) {
+    const { clipStartTime } = this.$state;
+    clipStartTime.set(event.detail);
+  }
+  ["media-clip-end-change-request"](event) {
+    const { clipEndTime } = this.$state;
+    clipEndTime.set(event.detail);
+    this.dispatch("duration-change", {
+      detail: event.detail,
+      trigger: event
+    });
+  }
+  ["media-duration-change-request"](event) {
+    const { providedDuration, clipEndTime } = this.$state;
+    providedDuration.set(event.detail);
+    if (clipEndTime() <= 0) {
+      this.dispatch("duration-change", {
+        detail: event.detail,
+        trigger: event
+      });
+    }
+  }
+  ["media-audio-track-change-request"](event) {
+    const { logger, audioTracks } = this.#media;
+    if (audioTracks.readonly) {
+      {
+        logger?.warnGroup(`[vidstack] attempted to change audio track but it is currently read-only`).labelledLog("Request Event", event).dispatch();
+      }
+      return;
+    }
+    const index = event.detail, track = audioTracks[index];
+    if (track) {
+      const key = event.type;
+      this.#request.queue.enqueue(key, event);
+      track.selected = true;
+    } else {
+      logger?.warnGroup("[vidstack] failed audio track change request (invalid index)").labelledLog("Audio Tracks", audioTracks.toArray()).labelledLog("Index", index).labelledLog("Request Event", event).dispatch();
+    }
+  }
+  async ["media-enter-fullscreen-request"](event) {
+    try {
+      await this.enterFullscreen(event.detail, event);
+    } catch (error) {
+      this.#onFullscreenError(error, event);
+    }
+  }
+  async ["media-exit-fullscreen-request"](event) {
+    try {
+      await this.exitFullscreen(event.detail, event);
+    } catch (error) {
+      this.#onFullscreenError(error, event);
+    }
+  }
+  async #onFullscreenChange(event) {
+    const lockType = peek(this.$props.fullscreenOrientation), isFullscreen = event.detail;
+    if (isUndefined(lockType) || lockType === "none" || !this.#orientation.supported) return;
+    if (isFullscreen) {
+      if (this.#orientation.locked) return;
+      this.dispatch("media-orientation-lock-request", {
+        detail: lockType,
+        trigger: event
+      });
+    } else if (this.#orientation.locked) {
+      this.dispatch("media-orientation-unlock-request", {
+        trigger: event
+      });
+    }
+  }
+  #onFullscreenError(error, request) {
+    {
+      this.#logError("fullscreen request failed", error, request);
+    }
+    this.#stateMgr.handle(
+      this.createEvent("fullscreen-error", {
+        detail: coerceToError(error)
+      })
+    );
+  }
+  async ["media-orientation-lock-request"](event) {
+    const key = event.type;
+    try {
+      this.#request.queue.enqueue(key, event);
+      await this.#orientation.lock(event.detail);
+    } catch (error) {
+      this.#request.queue.delete(key);
+      {
+        this.#logError("failed to lock screen orientation", error, event);
+      }
+    }
+  }
+  async ["media-orientation-unlock-request"](event) {
+    const key = event.type;
+    try {
+      this.#request.queue.enqueue(key, event);
+      await this.#orientation.unlock();
+    } catch (error) {
+      this.#request.queue.delete(key);
+      {
+        this.#logError("failed to unlock screen orientation", error, event);
+      }
+    }
+  }
+  async ["media-enter-pip-request"](event) {
+    try {
+      await this.enterPictureInPicture(event);
+    } catch (error) {
+      this.#onPictureInPictureError(error, event);
+    }
+  }
+  async ["media-exit-pip-request"](event) {
+    try {
+      await this.exitPictureInPicture(event);
+    } catch (error) {
+      this.#onPictureInPictureError(error, event);
+    }
+  }
+  #onPictureInPictureError(error, request) {
+    {
+      this.#logError("pip request failed", error, request);
+    }
+    this.#stateMgr.handle(
+      this.createEvent("picture-in-picture-error", {
+        detail: coerceToError(error)
+      })
+    );
+  }
+  ["media-live-edge-request"](event) {
+    const { live, liveEdge, canSeek } = this.$state;
+    if (!live() || liveEdge() || !canSeek()) return;
+    this.#request.queue.enqueue("media-seek-request", event);
+    try {
+      this.seekToLiveEdge();
+    } catch (error) {
+      this.#request.queue.delete("media-seek-request");
+      {
+        this.#logError("seek to live edge fail", error, event);
+      }
+    }
+  }
+  async ["media-loop-request"](event) {
+    try {
+      this.#request.looping = true;
+      this.#request.replaying = true;
+      await this.play(event);
+    } catch (error) {
+      this.#request.looping = false;
+    }
+  }
+  ["media-user-loop-change-request"](event) {
+    this.$state.userPrefersLoop.set(event.detail);
+  }
+  async ["media-pause-request"](event) {
+    if (this.$state.paused()) return;
+    try {
+      await this.pause(event);
+    } catch (error) {
+    }
+  }
+  async ["media-play-request"](event) {
+    if (!this.$state.paused()) return;
+    try {
+      await this.play(event);
+    } catch (e) {
+    }
+  }
+  ["media-rate-change-request"](event) {
+    const { playbackRate, canSetPlaybackRate } = this.$state;
+    if (playbackRate() === event.detail || !canSetPlaybackRate()) return;
+    const provider = this.#$provider();
+    if (!provider?.setPlaybackRate) return;
+    this.#request.queue.enqueue("media-rate-change-request", event);
+    provider.setPlaybackRate(event.detail);
+  }
+  ["media-audio-gain-change-request"](event) {
+    try {
+      this.setAudioGain(event.detail, event);
+    } catch (e) {
+    }
+  }
+  ["media-quality-change-request"](event) {
+    const { qualities, storage, logger } = this.#media;
+    if (qualities.readonly) {
+      {
+        logger?.warnGroup(`[vidstack] attempted to change video quality but it is currently read-only`).labelledLog("Request Event", event).dispatch();
+      }
+      return;
+    }
+    this.#request.queue.enqueue("media-quality-change-request", event);
+    const index = event.detail;
+    if (index < 0) {
+      qualities.autoSelect(event);
+      if (event.isOriginTrusted) storage?.setVideoQuality?.(null);
+    } else {
+      const quality = qualities[index];
+      if (quality) {
+        quality.selected = true;
+        if (event.isOriginTrusted) {
+          storage?.setVideoQuality?.({
+            id: quality.id,
+            width: quality.width,
+            height: quality.height,
+            bitrate: quality.bitrate
+          });
+        }
+      } else {
+        logger?.warnGroup("[vidstack] failed quality change request (invalid index)").labelledLog("Qualities", qualities.toArray()).labelledLog("Index", index).labelledLog("Request Event", event).dispatch();
+      }
+    }
+  }
+  ["media-pause-controls-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.controls.pause(event);
+  }
+  ["media-resume-controls-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.controls.resume(event);
+  }
+  ["media-seek-request"](event) {
+    const { canSeek, ended, live, seekableEnd, userBehindLiveEdge } = this.$state, seekTime = event.detail;
+    if (ended()) this.#request.replaying = true;
+    const key = event.type;
+    this.#request.seeking = false;
+    this.#request.queue.delete(key);
+    const boundedTime = boundTime(seekTime, this.$state);
+    if (!Number.isFinite(boundedTime) || !canSeek()) return;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setCurrentTime(boundedTime);
+    if (live() && event.isOriginTrusted && Math.abs(seekableEnd() - boundedTime) >= 2) {
+      userBehindLiveEdge.set(true);
+    }
+  }
+  ["media-seeking-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.$state.seeking.set(true);
+    this.#request.seeking = true;
+  }
+  ["media-start-loading"](event) {
+    if (this.$state.canLoad()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#stateMgr.handle(this.createEvent("can-load"));
+  }
+  ["media-poster-start-loading"](event) {
+    if (this.$state.canLoadPoster()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#stateMgr.handle(this.createEvent("can-load-poster"));
+  }
+  ["media-text-track-change-request"](event) {
+    const { index, mode } = event.detail, track = this.#media.textTracks[index];
+    if (track) {
+      const key = event.type;
+      this.#request.queue.enqueue(key, event);
+      track.setMode(mode, event);
+    } else {
+      this.#media.logger?.warnGroup("[vidstack] failed text track change request (invalid index)").labelledLog("Text Tracks", this.#media.textTracks.toArray()).labelledLog("Index", index).labelledLog("Request Event", event).dispatch();
+    }
+  }
+  ["media-mute-request"](event) {
+    if (this.$state.muted()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setMuted(true);
+  }
+  ["media-unmute-request"](event) {
+    const { muted, volume } = this.$state;
+    if (!muted()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#media.$provider().setMuted(false);
+    if (volume() === 0) {
+      this.#request.queue.enqueue(key, event);
+      this.#$provider().setVolume(0.25);
+    }
+  }
+  ["media-volume-change-request"](event) {
+    const { muted, volume } = this.$state;
+    const newVolume = event.detail;
+    if (volume() === newVolume) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setVolume(newVolume);
+    if (newVolume > 0 && muted()) {
+      this.#request.queue.enqueue(key, event);
+      this.#$provider().setMuted(false);
+    }
+  }
+  #logError(title, error, request) {
+    this.#media.logger?.errorGroup(`[vidstack] ${title}`).labelledLog("Error", error).labelledLog("Media Context", { ...this.#media }).labelledLog("Trigger Event", request).dispatch();
+  }
+}
+function throwIfNotReadyForPlayback(provider, canPlay) {
+  if (provider && canPlay) return;
+  throw Error(
+    `[vidstack] media is not ready - wait for \`can-play\` event.` 
+  );
+}
+function throwIfFullscreenNotSupported(target, fullscreen) {
+  if (fullscreen?.supported) return;
+  throw Error(
+    `[vidstack] fullscreen is not currently available on target \`${target}\`` 
+  );
+}
+class MediaRequestContext {
+  seeking = false;
+  looping = false;
+  replaying = false;
+  queue = new Queue();
+}
+
+const TRACKED_EVENT = /* @__PURE__ */ new Set([
+  "auto-play",
+  "auto-play-fail",
+  "can-load",
+  "sources-change",
+  "source-change",
+  "load-start",
+  "abort",
+  "error",
+  "loaded-metadata",
+  "loaded-data",
+  "can-play",
+  "play",
+  "play-fail",
+  "pause",
+  "playing",
+  "seeking",
+  "seeked",
+  "waiting"
+]);
+
+class MediaStateManager extends MediaPlayerController {
+  #request;
+  #media;
+  #trackedEvents = /* @__PURE__ */ new Map();
+  #clipEnded = false;
+  #playedIntervals = [];
+  #playedInterval = [-1, -1];
+  #firingWaiting = false;
+  #waitingTrigger;
+  constructor(request, media) {
+    super();
+    this.#request = request;
+    this.#media = media;
+  }
+  onAttach(el) {
+    el.setAttribute("aria-busy", "true");
+    new EventsController(this).add("fullscreen-change", this["fullscreen-change"].bind(this)).add("fullscreen-error", this["fullscreen-error"].bind(this)).add("orientation-change", this["orientation-change"].bind(this));
+  }
+  onConnect(el) {
+    effect(this.#watchCanSetVolume.bind(this));
+    this.#addTextTrackListeners();
+    this.#addQualityListeners();
+    this.#addAudioTrackListeners();
+    this.#resumePlaybackOnConnect();
+    onDispose(this.#pausePlaybackOnDisconnect.bind(this));
+  }
+  onDestroy() {
+    const { audioTracks, qualities, textTracks } = this.#media;
+    audioTracks[ListSymbol.reset]();
+    qualities[ListSymbol.reset]();
+    textTracks[ListSymbol.reset]();
+    this.#stopWatchingQualityResize();
+  }
+  handle(event) {
+    if (!this.scope) return;
+    const type = event.type;
+    untrack(() => this[event.type]?.(event));
+    if (!IS_SERVER) {
+      if (TRACKED_EVENT.has(type)) this.#trackedEvents.set(type, event);
+      this.dispatch(event);
+    }
+  }
+  #isPlayingOnDisconnect = false;
+  #resumePlaybackOnConnect() {
+    if (!this.#isPlayingOnDisconnect) return;
+    requestAnimationFrame(() => {
+      if (!this.scope) return;
+      this.#media.remote.play(new DOMEvent("dom-connect"));
+    });
+    this.#isPlayingOnDisconnect = false;
+  }
+  #pausePlaybackOnDisconnect() {
+    if (this.#isPlayingOnDisconnect) return;
+    this.#isPlayingOnDisconnect = !this.$state.paused();
+    this.#media.$provider()?.pause();
+  }
+  #resetTracking() {
+    this.#stopWaiting();
+    this.#clipEnded = false;
+    this.#request.replaying = false;
+    this.#request.looping = false;
+    this.#firingWaiting = false;
+    this.#waitingTrigger = void 0;
+    this.#trackedEvents.clear();
+  }
+  #satisfyRequest(request, event) {
+    const requestEvent = this.#request.queue.serve(request);
+    if (!requestEvent) return;
+    event.request = requestEvent;
+    event.triggers.add(requestEvent);
+  }
+  #addTextTrackListeners() {
+    this.#onTextTracksChange();
+    this.#onTextTrackModeChange();
+    const textTracks = this.#media.textTracks;
+    new EventsController(textTracks).add("add", this.#onTextTracksChange.bind(this)).add("remove", this.#onTextTracksChange.bind(this)).add("mode-change", this.#onTextTrackModeChange.bind(this));
+  }
+  #addQualityListeners() {
+    const qualities = this.#media.qualities;
+    new EventsController(qualities).add("add", this.#onQualitiesChange.bind(this)).add("remove", this.#onQualitiesChange.bind(this)).add("change", this.#onQualityChange.bind(this)).add("auto-change", this.#onAutoQualityChange.bind(this)).add("readonly-change", this.#onCanSetQualityChange.bind(this));
+  }
+  #addAudioTrackListeners() {
+    const audioTracks = this.#media.audioTracks;
+    new EventsController(audioTracks).add("add", this.#onAudioTracksChange.bind(this)).add("remove", this.#onAudioTracksChange.bind(this)).add("change", this.#onAudioTrackChange.bind(this));
+  }
+  #onTextTracksChange(event) {
+    const { textTracks } = this.$state;
+    textTracks.set(this.#media.textTracks.toArray());
+    this.dispatch("text-tracks-change", {
+      detail: textTracks(),
+      trigger: event
+    });
+  }
+  #onTextTrackModeChange(event) {
+    if (event) this.#satisfyRequest("media-text-track-change-request", event);
+    const current = this.#media.textTracks.selected, { textTrack } = this.$state;
+    if (textTrack() !== current) {
+      textTrack.set(current);
+      this.dispatch("text-track-change", {
+        detail: current,
+        trigger: event
+      });
+    }
+  }
+  #onAudioTracksChange(event) {
+    const { audioTracks } = this.$state;
+    audioTracks.set(this.#media.audioTracks.toArray());
+    this.dispatch("audio-tracks-change", {
+      detail: audioTracks(),
+      trigger: event
+    });
+  }
+  #onAudioTrackChange(event) {
+    const { audioTrack } = this.$state;
+    audioTrack.set(this.#media.audioTracks.selected);
+    if (event) this.#satisfyRequest("media-audio-track-change-request", event);
+    this.dispatch("audio-track-change", {
+      detail: audioTrack(),
+      trigger: event
+    });
+  }
+  #onQualitiesChange(event) {
+    const { qualities } = this.$state;
+    qualities.set(this.#media.qualities.toArray());
+    this.dispatch("qualities-change", {
+      detail: qualities(),
+      trigger: event
+    });
+  }
+  #onQualityChange(event) {
+    const { quality } = this.$state;
+    quality.set(this.#media.qualities.selected);
+    if (event) this.#satisfyRequest("media-quality-change-request", event);
+    this.dispatch("quality-change", {
+      detail: quality(),
+      trigger: event
+    });
+  }
+  #onAutoQualityChange() {
+    const { qualities } = this.#media, isAuto = qualities.auto;
+    this.$state.autoQuality.set(isAuto);
+    if (!isAuto) this.#stopWatchingQualityResize();
+  }
+  #stopQualityResizeEffect = null;
+  #watchQualityResize() {
+    this.#stopWatchingQualityResize();
+    this.#stopQualityResizeEffect = effect(() => {
+      const { qualities } = this.#media, { mediaWidth, mediaHeight } = this.$state, w = mediaWidth(), h = mediaHeight();
+      if (w === 0 || h === 0) return;
+      let selectedQuality = null, minScore = Infinity;
+      for (const quality of qualities) {
+        const score = Math.abs(quality.width - w) + Math.abs(quality.height - h);
+        if (score < minScore) {
+          minScore = score;
+          selectedQuality = quality;
+        }
+      }
+      if (selectedQuality) {
+        qualities[ListSymbol.select](
+          selectedQuality,
+          true,
+          new DOMEvent("resize", { detail: { width: w, height: h } })
+        );
+      }
+    });
+  }
+  #stopWatchingQualityResize() {
+    this.#stopQualityResizeEffect?.();
+    this.#stopQualityResizeEffect = null;
+  }
+  #onCanSetQualityChange() {
+    this.$state.canSetQuality.set(!this.#media.qualities.readonly);
+  }
+  #watchCanSetVolume() {
+    const { canSetVolume, isGoogleCastConnected } = this.$state;
+    if (isGoogleCastConnected()) {
+      canSetVolume.set(false);
+      return;
+    }
+    canChangeVolume().then(canSetVolume.set);
+  }
+  ["provider-change"](event) {
+    const prevProvider = this.#media.$provider(), newProvider = event.detail;
+    if (prevProvider?.type === newProvider?.type) return;
+    prevProvider?.destroy?.();
+    prevProvider?.scope?.dispose();
+    this.#media.$provider.set(event.detail);
+    if (prevProvider && event.detail === null) {
+      this.#resetMediaState(event);
+    }
+  }
+  ["provider-loader-change"](event) {
+    {
+      this.#media.logger?.infoGroup(`Loader change \`${event.detail?.constructor.name}\``).labelledLog("Event", event).dispatch();
+    }
+  }
+  ["auto-play"](event) {
+    this.$state.autoPlayError.set(null);
+  }
+  ["auto-play-fail"](event) {
+    this.$state.autoPlayError.set(event.detail);
+    this.#resetTracking();
+  }
+  ["can-load"](event) {
+    this.$state.canLoad.set(true);
+    this.#trackedEvents.set("can-load", event);
+    this.#media.textTracks[TextTrackSymbol.canLoad]();
+    this.#satisfyRequest("media-start-loading", event);
+  }
+  ["can-load-poster"](event) {
+    this.$state.canLoadPoster.set(true);
+    this.#trackedEvents.set("can-load-poster", event);
+    this.#satisfyRequest("media-poster-start-loading", event);
+  }
+  ["media-type-change"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const viewType = this.$state.viewType();
+    this.$state.mediaType.set(event.detail);
+    const providedViewType = this.$state.providedViewType(), currentViewType = providedViewType === "unknown" ? event.detail : providedViewType;
+    if (viewType !== currentViewType) {
+      if (IS_SERVER) {
+        this.$state.inferredViewType.set(currentViewType);
+      } else {
+        setTimeout(() => {
+          requestAnimationFrame(() => {
+            if (!this.scope) return;
+            this.$state.inferredViewType.set(event.detail);
+            this.dispatch("view-type-change", {
+              detail: currentViewType,
+              trigger: event
+            });
+          });
+        }, 0);
+      }
+    }
+  }
+  ["stream-type-change"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const { streamType, inferredStreamType } = this.$state;
+    inferredStreamType.set(event.detail);
+    event.detail = streamType();
+  }
+  ["rate-change"](event) {
+    const { storage } = this.#media, { canPlay } = this.$state;
+    this.$state.playbackRate.set(event.detail);
+    this.#satisfyRequest("media-rate-change-request", event);
+    if (canPlay()) {
+      storage?.setPlaybackRate?.(event.detail);
+    }
+  }
+  ["remote-playback-change"](event) {
+    const { remotePlaybackState, remotePlaybackType } = this.$state, { type, state } = event.detail, isConnected = state === "connected";
+    remotePlaybackType.set(type);
+    remotePlaybackState.set(state);
+    const key = type === "airplay" ? "media-airplay-request" : "media-google-cast-request";
+    if (isConnected) {
+      this.#satisfyRequest(key, event);
+    } else {
+      const requestEvent = this.#request.queue.peek(key);
+      if (requestEvent) {
+        event.request = requestEvent;
+        event.triggers.add(requestEvent);
+      }
+    }
+  }
+  ["sources-change"](event) {
+    const prevSources = this.$state.sources(), newSources = event.detail;
+    this.$state.sources.set(newSources);
+    this.#onSourceQualitiesChange(prevSources, newSources, event);
+  }
+  #onSourceQualitiesChange(prevSources, newSources, trigger) {
+    let { qualities } = this.#media, added = false, removed = false;
+    for (const prevSrc of prevSources) {
+      if (!isVideoQualitySrc(prevSrc)) continue;
+      const exists = newSources.some((s) => s.src === prevSrc.src);
+      if (!exists) {
+        const quality = qualities.getBySrc(prevSrc.src);
+        if (quality) {
+          qualities[ListSymbol.remove](quality, trigger);
+          removed = true;
+        }
+      }
+    }
+    if (removed && !qualities.length) {
+      this.$state.savedState.set(null);
+      qualities[ListSymbol.reset](trigger);
+    }
+    for (const src of newSources) {
+      if (!isVideoQualitySrc(src) || qualities.getBySrc(src.src)) continue;
+      const quality = {
+        id: src.id ?? src.height + "p",
+        bitrate: null,
+        codec: null,
+        ...src,
+        selected: false
+      };
+      qualities[ListSymbol.add](quality, trigger);
+      added = true;
+    }
+    if (added && !qualities[QualitySymbol.enableAuto]) {
+      this.#watchQualityResize();
+      qualities[QualitySymbol.enableAuto] = this.#watchQualityResize.bind(this);
+      qualities[QualitySymbol.setAuto](true, trigger);
+    }
+  }
+  ["source-change"](event) {
+    event.isQualityChange = event.originEvent?.type === "quality-change";
+    const source = event.detail;
+    this.#resetMediaState(event, event.isQualityChange);
+    this.#trackedEvents.set(event.type, event);
+    this.$state.source.set(source);
+    this.el?.setAttribute("aria-busy", "true");
+    {
+      this.#media.logger?.infoGroup("\u{1F4FC} Media source change").labelledLog("Source", source).dispatch();
+    }
+  }
+  #resetMediaState(event, isSourceQualityChange = false) {
+    const { audioTracks, qualities } = this.#media;
+    if (!isSourceQualityChange) {
+      this.#playedIntervals = [];
+      this.#playedInterval = [-1, -1];
+      audioTracks[ListSymbol.reset](event);
+      qualities[ListSymbol.reset](event);
+      softResetMediaState(this.$state, isSourceQualityChange);
+      this.#resetTracking();
+      return;
+    }
+    softResetMediaState(this.$state, isSourceQualityChange);
+    this.#resetTracking();
+  }
+  ["abort"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const canLoadEvent = this.#trackedEvents.get("can-load");
+    if (canLoadEvent && !event.triggers.hasType("can-load")) {
+      event.triggers.add(canLoadEvent);
+    }
+  }
+  ["load-start"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+  }
+  ["error"](event) {
+    this.$state.error.set(event.detail);
+    const abortEvent = this.#trackedEvents.get("abort");
+    if (abortEvent) event.triggers.add(abortEvent);
+    {
+      this.#media.logger?.errorGroup("Media Error").labelledLog("Error", event.detail).labelledLog("Event", event).labelledLog("Context", this.#media).dispatch();
+    }
+  }
+  ["loaded-metadata"](event) {
+    const loadStartEvent = this.#trackedEvents.get("load-start");
+    if (loadStartEvent) event.triggers.add(loadStartEvent);
+  }
+  ["loaded-data"](event) {
+    const loadStartEvent = this.#trackedEvents.get("load-start");
+    if (loadStartEvent) event.triggers.add(loadStartEvent);
+  }
+  ["can-play"](event) {
+    const loadedMetadata = this.#trackedEvents.get("loaded-metadata");
+    if (loadedMetadata) event.triggers.add(loadedMetadata);
+    this.#onCanPlayDetail(event.detail);
+    this.el?.setAttribute("aria-busy", "false");
+  }
+  ["can-play-through"](event) {
+    this.#onCanPlayDetail(event.detail);
+    const canPlay = this.#trackedEvents.get("can-play");
+    if (canPlay) event.triggers.add(canPlay);
+  }
+  #onCanPlayDetail(detail) {
+    const { seekable, buffered, intrinsicDuration, canPlay } = this.$state;
+    canPlay.set(true);
+    buffered.set(detail.buffered);
+    seekable.set(detail.seekable);
+    const seekableEnd = getTimeRangesEnd(detail.seekable) ?? Infinity;
+    intrinsicDuration.set(seekableEnd);
+  }
+  ["duration-change"](event) {
+    const { live, intrinsicDuration, providedDuration, clipEndTime, ended } = this.$state, time = event.detail;
+    if (!live()) {
+      const duration = !Number.isNaN(time) ? time : 0;
+      intrinsicDuration.set(duration);
+      if (ended()) this.#onEndPrecisionChange(event);
+    }
+    if (providedDuration() > 0 || clipEndTime() > 0) {
+      event.stopImmediatePropagation();
+    }
+  }
+  ["progress"](event) {
+    const { buffered, seekable } = this.$state, { buffered: newBuffered, seekable: newSeekable } = event.detail, newBufferedEnd = getTimeRangesEnd(newBuffered), hasBufferedLengthChanged = newBuffered.length !== buffered().length, hasBufferedEndChanged = newBufferedEnd !== getTimeRangesEnd(buffered()), newSeekableEnd = getTimeRangesEnd(newSeekable), hasSeekableLengthChanged = newSeekable.length !== seekable().length, hasSeekableEndChanged = newSeekableEnd !== getTimeRangesEnd(seekable());
+    if (hasBufferedLengthChanged || hasBufferedEndChanged) {
+      buffered.set(newBuffered);
+    }
+    if (hasSeekableLengthChanged || hasSeekableEndChanged) {
+      seekable.set(newSeekable);
+    }
+  }
+  ["play"](event) {
+    const {
+      paused,
+      autoPlayError,
+      ended,
+      autoPlaying,
+      playsInline,
+      pointer,
+      muted,
+      viewType,
+      live,
+      userBehindLiveEdge
+    } = this.$state;
+    this.#resetPlaybackIfNeeded();
+    if (!paused()) {
+      event.stopImmediatePropagation();
+      return;
+    }
+    event.autoPlay = autoPlaying();
+    const waitingEvent = this.#trackedEvents.get("waiting");
+    if (waitingEvent) event.triggers.add(waitingEvent);
+    this.#satisfyRequest("media-play-request", event);
+    this.#trackedEvents.set("play", event);
+    paused.set(false);
+    autoPlayError.set(null);
+    if (event.autoPlay) {
+      this.handle(
+        this.createEvent("auto-play", {
+          detail: { muted: muted() },
+          trigger: event
+        })
+      );
+      autoPlaying.set(false);
+    }
+    if (ended() || this.#request.replaying) {
+      this.#request.replaying = false;
+      ended.set(false);
+      this.handle(this.createEvent("replay", { trigger: event }));
+    }
+    if (!playsInline() && viewType() === "video" && pointer() === "coarse") {
+      this.#media.remote.enterFullscreen("prefer-media", event);
+    }
+    if (live() && !userBehindLiveEdge()) {
+      this.#media.remote.seekToLiveEdge(event);
+    }
+  }
+  #resetPlaybackIfNeeded(trigger) {
+    const provider = peek(this.#media.$provider);
+    if (!provider) return;
+    const { ended, seekableStart, clipEndTime, currentTime, realCurrentTime, duration } = this.$state;
+    const shouldReset = ended() || realCurrentTime() < seekableStart() || clipEndTime() > 0 && realCurrentTime() >= clipEndTime() || Math.abs(currentTime() - duration()) < 0.1;
+    if (shouldReset) {
+      this.dispatch("media-seek-request", {
+        detail: seekableStart(),
+        trigger
+      });
+    }
+    return shouldReset;
+  }
+  ["play-fail"](event) {
+    const { muted, autoPlaying } = this.$state;
+    const playEvent = this.#trackedEvents.get("play");
+    if (playEvent) event.triggers.add(playEvent);
+    this.#satisfyRequest("media-play-request", event);
+    const { paused, playing } = this.$state;
+    paused.set(true);
+    playing.set(false);
+    this.#resetTracking();
+    this.#trackedEvents.set("play-fail", event);
+    if (event.autoPlay) {
+      this.handle(
+        this.createEvent("auto-play-fail", {
+          detail: {
+            muted: muted(),
+            error: event.detail
+          },
+          trigger: event
+        })
+      );
+      autoPlaying.set(false);
+    }
+  }
+  ["playing"](event) {
+    const playEvent = this.#trackedEvents.get("play"), seekedEvent = this.#trackedEvents.get("seeked");
+    if (playEvent) event.triggers.add(playEvent);
+    else if (seekedEvent) event.triggers.add(seekedEvent);
+    setTimeout(() => this.#resetTracking(), 0);
+    const {
+      paused,
+      playing,
+      live,
+      liveSyncPosition,
+      seekableEnd,
+      started,
+      currentTime,
+      seeking,
+      ended
+    } = this.$state;
+    paused.set(false);
+    playing.set(true);
+    seeking.set(false);
+    ended.set(false);
+    if (this.#request.looping) {
+      this.#request.looping = false;
+      return;
+    }
+    if (live() && !started() && currentTime() === 0) {
+      const end = liveSyncPosition() ?? seekableEnd() - 2;
+      if (Number.isFinite(end)) this.#media.$provider().setCurrentTime(end);
+    }
+    this["started"](event);
+  }
+  ["started"](event) {
+    const { started } = this.$state;
+    if (!started()) {
+      started.set(true);
+      this.handle(this.createEvent("started", { trigger: event }));
+    }
+  }
+  ["pause"](event) {
+    if (!this.el?.isConnected) {
+      this.#isPlayingOnDisconnect = true;
+    }
+    this.#satisfyRequest("media-pause-request", event);
+    const seekedEvent = this.#trackedEvents.get("seeked");
+    if (seekedEvent) event.triggers.add(seekedEvent);
+    const { paused, playing } = this.$state;
+    paused.set(true);
+    playing.set(false);
+    if (this.#clipEnded) {
+      setTimeout(() => {
+        this.handle(this.createEvent("end", { trigger: event }));
+        this.#clipEnded = false;
+      }, 0);
+    }
+    this.#resetTracking();
+  }
+  ["time-change"](event) {
+    if (this.#request.looping) {
+      event.stopImmediatePropagation();
+      return;
+    }
+    let { waiting, played, clipEndTime, realCurrentTime, currentTime } = this.$state, newTime = event.detail, endTime = clipEndTime();
+    realCurrentTime.set(newTime);
+    this.#updatePlayed();
+    waiting.set(false);
+    for (const track of this.#media.textTracks) {
+      track[TextTrackSymbol.updateActiveCues](newTime, event);
+    }
+    if (endTime > 0 && newTime >= endTime) {
+      this.#clipEnded = true;
+      this.dispatch("media-pause-request", { trigger: event });
+    }
+    this.#saveTime();
+    this.dispatch("time-update", {
+      detail: { currentTime: currentTime(), played: played() },
+      trigger: event
+    });
+  }
+  #updatePlayed() {
+    const { currentTime, played, paused } = this.$state;
+    if (paused()) return;
+    this.#playedInterval = updateTimeIntervals(
+      this.#playedIntervals,
+      this.#playedInterval,
+      currentTime()
+    );
+    played.set(new TimeRange(this.#playedIntervals));
+  }
+  // Called to update time again incase duration precision has changed.
+  #onEndPrecisionChange(trigger) {
+    const { clipStartTime, clipEndTime, duration } = this.$state, isClipped = clipStartTime() > 0 || clipEndTime() > 0;
+    if (isClipped) return;
+    this.handle(
+      this.createEvent("time-change", {
+        detail: duration(),
+        trigger
+      })
+    );
+  }
+  #saveTime() {
+    const { storage } = this.#media, { canPlay, realCurrentTime } = this.$state;
+    if (canPlay()) {
+      storage?.setTime?.(realCurrentTime());
+    }
+  }
+  ["audio-gain-change"](event) {
+    const { storage } = this.#media, { canPlay, audioGain } = this.$state;
+    audioGain.set(event.detail);
+    this.#satisfyRequest("media-audio-gain-change-request", event);
+    if (canPlay()) storage?.setAudioGain?.(audioGain());
+  }
+  ["volume-change"](event) {
+    const { storage } = this.#media, { volume, muted, canPlay } = this.$state, detail = event.detail;
+    volume.set(detail.volume);
+    muted.set(detail.muted || detail.volume === 0);
+    this.#satisfyRequest("media-volume-change-request", event);
+    this.#satisfyRequest(detail.muted ? "media-mute-request" : "media-unmute-request", event);
+    if (canPlay()) {
+      storage?.setVolume?.(volume());
+      storage?.setMuted?.(muted());
+    }
+  }
+  ["seeking"] = functionThrottle(
+    (event) => {
+      const { seeking, realCurrentTime, paused } = this.$state;
+      seeking.set(true);
+      realCurrentTime.set(event.detail);
+      this.#satisfyRequest("media-seeking-request", event);
+      if (paused()) {
+        this.#waitingTrigger = event;
+        this.#fireWaiting();
+      }
+      this.#playedInterval = [-1, -1];
+    },
+    150,
+    { leading: true }
+  );
+  ["seeked"](event) {
+    const { seeking, currentTime, realCurrentTime, paused, seekableEnd, ended, live } = this.$state;
+    if (this.#request.seeking) {
+      seeking.set(true);
+      event.stopImmediatePropagation();
+    } else if (seeking()) {
+      const waitingEvent = this.#trackedEvents.get("waiting");
+      if (waitingEvent) event.triggers.add(waitingEvent);
+      const seekingEvent = this.#trackedEvents.get("seeking");
+      if (seekingEvent && !event.triggers.has(seekingEvent)) {
+        event.triggers.add(seekingEvent);
+      }
+      if (paused()) this.#stopWaiting();
+      seeking.set(false);
+      realCurrentTime.set(event.detail);
+      this.#satisfyRequest("media-seek-request", event);
+      const origin = event?.originEvent;
+      if (origin?.isTrusted && !(origin instanceof MessageEvent) && !/seek/.test(origin.type)) {
+        this["started"](event);
+      }
+    }
+    if (!live()) {
+      if (Math.floor(currentTime()) !== Math.floor(seekableEnd())) {
+        ended.set(false);
+      } else {
+        this.end(event);
+      }
+    }
+  }
+  ["waiting"](event) {
+    if (this.#firingWaiting || this.#request.seeking) return;
+    event.stopImmediatePropagation();
+    this.#waitingTrigger = event;
+    this.#fireWaiting();
+  }
+  #fireWaiting = functionDebounce(() => {
+    if (!this.#waitingTrigger) return;
+    this.#firingWaiting = true;
+    const { waiting, playing } = this.$state;
+    waiting.set(true);
+    playing.set(false);
+    const event = this.createEvent("waiting", { trigger: this.#waitingTrigger });
+    this.#trackedEvents.set("waiting", event);
+    this.dispatch(event);
+    this.#waitingTrigger = void 0;
+    this.#firingWaiting = false;
+  }, 300);
+  ["end"](event) {
+    const { loop, ended } = this.$state;
+    if (!loop() && ended()) return;
+    if (loop()) {
+      setTimeout(() => {
+        requestAnimationFrame(() => {
+          this.#resetPlaybackIfNeeded(event);
+          this.dispatch("media-loop-request", { trigger: event });
+        });
+      }, 10);
+      return;
+    }
+    setTimeout(() => this.#onEnded(event), 0);
+  }
+  #onEnded(event) {
+    const { storage } = this.#media, { paused, seeking, ended, duration } = this.$state;
+    this.#onEndPrecisionChange(event);
+    if (!paused()) {
+      this.dispatch("pause", { trigger: event });
+    }
+    if (seeking()) {
+      this.dispatch("seeked", {
+        detail: duration(),
+        trigger: event
+      });
+    }
+    ended.set(true);
+    this.#resetTracking();
+    storage?.setTime?.(duration(), true);
+    this.dispatch("ended", {
+      trigger: event
+    });
+  }
+  #stopWaiting() {
+    this.#fireWaiting.cancel();
+    this.$state.waiting.set(false);
+  }
+  ["fullscreen-change"](event) {
+    const isFullscreen = event.detail;
+    this.$state.fullscreen.set(isFullscreen);
+    this.#satisfyRequest(
+      isFullscreen ? "media-enter-fullscreen-request" : "media-exit-fullscreen-request",
+      event
+    );
+  }
+  ["fullscreen-error"](event) {
+    this.#satisfyRequest("media-enter-fullscreen-request", event);
+    this.#satisfyRequest("media-exit-fullscreen-request", event);
+  }
+  ["orientation-change"](event) {
+    const isLocked = event.detail.lock;
+    this.#satisfyRequest(
+      isLocked ? "media-orientation-lock-request" : "media-orientation-unlock-request",
+      event
+    );
+  }
+  ["picture-in-picture-change"](event) {
+    const isPiP = event.detail;
+    this.$state.pictureInPicture.set(isPiP);
+    this.#satisfyRequest(isPiP ? "media-enter-pip-request" : "media-exit-pip-request", event);
+  }
+  ["picture-in-picture-error"](event) {
+    this.#satisfyRequest("media-enter-pip-request", event);
+    this.#satisfyRequest("media-exit-pip-request", event);
+  }
+  ["title-change"](event) {
+    if (!event.trigger) return;
+    event.stopImmediatePropagation();
+    this.$state.inferredTitle.set(event.detail);
+  }
+  ["poster-change"](event) {
+    if (!event.trigger) return;
+    event.stopImmediatePropagation();
+    this.$state.inferredPoster.set(event.detail);
+  }
+}
+
+class MediaStateSync extends MediaPlayerController {
+  onSetup() {
+    this.#init();
+    if (IS_SERVER) return;
+    effect(this.#watchLogLevel.bind(this));
+    const effects = [
+      this.#watchMetadata,
+      this.#watchAutoplay,
+      this.#watchClipStartTime,
+      this.#watchClipEndTime,
+      this.#watchControls,
+      this.#watchCrossOrigin,
+      this.#watchDuration,
+      this.#watchLive,
+      this.#watchLiveEdge,
+      this.#watchLiveTolerance,
+      this.#watchLoop,
+      this.#watchPlaysInline,
+      this.#watchPoster,
+      this.#watchProvidedTypes,
+      this.#watchTitle
+    ];
+    for (const callback of effects) {
+      effect(callback.bind(this));
+    }
+  }
+  #init() {
+    const providedProps = {
+      duration: "providedDuration",
+      loop: "providedLoop",
+      poster: "providedPoster",
+      streamType: "providedStreamType",
+      title: "providedTitle",
+      viewType: "providedViewType"
+    };
+    const skip = /* @__PURE__ */ new Set([
+      "currentTime",
+      "paused",
+      "playbackRate",
+      "volume"
+    ]);
+    for (const prop of Object.keys(this.$props)) {
+      if (skip.has(prop)) continue;
+      this.$state[providedProps[prop] ?? prop]?.set(this.$props[prop]());
+    }
+    this.$state.muted.set(this.$props.muted() || this.$props.volume() === 0);
+  }
+  // Sync "provided" props with internal state. Provided props are used to differentiate from
+  // provider inferred values.
+  #watchProvidedTypes() {
+    const { viewType, streamType, title, poster, loop } = this.$props, $state = this.$state;
+    $state.providedPoster.set(poster());
+    $state.providedStreamType.set(streamType());
+    $state.providedViewType.set(viewType());
+    $state.providedTitle.set(title());
+    $state.providedLoop.set(loop());
+  }
+  #watchLogLevel() {
+    this.$state.logLevel.set(this.$props.logLevel());
+  }
+  #watchMetadata() {
+    const { artist, artwork } = this.$props;
+    this.$state.artist.set(artist());
+    this.$state.artwork.set(artwork());
+  }
+  #watchTitle() {
+    const { title } = this.$state;
+    this.dispatch("title-change", { detail: title() });
+  }
+  #watchAutoplay() {
+    const autoPlay = this.$props.autoPlay() || this.$props.autoplay();
+    this.$state.autoPlay.set(autoPlay);
+    this.dispatch("auto-play-change", { detail: autoPlay });
+  }
+  #watchLoop() {
+    const loop = this.$state.loop();
+    this.dispatch("loop-change", { detail: loop });
+  }
+  #watchControls() {
+    const controls = this.$props.controls();
+    this.$state.controls.set(controls);
+  }
+  #watchPoster() {
+    const { poster } = this.$state;
+    this.dispatch("poster-change", { detail: poster() });
+  }
+  #watchCrossOrigin() {
+    const crossOrigin = this.$props.crossOrigin() ?? this.$props.crossorigin(), value = crossOrigin === true ? "" : crossOrigin;
+    this.$state.crossOrigin.set(value);
+  }
+  #watchDuration() {
+    const { duration } = this.$props;
+    this.dispatch("media-duration-change-request", {
+      detail: duration()
+    });
+  }
+  #watchPlaysInline() {
+    const inline = this.$props.playsInline() || this.$props.playsinline();
+    this.$state.playsInline.set(inline);
+    this.dispatch("plays-inline-change", { detail: inline });
+  }
+  #watchClipStartTime() {
+    const { clipStartTime } = this.$props;
+    this.dispatch("media-clip-start-change-request", {
+      detail: clipStartTime()
+    });
+  }
+  #watchClipEndTime() {
+    const { clipEndTime } = this.$props;
+    this.dispatch("media-clip-end-change-request", {
+      detail: clipEndTime()
+    });
+  }
+  #watchLive() {
+    this.dispatch("live-change", { detail: this.$state.live() });
+  }
+  #watchLiveTolerance() {
+    this.$state.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());
+    this.$state.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());
+  }
+  #watchLiveEdge() {
+    this.dispatch("live-edge-change", { detail: this.$state.liveEdge() });
+  }
+}
+
+const actions = ["play", "pause", "seekforward", "seekbackward", "seekto"];
+class NavigatorMediaSession extends MediaPlayerController {
+  onConnect() {
+    effect(this.#onMetadataChange.bind(this));
+    effect(this.#onPlaybackStateChange.bind(this));
+    const handleAction = this.#handleAction.bind(this);
+    for (const action of actions) {
+      navigator.mediaSession.setActionHandler(action, handleAction);
+    }
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  #onDisconnect() {
+    for (const action of actions) {
+      navigator.mediaSession.setActionHandler(action, null);
+    }
+  }
+  #onMetadataChange() {
+    const { title, artist, artwork, poster } = this.$state;
+    navigator.mediaSession.metadata = new MediaMetadata({
+      title: title(),
+      artist: artist(),
+      artwork: artwork() ?? [{ src: poster() }]
+    });
+  }
+  #onPlaybackStateChange() {
+    const { canPlay, paused } = this.$state;
+    navigator.mediaSession.playbackState = !canPlay() ? "none" : paused() ? "paused" : "playing";
+  }
+  #handleAction(details) {
+    const trigger = new DOMEvent(`media-session-action`, { detail: details });
+    switch (details.action) {
+      case "play":
+        this.dispatch("media-play-request", { trigger });
+        break;
+      case "pause":
+        this.dispatch("media-pause-request", { trigger });
+        break;
+      case "seekto":
+      case "seekforward":
+      case "seekbackward":
+        this.dispatch("media-seek-request", {
+          detail: isNumber(details.seekTime) ? details.seekTime : this.$state.currentTime() + (details.seekOffset ?? (details.action === "seekforward" ? 10 : -10)),
+          trigger
+        });
+        break;
+    }
+  }
+}
+
+const LOCAL_STORAGE_KEY = "@vidstack/log-colors";
+const savedColors = init();
+function getLogColor(key) {
+  return savedColors.get(key);
+}
+function saveLogColor(key, { color = generateColor(), overwrite = false } = {}) {
+  if (!savedColors.has(key) || overwrite) {
+    savedColors.set(key, color);
+    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Object.entries(savedColors)));
+  }
+}
+function generateColor() {
+  return `hsl(${Math.random() * 360}, 55%, 70%)`;
+}
+function init() {
+  let colors;
+  try {
+    colors = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));
+  } catch {
+  }
+  return new Map(Object.entries(colors ?? {}));
+}
+
+const LogLevelValue = Object.freeze({
+  silent: 0,
+  error: 1,
+  warn: 2,
+  info: 3,
+  debug: 4
+});
+const LogLevelColor = Object.freeze({
+  silent: "white",
+  error: "hsl(6, 58%, 50%)",
+  warn: "hsl(51, 58%, 50%)",
+  info: "hsl(219, 58%, 50%)",
+  debug: "hsl(280, 58%, 50%)"
+});
+
+const s = 1e3;
+const m = s * 60;
+const h = m * 60;
+const d = h * 24;
+function ms(val) {
+  const msAbs = Math.abs(val);
+  if (msAbs >= d) {
+    return Math.round(val / d) + "d";
+  }
+  if (msAbs >= h) {
+    return Math.round(val / h) + "h";
+  }
+  if (msAbs >= m) {
+    return Math.round(val / m) + "m";
+  }
+  if (msAbs >= s) {
+    return Math.round(val / s) + "s";
+  }
+  return round(val, 2) + "ms";
+}
+
+class LogPrinter extends ViewController {
+  #level = "warn" ;
+  #lastLogged;
+  /**
+   * The current log level.
+   */
+  get logLevel() {
+    return this.#level ;
+  }
+  set logLevel(level) {
+    this.#level = level;
+  }
+  onConnect() {
+    this.listen("vds-log", (event) => {
+      event.stopPropagation();
+      const element = event.path?.[0] ?? (event.target instanceof ViewController ? event.target.el : event.target), eventTargetName = element?.$$COMPONENT_NAME?.replace(/^_/, "").replace(/Instance$/, "") ?? element?.tagName.toLowerCase() ?? "unknown";
+      const { level = "warn", data } = event.detail ?? {};
+      if (LogLevelValue[this.#level] < LogLevelValue[level]) {
+        return;
+      }
+      saveLogColor(eventTargetName);
+      const hint = data?.length === 1 && isGroupedLog(data[0]) ? data[0].title : isString(data?.[0]) ? data[0] : "";
+      console.groupCollapsed(
+        `%c${level.toUpperCase()}%c ${eventTargetName}%c ${hint.slice(0, 50)}${hint.length > 50 ? "..." : ""}`,
+        `background: ${LogLevelColor[level]}; color: white; padding: 1.5px 2.2px; border-radius: 2px; font-size: 11px;`,
+        `color: ${getLogColor(eventTargetName)}; padding: 4px 0px; font-size: 11px;`,
+        "color: gray; font-size: 11px; padding-left: 4px;"
+      );
+      if (data?.length === 1 && isGroupedLog(data[0])) {
+        if (element) data[0].logs.unshift({ label: "Element", data: [element] });
+        printGroup(level, data[0]);
+      } else if (data) {
+        print(level, ...data);
+      }
+      this.#printTimeDiff();
+      printStackTrace();
+      console.groupEnd();
+    });
+    onDispose(() => {
+      this.#lastLogged = void 0;
+    });
+  }
+  #printTimeDiff() {
+    labelledPrint("Time since last log", this.#calcLastLogTimeDiff());
+  }
+  #calcLastLogTimeDiff() {
+    const time = performance.now();
+    const diff = time - (this.#lastLogged ?? (this.#lastLogged = performance.now()));
+    this.#lastLogged = time;
+    return ms(diff);
+  }
+}
+function print(level, ...data) {
+  console[level](...data);
+}
+function labelledPrint(label, ...data) {
+  console.log(`%c${label}:`, "color: gray", ...data);
+}
+function printStackTrace() {
+  console.groupCollapsed("%cStack Trace", "color: gray");
+  console.trace();
+  console.groupEnd();
+}
+function printGroup(level, groupedLog) {
+  for (const log of groupedLog.logs) {
+    if (isGroupedLog(log)) {
+      console.groupCollapsed(groupedLog.title);
+      printGroup(level, log);
+      console.groupEnd();
+    } else if ("label" in log && !isUndefined(log.label)) {
+      labelledPrint(log.label, ...log.data);
+    } else {
+      print(level, ...log.data);
+    }
+  }
+}
+
+let $keyboard = signal(false);
+if (!IS_SERVER) {
+  listenEvent(document, "pointerdown", () => {
+    $keyboard.set(false);
+  });
+  listenEvent(document, "keydown", (e) => {
+    if (e.metaKey || e.altKey || e.ctrlKey) return;
+    $keyboard.set(true);
+  });
+}
+class FocusVisibleController extends ViewController {
+  #focused = signal(false);
+  onConnect(el) {
+    effect(() => {
+      const events = new EventsController(el);
+      if (!$keyboard()) {
+        this.#focused.set(false);
+        updateFocusAttr(el, false);
+        events.add("pointerenter", this.#onPointerEnter.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this));
+        return;
+      }
+      const active = document.activeElement === el;
+      this.#focused.set(active);
+      updateFocusAttr(el, active);
+      events.add("focus", this.#onFocus.bind(this)).add("blur", this.#onBlur.bind(this));
+    });
+  }
+  focused() {
+    return this.#focused();
+  }
+  #onFocus() {
+    this.#focused.set(true);
+    updateFocusAttr(this.el, true);
+  }
+  #onBlur() {
+    this.#focused.set(false);
+    updateFocusAttr(this.el, false);
+  }
+  #onPointerEnter() {
+    updateHoverAttr(this.el, true);
+  }
+  #onPointerLeave() {
+    updateHoverAttr(this.el, false);
+  }
+}
+function updateFocusAttr(el, isFocused) {
+  setAttribute(el, "data-focus", isFocused);
+  setAttribute(el, "data-hocus", isFocused);
+}
+function updateHoverAttr(el, isHovering) {
+  setAttribute(el, "data-hocus", isHovering);
+  setAttribute(el, "data-hover", isHovering);
+}
+
+class MediaPlayer extends Component {
+  static props = mediaPlayerProps;
+  static state = mediaState;
+  #media;
+  #stateMgr;
+  #requestMgr;
+  canPlayQueue = new RequestQueue();
+  remoteControl;
+  get #provider() {
+    return this.#media.$provider();
+  }
+  get #props() {
+    return this.$props;
+  }
+  constructor() {
+    super();
+    new MediaStateSync();
+    const context = {
+      player: this,
+      qualities: new VideoQualityList(),
+      audioTracks: new AudioTrackList(),
+      storage: null,
+      $provider: signal(null),
+      $providerSetup: signal(false),
+      $props: this.$props,
+      $state: this.$state
+    };
+    {
+      const logPrinter = new LogPrinter();
+      effect(() => {
+        logPrinter.logLevel = this.$props.logLevel();
+      });
+    }
+    context.logger = new Logger();
+    context.remote = this.remoteControl = new MediaRemoteControl(
+      context.logger 
+    );
+    context.remote.setPlayer(this);
+    context.textTracks = new TextTrackList();
+    context.textTracks[TextTrackSymbol.crossOrigin] = this.$state.crossOrigin;
+    context.textRenderers = new TextRenderers(context);
+    context.ariaKeys = {};
+    this.#media = context;
+    provideContext(mediaContext, context);
+    this.orientation = new ScreenOrientationController();
+    new FocusVisibleController();
+    new MediaKeyboardController(context);
+    new MediaEventsLogger(context);
+    const request = new MediaRequestContext();
+    this.#stateMgr = new MediaStateManager(request, context);
+    this.#requestMgr = new MediaRequestManager(this.#stateMgr, request, context);
+    context.delegate = new MediaPlayerDelegate(this.#stateMgr.handle.bind(this.#stateMgr), context);
+    context.notify = context.delegate.notify.bind(context.delegate);
+    if (typeof navigator !== "undefined" && "mediaSession" in navigator) {
+      new NavigatorMediaSession();
+    }
+    new MediaLoadController("load", this.startLoading.bind(this));
+    new MediaLoadController("posterLoad", this.startLoadingPoster.bind(this));
+  }
+  onSetup() {
+    this.#setupMediaAttributes();
+    effect(this.#watchCanPlay.bind(this));
+    effect(this.#watchMuted.bind(this));
+    effect(this.#watchPaused.bind(this));
+    effect(this.#watchVolume.bind(this));
+    effect(this.#watchCurrentTime.bind(this));
+    effect(this.#watchPlaysInline.bind(this));
+    effect(this.#watchPlaybackRate.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-player", "");
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "region");
+    effect(this.#watchStorage.bind(this));
+    if (IS_SERVER) this.#watchTitle();
+    else effect(this.#watchTitle.bind(this));
+    if (IS_SERVER) this.#watchOrientation();
+    else effect(this.#watchOrientation.bind(this));
+    listenEvent(el, "find-media-player", this.#onFindPlayer.bind(this));
+  }
+  onConnect(el) {
+    if (IS_IPHONE) setAttribute(el, "data-iphone", "");
+    const pointerQuery = window.matchMedia("(pointer: coarse)");
+    this.#onPointerChange(pointerQuery);
+    pointerQuery.onchange = this.#onPointerChange.bind(this);
+    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
+    resize.observe(el);
+    effect(this.#onResize.bind(this));
+    this.dispatch("media-player-connect", {
+      detail: this,
+      bubbles: true,
+      composed: true
+    });
+    this.#media.logger.setTarget(el);
+    onDispose(() => {
+      resize.disconnect();
+      pointerQuery.onchange = null;
+      this.#media.logger.setTarget(null);
+    });
+  }
+  onDestroy() {
+    this.#media.player = null;
+    this.canPlayQueue.reset();
+  }
+  #skipTitleUpdate = false;
+  #watchTitle() {
+    const el = this.$el, { title, live, viewType, providedTitle } = this.$state, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media", currentTitle = title();
+    setAttribute(
+      this.el,
+      "aria-label",
+      `${typeText} Player` + (currentTitle ? ` - ${currentTitle}` : "")
+    );
+    if (!IS_SERVER && el?.hasAttribute("title")) {
+      this.#skipTitleUpdate = true;
+      el?.removeAttribute("title");
+    }
+  }
+  #watchOrientation() {
+    const orientation = this.orientation.landscape ? "landscape" : "portrait";
+    this.$state.orientation.set(orientation);
+    setAttribute(this.el, "data-orientation", orientation);
+    this.#onResize();
+  }
+  #watchCanPlay() {
+    if (this.$state.canPlay() && this.#provider) this.canPlayQueue.start();
+    else this.canPlayQueue.stop();
+  }
+  #setupMediaAttributes() {
+    if (MediaPlayer[MEDIA_ATTRIBUTES]) {
+      this.setAttributes(MediaPlayer[MEDIA_ATTRIBUTES]);
+      return;
+    }
+    const $attrs = {
+      "data-load": function() {
+        return this.$props.load();
+      },
+      "data-captions": function() {
+        const track = this.$state.textTrack();
+        return !!track && isTrackCaptionKind(track);
+      },
+      "data-ios-controls": function() {
+        return this.$state.iOSControls();
+      },
+      "data-controls": function() {
+        return this.controls.showing;
+      },
+      "data-buffering": function() {
+        const { canLoad, canPlay, waiting } = this.$state;
+        return canLoad() && (!canPlay() || waiting());
+      },
+      "data-error": function() {
+        const { error } = this.$state;
+        return !!error();
+      },
+      "data-autoplay-error": function() {
+        const { autoPlayError } = this.$state;
+        return !!autoPlayError();
+      }
+    };
+    const alias = {
+      autoPlay: "autoplay",
+      canAirPlay: "can-airplay",
+      canPictureInPicture: "can-pip",
+      pictureInPicture: "pip",
+      playsInline: "playsinline",
+      remotePlaybackState: "remote-state",
+      remotePlaybackType: "remote-type",
+      isAirPlayConnected: "airplay",
+      isGoogleCastConnected: "google-cast"
+    };
+    for (const prop2 of mediaAttributes) {
+      const attrName = "data-" + (alias[prop2] ?? camelToKebabCase(prop2));
+      $attrs[attrName] = function() {
+        return this.$state[prop2]();
+      };
+    }
+    delete $attrs.title;
+    MediaPlayer[MEDIA_ATTRIBUTES] = $attrs;
+    this.setAttributes($attrs);
+  }
+  #onFindPlayer(event) {
+    event.detail(this);
+  }
+  #onResize() {
+    if (IS_SERVER || !this.el) return;
+    const width = this.el.clientWidth, height = this.el.clientHeight;
+    this.$state.width.set(width);
+    this.$state.height.set(height);
+    setStyle(this.el, "--player-width", width + "px");
+    setStyle(this.el, "--player-height", height + "px");
+  }
+  #onPointerChange(queryList) {
+    if (IS_SERVER) return;
+    const pointer = queryList.matches ? "coarse" : "fine";
+    setAttribute(this.el, "data-pointer", pointer);
+    this.$state.pointer.set(pointer);
+    this.#onResize();
+  }
+  /**
+   * The current media provider.
+   */
+  get provider() {
+    return this.#provider;
+  }
+  /**
+   * Media controls settings.
+   */
+  get controls() {
+    return this.#requestMgr.controls;
+  }
+  set controls(controls) {
+    this.#props.controls.set(controls);
+  }
+  /**
+   * Controls the screen orientation of the current browser window and dispatches orientation
+   * change events on the player.
+   */
+  orientation;
+  /**
+   * The title of the current media.
+   */
+  get title() {
+    return peek(this.$state.title);
+  }
+  set title(newTitle) {
+    if (this.#skipTitleUpdate) {
+      this.#skipTitleUpdate = false;
+      return;
+    }
+    this.#props.title.set(newTitle);
+  }
+  /**
+   * A list of all `VideoQuality` objects representing the set of available video renditions.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/video-quality}
+   */
+  get qualities() {
+    return this.#media.qualities;
+  }
+  /**
+   * A list of all `AudioTrack` objects representing the set of available audio tracks.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/audio-tracks}
+   */
+  get audioTracks() {
+    return this.#media.audioTracks;
+  }
+  /**
+   * A list of all `TextTrack` objects representing the set of available text tracks.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/text-tracks}
+   */
+  get textTracks() {
+    return this.#media.textTracks;
+  }
+  /**
+   * Contains text renderers which are responsible for loading, parsing, and rendering text
+   * tracks.
+   */
+  get textRenderers() {
+    return this.#media.textRenderers;
+  }
+  get duration() {
+    return this.$state.duration();
+  }
+  set duration(duration) {
+    this.#props.duration.set(duration);
+  }
+  get paused() {
+    return peek(this.$state.paused);
+  }
+  set paused(paused) {
+    this.#queuePausedUpdate(paused);
+  }
+  #watchPaused() {
+    this.#queuePausedUpdate(this.$props.paused());
+  }
+  #queuePausedUpdate(paused) {
+    if (paused) {
+      this.canPlayQueue.enqueue("paused", () => this.#requestMgr.pause());
+    } else this.canPlayQueue.enqueue("paused", () => this.#requestMgr.play());
+  }
+  get muted() {
+    return peek(this.$state.muted);
+  }
+  set muted(muted) {
+    this.#queueMutedUpdate(muted);
+  }
+  #watchMuted() {
+    this.#queueMutedUpdate(this.$props.muted());
+  }
+  #queueMutedUpdate(muted) {
+    this.canPlayQueue.enqueue("muted", () => {
+      if (this.#provider) this.#provider.setMuted(muted);
+    });
+  }
+  get currentTime() {
+    return peek(this.$state.currentTime);
+  }
+  set currentTime(time) {
+    this.#queueCurrentTimeUpdate(time);
+  }
+  #watchCurrentTime() {
+    this.#queueCurrentTimeUpdate(this.$props.currentTime());
+  }
+  #queueCurrentTimeUpdate(time) {
+    this.canPlayQueue.enqueue("currentTime", () => {
+      const { currentTime } = this.$state;
+      if (time === peek(currentTime)) return;
+      peek(() => {
+        if (!this.#provider) return;
+        const boundedTime = boundTime(time, this.$state);
+        if (Number.isFinite(boundedTime)) {
+          this.#provider.setCurrentTime(boundedTime);
+        }
+      });
+    });
+  }
+  get volume() {
+    return peek(this.$state.volume);
+  }
+  set volume(volume) {
+    this.#queueVolumeUpdate(volume);
+  }
+  #watchVolume() {
+    this.#queueVolumeUpdate(this.$props.volume());
+  }
+  #queueVolumeUpdate(volume) {
+    const clampedVolume = clampNumber(0, volume, 1);
+    this.canPlayQueue.enqueue("volume", () => {
+      if (this.#provider) this.#provider.setVolume(clampedVolume);
+    });
+  }
+  get playbackRate() {
+    return peek(this.$state.playbackRate);
+  }
+  set playbackRate(rate) {
+    this.#queuePlaybackRateUpdate(rate);
+  }
+  #watchPlaybackRate() {
+    this.#queuePlaybackRateUpdate(this.$props.playbackRate());
+  }
+  #queuePlaybackRateUpdate(rate) {
+    this.canPlayQueue.enqueue("rate", () => {
+      if (this.#provider) this.#provider.setPlaybackRate?.(rate);
+    });
+  }
+  #watchPlaysInline() {
+    this.#queuePlaysInlineUpdate(this.$props.playsInline());
+  }
+  #queuePlaysInlineUpdate(inline) {
+    this.canPlayQueue.enqueue("playsinline", () => {
+      if (this.#provider) this.#provider.setPlaysInline?.(inline);
+    });
+  }
+  #watchStorage() {
+    let storageValue = this.$props.storage(), storage = isString(storageValue) ? new LocalMediaStorage() : storageValue;
+    if (storage?.onChange) {
+      const { source } = this.$state, playerId = isString(storageValue) ? storageValue : this.el?.id, mediaId = computed(this.#computeMediaId.bind(this));
+      effect(() => storage.onChange(source(), mediaId(), playerId || void 0));
+    }
+    this.#media.storage = storage;
+    this.#media.textTracks.setStorage(storage);
+    onDispose(() => {
+      storage?.onDestroy?.();
+      this.#media.storage = null;
+      this.#media.textTracks.setStorage(null);
+    });
+  }
+  #computeMediaId() {
+    const { clipStartTime, clipEndTime } = this.$props, { source } = this.$state, src = source();
+    return src.src ? `${src.src}:${clipStartTime()}:${clipEndTime()}` : null;
+  }
+  /**
+   * Begins/resumes playback of the media. If this method is called programmatically before the
+   * user has interacted with the player, the promise may be rejected subject to the browser's
+   * autoplay policies. This method will throw if called before media is ready for playback.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play}
+   */
+  async play(trigger) {
+    return this.#requestMgr.play(trigger);
+  }
+  /**
+   * Pauses playback of the media. This method will throw if called before media is ready for
+   * playback.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause}
+   */
+  async pause(trigger) {
+    return this.#requestMgr.pause(trigger);
+  }
+  /**
+   * Attempts to display the player in fullscreen. The promise will resolve if successful, and
+   * reject if not. This method will throw if any fullscreen API is _not_ currently available.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/fullscreen}
+   */
+  async enterFullscreen(target, trigger) {
+    return this.#requestMgr.enterFullscreen(target, trigger);
+  }
+  /**
+   * Attempts to display the player inline by exiting fullscreen. This method will throw if any
+   * fullscreen API is _not_ currently available.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/fullscreen}
+   */
+  async exitFullscreen(target, trigger) {
+    return this.#requestMgr.exitFullscreen(target, trigger);
+  }
+  /**
+   * Attempts to display the player in picture-in-picture mode. This method will throw if PIP is
+   * not supported. This method will also return a `PictureInPictureWindow` if the current
+   * provider supports it.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
+   */
+  enterPictureInPicture(trigger) {
+    return this.#requestMgr.enterPictureInPicture(trigger);
+  }
+  /**
+   * Attempts to display the player in inline by exiting picture-in-picture mode. This method
+   * will throw if not supported.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
+   */
+  exitPictureInPicture(trigger) {
+    return this.#requestMgr.exitPictureInPicture(trigger);
+  }
+  /**
+   * Sets the current time to the live edge (i.e., `duration`). This is a no-op for non-live
+   * streams and will throw if called before media is ready for playback.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/live}
+   */
+  seekToLiveEdge(trigger) {
+    this.#requestMgr.seekToLiveEdge(trigger);
+  }
+  /**
+   * Called when media can begin loading. Calling this method will trigger the initial provider
+   * loading process. Calling it more than once has no effect.
+   *
+   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoading(trigger) {
+    this.#media.notify("can-load", void 0, trigger);
+  }
+  /**
+   * Called when the poster image can begin loading. Calling it more than once has no effect.
+   *
+   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoadingPoster(trigger) {
+    this.#media.notify("can-load-poster", void 0, trigger);
+  }
+  /**
+   * Request Apple AirPlay picker to open.
+   */
+  requestAirPlay(trigger) {
+    return this.#requestMgr.requestAirPlay(trigger);
+  }
+  /**
+   * Request Google Cast device picker to open. The Google Cast framework will be loaded if it
+   * hasn't yet.
+   */
+  requestGoogleCast(trigger) {
+    return this.#requestMgr.requestGoogleCast(trigger);
+  }
+  /**
+   * Set the audio gain, amplifying volume and enabling a maximum volume above 100%.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/audio-gain}
+   */
+  setAudioGain(gain, trigger) {
+    return this.#requestMgr.setAudioGain(gain, trigger);
+  }
+  destroy() {
+    super.destroy();
+    this.#media.remote.setPlayer(null);
+    this.dispatch("destroy");
+  }
+}
+const mediaplayer__proto = MediaPlayer.prototype;
+prop(mediaplayer__proto, "canPlayQueue");
+prop(mediaplayer__proto, "remoteControl");
+prop(mediaplayer__proto, "provider");
+prop(mediaplayer__proto, "controls");
+prop(mediaplayer__proto, "orientation");
+prop(mediaplayer__proto, "title");
+prop(mediaplayer__proto, "qualities");
+prop(mediaplayer__proto, "audioTracks");
+prop(mediaplayer__proto, "textTracks");
+prop(mediaplayer__proto, "textRenderers");
+prop(mediaplayer__proto, "duration");
+prop(mediaplayer__proto, "paused");
+prop(mediaplayer__proto, "muted");
+prop(mediaplayer__proto, "currentTime");
+prop(mediaplayer__proto, "volume");
+prop(mediaplayer__proto, "playbackRate");
+method(mediaplayer__proto, "play");
+method(mediaplayer__proto, "pause");
+method(mediaplayer__proto, "enterFullscreen");
+method(mediaplayer__proto, "exitFullscreen");
+method(mediaplayer__proto, "enterPictureInPicture");
+method(mediaplayer__proto, "exitPictureInPicture");
+method(mediaplayer__proto, "seekToLiveEdge");
+method(mediaplayer__proto, "startLoading");
+method(mediaplayer__proto, "startLoadingPoster");
+method(mediaplayer__proto, "requestAirPlay");
+method(mediaplayer__proto, "requestGoogleCast");
+method(mediaplayer__proto, "setAudioGain");
+
+function resolveStreamTypeFromDASHManifest(manifestSrc, requestInit) {
+  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
+    return /type="static"/.test(manifest) ? "on-demand" : "live";
+  });
+}
+function resolveStreamTypeFromHLSManifest(manifestSrc, requestInit) {
+  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
+    const renditionURI = resolveHLSRenditionURI(manifest);
+    if (renditionURI) {
+      return resolveStreamTypeFromHLSManifest(
+        /^https?:/.test(renditionURI) ? renditionURI : new URL(renditionURI, manifestSrc).href,
+        requestInit
+      );
+    }
+    const streamType = /EXT-X-PLAYLIST-TYPE:\s*VOD/.test(manifest) ? "on-demand" : "live";
+    if (streamType === "live" && resolveTargetDuration(manifest) >= 10 && (/#EXT-X-DVR-ENABLED:\s*true/.test(manifest) || manifest.includes("#EXT-X-DISCONTINUITY"))) {
+      return "live:dvr";
+    }
+    return streamType;
+  });
+}
+function resolveHLSRenditionURI(manifest) {
+  const matches = manifest.match(/#EXT-X-STREAM-INF:[^\n]+(\n[^\n]+)*/g);
+  return matches ? matches[0].split("\n")[1].trim() : null;
+}
+function resolveTargetDuration(manifest) {
+  const lines = manifest.split("\n");
+  for (const line of lines) {
+    if (line.startsWith("#EXT-X-TARGETDURATION")) {
+      const duration = parseFloat(line.split(":")[1]);
+      if (!isNaN(duration)) {
+        return duration;
+      }
+    }
+  }
+  return -1;
+}
+
+let warned$1 = /* @__PURE__ */ new Set() ;
+const sourceTypes = /* @__PURE__ */ new Map();
+class SourceSelection {
+  #initialize = false;
+  #loaders;
+  #domSources;
+  #media;
+  #loader;
+  constructor(domSources, media, loader, customLoaders = []) {
+    this.#domSources = domSources;
+    this.#media = media;
+    this.#loader = loader;
+    const DASH_LOADER = new DASHProviderLoader(), HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader(), YOUTUBE_LOADER = new YouTubeProviderLoader(), VIMEO_LOADER = new VimeoProviderLoader(), EMBED_LOADERS = [YOUTUBE_LOADER, VIMEO_LOADER];
+    this.#loaders = computed(() => {
+      const remoteLoader = media.$state.remotePlaybackLoader();
+      const loaders = media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, HLS_LOADER, ...EMBED_LOADERS, ...customLoaders] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, ...EMBED_LOADERS, ...customLoaders];
+      return remoteLoader ? [remoteLoader, ...loaders] : loaders;
+    });
+    const { $state } = media;
+    $state.sources.set(normalizeSrc(media.$props.src()));
+    for (const src of $state.sources()) {
+      const loader2 = this.#loaders().find((loader3) => loader3.canPlay(src));
+      if (!loader2) continue;
+      const mediaType = loader2.mediaType(src);
+      media.$state.source.set(src);
+      media.$state.mediaType.set(mediaType);
+      media.$state.inferredViewType.set(mediaType);
+      this.#loader.set(loader2);
+      this.#initialize = true;
+      break;
+    }
+  }
+  connect() {
+    const loader = this.#loader();
+    if (this.#initialize) {
+      this.#notifySourceChange(this.#media.$state.source(), loader);
+      this.#notifyLoaderChange(loader);
+      this.#initialize = false;
+    }
+    effect(this.#onSourcesChange.bind(this));
+    effect(this.#onSourceChange.bind(this));
+    effect(this.#onSetup.bind(this));
+    effect(this.#onLoadSource.bind(this));
+    effect(this.#onLoadPoster.bind(this));
+  }
+  #onSourcesChange() {
+    this.#media.notify("sources-change", [
+      ...normalizeSrc(this.#media.$props.src()),
+      ...this.#domSources()
+    ]);
+  }
+  #onSourceChange() {
+    const { $state } = this.#media;
+    const sources = $state.sources(), currentSource = peek($state.source), newSource = this.#findNewSource(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;
+    if (noMatch && !warned$1.has(newSource.src) && !peek(this.#loader)) {
+      const source = sources[0];
+      console.warn(
+        `[vidstack] could not find a loader for any of the given media sources, consider providing \`type\`:
+
+--- HTML ---
+
+<media-provider>
+  <source src="${source.src}" type="video/mp4" />
+</media-provider>"
+
+--- React ---
+
+<MediaPlayer src={{ src: "${source.src}", type: "video/mp4" }}>
+
+---
+
+Falling back to fetching source headers...`
+      );
+      warned$1.add(newSource.src);
+    }
+    if (noMatch) {
+      const { crossOrigin } = $state, credentials = getRequestCredentials(crossOrigin()), abort = new AbortController();
+      Promise.all(
+        sources.map(
+          (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
+            method: "HEAD",
+            credentials,
+            signal: abort.signal
+          }).then((res) => {
+            source.type = res.headers.get("content-type") || "??";
+            sourceTypes.set(source.src, source.type);
+            return source;
+          }).catch(() => source) : source
+        )
+      ).then((sources2) => {
+        if (abort.signal.aborted) return;
+        const newSource2 = this.#findNewSource(peek($state.source), sources2);
+        tick();
+        if (!newSource2.src) {
+          this.#media.notify("error", {
+            message: "Failed to load resource.",
+            code: 4
+          });
+        }
+      });
+      return () => abort.abort();
+    }
+    tick();
+  }
+  #findNewSource(currentSource, sources) {
+    let newSource = { src: "", type: "" }, newLoader = null, triggerEvent = new DOMEvent("sources-change", { detail: { sources } }), loaders = this.#loaders(), { started, paused, currentTime, quality, savedState } = this.#media.$state;
+    for (const src of sources) {
+      const loader = loaders.find((loader2) => loader2.canPlay(src));
+      if (loader) {
+        newSource = src;
+        newLoader = loader;
+        break;
+      }
+    }
+    if (isVideoQualitySrc(newSource)) {
+      const currentQuality = quality(), sourceQuality = sources.find((s) => s.src === currentQuality?.src);
+      if (peek(started)) {
+        savedState.set({
+          paused: peek(paused),
+          currentTime: peek(currentTime)
+        });
+      } else {
+        savedState.set(null);
+      }
+      if (sourceQuality) {
+        newSource = sourceQuality;
+        triggerEvent = new DOMEvent("quality-change", {
+          detail: { quality: currentQuality }
+        });
+      }
+    }
+    if (!isSameSrc(currentSource, newSource)) {
+      this.#notifySourceChange(newSource, newLoader, triggerEvent);
+    }
+    if (newLoader !== peek(this.#loader)) {
+      this.#notifyLoaderChange(newLoader, triggerEvent);
+    }
+    return newSource;
+  }
+  #notifySourceChange(src, loader, trigger) {
+    this.#media.notify("source-change", src, trigger);
+    this.#media.notify("media-type-change", loader?.mediaType(src) || "unknown", trigger);
+  }
+  #notifyLoaderChange(loader, trigger) {
+    this.#media.$providerSetup.set(false);
+    this.#media.notify("provider-change", null, trigger);
+    loader && peek(() => loader.preconnect?.(this.#media));
+    this.#loader.set(loader);
+    this.#media.notify("provider-loader-change", loader, trigger);
+  }
+  #onSetup() {
+    const provider = this.#media.$provider();
+    if (!provider || peek(this.#media.$providerSetup)) return;
+    if (this.#media.$state.canLoad()) {
+      scoped(() => provider.setup(), provider.scope);
+      this.#media.$providerSetup.set(true);
+      return;
+    }
+    peek(() => provider.preconnect?.());
+  }
+  #onLoadSource() {
+    if (!this.#media.$providerSetup()) return;
+    const provider = this.#media.$provider(), source = this.#media.$state.source(), crossOrigin = peek(this.#media.$state.crossOrigin), preferNativeHLS = peek(this.#media.$props.preferNativeHLS);
+    if (isSameSrc(provider?.currentSrc, source)) {
+      return;
+    }
+    if (this.#media.$state.canLoad()) {
+      const abort = new AbortController();
+      if (isHLSSrc(source)) {
+        if (preferNativeHLS || !isHLSSupported()) {
+          resolveStreamTypeFromHLSManifest(source.src, {
+            credentials: getRequestCredentials(crossOrigin),
+            signal: abort.signal
+          }).then((streamType) => {
+            this.#media.notify("stream-type-change", streamType);
+          }).catch(noop);
+        }
+      } else if (isDASHSrc(source)) {
+        resolveStreamTypeFromDASHManifest(source.src, {
+          credentials: getRequestCredentials(crossOrigin),
+          signal: abort.signal
+        }).then((streamType) => {
+          this.#media.notify("stream-type-change", streamType);
+        }).catch(noop);
+      } else {
+        this.#media.notify("stream-type-change", "on-demand");
+      }
+      peek(() => {
+        const preload = peek(this.#media.$state.preload);
+        return provider?.loadSource(source, preload).catch((error) => {
+          {
+            this.#media.logger?.errorGroup("[vidstack] failed to load source").labelledLog("Error", error).labelledLog("Source", source).labelledLog("Provider", provider).labelledLog("Media Context", { ...this.#media }).dispatch();
+          }
+        });
+      });
+      return () => abort.abort();
+    }
+    try {
+      isString(source.src) && preconnect(new URL(source.src).origin);
+    } catch (error) {
+      {
+        this.#media.logger?.infoGroup(`Failed to preconnect to source: ${source.src}`).labelledLog("Error", error).dispatch();
+      }
+    }
+  }
+  #onLoadPoster() {
+    const loader = this.#loader(), { providedPoster, source, canLoadPoster } = this.#media.$state;
+    if (!loader || !loader.loadPoster || !source() || !canLoadPoster() || providedPoster()) return;
+    const abort = new AbortController(), trigger = new DOMEvent("source-change", { detail: source });
+    loader.loadPoster(source(), this.#media, abort).then((url) => {
+      this.#media.notify("poster-change", url || "", trigger);
+    }).catch(() => {
+      this.#media.notify("poster-change", "", trigger);
+    });
+    return () => {
+      abort.abort();
+    };
+  }
+}
+function normalizeSrc(src) {
+  return (isArray(src) ? src : [src]).map((src2) => {
+    if (isString(src2)) {
+      return { src: src2, type: inferType(src2) };
+    } else {
+      return { ...src2, type: inferType(src2.src, src2.type) };
+    }
+  });
+}
+function inferType(src, type) {
+  if (isString(type) && type.length) {
+    return type;
+  } else if (isString(src) && sourceTypes.has(src)) {
+    return sourceTypes.get(src);
+  } else if (!type && isHLSSrc({ src, type: "" })) {
+    return "application/x-mpegurl";
+  } else if (!type && isDASHSrc({ src, type: "" })) {
+    return "application/dash+xml";
+  } else if (!isString(src) || src.startsWith("blob:")) {
+    return "video/object";
+  } else if (src.includes("youtube") || src.includes("youtu.be")) {
+    return "video/youtube";
+  } else if (src.includes("vimeo") && !src.includes("progressive_redirect") && !src.includes(".m3u8")) {
+    return "video/vimeo";
+  }
+  return "?";
+}
+function isSameSrc(a, b) {
+  return a?.src === b?.src && a?.type === b?.type;
+}
+
+class Tracks {
+  #domTracks;
+  #media;
+  #prevTracks = [];
+  constructor(domTracks, media) {
+    this.#domTracks = domTracks;
+    this.#media = media;
+    effect(this.#onTracksChange.bind(this));
+  }
+  #onTracksChange() {
+    const newTracks = this.#domTracks();
+    for (const oldTrack of this.#prevTracks) {
+      if (!newTracks.some((t) => t.id === oldTrack.id)) {
+        const track = oldTrack.id && this.#media.textTracks.getById(oldTrack.id);
+        if (track) this.#media.textTracks.remove(track);
+      }
+    }
+    for (const newTrack of newTracks) {
+      const id = newTrack.id || TextTrack.createId(newTrack);
+      if (!this.#media.textTracks.getById(id)) {
+        newTrack.id = id;
+        this.#media.textTracks.add(newTrack);
+      }
+    }
+    this.#prevTracks = newTracks;
+  }
+}
+
+class MediaProvider extends Component {
+  static props = {
+    loaders: []
+  };
+  static state = new State({
+    loader: null
+  });
+  #media;
+  #sources;
+  #domSources = signal([]);
+  #domTracks = signal([]);
+  #loader = null;
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#sources = new SourceSelection(
+      this.#domSources,
+      this.#media,
+      this.$state.loader,
+      this.$props.loaders()
+    );
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-provider", "");
+  }
+  onConnect(el) {
+    this.#sources.connect();
+    new Tracks(this.#domTracks, this.#media);
+    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
+    resize.observe(el);
+    const mutations = new MutationObserver(this.#onMutation.bind(this));
+    mutations.observe(el, { attributes: true, childList: true });
+    this.#onResize();
+    this.#onMutation();
+    onDispose(() => {
+      resize.disconnect();
+      mutations.disconnect();
+    });
+  }
+  #loadRafId = -1;
+  load(target) {
+    target?.setAttribute("aria-hidden", "true");
+    window.cancelAnimationFrame(this.#loadRafId);
+    this.#loadRafId = requestAnimationFrame(() => this.#runLoader(target));
+    onDispose(() => {
+      window.cancelAnimationFrame(this.#loadRafId);
+    });
+  }
+  #runLoader(target) {
+    if (!this.scope) return;
+    const loader = this.$state.loader(), { $provider } = this.#media;
+    if (this.#loader === loader && loader?.target === target && peek($provider)) return;
+    this.#destroyProvider();
+    this.#loader = loader;
+    if (loader) loader.target = target || null;
+    if (!loader || !target) return;
+    loader.load(this.#media).then((provider) => {
+      if (!this.scope) return;
+      if (peek(this.$state.loader) !== loader) return;
+      this.#media.notify("provider-change", provider);
+    });
+  }
+  onDestroy() {
+    this.#loader = null;
+    this.#destroyProvider();
+  }
+  #destroyProvider() {
+    this.#media?.notify("provider-change", null);
+  }
+  #onResize() {
+    if (!this.el) return;
+    const { player, $state } = this.#media, width = this.el.offsetWidth, height = this.el.offsetHeight;
+    if (!player) return;
+    $state.mediaWidth.set(width);
+    $state.mediaHeight.set(height);
+    if (player.el) {
+      setStyle(player.el, "--media-width", width + "px");
+      setStyle(player.el, "--media-height", height + "px");
+    }
+  }
+  #onMutation() {
+    const sources = [], tracks = [], children = this.el.children;
+    for (const el of children) {
+      if (el.hasAttribute("data-vds")) continue;
+      if (el instanceof HTMLSourceElement) {
+        const src = {
+          id: el.id,
+          src: el.src,
+          type: el.type
+        };
+        for (const prop of ["id", "src", "width", "height", "bitrate", "codec"]) {
+          const value = el.getAttribute(`data-${prop}`);
+          if (isString(value)) src[prop] = /id|src|codec/.test(prop) ? value : Number(value);
+        }
+        sources.push(src);
+      } else if (el instanceof HTMLTrackElement) {
+        const track = {
+          src: el.src,
+          kind: el.track.kind,
+          language: el.srclang,
+          label: el.label,
+          default: el.default,
+          type: el.getAttribute("data-type")
+        };
+        tracks.push({
+          id: el.id || TextTrack.createId(track),
+          ...track
+        });
+      }
+    }
+    this.#domSources.set(sources);
+    this.#domTracks.set(tracks);
+    tick();
+  }
+}
+const mediaprovider__proto = MediaProvider.prototype;
+method(mediaprovider__proto, "load");
+
+class MediaAnnouncer extends Component {
+  static props = {
+    translations: null
+  };
+  static state = new State({
+    label: null,
+    busy: false
+  });
+  #media;
+  #initializing = false;
+  onSetup() {
+    this.#media = useMediaContext();
+  }
+  onAttach(el) {
+    el.style.display = "contents";
+  }
+  onConnect(el) {
+    el.setAttribute("data-media-announcer", "");
+    setAttributeIfEmpty(el, "role", "status");
+    setAttributeIfEmpty(el, "aria-live", "polite");
+    const { busy } = this.$state;
+    this.setAttributes({
+      "aria-busy": () => busy() ? "true" : null
+    });
+    this.#initializing = true;
+    effect(this.#watchPaused.bind(this));
+    effect(this.#watchVolume.bind(this));
+    effect(this.#watchCaptions.bind(this));
+    effect(this.#watchFullscreen.bind(this));
+    effect(this.#watchPiP.bind(this));
+    effect(this.#watchSeeking.bind(this));
+    effect(this.#watchLabel.bind(this));
+    tick();
+    this.#initializing = false;
+  }
+  #watchPaused() {
+    const { paused } = this.#media.$state;
+    this.#setLabel(!paused() ? "Play" : "Pause");
+  }
+  #watchFullscreen() {
+    const { fullscreen } = this.#media.$state;
+    this.#setLabel(fullscreen() ? "Enter Fullscreen" : "Exit Fullscreen");
+  }
+  #watchPiP() {
+    const { pictureInPicture } = this.#media.$state;
+    this.#setLabel(pictureInPicture() ? "Enter PiP" : "Exit PiP");
+  }
+  #watchCaptions() {
+    const { textTrack } = this.#media.$state;
+    this.#setLabel(textTrack() ? "Closed-Captions On" : "Closed-Captions Off");
+  }
+  #watchVolume() {
+    const { muted, volume, audioGain } = this.#media.$state;
+    this.#setLabel(
+      muted() || volume() === 0 ? "Mute" : `${Math.round(volume() * (audioGain() ?? 1) * 100)}% ${this.#translate("Volume")}`
+    );
+  }
+  #startedSeekingAt = -1;
+  #seekTimer = -1;
+  #watchSeeking() {
+    const { seeking, currentTime } = this.#media.$state, isSeeking = seeking();
+    if (this.#startedSeekingAt > 0) {
+      window.clearTimeout(this.#seekTimer);
+      this.#seekTimer = window.setTimeout(() => {
+        if (!this.scope) return;
+        const newTime = peek(currentTime), seconds = Math.abs(newTime - this.#startedSeekingAt);
+        if (seconds >= 1) {
+          const isForward = newTime >= this.#startedSeekingAt, spokenTime = formatSpokenTime(seconds);
+          this.#setLabel(
+            `${this.#translate(isForward ? "Seek Forward" : "Seek Backward")} ${spokenTime}`
+          );
+        }
+        this.#startedSeekingAt = -1;
+        this.#seekTimer = -1;
+      }, 300);
+    } else if (isSeeking) {
+      this.#startedSeekingAt = peek(currentTime);
+    }
+  }
+  #translate(word) {
+    const { translations } = this.$props;
+    return translations?.()?.[word || ""] ?? word;
+  }
+  #watchLabel() {
+    const { label, busy } = this.$state, $label = this.#translate(label());
+    if (this.#initializing) return;
+    busy.set(true);
+    const id = window.setTimeout(() => void busy.set(false), 150);
+    this.el && setAttribute(this.el, "aria-label", $label);
+    if (isString($label)) {
+      this.dispatch("change", { detail: $label });
+    }
+    return () => window.clearTimeout(id);
+  }
+  #setLabel(word) {
+    const { label } = this.$state;
+    label.set(word);
+  }
+}
+
+class Controls extends Component {
+  static props = {
+    hideDelay: 2e3,
+    hideOnMouseLeave: false
+  };
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    effect(this.#watchProps.bind(this));
+  }
+  onAttach(el) {
+    const { pictureInPicture, fullscreen } = this.#media.$state;
+    setStyle(el, "pointer-events", "none");
+    setAttributeIfEmpty(el, "role", "group");
+    this.setAttributes({
+      "data-visible": this.#isShowing.bind(this),
+      "data-fullscreen": fullscreen,
+      "data-pip": pictureInPicture
+    });
+    effect(() => {
+      this.dispatch("change", { detail: this.#isShowing() });
+    });
+    effect(this.#hideControls.bind(this));
+    effect(() => {
+      const isFullscreen = fullscreen();
+      for (const side of ["top", "right", "bottom", "left"]) {
+        setStyle(el, `padding-${side}`, isFullscreen && `env(safe-area-inset-${side})`);
+      }
+    });
+  }
+  #hideControls() {
+    if (!this.el) return;
+    const { nativeControls } = this.#media.$state, isHidden = nativeControls();
+    setAttribute(this.el, "aria-hidden", isHidden ? "true" : null);
+    setStyle(this.el, "display", isHidden ? "none" : null);
+  }
+  #watchProps() {
+    const { controls } = this.#media.player, { hideDelay, hideOnMouseLeave } = this.$props;
+    controls.defaultDelay = hideDelay() === 2e3 ? this.#media.$props.controlsDelay() : hideDelay();
+    controls.hideOnMouseLeave = hideOnMouseLeave();
+  }
+  #isShowing() {
+    const { controlsVisible } = this.#media.$state;
+    return controlsVisible();
+  }
+}
+
+class ControlsGroup extends Component {
+  onAttach(el) {
+    if (!el.style.pointerEvents) setStyle(el, "pointer-events", "auto");
+  }
+}
+
+class Popper extends ViewController {
+  #delegate;
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+    effect(this.#watchTrigger.bind(this));
+  }
+  onDestroy() {
+    this.#stopAnimationEndListener?.();
+    this.#stopAnimationEndListener = null;
+  }
+  #watchTrigger() {
+    const trigger = this.#delegate.trigger();
+    if (!trigger) {
+      this.hide();
+      return;
+    }
+    const show = this.show.bind(this), hide = this.hide.bind(this);
+    this.#delegate.listen(trigger, show, hide);
+  }
+  #showTimerId = -1;
+  #hideRafId = -1;
+  #stopAnimationEndListener = null;
+  show(trigger) {
+    this.#cancelShowing();
+    window.cancelAnimationFrame(this.#hideRafId);
+    this.#hideRafId = -1;
+    this.#stopAnimationEndListener?.();
+    this.#stopAnimationEndListener = null;
+    this.#showTimerId = window.setTimeout(() => {
+      this.#showTimerId = -1;
+      const content = this.#delegate.content();
+      if (content) content.style.removeProperty("display");
+      peek(() => this.#delegate.onChange(true, trigger));
+    }, this.#delegate.showDelay?.() ?? 0);
+  }
+  hide(trigger) {
+    this.#cancelShowing();
+    peek(() => this.#delegate.onChange(false, trigger));
+    this.#hideRafId = requestAnimationFrame(() => {
+      this.#cancelShowing();
+      this.#hideRafId = -1;
+      const content = this.#delegate.content();
+      if (content) {
+        const onHide = () => {
+          content.style.display = "none";
+          this.#stopAnimationEndListener = null;
+        };
+        const isAnimated = hasAnimation(content);
+        if (isAnimated) {
+          this.#stopAnimationEndListener?.();
+          const stop = listenEvent(content, "animationend", onHide, { once: true });
+          this.#stopAnimationEndListener = stop;
+        } else {
+          onHide();
+        }
+      }
+    });
+  }
+  #cancelShowing() {
+    window.clearTimeout(this.#showTimerId);
+    this.#showTimerId = -1;
+  }
+}
+
+const tooltipContext = createContext();
+
+let id = 0;
+class Tooltip extends Component {
+  static props = {
+    showDelay: 700
+  };
+  #id = `media-tooltip-${++id}`;
+  #trigger = signal(null);
+  #content = signal(null);
+  #showing = signal(false);
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { showDelay } = this.$props;
+    new Popper({
+      trigger: this.#trigger,
+      content: this.#content,
+      showDelay,
+      listen(trigger, show, hide) {
+        effect(() => {
+          if ($keyboard()) listenEvent(trigger, "focus", show);
+          listenEvent(trigger, "blur", hide);
+        });
+        new EventsController(trigger).add("touchstart", (e) => e.preventDefault(), { passive: false }).add("mouseenter", show).add("mouseleave", hide);
+      },
+      onChange: this.#onShowingChange.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  onSetup() {
+    provideContext(tooltipContext, {
+      trigger: this.#trigger,
+      content: this.#content,
+      showing: this.#showing,
+      attachTrigger: this.#attachTrigger.bind(this),
+      detachTrigger: this.#detachTrigger.bind(this),
+      attachContent: this.#attachContent.bind(this),
+      detachContent: this.#detachContent.bind(this)
+    });
+  }
+  #attachTrigger(el) {
+    this.#trigger.set(el);
+    let tooltipName = el.getAttribute("data-media-tooltip");
+    if (tooltipName) {
+      this.el?.setAttribute(`data-media-${tooltipName}-tooltip`, "");
+    }
+    setAttribute(el, "data-describedby", this.#id);
+  }
+  #detachTrigger(el) {
+    el.removeAttribute("data-describedby");
+    el.removeAttribute("aria-describedby");
+    this.#trigger.set(null);
+  }
+  #attachContent(el) {
+    el.setAttribute("id", this.#id);
+    el.style.display = "none";
+    setAttributeIfEmpty(el, "role", "tooltip");
+    this.#content.set(el);
+  }
+  #detachContent(el) {
+    el.removeAttribute("id");
+    el.removeAttribute("role");
+    this.#content.set(null);
+  }
+  #onShowingChange(isShowing) {
+    const trigger = this.#trigger(), content = this.#content();
+    if (trigger) {
+      setAttribute(trigger, "aria-describedby", isShowing ? this.#id : null);
+    }
+    for (const el of [this.el, trigger, content]) {
+      el && setAttribute(el, "data-visible", isShowing);
+    }
+    this.#showing.set(isShowing);
+  }
+}
+
+class TooltipTrigger extends Component {
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onConnect(el) {
+    onDispose(
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        this.#attach();
+        const tooltip = useContext(tooltipContext);
+        onDispose(() => {
+          const button = this.#getButton();
+          button && tooltip.detachTrigger(button);
+        });
+      })
+    );
+  }
+  #attach() {
+    const button = this.#getButton(), tooltip = useContext(tooltipContext);
+    button && tooltip.attachTrigger(button);
+  }
+  #getButton() {
+    const candidate = this.el.firstElementChild;
+    return candidate?.localName === "button" || candidate?.getAttribute("role") === "button" ? candidate : this.el;
+  }
+}
+
+class TooltipContent extends Component {
+  static props = {
+    placement: "top center",
+    offset: 0,
+    alignOffset: 0
+  };
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { placement } = this.$props;
+    this.setAttributes({
+      "data-placement": placement
+    });
+  }
+  onAttach(el) {
+    this.#attach(el);
+    Object.assign(el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+  }
+  onConnect(el) {
+    this.#attach(el);
+    const tooltip = useContext(tooltipContext);
+    onDispose(() => tooltip.detachContent(el));
+    onDispose(
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        effect(this.#watchPlacement.bind(this));
+      })
+    );
+  }
+  #attach(el) {
+    const tooltip = useContext(tooltipContext);
+    tooltip.attachContent(el);
+  }
+  #watchPlacement() {
+    const { showing } = useContext(tooltipContext);
+    if (!showing()) return;
+    const { placement, offset: mainOffset, alignOffset } = this.$props;
+    return autoPlacement(this.el, this.#getTrigger(), placement(), {
+      offsetVarName: "media-tooltip",
+      xOffset: alignOffset(),
+      yOffset: mainOffset()
+    });
+  }
+  #getTrigger() {
+    return useContext(tooltipContext).trigger();
+  }
+}
+
+class ToggleButtonController extends ViewController {
+  static props = {
+    disabled: false
+  };
+  #delegate;
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+    new FocusVisibleController();
+    if (delegate.keyShortcut) {
+      new ARIAKeyShortcuts(delegate.keyShortcut);
+    }
+  }
+  onSetup() {
+    const { disabled } = this.$props;
+    this.setAttributes({
+      "data-pressed": this.#delegate.isPresssed,
+      "aria-pressed": this.#isARIAPressed.bind(this),
+      "aria-disabled": () => disabled() ? "true" : null
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+  }
+  onConnect(el) {
+    const events = onPress(el, this.#onMaybePress.bind(this));
+    for (const type of ["click", "touchstart"]) {
+      events.add(type, this.#onInteraction.bind(this), {
+        passive: true
+      });
+    }
+  }
+  #isARIAPressed() {
+    return ariaBool$1(this.#delegate.isPresssed());
+  }
+  #onPressed(event) {
+    if (isWriteSignal(this.#delegate.isPresssed)) {
+      this.#delegate.isPresssed.set((p) => !p);
+    }
+  }
+  #onMaybePress(event) {
+    const disabled = this.$props.disabled() || this.el.hasAttribute("data-disabled");
+    if (disabled) {
+      event.preventDefault();
+      event.stopImmediatePropagation();
+      return;
+    }
+    event.preventDefault();
+    (this.#delegate.onPress ?? this.#onPressed).call(this, event);
+  }
+  #onInteraction(event) {
+    if (this.$props.disabled()) {
+      event.preventDefault();
+      event.stopImmediatePropagation();
+    }
+  }
+}
+
+class ToggleButton extends Component {
+  static props = {
+    disabled: false,
+    defaultPressed: false
+  };
+  #pressed = signal(false);
+  /**
+   * Whether the toggle is currently in a `pressed` state.
+   */
+  get pressed() {
+    return this.#pressed();
+  }
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#pressed
+    });
+  }
+}
+const togglebutton__proto = ToggleButton.prototype;
+prop(togglebutton__proto, "pressed");
+
+function ariaBool(value) {
+  return value ? "true" : "false";
+}
+function $ariaBool(signal) {
+  return () => ariaBool(signal());
+}
+
+class AirPlayButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { canAirPlay, isAirPlayConnected } = this.#media.$state;
+    this.setAttributes({
+      "data-active": isAirPlayConnected,
+      "data-supported": canAirPlay,
+      "data-state": this.#getState.bind(this),
+      "aria-hidden": $ariaBool(() => !canAirPlay())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "airplay");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    remote.requestAirPlay(event);
+  }
+  #isPressed() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "airplay" && remotePlaybackState() !== "disconnected";
+  }
+  #getState() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "airplay" && remotePlaybackState();
+  }
+  #getDefaultLabel() {
+    const { remotePlaybackState } = this.#media.$state;
+    return `AirPlay ${remotePlaybackState()}`;
+  }
+}
+
+class GoogleCastButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { canGoogleCast, isGoogleCastConnected } = this.#media.$state;
+    this.setAttributes({
+      "data-active": isGoogleCastConnected,
+      "data-supported": canGoogleCast,
+      "data-state": this.#getState.bind(this),
+      "aria-hidden": $ariaBool(() => !canGoogleCast())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "google-cast");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    remote.requestGoogleCast(event);
+  }
+  #isPressed() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "google-cast" && remotePlaybackState() !== "disconnected";
+  }
+  #getState() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "google-cast" && remotePlaybackState();
+  }
+  #getDefaultLabel() {
+    const { remotePlaybackState } = this.#media.$state;
+    return `Google Cast ${remotePlaybackState()}`;
+  }
+}
+
+class PlayButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "togglePaused",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { paused, ended } = this.#media.$state;
+    this.setAttributes({
+      "data-paused": paused,
+      "data-ended": ended
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "play");
+    setARIALabel(el, "Play");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.pause(event) : remote.play(event);
+  }
+  #isPressed() {
+    const { paused } = this.#media.$state;
+    return !paused();
+  }
+}
+
+class CaptionButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleCaptions",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "data-active": this.#isPressed.bind(this),
+      "data-supported": () => !this.#isHidden(),
+      "aria-hidden": $ariaBool(this.#isHidden.bind(this))
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "caption");
+    setARIALabel(el, "Captions");
+  }
+  #onPress(event) {
+    this.#media.remote.toggleCaptions(event);
+  }
+  #isPressed() {
+    const { textTrack } = this.#media.$state, track = textTrack();
+    return !!track && isTrackCaptionKind(track);
+  }
+  #isHidden() {
+    const { hasCaptions } = this.#media.$state;
+    return !hasCaptions();
+  }
+}
+
+class FullscreenButton extends Component {
+  static props = {
+    ...ToggleButtonController.props,
+    target: "prefer-media"
+  };
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleFullscreen",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { fullscreen } = this.#media.$state, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      "data-active": fullscreen,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "fullscreen");
+    setARIALabel(el, "Fullscreen");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote, target = this.$props.target();
+    this.#isPressed() ? remote.exitFullscreen(target, event) : remote.enterFullscreen(target, event);
+  }
+  #isPressed() {
+    const { fullscreen } = this.#media.$state;
+    return fullscreen();
+  }
+  #isSupported() {
+    const { canFullscreen } = this.#media.$state;
+    return canFullscreen();
+  }
+}
+
+class MuteButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleMuted",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "data-muted": this.#isPressed.bind(this),
+      "data-state": this.#getState.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-mute-button", "");
+    el.setAttribute("data-media-tooltip", "mute");
+    setARIALabel(el, "Mute");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.unmute(event) : remote.mute(event);
+  }
+  #isPressed() {
+    const { muted, volume } = this.#media.$state;
+    return muted() || volume() === 0;
+  }
+  #getState() {
+    const { muted, volume } = this.#media.$state, $volume = volume();
+    if (muted() || $volume === 0) return "muted";
+    else if ($volume >= 0.5) return "high";
+    else if ($volume < 0.5) return "low";
+  }
+}
+
+class PIPButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "togglePictureInPicture",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { pictureInPicture } = this.#media.$state, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      "data-active": pictureInPicture,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "pip");
+    setARIALabel(el, "PiP");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.exitPictureInPicture(event) : remote.enterPictureInPicture(event);
+  }
+  #isPressed() {
+    const { pictureInPicture } = this.#media.$state;
+    return pictureInPicture();
+  }
+  #isSupported() {
+    const { canPictureInPicture } = this.#media.$state;
+    return canPictureInPicture();
+  }
+}
+
+class SeekButton extends Component {
+  static props = {
+    disabled: false,
+    seconds: 30
+  };
+  #media;
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { seeking } = this.#media.$state, { seconds } = this.$props, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      seconds,
+      "data-seeking": seeking,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+    el.setAttribute("data-media-tooltip", "seek");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  onConnect(el) {
+    onPress(el, this.#onPress.bind(this));
+  }
+  #isSupported() {
+    const { canSeek } = this.#media.$state;
+    return canSeek();
+  }
+  #getDefaultLabel() {
+    const { seconds } = this.$props;
+    return `Seek ${seconds() > 0 ? "forward" : "backward"} ${seconds()} seconds`;
+  }
+  #onPress(event) {
+    const { seconds, disabled } = this.$props;
+    if (disabled()) return;
+    const { currentTime } = this.#media.$state, seekTo = currentTime() + seconds();
+    this.#media.remote.seek(seekTo, event);
+  }
+}
+
+class LiveButton extends Component {
+  static props = {
+    disabled: false
+  };
+  #media;
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { disabled } = this.$props, { live, liveEdge } = this.#media.$state, isHidden = () => !live();
+    this.setAttributes({
+      "data-edge": liveEdge,
+      "data-hidden": isHidden,
+      "aria-disabled": $ariaBool(() => disabled() || liveEdge()),
+      "aria-hidden": $ariaBool(isHidden)
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+    el.setAttribute("data-media-tooltip", "live");
+  }
+  onConnect(el) {
+    onPress(el, this.#onPress.bind(this));
+  }
+  #onPress(event) {
+    const { disabled } = this.$props, { liveEdge } = this.#media.$state;
+    if (disabled() || liveEdge()) return;
+    this.#media.remote.seekToLiveEdge(event);
+  }
+}
+
+const sliderState = new State({
+  min: 0,
+  max: 100,
+  value: 0,
+  step: 1,
+  pointerValue: 0,
+  focused: false,
+  dragging: false,
+  pointing: false,
+  hidden: false,
+  get active() {
+    return this.dragging || this.focused || this.pointing;
+  },
+  get fillRate() {
+    return calcRate(this.min, this.max, this.value);
+  },
+  get fillPercent() {
+    return this.fillRate * 100;
+  },
+  get pointerRate() {
+    return calcRate(this.min, this.max, this.pointerValue);
+  },
+  get pointerPercent() {
+    return this.pointerRate * 100;
+  }
+});
+function calcRate(min, max, value) {
+  const range = max - min, offset = value - min;
+  return range > 0 ? offset / range : 0;
+}
+
+class IntersectionObserverController extends ViewController {
+  #init;
+  #observer;
+  constructor(init) {
+    super();
+    this.#init = init;
+  }
+  onConnect(el) {
+    this.#observer = new IntersectionObserver((entries) => {
+      this.#init.callback?.(entries, this.#observer);
+    }, this.#init);
+    this.#observer.observe(el);
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  /**
+   * Disconnect any active intersection observers.
+   */
+  #onDisconnect() {
+    this.#observer?.disconnect();
+    this.#observer = void 0;
+  }
+}
+
+const sliderContext = createContext();
+const sliderObserverContext = createContext();
+
+function getClampedValue(min, max, value, step) {
+  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
+}
+function getValueFromRate(min, max, rate, step) {
+  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * Math.round(stepRatio);
+  return min + steps;
+}
+
+const SliderKeyDirection = {
+  Left: -1,
+  ArrowLeft: -1,
+  Up: 1,
+  ArrowUp: 1,
+  Right: 1,
+  ArrowRight: 1,
+  Down: -1,
+  ArrowDown: -1
+};
+class SliderEventsController extends ViewController {
+  #delegate;
+  #media;
+  #observer;
+  constructor(delegate, media) {
+    super();
+    this.#delegate = delegate;
+    this.#media = media;
+  }
+  onSetup() {
+    if (hasProvidedContext(sliderObserverContext)) {
+      this.#observer = useContext(sliderObserverContext);
+    }
+  }
+  onConnect(el) {
+    effect(this.#attachEventListeners.bind(this, el));
+    effect(this.#attachPointerListeners.bind(this, el));
+    if (this.#delegate.swipeGesture) effect(this.#watchSwipeGesture.bind(this));
+  }
+  #watchSwipeGesture() {
+    const { pointer } = this.#media.$state;
+    if (pointer() !== "coarse" || !this.#delegate.swipeGesture()) {
+      this.#provider = null;
+      return;
+    }
+    this.#provider = this.#media.player.el?.querySelector(
+      "media-provider,[data-media-provider]"
+    );
+    if (!this.#provider) return;
+    new EventsController(this.#provider).add("touchstart", this.#onTouchStart.bind(this), {
+      passive: true
+    }).add("touchmove", this.#onTouchMove.bind(this), { passive: false });
+  }
+  #provider = null;
+  #touch = null;
+  #touchStartValue = null;
+  #onTouchStart(event) {
+    this.#touch = event.touches[0];
+  }
+  #onTouchMove(event) {
+    if (isNull(this.#touch) || isTouchPinchEvent(event)) return;
+    const touch = event.touches[0], xDiff = touch.clientX - this.#touch.clientX, yDiff = touch.clientY - this.#touch.clientY, isDragging = this.$state.dragging();
+    if (!isDragging && Math.abs(yDiff) > 5) {
+      return;
+    }
+    if (isDragging) return;
+    event.preventDefault();
+    if (Math.abs(xDiff) > 20) {
+      this.#touch = touch;
+      this.#touchStartValue = this.$state.value();
+      this.#onStartDragging(this.#touchStartValue, event);
+    }
+  }
+  #attachEventListeners(el) {
+    const { hidden } = this.$props;
+    listenEvent(el, "focus", this.#onFocus.bind(this));
+    if (hidden() || this.#delegate.isDisabled()) return;
+    new EventsController(el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("pointerenter", this.#onPointerEnter.bind(this)).add("pointermove", this.#onPointerMove.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this)).add("pointerdown", this.#onPointerDown.bind(this));
+  }
+  #attachPointerListeners(el) {
+    if (this.#delegate.isDisabled() || !this.$state.dragging()) return;
+    new EventsController(document).add("pointerup", this.#onDocumentPointerUp.bind(this), { capture: true }).add("pointermove", this.#onDocumentPointerMove.bind(this)).add("touchmove", this.#onDocumentTouchMove.bind(this), {
+      passive: false
+    });
+  }
+  #onFocus() {
+    this.#updatePointerValue(this.$state.value());
+  }
+  #updateValue(newValue, trigger) {
+    const { value, min, max, dragging } = this.$state;
+    const clampedValue = Math.max(min(), Math.min(newValue, max()));
+    value.set(clampedValue);
+    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
+    this.dispatch(event);
+    this.#delegate.onValueChange?.(event);
+    if (dragging()) {
+      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
+      this.dispatch(event2);
+      this.#delegate.onDragValueChange?.(event2);
+    }
+  }
+  #updatePointerValue(value, trigger) {
+    const { pointerValue, dragging } = this.$state;
+    pointerValue.set(value);
+    this.dispatch("pointer-value-change", { detail: value, trigger });
+    if (dragging()) {
+      this.#updateValue(value, trigger);
+    }
+  }
+  #getPointerValue(event) {
+    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$state;
+    if (this.$props.orientation() === "vertical") {
+      const { bottom: trackBottom, height: trackHeight } = rect;
+      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
+    } else {
+      if (this.#touch && isNumber(this.#touchStartValue)) {
+        const { width } = this.#provider.getBoundingClientRect(), rate = (event.clientX - this.#touch.clientX) / width, range = max() - min(), diff = range * Math.abs(rate);
+        thumbPositionRate = (rate < 0 ? this.#touchStartValue - diff : this.#touchStartValue + diff) / range;
+      } else {
+        const { left: trackLeft, width: trackWidth } = rect;
+        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
+      }
+    }
+    return Math.max(
+      min(),
+      Math.min(
+        max(),
+        this.#delegate.roundValue(
+          getValueFromRate(min(), max(), thumbPositionRate, this.#delegate.getStep())
+        )
+      )
+    );
+  }
+  #onPointerEnter(event) {
+    this.$state.pointing.set(true);
+  }
+  #onPointerMove(event) {
+    const { dragging } = this.$state;
+    if (dragging()) return;
+    this.#updatePointerValue(this.#getPointerValue(event), event);
+  }
+  #onPointerLeave(event) {
+    this.$state.pointing.set(false);
+  }
+  #onPointerDown(event) {
+    if (event.button !== 0) return;
+    const value = this.#getPointerValue(event);
+    this.#onStartDragging(value, event);
+    this.#updatePointerValue(value, event);
+  }
+  #onStartDragging(value, trigger) {
+    const { dragging } = this.$state;
+    if (dragging()) return;
+    dragging.set(true);
+    this.#media.remote.pauseControls(trigger);
+    const event = this.createEvent("drag-start", { detail: value, trigger });
+    this.dispatch(event);
+    this.#delegate.onDragStart?.(event);
+    this.#observer?.onDragStart?.();
+  }
+  #onStopDragging(value, trigger) {
+    const { dragging } = this.$state;
+    if (!dragging()) return;
+    dragging.set(false);
+    this.#media.remote.resumeControls(trigger);
+    const event = this.createEvent("drag-end", { detail: value, trigger });
+    this.dispatch(event);
+    this.#delegate.onDragEnd?.(event);
+    this.#touch = null;
+    this.#touchStartValue = null;
+    this.#observer?.onDragEnd?.();
+  }
+  // -------------------------------------------------------------------------------------------
+  // Keyboard Events
+  // -------------------------------------------------------------------------------------------
+  #lastDownKey;
+  #repeatedKeys = false;
+  #onKeyDown(event) {
+    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);
+    if (!isValidKey) return;
+    const { key } = event, jumpValue = this.#calcJumpValue(event);
+    if (!isNull(jumpValue)) {
+      this.#updatePointerValue(jumpValue, event);
+      this.#updateValue(jumpValue, event);
+      return;
+    }
+    const newValue = this.#calcNewKeyValue(event);
+    if (!this.#repeatedKeys) {
+      this.#repeatedKeys = key === this.#lastDownKey;
+      if (!this.$state.dragging() && this.#repeatedKeys) {
+        this.#onStartDragging(newValue, event);
+      }
+    }
+    this.#updatePointerValue(newValue, event);
+    this.#lastDownKey = key;
+  }
+  #onKeyUp(event) {
+    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);
+    if (!isValidKey || !isNull(this.#calcJumpValue(event))) return;
+    const newValue = this.#repeatedKeys ? this.$state.pointerValue() : this.#calcNewKeyValue(event);
+    this.#updateValue(newValue, event);
+    this.#onStopDragging(newValue, event);
+    this.#lastDownKey = "";
+    this.#repeatedKeys = false;
+  }
+  #calcJumpValue(event) {
+    let key = event.key, { min, max } = this.$state;
+    if (key === "Home" || key === "PageUp") {
+      return min();
+    } else if (key === "End" || key === "PageDown") {
+      return max();
+    } else if (!event.metaKey && /^[0-9]$/.test(key)) {
+      return (max() - min()) / 10 * Number(key);
+    }
+    return null;
+  }
+  #calcNewKeyValue(event) {
+    const { key, shiftKey } = event;
+    event.preventDefault();
+    event.stopPropagation();
+    const { shiftKeyMultiplier } = this.$props;
+    const { min, max, value, pointerValue } = this.$state, step = this.#delegate.getStep(), keyStep = this.#delegate.getKeyStep();
+    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, currentValue = this.#repeatedKeys ? pointerValue() : this.#delegate.getValue?.() ?? value(), steps = (currentValue + diff) / step;
+    return Math.max(min(), Math.min(max(), Number((step * steps).toFixed(3))));
+  }
+  // -------------------------------------------------------------------------------------------
+  // Document (Pointer Events)
+  // -------------------------------------------------------------------------------------------
+  #onDocumentPointerUp(event) {
+    if (event.button !== 0) return;
+    event.preventDefault();
+    event.stopImmediatePropagation();
+    const value = this.#getPointerValue(event);
+    this.#updatePointerValue(value, event);
+    this.#onStopDragging(value, event);
+  }
+  #onDocumentTouchMove(event) {
+    event.preventDefault();
+  }
+  #onDocumentPointerMove = functionThrottle(
+    (event) => {
+      this.#updatePointerValue(this.#getPointerValue(event), event);
+    },
+    20,
+    { leading: true }
+  );
+}
+
+const sliderValueFormatContext = createContext(() => ({}));
+
+class SliderController extends ViewController {
+  static props = {
+    hidden: false,
+    disabled: false,
+    step: 1,
+    keyStep: 1,
+    orientation: "horizontal",
+    shiftKeyMultiplier: 5
+  };
+  #media;
+  #delegate;
+  #isVisible = signal(true);
+  #isIntersecting = signal(true);
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const focus = new FocusVisibleController();
+    focus.attach(this);
+    this.$state.focused = focus.focused.bind(focus);
+    if (!hasProvidedContext(sliderValueFormatContext)) {
+      provideContext(sliderValueFormatContext, {
+        default: "value"
+      });
+    }
+    provideContext(sliderContext, {
+      orientation: this.$props.orientation,
+      disabled: this.#delegate.isDisabled,
+      preview: signal(null)
+    });
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchStep.bind(this));
+    effect(this.#watchDisabled.bind(this));
+    this.#setupAttrs();
+    new SliderEventsController(this.#delegate, this.#media).attach(this);
+    new IntersectionObserverController({
+      callback: this.#onIntersectionChange.bind(this)
+    }).attach(this);
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "role", "slider");
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "autocomplete", "off");
+    if (IS_SERVER) this.#watchCSSVars();
+    else effect(this.#watchCSSVars.bind(this));
+  }
+  onConnect(el) {
+    onDispose(observeVisibility(el, this.#isVisible.set));
+    effect(this.#watchHidden.bind(this));
+  }
+  #onIntersectionChange(entries) {
+    this.#isIntersecting.set(entries[0].isIntersecting);
+  }
+  // -------------------------------------------------------------------------------------------
+  // Watch
+  // -------------------------------------------------------------------------------------------
+  #watchHidden() {
+    const { hidden } = this.$props;
+    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting.bind(this));
+  }
+  #watchValue() {
+    const { dragging, value, min, max } = this.$state;
+    if (peek(dragging)) return;
+    value.set(getClampedValue(min(), max(), value(), this.#delegate.getStep()));
+  }
+  #watchStep() {
+    this.$state.step.set(this.#delegate.getStep());
+  }
+  #watchDisabled() {
+    if (!this.#delegate.isDisabled()) return;
+    const { dragging, pointing } = this.$state;
+    dragging.set(false);
+    pointing.set(false);
+  }
+  // -------------------------------------------------------------------------------------------
+  // ARIA
+  // -------------------------------------------------------------------------------------------
+  #getARIADisabled() {
+    return ariaBool$1(this.#delegate.isDisabled());
+  }
+  // -------------------------------------------------------------------------------------------
+  // Attributes
+  // -------------------------------------------------------------------------------------------
+  #setupAttrs() {
+    const { orientation } = this.$props, { dragging, active, pointing } = this.$state;
+    this.setAttributes({
+      "data-dragging": dragging,
+      "data-pointing": pointing,
+      "data-active": active,
+      "aria-disabled": this.#getARIADisabled.bind(this),
+      "aria-valuemin": this.#delegate.aria.valueMin ?? this.$state.min,
+      "aria-valuemax": this.#delegate.aria.valueMax ?? this.$state.max,
+      "aria-valuenow": this.#delegate.aria.valueNow,
+      "aria-valuetext": this.#delegate.aria.valueText,
+      "aria-orientation": orientation
+    });
+  }
+  #watchCSSVars() {
+    const { fillPercent, pointerPercent } = this.$state;
+    this.#updateSliderVars(round(fillPercent(), 3), round(pointerPercent(), 3));
+  }
+  #updateSliderVars = animationFrameThrottle((fillPercent, pointerPercent) => {
+    this.el?.style.setProperty("--slider-fill", fillPercent + "%");
+    this.el?.style.setProperty("--slider-pointer", pointerPercent + "%");
+  });
+}
+
+class Slider extends Component {
+  static props = {
+    ...SliderController.props,
+    min: 0,
+    max: 100,
+    value: 0
+  };
+  static state = sliderState;
+  constructor() {
+    super();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.$props.disabled,
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      }
+    });
+  }
+  onSetup() {
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchMinMax.bind(this));
+  }
+  // -------------------------------------------------------------------------------------------
+  // Props
+  // -------------------------------------------------------------------------------------------
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const { value, max } = this.$state;
+    return round(value() / max() * 100, 2) + "%";
+  }
+  // -------------------------------------------------------------------------------------------
+  // Watch
+  // -------------------------------------------------------------------------------------------
+  #watchValue() {
+    const { value } = this.$props;
+    this.$state.value.set(value());
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+}
+
+const cache = /* @__PURE__ */ new Map(), pending = /* @__PURE__ */ new Map(), warned = /* @__PURE__ */ new Set() ;
+class ThumbnailsLoader {
+  #media;
+  #src;
+  #crossOrigin;
+  $images = signal([]);
+  static create(src, crossOrigin) {
+    const media = useMediaContext();
+    return new ThumbnailsLoader(src, crossOrigin, media);
+  }
+  constructor(src, crossOrigin, media) {
+    this.#src = src;
+    this.#crossOrigin = crossOrigin;
+    this.#media = media;
+    effect(this.#onLoadCues.bind(this));
+  }
+  #onLoadCues() {
+    const { canLoad } = this.#media.$state;
+    if (!canLoad()) return;
+    const src = this.#src();
+    if (!src) return;
+    if (isString(src) && cache.has(src)) {
+      const cues = cache.get(src);
+      cache.delete(src);
+      cache.set(src, cues);
+      if (cache.size > 99) {
+        const firstKey = cache.keys().next().value;
+        cache.delete(firstKey);
+      }
+      this.$images.set(cache.get(src));
+    } else if (isString(src)) {
+      const crossOrigin = this.#crossOrigin(), currentKey = src + "::" + crossOrigin;
+      if (!pending.has(currentKey)) {
+        const promise = new Promise(async (resolve, reject) => {
+          try {
+            const response = await fetch(src, {
+              credentials: getRequestCredentials(crossOrigin)
+            }), isJSON = response.headers.get("content-type") === "application/json";
+            if (isJSON) {
+              const json = await response.json();
+              if (isArray(json)) {
+                if (json[0] && "text" in json[0]) {
+                  resolve(this.#processVTTCues(json));
+                } else {
+                  for (let i = 0; i < json.length; i++) {
+                    const image = json[i];
+                    assert(isObject(image), `Item not an object at index ${i}`);
+                    assert(
+                      "url" in image && isString(image.url),
+                      `Invalid or missing \`url\` property at index ${i}`
+                    );
+                    assert(
+                      "startTime" in image && isNumber(image.startTime),
+                      `Invalid or missing \`startTime\` property at index ${i}`
+                    );
+                  }
+                  resolve(json);
+                }
+              } else {
+                resolve(this.#processStoryboard(json));
+              }
+              return;
+            }
+            import('media-captions').then(async ({ parseResponse }) => {
+              try {
+                const { cues } = await parseResponse(response);
+                resolve(this.#processVTTCues(cues));
+              } catch (e) {
+                reject(e);
+              }
+            });
+          } catch (e) {
+            reject(e);
+          }
+        }).then((images) => {
+          cache.set(currentKey, images);
+          return images;
+        }).catch((error) => {
+          this.#onError(src, error);
+        }).finally(() => {
+          if (isString(currentKey)) pending.delete(currentKey);
+        });
+        pending.set(currentKey, promise);
+      }
+      pending.get(currentKey)?.then((images) => {
+        this.$images.set(images || []);
+      });
+    } else if (isArray(src)) {
+      try {
+        this.$images.set(this.#processImages(src));
+      } catch (error) {
+        this.#onError(src, error);
+      }
+    } else {
+      try {
+        this.$images.set(this.#processStoryboard(src));
+      } catch (error) {
+        this.#onError(src, error);
+      }
+    }
+    return () => {
+      this.$images.set([]);
+    };
+  }
+  #processImages(images) {
+    const baseURL = this.#resolveBaseUrl();
+    return images.map((img, i) => {
+      assert(
+        img.url && isString(img.url),
+        `Invalid or missing \`url\` property at index ${i}`
+      );
+      assert(
+        "startTime" in img && isNumber(img.startTime),
+        `Invalid or missing \`startTime\` property at index ${i}`
+      );
+      return {
+        ...img,
+        url: isString(img.url) ? this.#resolveURL(img.url, baseURL) : img.url
+      };
+    });
+  }
+  #processStoryboard(board) {
+    assert(isString(board.url), "Missing `url` in storyboard object");
+    assert(isArray(board.tiles) && board.tiles?.length, `Empty tiles in storyboard`);
+    const url = new URL(board.url), images = [];
+    const tileWidth = "tile_width" in board ? board.tile_width : board.tileWidth, tileHeight = "tile_height" in board ? board.tile_height : board.tileHeight;
+    for (const tile of board.tiles) {
+      images.push({
+        url,
+        startTime: "start" in tile ? tile.start : tile.startTime,
+        width: tileWidth,
+        height: tileHeight,
+        coords: { x: tile.x, y: tile.y }
+      });
+    }
+    return images;
+  }
+  #processVTTCues(cues) {
+    for (let i = 0; i < cues.length; i++) {
+      const cue = cues[i];
+      assert(
+        "startTime" in cue && isNumber(cue.startTime),
+        `Invalid or missing \`startTime\` property at index ${i}`
+      );
+      assert(
+        "text" in cue && isString(cue.text),
+        `Invalid or missing \`text\` property at index ${i}`
+      );
+    }
+    const images = [], baseURL = this.#resolveBaseUrl();
+    for (const cue of cues) {
+      const [url, hash] = cue.text.split("#"), data = this.#resolveData(hash);
+      images.push({
+        url: this.#resolveURL(url, baseURL),
+        startTime: cue.startTime,
+        endTime: cue.endTime,
+        width: data?.w,
+        height: data?.h,
+        coords: data && isNumber(data.x) && isNumber(data.y) ? { x: data.x, y: data.y } : void 0
+      });
+    }
+    return images;
+  }
+  #resolveBaseUrl() {
+    let baseURL = peek(this.#src);
+    if (!isString(baseURL) || !/^https?:/.test(baseURL)) {
+      return location.href;
+    }
+    return baseURL;
+  }
+  #resolveURL(src, baseURL) {
+    return /^https?:/.test(src) ? new URL(src) : new URL(src, baseURL);
+  }
+  #resolveData(hash) {
+    if (!hash) return {};
+    const [hashProps, values] = hash.split("="), hashValues = values?.split(","), data = {};
+    if (!hashProps || !hashValues) {
+      return null;
+    }
+    for (let i = 0; i < hashProps.length; i++) {
+      const value = +hashValues[i];
+      if (!isNaN(value)) data[hashProps[i]] = value;
+    }
+    return data;
+  }
+  #onError(src, error) {
+    if (warned?.has(src)) return;
+    this.#media.logger?.errorGroup("[vidstack] failed to load thumbnails").labelledLog("Src", src).labelledLog("Error", error).dispatch();
+    warned?.add(src);
+  }
+}
+
+class Thumbnail extends Component {
+  static props = {
+    src: null,
+    time: 0,
+    crossOrigin: null
+  };
+  static state = new State({
+    src: "",
+    img: null,
+    thumbnails: [],
+    activeThumbnail: null,
+    crossOrigin: null,
+    loading: false,
+    error: null,
+    hidden: false
+  });
+  media;
+  #loader;
+  #styleResets = [];
+  onSetup() {
+    this.media = useMediaContext();
+    this.#loader = ThumbnailsLoader.create(this.$props.src, this.$state.crossOrigin);
+    this.#watchCrossOrigin();
+    this.setAttributes({
+      "data-loading": this.#isLoading.bind(this),
+      "data-error": this.#hasError.bind(this),
+      "data-hidden": this.$state.hidden,
+      "aria-hidden": $ariaBool(this.$state.hidden)
+    });
+  }
+  onConnect(el) {
+    effect(this.#watchImg.bind(this));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#onLoadStart.bind(this));
+    effect(this.#onFindActiveThumbnail.bind(this));
+    effect(this.#resize.bind(this));
+  }
+  #watchImg() {
+    const img = this.$state.img();
+    if (!img) return;
+    new EventsController(img).add("load", this.#onLoaded.bind(this)).add("error", this.#onError.bind(this));
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
+  }
+  #onLoadStart() {
+    const { src, loading, error } = this.$state;
+    if (src()) {
+      loading.set(true);
+      error.set(null);
+    }
+    return () => {
+      this.#resetStyles();
+      loading.set(false);
+      error.set(null);
+    };
+  }
+  #onLoaded() {
+    const { loading, error } = this.$state;
+    this.#resize();
+    loading.set(false);
+    error.set(null);
+  }
+  #onError(event) {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(event);
+  }
+  #isLoading() {
+    const { loading, hidden } = this.$state;
+    return !hidden() && loading();
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error());
+  }
+  #watchHidden() {
+    const { hidden } = this.$state, { duration } = this.media.$state, images = this.#loader.$images();
+    hidden.set(this.#hasError() || !Number.isFinite(duration()) || images.length === 0);
+  }
+  getTime() {
+    return this.$props.time();
+  }
+  #onFindActiveThumbnail() {
+    let images = this.#loader.$images();
+    if (!images.length) return;
+    let time = this.getTime(), { src, activeThumbnail } = this.$state, activeIndex = -1, activeImage = null;
+    for (let i = images.length - 1; i >= 0; i--) {
+      const image = images[i];
+      if (time >= image.startTime && (!image.endTime || time < image.endTime)) {
+        activeIndex = i;
+        break;
+      }
+    }
+    if (images[activeIndex]) {
+      activeImage = images[activeIndex];
+    }
+    activeThumbnail.set(activeImage);
+    src.set(activeImage?.url.href || "");
+  }
+  #resize() {
+    if (!this.scope || this.$state.hidden()) return;
+    const rootEl = this.el, imgEl = this.$state.img(), thumbnail = this.$state.activeThumbnail();
+    if (!imgEl || !thumbnail || !rootEl) return;
+    let width = thumbnail.width ?? imgEl.naturalWidth, height = thumbnail?.height ?? imgEl.naturalHeight, {
+      maxWidth,
+      maxHeight,
+      minWidth,
+      minHeight,
+      width: elWidth,
+      height: elHeight
+    } = getComputedStyle(this.el);
+    if (minWidth === "100%") minWidth = parseFloat(elWidth) + "";
+    if (minHeight === "100%") minHeight = parseFloat(elHeight) + "";
+    let minRatio = Math.max(parseInt(minWidth) / width, parseInt(minHeight) / height), maxRatio = Math.min(
+      Math.max(parseInt(minWidth), parseInt(maxWidth)) / width,
+      Math.max(parseInt(minHeight), parseInt(maxHeight)) / height
+    ), scale = !isNaN(maxRatio) && maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
+    this.#style(rootEl, "--thumbnail-width", `${width * scale}px`);
+    this.#style(rootEl, "--thumbnail-height", `${height * scale}px`);
+    this.#style(rootEl, "--thumbnail-aspect-ratio", String(round(width / height, 5)));
+    this.#style(imgEl, "width", `${imgEl.naturalWidth * scale}px`);
+    this.#style(imgEl, "height", `${imgEl.naturalHeight * scale}px`);
+    this.#style(
+      imgEl,
+      "transform",
+      thumbnail.coords ? `translate(-${thumbnail.coords.x * scale}px, -${thumbnail.coords.y * scale}px)` : ""
+    );
+    this.#style(imgEl, "max-width", "none");
+  }
+  #style(el, name, value) {
+    el.style.setProperty(name, value);
+    this.#styleResets.push(() => el.style.removeProperty(name));
+  }
+  #resetStyles() {
+    for (const reset of this.#styleResets) reset();
+    this.#styleResets = [];
+  }
+}
+
+class SliderThumbnail extends Thumbnail {
+  #slider;
+  onAttach(el) {
+    this.#slider = useState(Slider.state);
+  }
+  getTime() {
+    const { duration, clipStartTime } = this.media.$state;
+    return clipStartTime() + this.#slider.pointerRate() * duration();
+  }
+}
+
+class SliderVideo extends Component {
+  static props = {
+    src: null,
+    crossOrigin: null
+  };
+  static state = new State({
+    video: null,
+    src: null,
+    crossOrigin: null,
+    canPlay: false,
+    error: null,
+    hidden: false
+  });
+  #media;
+  #slider;
+  get video() {
+    return this.$state.video();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#slider = useState(Slider.state);
+    this.#watchCrossOrigin();
+    this.setAttributes({
+      "data-loading": this.#isLoading.bind(this),
+      "data-hidden": this.$state.hidden,
+      "data-error": this.#hasError.bind(this),
+      "aria-hidden": $ariaBool(this.$state.hidden)
+    });
+  }
+  onAttach(el) {
+    effect(this.#watchVideo.bind(this));
+    effect(this.#watchSrc.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#onSrcChange.bind(this));
+    effect(this.#onUpdateTime.bind(this));
+  }
+  #watchVideo() {
+    const video = this.$state.video();
+    if (!video) return;
+    if (video.readyState >= 2) this.#onCanPlay();
+    new EventsController(video).add("canplay", this.#onCanPlay.bind(this)).add("error", this.#onError.bind(this));
+  }
+  #watchSrc() {
+    const { src } = this.$state, { canLoad } = this.#media.$state;
+    src.set(canLoad() ? this.$props.src() : null);
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
+  }
+  #isLoading() {
+    const { canPlay, hidden } = this.$state;
+    return !canPlay() && !hidden();
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error);
+  }
+  #watchHidden() {
+    const { src, hidden } = this.$state, { canLoad, duration } = this.#media.$state;
+    hidden.set(canLoad() && (!src() || this.#hasError() || !Number.isFinite(duration())));
+  }
+  #onSrcChange() {
+    const { src, canPlay, error } = this.$state;
+    src();
+    canPlay.set(false);
+    error.set(null);
+  }
+  #onCanPlay(event) {
+    const { canPlay, error } = this.$state;
+    canPlay.set(true);
+    error.set(null);
+    this.dispatch("can-play", { trigger: event });
+  }
+  #onError(event) {
+    const { canPlay, error } = this.$state;
+    canPlay.set(false);
+    error.set(event);
+    this.dispatch("error", { trigger: event });
+  }
+  #onUpdateTime() {
+    const { video, canPlay } = this.$state, { duration } = this.#media.$state, { pointerRate } = this.#slider, media = video(), canUpdate = canPlay() && media && Number.isFinite(duration()) && Number.isFinite(pointerRate());
+    if (canUpdate) {
+      media.currentTime = pointerRate() * duration();
+    }
+  }
+}
+const slidervideo__proto = SliderVideo.prototype;
+prop(slidervideo__proto, "video");
+
+class SliderValue extends Component {
+  static props = {
+    type: "pointer",
+    format: null,
+    showHours: false,
+    showMs: false,
+    padHours: null,
+    padMinutes: null,
+    decimalPlaces: 2
+  };
+  #format;
+  #text;
+  #slider;
+  onSetup() {
+    this.#slider = useState(Slider.state);
+    this.#format = useContext(sliderValueFormatContext);
+    this.#text = computed(this.getValueText.bind(this));
+  }
+  /**
+   * Returns the current value formatted as text based on prop settings.
+   */
+  getValueText() {
+    const {
+      type,
+      format: $format,
+      decimalPlaces,
+      padHours,
+      padMinutes,
+      showHours,
+      showMs
+    } = this.$props, { value: sliderValue, pointerValue, min, max } = this.#slider, format = $format?.() ?? this.#format.default;
+    const value = type() === "current" ? sliderValue() : pointerValue();
+    if (format === "percent") {
+      const range = max() - min();
+      const percent = value / range * 100;
+      return (this.#format.percent ?? round)(percent, decimalPlaces()) + "%";
+    } else if (format === "time") {
+      return (this.#format.time ?? formatTime)(value, {
+        padHrs: padHours(),
+        padMins: padMinutes(),
+        showHrs: showHours(),
+        showMs: showMs()
+      });
+    } else {
+      return (this.#format.value?.(value) ?? value.toFixed(2)) + "";
+    }
+  }
+}
+const slidervalue__proto = SliderValue.prototype;
+method(slidervalue__proto, "getValueText");
+
+class SliderPreview extends Component {
+  static props = {
+    offset: 0,
+    noClamp: false
+  };
+  #slider;
+  onSetup() {
+    this.#slider = useContext(sliderContext);
+    const { active } = useState(Slider.state);
+    this.setAttributes({
+      "data-visible": active
+    });
+  }
+  onAttach(el) {
+    Object.assign(el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+  }
+  onConnect(el) {
+    const { preview } = this.#slider;
+    preview.set(el);
+    onDispose(() => preview.set(null));
+    effect(this.#updatePlacement.bind(this));
+    const resize = new ResizeObserver(this.#updatePlacement.bind(this));
+    resize.observe(el);
+    onDispose(() => resize.disconnect());
+  }
+  #updatePlacement = animationFrameThrottle(() => {
+    const { disabled, orientation } = this.#slider;
+    if (disabled()) return;
+    const el = this.el, { offset, noClamp } = this.$props;
+    if (!el) return;
+    updateSliderPreviewPlacement(el, {
+      clamp: !noClamp(),
+      offset: offset(),
+      orientation: orientation()
+    });
+  });
+}
+function updateSliderPreviewPlacement(el, {
+  clamp,
+  offset,
+  orientation
+}) {
+  const computedStyle = getComputedStyle(el), width = parseFloat(computedStyle.width), height = parseFloat(computedStyle.height), styles = {
+    top: null,
+    right: null,
+    bottom: null,
+    left: null
+  };
+  styles[orientation === "horizontal" ? "bottom" : "left"] = `calc(100% + var(--media-slider-preview-offset, ${offset}px))`;
+  if (orientation === "horizontal") {
+    const widthHalf = width / 2;
+    if (!clamp) {
+      styles.left = `calc(var(--slider-pointer) - ${widthHalf}px)`;
+    } else {
+      const leftClamp = `max(0px, calc(var(--slider-pointer) - ${widthHalf}px))`, rightClamp = `calc(100% - ${width}px)`;
+      styles.left = `min(${leftClamp}, ${rightClamp})`;
+    }
+  } else {
+    const heightHalf = height / 2;
+    if (!clamp) {
+      styles.bottom = `calc(var(--slider-pointer) - ${heightHalf}px)`;
+    } else {
+      const topClamp = `max(${heightHalf}px, calc(var(--slider-pointer) - ${heightHalf}px))`, bottomClamp = `calc(100% - ${height}px)`;
+      styles.bottom = `min(${topClamp}, ${bottomClamp})`;
+    }
+  }
+  Object.assign(el.style, styles);
+}
+
+class VolumeSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    keyStep: 5,
+    shiftKeyMultiplier: 2
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    const { audioGain } = this.#media.$state;
+    provideContext(sliderValueFormatContext, {
+      default: "percent",
+      value(value) {
+        return (value * (audioGain() ?? 1)).toFixed(2);
+      },
+      percent(value) {
+        return Math.round(value * (audioGain() ?? 1));
+      }
+    });
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueMax: this.#getARIAValueMax.bind(this),
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchVolume.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-volume-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Volume");
+    const { canSetVolume } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetVolume,
+      "aria-hidden": $ariaBool(() => !canSetVolume())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state, { audioGain } = this.#media.$state;
+    return Math.round(value() * (audioGain() ?? 1));
+  }
+  #getARIAValueText() {
+    const { value, max } = this.$state, { audioGain } = this.#media.$state;
+    return round(value() / max() * (audioGain() ?? 1) * 100, 2) + "%";
+  }
+  #getARIAValueMax() {
+    const { audioGain } = this.#media.$state;
+    return this.$state.max() * (audioGain() ?? 1);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetVolume } = this.#media.$state;
+    return disabled() || !canSetVolume();
+  }
+  #watchVolume() {
+    const { muted, volume } = this.#media.$state;
+    const newValue = muted() ? 0 : volume() * 100;
+    this.$state.value.set(newValue);
+    this.dispatch("value-change", { detail: newValue });
+  }
+  #throttleVolumeChange = functionThrottle(this.#onVolumeChange.bind(this), 25);
+  #onVolumeChange(event) {
+    if (!event.trigger) return;
+    const mediaVolume = round(event.detail / 100, 3);
+    this.#media.remote.changeVolume(mediaVolume, event);
+  }
+  #onValueChange(event) {
+    this.#throttleVolumeChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttleVolumeChange(event);
+  }
+}
+
+class AudioGainSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 25,
+    keyStep: 25,
+    shiftKeyMultiplier: 2,
+    min: 0,
+    max: 300
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(sliderValueFormatContext, {
+      default: "percent",
+      percent: (_, decimalPlaces) => {
+        return round(this.$state.value(), decimalPlaces) + "%";
+      }
+    });
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMinMax.bind(this));
+    effect(this.#watchAudioGain.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-audio-gain-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Audio Boost");
+    const { canSetAudioGain } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetAudioGain,
+      "aria-hidden": $ariaBool(() => !canSetAudioGain())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const { value } = this.$state;
+    return value() + "%";
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+  #watchAudioGain() {
+    const { audioGain } = this.#media.$state, value = ((audioGain() ?? 1) - 1) * 100;
+    this.$state.value.set(value);
+    this.dispatch("value-change", { detail: value });
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetAudioGain } = this.#media.$state;
+    return disabled() || !canSetAudioGain();
+  }
+  #onAudioGainChange(event) {
+    if (!event.trigger) return;
+    const gain = round(1 + event.detail / 100, 2);
+    this.#media.remote.changeAudioGain(gain, event);
+  }
+  #onValueChange(event) {
+    this.#onAudioGainChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#onAudioGainChange(event);
+  }
+}
+
+class SpeedSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 0.25,
+    keyStep: 0.25,
+    shiftKeyMultiplier: 2,
+    min: 0,
+    max: 2
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: this.#roundValue,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMinMax.bind(this));
+    effect(this.#watchPlaybackRate.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-speed-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Speed");
+    const { canSetPlaybackRate } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetPlaybackRate,
+      "aria-hidden": $ariaBool(() => !canSetPlaybackRate())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return value();
+  }
+  #getARIAValueText() {
+    const { value } = this.$state;
+    return value() + "x";
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+  #watchPlaybackRate() {
+    const { playbackRate } = this.#media.$state;
+    const newValue = playbackRate();
+    this.$state.value.set(newValue);
+    this.dispatch("value-change", { detail: newValue });
+  }
+  #roundValue(value) {
+    return round(value, 2);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetPlaybackRate } = this.#media.$state;
+    return disabled() || !canSetPlaybackRate();
+  }
+  #throttledSpeedChange = functionThrottle(this.#onPlaybackRateChange.bind(this), 25);
+  #onPlaybackRateChange(event) {
+    if (!event.trigger) return;
+    const rate = event.detail;
+    this.#media.remote.changePlaybackRate(rate, event);
+  }
+  #onValueChange(event) {
+    this.#throttledSpeedChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttledSpeedChange(event);
+  }
+}
+
+class QualitySlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 1,
+    keyStep: 1,
+    shiftKeyMultiplier: 1
+  };
+  static state = sliderState;
+  #media;
+  #sortedQualities = computed(() => {
+    const { qualities } = this.#media.$state;
+    return sortVideoQualities(qualities());
+  });
+  onSetup() {
+    this.#media = useMediaContext();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMax.bind(this));
+    effect(this.#watchQuality.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-quality-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Video Quality");
+    const { qualities, canSetQuality } = this.#media.$state, $supported = computed(() => canSetQuality() && qualities().length > 0);
+    this.setAttributes({
+      "data-supported": $supported,
+      "aria-hidden": $ariaBool(() => !$supported())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return value();
+  }
+  #getARIAValueText() {
+    const { quality } = this.#media.$state;
+    if (!quality()) return "";
+    const { height, bitrate } = quality(), bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null;
+    return height ? `${height}p${bitrateText ? ` (${bitrateText})` : ""}` : "Auto";
+  }
+  #watchMax() {
+    const $qualities = this.#sortedQualities();
+    this.$state.max.set(Math.max(0, $qualities.length - 1));
+  }
+  #watchQuality() {
+    let { quality } = this.#media.$state, $qualities = this.#sortedQualities(), value = Math.max(0, $qualities.indexOf(quality()));
+    this.$state.value.set(value);
+    this.dispatch("value-change", { detail: value });
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetQuality, qualities } = this.#media.$state;
+    return disabled() || qualities().length <= 1 || !canSetQuality();
+  }
+  #throttledQualityChange = functionThrottle(this.#onQualityChange.bind(this), 25);
+  #onQualityChange(event) {
+    if (!event.trigger) return;
+    const { qualities } = this.#media, quality = peek(this.#sortedQualities)[event.detail];
+    this.#media.remote.changeQuality(qualities.indexOf(quality), event);
+  }
+  #onValueChange(event) {
+    this.#throttledQualityChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttledQualityChange(event);
+  }
+}
+
+class TimeSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 0.1,
+    keyStep: 5,
+    shiftKeyMultiplier: 2,
+    pauseWhileDragging: false,
+    noSwipeGesture: false,
+    seekingRequestThrottle: 100
+  };
+  static state = sliderState;
+  #media;
+  #dispatchSeeking;
+  #chapter = signal(null);
+  constructor() {
+    super();
+    const { noSwipeGesture } = this.$props;
+    new SliderController({
+      swipeGesture: () => !noSwipeGesture(),
+      getValue: this.#getValue.bind(this),
+      getStep: this.#getStep.bind(this),
+      getKeyStep: this.#getKeyStep.bind(this),
+      roundValue: this.#roundValue,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragStart: this.#onDragStart.bind(this),
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onDragEnd: this.#onDragEnd.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(sliderValueFormatContext, {
+      default: "time",
+      value: this.#formatValue.bind(this),
+      time: this.#formatTime.bind(this)
+    });
+    this.setAttributes({
+      "data-chapters": this.#hasChapters.bind(this)
+    });
+    this.setStyles({
+      "--slider-progress": this.#calcBufferedPercent.bind(this)
+    });
+    effect(this.#watchCurrentTime.bind(this));
+    effect(this.#watchSeekingThrottle.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-time-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Seek");
+  }
+  onConnect(el) {
+    effect(this.#watchPreviewing.bind(this));
+    watchActiveTextTrack(this.#media.textTracks, "chapters", this.#chapter.set);
+  }
+  #calcBufferedPercent() {
+    const { bufferedEnd, duration } = this.#media.$state;
+    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + "%";
+  }
+  #hasChapters() {
+    const { duration } = this.#media.$state;
+    return this.#chapter()?.cues.length && Number.isFinite(duration()) && duration() > 0;
+  }
+  #watchSeekingThrottle() {
+    this.#dispatchSeeking = functionThrottle(
+      this.#seeking.bind(this),
+      this.$props.seekingRequestThrottle()
+    );
+  }
+  #watchCurrentTime() {
+    if (this.$state.hidden()) return;
+    const { value, dragging } = this.$state, newValue = this.#getValue();
+    if (!peek(dragging)) {
+      value.set(newValue);
+      this.dispatch("value-change", { detail: newValue });
+    }
+  }
+  #watchPreviewing() {
+    const player = this.#media.player.el, { preview } = useContext(sliderContext);
+    player && preview() && setAttribute(player, "data-preview", this.$state.active());
+  }
+  #seeking(time, event) {
+    this.#media.remote.seeking(time, event);
+  }
+  #seek(time, percent, event) {
+    this.#dispatchSeeking.cancel();
+    const { live } = this.#media.$state;
+    if (live() && percent >= 99) {
+      this.#media.remote.seekToLiveEdge(event);
+      return;
+    }
+    this.#media.remote.seek(time, event);
+  }
+  #playingBeforeDragStart = false;
+  #onDragStart(event) {
+    const { pauseWhileDragging } = this.$props;
+    if (pauseWhileDragging()) {
+      const { paused } = this.#media.$state;
+      this.#playingBeforeDragStart = !paused();
+      this.#media.remote.pause(event);
+    }
+  }
+  #onDragValueChange(event) {
+    this.#dispatchSeeking(this.#percentToTime(event.detail), event);
+  }
+  #onDragEnd(event) {
+    const { seeking } = this.#media.$state;
+    if (!peek(seeking)) this.#seeking(this.#percentToTime(event.detail), event);
+    const percent = event.detail;
+    this.#seek(this.#percentToTime(percent), percent, event);
+    const { pauseWhileDragging } = this.$props;
+    if (pauseWhileDragging() && this.#playingBeforeDragStart) {
+      this.#media.remote.play(event);
+      this.#playingBeforeDragStart = false;
+    }
+  }
+  #onValueChange(event) {
+    const { dragging } = this.$state;
+    if (dragging() || !event.trigger) return;
+    this.#onDragEnd(event);
+  }
+  // -------------------------------------------------------------------------------------------
+  // Props
+  // -------------------------------------------------------------------------------------------
+  #getValue() {
+    const { currentTime } = this.#media.$state;
+    return this.#timeToPercent(currentTime());
+  }
+  #getStep() {
+    const value = this.$props.step() / this.#media.$state.duration() * 100;
+    return Number.isFinite(value) ? value : 1;
+  }
+  #getKeyStep() {
+    const value = this.$props.keyStep() / this.#media.$state.duration() * 100;
+    return Number.isFinite(value) ? value : 1;
+  }
+  #roundValue(value) {
+    return round(value, 3);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSeek } = this.#media.$state;
+    return disabled() || !canSeek();
+  }
+  // -------------------------------------------------------------------------------------------
+  // ARIA
+  // -------------------------------------------------------------------------------------------
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const time = this.#percentToTime(this.$state.value()), { duration } = this.#media.$state;
+    return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : "live";
+  }
+  // -------------------------------------------------------------------------------------------
+  // Format
+  // -------------------------------------------------------------------------------------------
+  #percentToTime(percent) {
+    const { duration } = this.#media.$state;
+    return round(percent / 100 * duration(), 5);
+  }
+  #timeToPercent(time) {
+    const { liveEdge, duration } = this.#media.$state, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));
+    return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
+  }
+  #formatValue(percent) {
+    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state;
+    return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : "LIVE";
+  }
+  #formatTime(percent, options) {
+    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state, value = live() ? time - duration() : time;
+    return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(Math.abs(value), options)}` : "LIVE";
+  }
+}
+
+class SliderChapters extends Component {
+  static props = {
+    disabled: false
+  };
+  #media;
+  #sliderState;
+  #updateScope;
+  #titleRef = null;
+  #refs = [];
+  #$track = signal(null);
+  #$cues = signal([]);
+  #activeIndex = signal(-1);
+  #activePointerIndex = signal(-1);
+  #bufferedIndex = 0;
+  get cues() {
+    return this.#$cues();
+  }
+  get activeCue() {
+    return this.#$cues()[this.#activeIndex()] || null;
+  }
+  get activePointerCue() {
+    return this.#$cues()[this.#activePointerIndex()] || null;
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#sliderState = useState(TimeSlider.state);
+  }
+  onAttach(el) {
+    watchActiveTextTrack(this.#media.textTracks, "chapters", this.#setTrack.bind(this));
+    effect(this.#watchSource.bind(this));
+  }
+  onConnect() {
+    onDispose(() => this.#reset.bind(this));
+  }
+  onDestroy() {
+    this.#setTrack(null);
+  }
+  setRefs(refs) {
+    this.#refs = refs;
+    this.#updateScope?.dispose();
+    if (this.#refs.length === 1) {
+      const el = this.#refs[0];
+      el.style.width = "100%";
+      el.style.setProperty("--chapter-fill", "var(--slider-fill)");
+      el.style.setProperty("--chapter-progress", "var(--slider-progress)");
+    } else if (this.#refs.length > 0) {
+      scoped(() => this.#watch(), this.#updateScope = createScope());
+    }
+  }
+  #setTrack(track) {
+    if (peek(this.#$track) === track) return;
+    this.#reset();
+    this.#$track.set(track);
+  }
+  #reset() {
+    this.#refs = [];
+    this.#$cues.set([]);
+    this.#activeIndex.set(-1);
+    this.#activePointerIndex.set(-1);
+    this.#bufferedIndex = 0;
+    this.#updateScope?.dispose();
+  }
+  #watch() {
+    if (!this.#refs.length) return;
+    effect(this.#watchUpdates.bind(this));
+  }
+  #watchUpdates() {
+    const { hidden } = this.#sliderState;
+    if (hidden()) return;
+    effect(this.#watchContainerWidths.bind(this));
+    effect(this.#watchFillPercent.bind(this));
+    effect(this.#watchPointerPercent.bind(this));
+    effect(this.#watchBufferedPercent.bind(this));
+  }
+  #watchContainerWidths() {
+    const cues = this.#$cues();
+    if (!cues.length) return;
+    let cue, { seekableStart, seekableEnd } = this.#media.$state, startTime = seekableStart(), endTime = seekableEnd() || cues[cues.length - 1].endTime, duration = endTime - startTime, remainingWidth = 100;
+    for (let i = 0; i < cues.length; i++) {
+      cue = cues[i];
+      if (this.#refs[i]) {
+        const width = i === cues.length - 1 ? remainingWidth : round((cue.endTime - Math.max(startTime, cue.startTime)) / duration * 100, 3);
+        this.#refs[i].style.width = width + "%";
+        remainingWidth -= width;
+      }
+    }
+  }
+  #watchFillPercent() {
+    let { liveEdge, seekableStart, seekableEnd } = this.#media.$state, { fillPercent, value } = this.#sliderState, cues = this.#$cues(), isLiveEdge = liveEdge(), prevActiveIndex = peek(this.#activeIndex), currentChapter = cues[prevActiveIndex];
+    let currentActiveIndex = isLiveEdge ? this.#$cues.length - 1 : this.#findActiveChapterIndex(
+      currentChapter ? currentChapter.startTime / seekableEnd() * 100 <= peek(value) ? prevActiveIndex : 0 : 0,
+      fillPercent()
+    );
+    if (isLiveEdge || !currentChapter) {
+      this.#updateFillPercents(0, cues.length, 100);
+    } else if (currentActiveIndex > prevActiveIndex) {
+      this.#updateFillPercents(prevActiveIndex, currentActiveIndex, 100);
+    } else if (currentActiveIndex < prevActiveIndex) {
+      this.#updateFillPercents(currentActiveIndex + 1, prevActiveIndex + 1, 0);
+    }
+    const percent = isLiveEdge ? 100 : this.#calcPercent(
+      cues[currentActiveIndex],
+      fillPercent(),
+      seekableStart(),
+      this.#getEndTime(cues)
+    );
+    this.#updateFillPercent(this.#refs[currentActiveIndex], percent);
+    this.#activeIndex.set(currentActiveIndex);
+  }
+  #watchPointerPercent() {
+    let { pointing, pointerPercent } = this.#sliderState;
+    if (!pointing()) {
+      this.#activePointerIndex.set(-1);
+      return;
+    }
+    const activeIndex = this.#findActiveChapterIndex(0, pointerPercent());
+    this.#activePointerIndex.set(activeIndex);
+  }
+  #updateFillPercents(start, end, percent) {
+    for (let i = start; i < end; i++) this.#updateFillPercent(this.#refs[i], percent);
+  }
+  #updateFillPercent(ref, percent) {
+    if (!ref) return;
+    ref.style.setProperty("--chapter-fill", percent + "%");
+    setAttribute(ref, "data-active", percent > 0 && percent < 100);
+    setAttribute(ref, "data-ended", percent === 100);
+  }
+  #findActiveChapterIndex(startIndex, percent) {
+    let chapterPercent = 0, cues = this.#$cues();
+    if (percent === 0) return 0;
+    else if (percent === 100) return cues.length - 1;
+    let { seekableStart } = this.#media.$state, startTime = seekableStart(), endTime = this.#getEndTime(cues);
+    for (let i = startIndex; i < cues.length; i++) {
+      chapterPercent = this.#calcPercent(cues[i], percent, startTime, endTime);
+      if (chapterPercent >= 0 && chapterPercent < 100) return i;
+    }
+    return 0;
+  }
+  #watchBufferedPercent() {
+    this.#updateBufferedPercent(this.#bufferedPercent());
+  }
+  #updateBufferedPercent = animationFrameThrottle((bufferedPercent) => {
+    let percent, cues = this.#$cues(), { seekableStart } = this.#media.$state, startTime = seekableStart(), endTime = this.#getEndTime(cues);
+    for (let i = this.#bufferedIndex; i < this.#refs.length; i++) {
+      percent = this.#calcPercent(cues[i], bufferedPercent, startTime, endTime);
+      this.#refs[i]?.style.setProperty("--chapter-progress", percent + "%");
+      if (percent < 100) {
+        this.#bufferedIndex = i;
+        break;
+      }
+    }
+  });
+  #bufferedPercent = computed(this.#calcMediaBufferedPercent.bind(this));
+  #calcMediaBufferedPercent() {
+    const { bufferedEnd, duration } = this.#media.$state;
+    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1), 3) * 100;
+  }
+  #getEndTime(cues) {
+    const { seekableEnd } = this.#media.$state, endTime = seekableEnd();
+    return Number.isFinite(endTime) ? endTime : cues[cues.length - 1]?.endTime || 0;
+  }
+  #calcPercent(cue, percent, startTime, endTime) {
+    if (!cue) return 0;
+    const cues = this.#$cues();
+    if (cues.length === 0) return 0;
+    const duration = endTime - startTime, cueStartTime = Math.max(0, cue.startTime - startTime), cueEndTime = Math.min(endTime, cue.endTime) - startTime;
+    const startRatio = cueStartTime / duration, startPercent = startRatio * 100, endPercent = Math.min(1, startRatio + (cueEndTime - cueStartTime) / duration) * 100;
+    return Math.max(
+      0,
+      round(
+        percent >= endPercent ? 100 : (percent - startPercent) / (endPercent - startPercent) * 100,
+        3
+      )
+    );
+  }
+  #fillGaps(cues) {
+    let chapters = [], { seekableStart, seekableEnd, duration } = this.#media.$state, startTime = seekableStart(), endTime = seekableEnd();
+    cues = cues.filter((cue) => cue.startTime <= endTime && cue.endTime >= startTime);
+    const firstCue = cues[0];
+    if (firstCue && firstCue.startTime > startTime) {
+      chapters.push(new window.VTTCue(startTime, firstCue.startTime, ""));
+    }
+    for (let i = 0; i < cues.length - 1; i++) {
+      const currentCue = cues[i], nextCue = cues[i + 1];
+      chapters.push(currentCue);
+      if (nextCue) {
+        const timeDiff = nextCue.startTime - currentCue.endTime;
+        if (timeDiff > 0) {
+          chapters.push(new window.VTTCue(currentCue.endTime, currentCue.endTime + timeDiff, ""));
+        }
+      }
+    }
+    const lastCue = cues[cues.length - 1];
+    if (lastCue) {
+      chapters.push(lastCue);
+      const endTime2 = duration();
+      if (endTime2 >= 0 && endTime2 - lastCue.endTime > 1) {
+        chapters.push(new window.VTTCue(lastCue.endTime, duration(), ""));
+      }
+    }
+    return chapters;
+  }
+  #watchSource() {
+    const { source } = this.#media.$state;
+    source();
+    this.#onTrackChange();
+  }
+  #onTrackChange() {
+    if (!this.scope) return;
+    const { disabled } = this.$props;
+    if (disabled()) {
+      this.#$cues.set([]);
+      this.#activeIndex.set(0);
+      this.#bufferedIndex = 0;
+      return;
+    }
+    const track = this.#$track();
+    if (track) {
+      const onCuesChange = this.#onCuesChange.bind(this);
+      onCuesChange();
+      new EventsController(track).add("add-cue", onCuesChange).add("remove-cue", onCuesChange);
+      effect(this.#watchMediaDuration.bind(this));
+    }
+    this.#titleRef = this.#findChapterTitleRef();
+    if (this.#titleRef) effect(this.#onChapterTitleChange.bind(this));
+    return () => {
+      if (this.#titleRef) {
+        this.#titleRef.textContent = "";
+        this.#titleRef = null;
+      }
+    };
+  }
+  #watchMediaDuration() {
+    this.#media.$state.duration();
+    this.#onCuesChange();
+  }
+  #onCuesChange = functionDebounce(
+    () => {
+      const track = peek(this.#$track);
+      if (!this.scope || !track || !track.cues.length) return;
+      this.#$cues.set(this.#fillGaps(track.cues));
+      this.#activeIndex.set(0);
+      this.#bufferedIndex = 0;
+    },
+    150,
+    true
+  );
+  #onChapterTitleChange() {
+    const cue = this.activePointerCue || this.activeCue;
+    if (this.#titleRef) this.#titleRef.textContent = cue?.text || "";
+  }
+  #findParentSlider() {
+    let node = this.el;
+    while (node && node.getAttribute("role") !== "slider") {
+      node = node.parentElement;
+    }
+    return node;
+  }
+  #findChapterTitleRef() {
+    const slider = this.#findParentSlider();
+    return slider ? slider.querySelector('[data-part="chapter-title"]') : null;
+  }
+}
+const sliderchapters__proto = SliderChapters.prototype;
+prop(sliderchapters__proto, "cues");
+prop(sliderchapters__proto, "activeCue");
+prop(sliderchapters__proto, "activePointerCue");
+method(sliderchapters__proto, "setRefs");
+
+const menuContext = createContext();
+
+function scrollIntoView(el, options) {
+  const scrolls = r(el, options);
+  for (const { el: el2, top, left } of scrolls) {
+    el2.scroll({ top, left, behavior: options.behavior });
+  }
+}
+function scrollIntoCenter(el, options = {}) {
+  scrollIntoView(el, {
+    scrollMode: "if-needed",
+    block: "center",
+    inline: "center",
+    ...options
+  });
+}
+
+const FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
+  "a[href]",
+  "[tabindex]",
+  "input",
+  "select",
+  "button"
+].map((selector) => `${selector}:not([aria-hidden='true'])`).join(",");
+const VALID_KEYS = /* @__PURE__ */ new Set([
+  "Escape",
+  "Tab",
+  "ArrowUp",
+  "ArrowDown",
+  "Home",
+  "PageUp",
+  "End",
+  "PageDown",
+  "Enter",
+  " "
+]);
+class MenuFocusController {
+  #index = -1;
+  #el = null;
+  #elements = [];
+  #delegate;
+  get items() {
+    return this.#elements;
+  }
+  constructor(delegate) {
+    this.#delegate = delegate;
+  }
+  attachMenu(el) {
+    listenEvent(el, "focus", this.#onFocus.bind(this));
+    this.#el = el;
+    onDispose(() => {
+      this.#el = null;
+    });
+  }
+  listen() {
+    if (!this.#el) return;
+    this.update();
+    new EventsController(this.#el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this));
+    onDispose(() => {
+      this.#index = -1;
+      this.#elements = [];
+    });
+  }
+  update() {
+    this.#index = 0;
+    this.#elements = this.#getFocusableElements();
+  }
+  scroll(index = this.#findActiveIndex()) {
+    const element = this.#elements[index];
+    if (element) {
+      requestAnimationFrame(() => {
+        requestAnimationFrame(() => {
+          scrollIntoCenter(element, {
+            behavior: "smooth",
+            boundary: (el) => {
+              return !el.hasAttribute("data-root");
+            }
+          });
+        });
+      });
+    }
+  }
+  focusActive(scroll = true) {
+    const index = this.#findActiveIndex();
+    this.#focusAt(index >= 0 ? index : 0, scroll);
+  }
+  #focusAt(index, scroll = true) {
+    this.#index = index;
+    if (this.#elements[index]) {
+      this.#elements[index].focus({ preventScroll: true });
+      if (scroll) this.scroll(index);
+    } else {
+      this.#el?.focus({ preventScroll: true });
+    }
+  }
+  #findActiveIndex() {
+    return this.#elements.findIndex(
+      (el) => document.activeElement === el || el.getAttribute("role") === "menuitemradio" && el.getAttribute("aria-checked") === "true"
+    );
+  }
+  #onFocus() {
+    if (this.#index >= 0) return;
+    this.update();
+    this.focusActive();
+  }
+  #validateKeyEvent(event) {
+    const el = event.target;
+    if (wasEnterKeyPressed(event) && el instanceof Element) {
+      const role = el.getAttribute("role");
+      return !/a|input|select|button/.test(el.localName) && !role;
+    }
+    return VALID_KEYS.has(event.key);
+  }
+  #onKeyUp(event) {
+    if (!this.#validateKeyEvent(event)) return;
+    event.stopPropagation();
+    event.preventDefault();
+  }
+  #onKeyDown(event) {
+    if (!this.#validateKeyEvent(event)) return;
+    event.stopPropagation();
+    event.preventDefault();
+    switch (event.key) {
+      case "Escape":
+        this.#delegate.closeMenu(event);
+        break;
+      case "Tab":
+        this.#focusAt(this.#nextIndex(event.shiftKey ? -1 : 1));
+        break;
+      case "ArrowUp":
+        this.#focusAt(this.#nextIndex(-1));
+        break;
+      case "ArrowDown":
+        this.#focusAt(this.#nextIndex(1));
+        break;
+      case "Home":
+      case "PageUp":
+        this.#focusAt(0);
+        break;
+      case "End":
+      case "PageDown":
+        this.#focusAt(this.#elements.length - 1);
+        break;
+    }
+  }
+  #nextIndex(delta) {
+    let index = this.#index;
+    do {
+      index = (index + delta + this.#elements.length) % this.#elements.length;
+    } while (this.#elements[index]?.offsetParent === null);
+    return index;
+  }
+  #getFocusableElements() {
+    if (!this.#el) return [];
+    const focusableElements = this.#el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
+    const is = (node) => {
+      return node.getAttribute("role") === "menu";
+    };
+    for (const el of focusableElements) {
+      if (isHTMLElement(el) && el.offsetParent !== null && // does not have display: none
+      isElementParent(this.#el, el, is)) {
+        elements.push(el);
+      }
+    }
+    return elements;
+  }
+}
+
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __decorateClass = (decorators, target, key, kind) => {
+  var result = __getOwnPropDesc(target, key) ;
+  for (var i = decorators.length - 1, decorator; i >= 0; i--)
+    if (decorator = decorators[i])
+      result = (decorator(target, key, result) ) || result;
+  if (result) __defProp(target, key, result);
+  return result;
+};
+let idCount = 0;
+class Menu extends Component {
+  static props = {
+    showDelay: 0
+  };
+  #media;
+  #menuId;
+  #menuButtonId;
+  #expanded = signal(false);
+  #disabled = signal(false);
+  #trigger = signal(null);
+  #content = signal(null);
+  #parentMenu;
+  #submenus = /* @__PURE__ */ new Set();
+  #menuObserver = null;
+  #popper;
+  #focus;
+  #isSliderActive = false;
+  #isTriggerDisabled = signal(false);
+  #transitionCallbacks = /* @__PURE__ */ new Set();
+  get triggerElement() {
+    return this.#trigger();
+  }
+  get contentElement() {
+    return this.#content();
+  }
+  get isSubmenu() {
+    return !!this.#parentMenu;
+  }
+  constructor() {
+    super();
+    const { showDelay } = this.$props;
+    this.#popper = new Popper({
+      trigger: this.#trigger,
+      content: this.#content,
+      showDelay,
+      listen: (trigger, show, hide) => {
+        onPress(trigger, (event) => {
+          if (this.#expanded()) hide(event);
+          else show(event);
+        });
+        const closeTarget = this.#getCloseTarget();
+        if (closeTarget) {
+          onPress(closeTarget, (event) => {
+            event.stopPropagation();
+            hide(event);
+          });
+        }
+      },
+      onChange: this.#onExpandedChange.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const currentIdCount = ++idCount;
+    this.#menuId = `media-menu-${currentIdCount}`;
+    this.#menuButtonId = `media-menu-button-${currentIdCount}`;
+    this.#focus = new MenuFocusController({
+      closeMenu: this.close.bind(this)
+    });
+    if (hasProvidedContext(menuContext)) {
+      this.#parentMenu = useContext(menuContext);
+    }
+    this.#observeSliders();
+    this.setAttributes({
+      "data-open": this.#expanded,
+      "data-root": !this.isSubmenu,
+      "data-submenu": this.isSubmenu,
+      "data-disabled": this.#isDisabled.bind(this)
+    });
+    provideContext(menuContext, {
+      button: this.#trigger,
+      content: this.#content,
+      expanded: this.#expanded,
+      hint: signal(""),
+      submenu: !!this.#parentMenu,
+      disable: this.#disable.bind(this),
+      attachMenuButton: this.#attachMenuButton.bind(this),
+      attachMenuItems: this.#attachMenuItems.bind(this),
+      attachObserver: this.#attachObserver.bind(this),
+      disableMenuButton: this.#disableMenuButton.bind(this),
+      addSubmenu: this.#addSubmenu.bind(this),
+      onTransitionEvent: (callback) => {
+        this.#transitionCallbacks.add(callback);
+        onDispose(() => {
+          this.#transitionCallbacks.delete(callback);
+        });
+      }
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  onConnect(el) {
+    effect(this.#watchExpanded.bind(this));
+    if (this.isSubmenu) {
+      this.#parentMenu?.addSubmenu(this);
+    }
+  }
+  onDestroy() {
+    this.#trigger.set(null);
+    this.#content.set(null);
+    this.#menuObserver = null;
+    this.#transitionCallbacks.clear();
+  }
+  #observeSliders() {
+    let sliderActiveTimer = -1, parentSliderObserver = hasProvidedContext(sliderObserverContext) ? useContext(sliderObserverContext) : null;
+    provideContext(sliderObserverContext, {
+      onDragStart: () => {
+        parentSliderObserver?.onDragStart?.();
+        window.clearTimeout(sliderActiveTimer);
+        sliderActiveTimer = -1;
+        this.#isSliderActive = true;
+      },
+      onDragEnd: () => {
+        parentSliderObserver?.onDragEnd?.();
+        sliderActiveTimer = window.setTimeout(() => {
+          this.#isSliderActive = false;
+          sliderActiveTimer = -1;
+        }, 300);
+      }
+    });
+  }
+  #watchExpanded() {
+    const expanded = this.#isExpanded();
+    if (!this.isSubmenu) this.#onResize();
+    this.#updateMenuItemsHidden(expanded);
+    if (!expanded) return;
+    effect(() => {
+      const { height } = this.#media.$state, content = this.#content();
+      content && setStyle(content, "--player-height", height() + "px");
+    });
+    this.#focus.listen();
+    this.listen("pointerup", this.#onPointerUp.bind(this));
+    listenEvent(window, "pointerup", this.#onWindowPointerUp.bind(this));
+  }
+  #attachMenuButton(button) {
+    const el = button.el, isMenuItem = this.isSubmenu, isARIADisabled = $ariaBool(this.#isDisabled.bind(this));
+    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
+    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
+    setAttribute(el, "id", this.#menuButtonId);
+    setAttribute(el, "aria-haspopup", "menu");
+    setAttribute(el, "aria-expanded", "false");
+    setAttribute(el, "data-root", !this.isSubmenu);
+    setAttribute(el, "data-submenu", this.isSubmenu);
+    const watchAttrs = () => {
+      setAttribute(el, "data-open", this.#expanded());
+      setAttribute(el, "aria-disabled", isARIADisabled());
+    };
+    if (IS_SERVER) watchAttrs();
+    else effect(watchAttrs);
+    this.#trigger.set(el);
+    onDispose(() => {
+      this.#trigger.set(null);
+    });
+  }
+  #attachMenuItems(items) {
+    const el = items.el;
+    el.style.setProperty("display", "none");
+    setAttribute(el, "id", this.#menuId);
+    setAttributeIfEmpty(el, "role", "menu");
+    setAttributeIfEmpty(el, "tabindex", "-1");
+    setAttribute(el, "data-root", !this.isSubmenu);
+    setAttribute(el, "data-submenu", this.isSubmenu);
+    this.#content.set(el);
+    onDispose(() => this.#content.set(null));
+    const watchAttrs = () => setAttribute(el, "data-open", this.#expanded());
+    if (IS_SERVER) watchAttrs();
+    else effect(watchAttrs);
+    this.#focus.attachMenu(el);
+    this.#updateMenuItemsHidden(false);
+    const onTransition = this.#onResizeTransition.bind(this);
+    if (!this.isSubmenu) {
+      items.listen("transitionstart", onTransition);
+      items.listen("transitionend", onTransition);
+      items.listen("animationend", this.#onResize);
+      items.listen("vds-menu-resize", this.#onResize);
+    } else {
+      this.#parentMenu?.onTransitionEvent(onTransition);
+    }
+  }
+  #attachObserver(observer) {
+    this.#menuObserver = observer;
+  }
+  #updateMenuItemsHidden(expanded) {
+    const content = peek(this.#content);
+    if (content) setAttribute(content, "aria-hidden", ariaBool$1(!expanded));
+  }
+  #disableMenuButton(disabled) {
+    this.#isTriggerDisabled.set(disabled);
+  }
+  #wasKeyboardExpand = false;
+  #onExpandedChange(isExpanded, event) {
+    this.#wasKeyboardExpand = isKeyboardEvent(event);
+    event?.stopPropagation();
+    if (this.#expanded() === isExpanded) return;
+    if (this.#isDisabled()) {
+      if (isExpanded) this.#popper.hide(event);
+      return;
+    }
+    this.el?.dispatchEvent(
+      new Event("vds-menu-resize", {
+        bubbles: true,
+        composed: true
+      })
+    );
+    const trigger = this.#trigger(), content = this.#content();
+    if (trigger) {
+      setAttribute(trigger, "aria-controls", isExpanded && this.#menuId);
+      setAttribute(trigger, "aria-expanded", ariaBool$1(isExpanded));
+    }
+    if (content) setAttribute(content, "aria-labelledby", isExpanded && this.#menuButtonId);
+    this.#expanded.set(isExpanded);
+    this.#toggleMediaControls(event);
+    tick();
+    if (this.#wasKeyboardExpand) {
+      if (isExpanded) content?.focus();
+      else trigger?.focus();
+      for (const el of [this.el, content]) {
+        el && el.setAttribute("data-keyboard", "");
+      }
+    } else {
+      for (const el of [this.el, content]) {
+        el && el.removeAttribute("data-keyboard");
+      }
+    }
+    this.dispatch(isExpanded ? "open" : "close", { trigger: event });
+    if (isExpanded) {
+      if (!this.isSubmenu && this.#media.activeMenu !== this) {
+        this.#media.activeMenu?.close(event);
+        this.#media.activeMenu = this;
+      }
+      this.#menuObserver?.onOpen?.(event);
+    } else {
+      if (this.isSubmenu) {
+        for (const el of this.#submenus) el.close(event);
+      } else {
+        this.#media.activeMenu = null;
+      }
+      this.#menuObserver?.onClose?.(event);
+    }
+    if (isExpanded) {
+      requestAnimationFrame(this.#updateFocus.bind(this));
+    }
+  }
+  #updateFocus() {
+    if (this.#isTransitionActive || this.#isSubmenuOpen) return;
+    this.#focus.update();
+    requestAnimationFrame(() => {
+      if (this.#wasKeyboardExpand) {
+        this.#focus.focusActive();
+      } else {
+        this.#focus.scroll();
+      }
+    });
+  }
+  #isExpanded() {
+    return !this.#isDisabled() && this.#expanded();
+  }
+  #isDisabled() {
+    return this.#disabled() || this.#isTriggerDisabled();
+  }
+  #disable(disabled) {
+    this.#disabled.set(disabled);
+  }
+  #onPointerUp(event) {
+    const content = this.#content();
+    if (this.#isSliderActive || content && isEventInside(content, event)) {
+      return;
+    }
+    event.stopPropagation();
+  }
+  #onWindowPointerUp(event) {
+    const content = this.#content();
+    if (this.#isSliderActive || content && isEventInside(content, event)) {
+      return;
+    }
+    this.close(event);
+  }
+  #getCloseTarget() {
+    const target = this.el?.querySelector('[data-part="close-target"]');
+    return this.el && target && isElementParent(this.el, target, (node) => node.getAttribute("role") === "menu") ? target : null;
+  }
+  #toggleMediaControls(trigger) {
+    if (this.isSubmenu) return;
+    if (this.#expanded()) this.#media.remote.pauseControls(trigger);
+    else this.#media.remote.resumeControls(trigger);
+  }
+  #addSubmenu(menu) {
+    this.#submenus.add(menu);
+    new EventsController(menu).add("open", this.#onSubmenuOpenBind).add("close", this.#onSubmenuCloseBind);
+    onDispose(this.#removeSubmenuBind);
+  }
+  #removeSubmenuBind = this.#removeSubmenu.bind(this);
+  #removeSubmenu(menu) {
+    this.#submenus.delete(menu);
+  }
+  #isSubmenuOpen = false;
+  #onSubmenuOpenBind = this.#onSubmenuOpen.bind(this);
+  #onSubmenuOpen(event) {
+    this.#isSubmenuOpen = true;
+    const content = this.#content();
+    if (this.isSubmenu) {
+      this.triggerElement?.setAttribute("aria-hidden", "true");
+    }
+    for (const target of this.#submenus) {
+      if (target !== event.target) {
+        for (const el of [target.el, target.triggerElement]) {
+          el?.setAttribute("aria-hidden", "true");
+        }
+      }
+    }
+    if (content) {
+      const el = event.target.el;
+      for (const child of content.children) {
+        if (child.contains(el)) {
+          child.setAttribute("data-open", "");
+        } else if (child !== el) {
+          child.setAttribute("data-hidden", "");
+        }
+      }
+    }
+  }
+  #onSubmenuCloseBind = this.#onSubmenuClose.bind(this);
+  #onSubmenuClose(event) {
+    this.#isSubmenuOpen = false;
+    const content = this.#content();
+    if (this.isSubmenu) {
+      this.triggerElement?.setAttribute("aria-hidden", "false");
+    }
+    for (const target of this.#submenus) {
+      for (const el of [target.el, target.triggerElement]) {
+        el?.setAttribute("aria-hidden", "false");
+      }
+    }
+    if (content) {
+      for (const child of content.children) {
+        child.removeAttribute("data-open");
+        child.removeAttribute("data-hidden");
+      }
+    }
+  }
+  #onResize = animationFrameThrottle(() => {
+    const content = peek(this.#content);
+    if (!content || IS_SERVER) return;
+    let height = 0, styles = getComputedStyle(content), children = [...content.children];
+    for (const prop2 of ["paddingTop", "paddingBottom", "borderTopWidth", "borderBottomWidth"]) {
+      height += parseFloat(styles[prop2]) || 0;
+    }
+    for (const child of children) {
+      if (isHTMLElement(child) && child.style.display === "contents") {
+        children.push(...child.children);
+      } else if (child.nodeType === 3) {
+        height += parseFloat(getComputedStyle(child).fontSize);
+      } else if (isHTMLElement(child)) {
+        if (!isElementVisible(child)) continue;
+        const style = getComputedStyle(child);
+        height += child.offsetHeight + (parseFloat(style.marginTop) || 0) + (parseFloat(style.marginBottom) || 0);
+      }
+    }
+    setStyle(content, "--menu-height", height + "px");
+  });
+  #isTransitionActive = false;
+  #onResizeTransition(event) {
+    const content = this.#content();
+    if (content && event.propertyName === "height") {
+      this.#isTransitionActive = event.type === "transitionstart";
+      setAttribute(content, "data-transition", this.#isTransitionActive ? "height" : null);
+      if (this.#expanded()) this.#updateFocus();
+    }
+    for (const callback of this.#transitionCallbacks) callback(event);
+  }
+  open(trigger) {
+    if (peek(this.#expanded)) return;
+    this.#popper.show(trigger);
+    tick();
+  }
+  close(trigger) {
+    if (!peek(this.#expanded)) return;
+    this.#popper.hide(trigger);
+    tick();
+  }
+}
+__decorateClass([
+  prop
+], Menu.prototype, "triggerElement");
+__decorateClass([
+  prop
+], Menu.prototype, "contentElement");
+__decorateClass([
+  prop
+], Menu.prototype, "isSubmenu");
+__decorateClass([
+  method
+], Menu.prototype, "open");
+__decorateClass([
+  method
+], Menu.prototype, "close");
+
+class MenuButton extends Component {
+  static props = {
+    disabled: false
+  };
+  #menu;
+  #hintEl = signal(null);
+  get expanded() {
+    return this.#menu?.expanded() ?? false;
+  }
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#menu = useContext(menuContext);
+  }
+  onAttach(el) {
+    this.#menu.attachMenuButton(this);
+    effect(this.#watchDisabled.bind(this));
+    setAttributeIfEmpty(el, "type", "button");
+  }
+  onConnect(el) {
+    effect(this.#watchHintEl.bind(this));
+    this.#onMutation();
+    const mutations = new MutationObserver(this.#onMutation.bind(this));
+    mutations.observe(el, { attributeFilter: ["data-part"], childList: true, subtree: true });
+    onDispose(() => mutations.disconnect());
+    onPress(el, (trigger) => {
+      this.dispatch("select", { trigger });
+    });
+  }
+  #watchDisabled() {
+    this.#menu.disableMenuButton(this.$props.disabled());
+  }
+  #watchHintEl() {
+    const el = this.#hintEl();
+    if (!el) return;
+    effect(() => {
+      const text = this.#menu.hint();
+      if (text) el.textContent = text;
+    });
+  }
+  #onMutation() {
+    const hintEl = this.el?.querySelector('[data-part="hint"]');
+    this.#hintEl.set(hintEl ?? null);
+  }
+}
+const menubutton__proto = MenuButton.prototype;
+prop(menubutton__proto, "expanded");
+
+class MenuItem extends MenuButton {
+}
+
+class MenuPortal extends Component {
+  static props = {
+    container: null,
+    disabled: false
+  };
+  #target = null;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(menuPortalContext, {
+      attach: this.#attachElement.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  // Need this so connect scope is defined.
+  onConnect(el) {
+  }
+  onDestroy() {
+    this.#target?.remove();
+    this.#target = null;
+  }
+  #attachElement(el) {
+    this.#portal(false);
+    this.#target = el;
+    requestScopedAnimationFrame(() => {
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        effect(this.#watchDisabled.bind(this));
+      });
+    });
+  }
+  #watchDisabled() {
+    const { fullscreen } = this.#media.$state, { disabled } = this.$props;
+    this.#portal(disabled() === "fullscreen" ? !fullscreen() : !disabled());
+  }
+  #portal(shouldPortal) {
+    if (!this.#target) return;
+    let container = this.#getContainer(this.$props.container());
+    if (!container) return;
+    const isPortalled = this.#target.parentElement === container;
+    setAttribute(this.#target, "data-portal", shouldPortal);
+    if (shouldPortal) {
+      if (!isPortalled) {
+        this.#target.remove();
+        container.append(this.#target);
+      }
+    } else if (isPortalled && this.#target.parentElement === container) {
+      this.#target.remove();
+      this.el?.append(this.#target);
+    }
+  }
+  #getContainer(selector) {
+    if (isHTMLElement(selector)) return selector;
+    return selector ? document.querySelector(selector) : document.body;
+  }
+}
+const menuPortalContext = createContext();
+
+class MenuItems extends Component {
+  static props = {
+    placement: null,
+    offset: 0,
+    alignOffset: 0
+  };
+  #menu;
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { placement } = this.$props;
+    this.setAttributes({
+      "data-placement": placement
+    });
+  }
+  onAttach(el) {
+    this.#menu = useContext(menuContext);
+    this.#menu.attachMenuItems(this);
+    if (hasProvidedContext(menuPortalContext)) {
+      const portal = useContext(menuPortalContext);
+      if (portal) {
+        provideContext(menuPortalContext, null);
+        portal.attach(el);
+        onDispose(() => portal.attach(null));
+      }
+    }
+  }
+  onConnect(el) {
+    effect(this.#watchPlacement.bind(this));
+  }
+  #watchPlacement() {
+    const { expanded } = this.#menu;
+    if (!this.el || !expanded()) return;
+    const placement = this.$props.placement();
+    if (!placement) return;
+    Object.assign(this.el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+    const { offset: mainOffset, alignOffset } = this.$props;
+    onDispose(
+      autoPlacement(this.el, this.#getButton(), placement, {
+        offsetVarName: "media-menu",
+        xOffset: alignOffset(),
+        yOffset: mainOffset()
+      })
+    );
+    onDispose(this.#hide.bind(this));
+  }
+  #hide() {
+    if (!this.el) return;
+    this.el.removeAttribute("style");
+    this.el.style.display = "none";
+  }
+  #getButton() {
+    return this.#menu.button();
+  }
+}
+
+const radioControllerContext = createContext();
+
+class RadioGroupController extends ViewController {
+  #group = /* @__PURE__ */ new Set();
+  #value = signal("");
+  #controller = null;
+  onValueChange;
+  get values() {
+    return Array.from(this.#group).map((radio) => radio.value());
+  }
+  get value() {
+    return this.#value();
+  }
+  set value(value) {
+    this.#onChange(value);
+  }
+  onSetup() {
+    provideContext(radioControllerContext, {
+      add: this.#addRadio.bind(this),
+      remove: this.#removeRadio.bind(this)
+    });
+  }
+  onAttach(el) {
+    const isMenuItem = hasProvidedContext(menuContext);
+    if (!isMenuItem) setAttributeIfEmpty(el, "role", "radiogroup");
+    this.setAttributes({ value: this.#value });
+  }
+  onDestroy() {
+    this.#group.clear();
+  }
+  #addRadio(radio) {
+    if (this.#group.has(radio)) return;
+    this.#group.add(radio);
+    radio.onCheck = this.#onChangeBind;
+    radio.check(radio.value() === this.#value());
+  }
+  #removeRadio(radio) {
+    radio.onCheck = null;
+    this.#group.delete(radio);
+  }
+  #onChangeBind = this.#onChange.bind(this);
+  #onChange(newValue, trigger) {
+    const currentValue = peek(this.#value);
+    if (!newValue || newValue === currentValue) return;
+    const currentRadio = this.#findRadio(currentValue), newRadio = this.#findRadio(newValue);
+    currentRadio?.check(false, trigger);
+    newRadio?.check(true, trigger);
+    this.#value.set(newValue);
+    this.onValueChange?.(newValue, trigger);
+  }
+  #findRadio(newValue) {
+    for (const radio of this.#group) {
+      if (newValue === peek(radio.value)) return radio;
+    }
+    return null;
+  }
+}
+
+class RadioGroup extends Component {
+  static props = {
+    value: ""
+  };
+  #controller;
+  /**
+   * A list of radio values that belong this group.
+   */
+  get values() {
+    return this.#controller.values;
+  }
+  /**
+   * The radio value that is checked in this group.
+   */
+  get value() {
+    return this.#controller.value;
+  }
+  set value(newValue) {
+    this.#controller.value = newValue;
+  }
+  constructor() {
+    super();
+    this.#controller = new RadioGroupController();
+    this.#controller.onValueChange = this.#onValueChange.bind(this);
+  }
+  onSetup() {
+    if (IS_SERVER) this.#watchValue();
+    else effect(this.#watchValue.bind(this));
+  }
+  #watchValue() {
+    this.#controller.value = this.$props.value();
+  }
+  #onValueChange(value, trigger) {
+    const event = this.createEvent("change", { detail: value, trigger });
+    this.dispatch(event);
+  }
+}
+const radiogroup__proto = RadioGroup.prototype;
+prop(radiogroup__proto, "values");
+prop(radiogroup__proto, "value");
+
+class Radio extends Component {
+  static props = {
+    value: ""
+  };
+  #checked = signal(false);
+  #controller = {
+    value: this.$props.value,
+    check: this.#check.bind(this),
+    onCheck: null
+  };
+  /**
+   * Whether this radio is currently checked.
+   */
+  get checked() {
+    return this.#checked();
+  }
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.setAttributes({
+      value: this.$props.value,
+      "data-checked": this.#checked,
+      "aria-checked": $ariaBool(this.#checked)
+    });
+  }
+  onAttach(el) {
+    const isMenuItem = hasProvidedContext(menuContext);
+    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
+    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitemradio" : "radio");
+    effect(this.#watchValue.bind(this));
+  }
+  onConnect(el) {
+    this.#addToGroup();
+    onPress(el, this.#onPress.bind(this));
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  #onDisconnect() {
+    scoped(() => {
+      const group = useContext(radioControllerContext);
+      group.remove(this.#controller);
+    }, this.connectScope);
+  }
+  #addToGroup() {
+    const group = useContext(radioControllerContext);
+    group.add(this.#controller);
+  }
+  #watchValue() {
+    const { value } = this.$props, newValue = value();
+    if (peek(this.#checked)) {
+      this.#controller.onCheck?.(newValue);
+    }
+  }
+  #onPress(event) {
+    if (peek(this.#checked)) return;
+    this.#onChange(true, event);
+    this.#onSelect(event);
+    this.#controller.onCheck?.(peek(this.$props.value), event);
+  }
+  #check(value, trigger) {
+    if (peek(this.#checked) === value) return;
+    this.#onChange(value, trigger);
+  }
+  #onChange(value, trigger) {
+    this.#checked.set(value);
+    this.dispatch("change", { detail: value, trigger });
+  }
+  #onSelect(trigger) {
+    this.dispatch("select", { trigger });
+  }
+}
+const radio__proto = Radio.prototype;
+prop(radio__proto, "checked");
+
+class Gesture extends Component {
+  static props = {
+    disabled: false,
+    event: void 0,
+    action: void 0
+  };
+  #media;
+  #provider = null;
+  onSetup() {
+    this.#media = useMediaContext();
+    const { event, action } = this.$props;
+    this.setAttributes({
+      event,
+      action
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-gesture", "");
+    el.style.setProperty("pointer-events", "none");
+  }
+  onConnect(el) {
+    this.#provider = this.#media.player.el?.querySelector(
+      "[data-media-provider]"
+    );
+    effect(this.#attachListener.bind(this));
+  }
+  #attachListener() {
+    let eventType = this.$props.event(), disabled = this.$props.disabled();
+    if (!this.#provider || !eventType || disabled) return;
+    if (/^dbl/.test(eventType)) {
+      eventType = eventType.split(/^dbl/)[1];
+    }
+    if (eventType === "pointerup" || eventType === "pointerdown") {
+      const pointer = this.#media.$state.pointer();
+      if (pointer === "coarse") {
+        eventType = eventType === "pointerup" ? "touchend" : "touchstart";
+      }
+    }
+    listenEvent(
+      this.#provider,
+      eventType,
+      this.#acceptEvent.bind(this),
+      { passive: false }
+    );
+  }
+  #presses = 0;
+  #pressTimerId = -1;
+  #acceptEvent(event) {
+    if (this.$props.disabled() || isPointerEvent(event) && (event.button !== 0 || this.#media.activeMenu) || isTouchEvent(event) && this.#media.activeMenu || isTouchPinchEvent(event) || !this.#inBounds(event)) {
+      return;
+    }
+    event.MEDIA_GESTURE = true;
+    event.preventDefault();
+    const eventType = peek(this.$props.event), isDblEvent = eventType?.startsWith("dbl");
+    if (!isDblEvent) {
+      if (this.#presses === 0) {
+        setTimeout(() => {
+          if (this.#presses === 1) this.#handleEvent(event);
+        }, 250);
+      }
+    } else if (this.#presses === 1) {
+      queueMicrotask(() => this.#handleEvent(event));
+      clearTimeout(this.#pressTimerId);
+      this.#presses = 0;
+      return;
+    }
+    if (this.#presses === 0) {
+      this.#pressTimerId = window.setTimeout(() => {
+        this.#presses = 0;
+      }, 275);
+    }
+    this.#presses++;
+  }
+  #handleEvent(event) {
+    this.el.setAttribute("data-triggered", "");
+    requestAnimationFrame(() => {
+      if (this.#isTopLayer()) {
+        this.#performAction(peek(this.$props.action), event);
+      }
+      requestAnimationFrame(() => {
+        this.el.removeAttribute("data-triggered");
+      });
+    });
+  }
+  /** Validate event occurred in gesture bounds. */
+  #inBounds(event) {
+    if (!this.el) return false;
+    if (isPointerEvent(event) || isMouseEvent(event) || isTouchEvent(event)) {
+      const touch = isTouchEvent(event) ? event.changedTouches[0] ?? event.touches[0] : void 0;
+      const clientX = touch?.clientX ?? event.clientX;
+      const clientY = touch?.clientY ?? event.clientY;
+      const rect = this.el.getBoundingClientRect();
+      const inBounds = clientY >= rect.top && clientY <= rect.bottom && clientX >= rect.left && clientX <= rect.right;
+      return event.type.includes("leave") ? !inBounds : inBounds;
+    }
+    return true;
+  }
+  /** Validate gesture has the highest z-index in this triggered group. */
+  #isTopLayer() {
+    const gestures = this.#media.player.el.querySelectorAll(
+      "[data-media-gesture][data-triggered]"
+    );
+    return Array.from(gestures).sort(
+      (a, b) => +getComputedStyle(b).zIndex - +getComputedStyle(a).zIndex
+    )[0] === this.el;
+  }
+  #performAction(action, trigger) {
+    if (!action) return;
+    const willTriggerEvent = new DOMEvent("will-trigger", {
+      detail: action,
+      cancelable: true,
+      trigger
+    });
+    this.dispatchEvent(willTriggerEvent);
+    if (willTriggerEvent.defaultPrevented) return;
+    const [method, value] = action.replace(/:([a-z])/, "-$1").split(":");
+    if (action.includes(":fullscreen")) {
+      this.#media.remote.toggleFullscreen("prefer-media", trigger);
+    } else if (action.includes("seek:")) {
+      this.#media.remote.seek(peek(this.#media.$state.currentTime) + (+value || 0), trigger);
+    } else {
+      this.#media.remote[kebabToCamelCase(method)](trigger);
+    }
+    this.dispatch("trigger", {
+      detail: action,
+      trigger
+    });
+  }
+}
+
+class CaptionsTextRenderer {
+  priority = 10;
+  #track = null;
+  #renderer;
+  #events;
+  constructor(renderer) {
+    this.#renderer = renderer;
+  }
+  attach() {
+  }
+  canRender() {
+    return true;
+  }
+  detach() {
+    this.#events?.abort();
+    this.#events = void 0;
+    this.#renderer.reset();
+    this.#track = null;
+  }
+  changeTrack(track) {
+    if (!track || this.#track === track) return;
+    this.#events?.abort();
+    this.#events = new EventsController(track);
+    if (track.readyState < 2) {
+      this.#renderer.reset();
+      this.#events.add("load", () => this.#changeTrack(track), { once: true });
+    } else {
+      this.#changeTrack(track);
+    }
+    this.#events.add("add-cue", (event) => {
+      this.#renderer.addCue(event.detail);
+    }).add("remove-cue", (event) => {
+      this.#renderer.removeCue(event.detail);
+    });
+    this.#track = track;
+  }
+  #changeTrack(track) {
+    this.#renderer.changeTrack({
+      cues: [...track.cues],
+      regions: [...track.regions]
+    });
+  }
+}
+
+class Captions extends Component {
+  static props = {
+    textDir: "ltr",
+    exampleText: "Captions look like this."
+  };
+  #media;
+  static lib = signal(null);
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "aria-hidden": $ariaBool(this.#isHidden.bind(this))
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("pointer-events", "none");
+  }
+  onConnect(el) {
+    if (!Captions.lib()) {
+      import('media-captions').then((lib) => Captions.lib.set(lib));
+    }
+    effect(this.#watchViewType.bind(this));
+  }
+  #isHidden() {
+    const { textTrack, remotePlaybackState, iOSControls } = this.#media.$state, track = textTrack();
+    return iOSControls() || remotePlaybackState() === "connected" || !track || !isTrackCaptionKind(track);
+  }
+  #watchViewType() {
+    if (!Captions.lib()) return;
+    const { viewType } = this.#media.$state;
+    if (viewType() === "audio") {
+      return this.#setupAudioView();
+    } else {
+      return this.#setupVideoView();
+    }
+  }
+  #setupAudioView() {
+    effect(this.#onTrackChange.bind(this));
+    this.#listenToFontStyleChanges(null);
+    return () => {
+      this.el.textContent = "";
+    };
+  }
+  #onTrackChange() {
+    if (this.#isHidden()) return;
+    this.#onCueChange();
+    const { textTrack } = this.#media.$state;
+    listenEvent(textTrack(), "cue-change", this.#onCueChange.bind(this));
+    effect(this.#onUpdateTimedNodes.bind(this));
+  }
+  #onCueChange() {
+    this.el.textContent = "";
+    if (this.#hideExampleTimer >= 0) {
+      this.#removeExample();
+    }
+    const { realCurrentTime, textTrack } = this.#media.$state, { renderVTTCueString } = Captions.lib(), time = peek(realCurrentTime), activeCues = peek(textTrack).activeCues;
+    for (const cue of activeCues) {
+      const displayEl = this.#createCueDisplayElement(), cueEl = this.#createCueElement();
+      cueEl.innerHTML = renderVTTCueString(cue, time);
+      displayEl.append(cueEl);
+      this.el.append(cueEl);
+    }
+  }
+  #onUpdateTimedNodes() {
+    const { realCurrentTime } = this.#media.$state, { updateTimedVTTCueNodes } = Captions.lib();
+    updateTimedVTTCueNodes(this.el, realCurrentTime());
+  }
+  #setupVideoView() {
+    const { CaptionsRenderer } = Captions.lib(), renderer = new CaptionsRenderer(this.el), textRenderer = new CaptionsTextRenderer(renderer);
+    this.#media.textRenderers.add(textRenderer);
+    effect(this.#watchTextDirection.bind(this, renderer));
+    effect(this.#watchMediaTime.bind(this, renderer));
+    this.#listenToFontStyleChanges(renderer);
+    return () => {
+      this.el.textContent = "";
+      this.#media.textRenderers.remove(textRenderer);
+      renderer.destroy();
+    };
+  }
+  #watchTextDirection(renderer) {
+    renderer.dir = this.$props.textDir();
+  }
+  #watchMediaTime(renderer) {
+    if (this.#isHidden()) return;
+    const { realCurrentTime, textTrack } = this.#media.$state;
+    renderer.currentTime = realCurrentTime();
+    if (this.#hideExampleTimer >= 0 && textTrack()?.activeCues[0]) {
+      this.#removeExample();
+    }
+  }
+  #listenToFontStyleChanges(renderer) {
+    const player = this.#media.player;
+    if (!player) return;
+    const onChange = this.#onFontStyleChange.bind(this, renderer);
+    listenEvent(player, "vds-font-change", onChange);
+  }
+  #onFontStyleChange(renderer) {
+    if (this.#hideExampleTimer >= 0) {
+      this.#hideExample();
+      return;
+    }
+    const { textTrack } = this.#media.$state;
+    if (!textTrack()?.activeCues[0]) {
+      this.#showExample();
+    } else {
+      renderer?.update(true);
+    }
+  }
+  #showExample() {
+    const display = this.#createCueDisplayElement();
+    setAttribute(display, "data-example", "");
+    const cue = this.#createCueElement();
+    setAttribute(cue, "data-example", "");
+    cue.textContent = this.$props.exampleText();
+    display?.append(cue);
+    this.el?.append(display);
+    this.el?.setAttribute("data-example", "");
+    this.#hideExample();
+  }
+  #hideExampleTimer = -1;
+  #hideExample() {
+    window.clearTimeout(this.#hideExampleTimer);
+    this.#hideExampleTimer = window.setTimeout(this.#removeExample.bind(this), 2500);
+  }
+  #removeExample() {
+    this.el?.removeAttribute("data-example");
+    if (this.el?.querySelector("[data-example]")) this.el.textContent = "";
+    this.#hideExampleTimer = -1;
+  }
+  #createCueDisplayElement() {
+    const el = document.createElement("div");
+    setAttribute(el, "data-part", "cue-display");
+    return el;
+  }
+  #createCueElement() {
+    const el = document.createElement("div");
+    setAttribute(el, "data-part", "cue");
+    return el;
+  }
+}
+
+class Poster extends Component {
+  static props = {
+    src: null,
+    alt: null,
+    crossOrigin: null
+  };
+  static state = new State({
+    img: null,
+    src: null,
+    alt: null,
+    crossOrigin: null,
+    loading: true,
+    error: null,
+    hidden: false
+  });
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#watchSrc();
+    this.#watchAlt();
+    this.#watchCrossOrigin();
+    this.#watchHidden();
+  }
+  onAttach(el) {
+    el.style.setProperty("pointer-events", "none");
+    effect(this.#watchImg.bind(this));
+    effect(this.#watchSrc.bind(this));
+    effect(this.#watchAlt.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#watchHidden.bind(this));
+    const { started } = this.#media.$state;
+    this.setAttributes({
+      "data-visible": () => !started() && !this.$state.hidden(),
+      "data-loading": this.#isLoading.bind(this),
+      "data-error": this.#hasError.bind(this),
+      "data-hidden": this.$state.hidden
+    });
+  }
+  onConnect(el) {
+    effect(this.#onPreconnect.bind(this));
+    effect(this.#onLoadStart.bind(this));
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error());
+  }
+  #onPreconnect() {
+    const { canLoadPoster, poster } = this.#media.$state;
+    if (!canLoadPoster() && poster()) preconnect(poster(), "preconnect");
+  }
+  #watchHidden() {
+    const { src } = this.$props, { poster, nativeControls } = this.#media.$state;
+    this.el && setAttribute(this.el, "display", nativeControls() ? "none" : null);
+    this.$state.hidden.set(this.#hasError() || !(src() || poster()) || nativeControls());
+  }
+  #isLoading() {
+    const { loading, hidden } = this.$state;
+    return !hidden() && loading();
+  }
+  #watchImg() {
+    const img = this.$state.img();
+    if (!img) return;
+    new EventsController(img).add("load", this.#onLoad.bind(this)).add("error", this.#onError.bind(this));
+    if (img.complete) this.#onLoad();
+  }
+  #prevSrc = "";
+  #watchSrc() {
+    const { poster: defaultPoster } = this.#media.$props, { canLoadPoster, providedPoster, inferredPoster } = this.#media.$state;
+    const src = this.$props.src() || "", poster = src || defaultPoster() || inferredPoster();
+    if (this.#prevSrc === providedPoster()) {
+      providedPoster.set(src);
+    }
+    this.$state.src.set(canLoadPoster() && poster.length ? poster : null);
+    this.#prevSrc = src;
+  }
+  #watchAlt() {
+    const { src } = this.$props, { alt } = this.$state, { poster } = this.#media.$state;
+    alt.set(src() || poster() ? this.$props.alt() : null);
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin, poster: src } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(
+      /ytimg\.com|vimeo/.test(src() || "") ? null : crossOrigin === true ? "anonymous" : crossOrigin
+    );
+  }
+  #onLoadStart() {
+    const { loading, error } = this.$state, { canLoadPoster, poster } = this.#media.$state;
+    loading.set(canLoadPoster() && !!poster());
+    error.set(null);
+  }
+  #onLoad() {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(null);
+  }
+  #onError(event) {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(event);
+  }
+}
+
+class Time extends Component {
+  static props = {
+    type: "current",
+    showHours: false,
+    padHours: null,
+    padMinutes: null,
+    remainder: false,
+    toggle: false,
+    hidden: false
+  };
+  static state = new State({
+    timeText: "",
+    hidden: false
+  });
+  #media;
+  #invert = signal(null);
+  #isVisible = signal(true);
+  #isIntersecting = signal(true);
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#watchTime();
+    const { type } = this.$props;
+    this.setAttributes({
+      "data-type": type,
+      "data-remainder": this.#shouldInvert.bind(this)
+    });
+    new IntersectionObserverController({
+      callback: this.#onIntersectionChange.bind(this)
+    }).attach(this);
+  }
+  onAttach(el) {
+    if (!el.hasAttribute("role")) effect(this.#watchRole.bind(this));
+    effect(this.#watchTime.bind(this));
+  }
+  onConnect(el) {
+    onDispose(observeVisibility(el, this.#isVisible.set));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#watchToggle.bind(this));
+  }
+  #onIntersectionChange(entries) {
+    this.#isIntersecting.set(entries[0].isIntersecting);
+  }
+  #watchHidden() {
+    const { hidden } = this.$props;
+    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting());
+  }
+  #watchToggle() {
+    if (!this.$props.toggle()) {
+      this.#invert.set(null);
+      return;
+    }
+    if (this.el) {
+      onPress(this.el, this.#onToggle.bind(this));
+    }
+  }
+  #watchTime() {
+    const { hidden, timeText } = this.$state, { duration } = this.#media.$state;
+    if (hidden()) return;
+    const { type, padHours, padMinutes, showHours } = this.$props, seconds = this.#getSeconds(type()), $duration = duration(), shouldInvert = this.#shouldInvert();
+    if (!Number.isFinite(seconds + $duration)) {
+      timeText.set("LIVE");
+      return;
+    }
+    const time = shouldInvert ? Math.max(0, $duration - seconds) : seconds, formattedTime = formatTime(time, {
+      padHrs: padHours(),
+      padMins: padMinutes(),
+      showHrs: showHours()
+    });
+    timeText.set((shouldInvert ? "-" : "") + formattedTime);
+  }
+  #watchRole() {
+    if (!this.el) return;
+    const { toggle } = this.$props;
+    setAttribute(this.el, "role", toggle() ? "timer" : null);
+    setAttribute(this.el, "tabindex", toggle() ? 0 : null);
+  }
+  #getSeconds(type) {
+    const { bufferedEnd, duration, currentTime } = this.#media.$state;
+    switch (type) {
+      case "buffered":
+        return bufferedEnd();
+      case "duration":
+        return duration();
+      default:
+        return currentTime();
+    }
+  }
+  #shouldInvert() {
+    return this.$props.remainder() && this.#invert() !== false;
+  }
+  #onToggle(event) {
+    event.preventDefault();
+    if (this.#invert() === null) {
+      this.#invert.set(!this.$props.remainder());
+      return;
+    }
+    this.#invert.set((v) => !v);
+  }
+}
+
+class MediaPlayerInstance extends MediaPlayer {
+}
+class MediaProviderInstance extends MediaProvider {
+}
+class MediaAnnouncerInstance extends MediaAnnouncer {
+}
+class ControlsInstance extends Controls {
+}
+class ControlsGroupInstance extends ControlsGroup {
+}
+class ToggleButtonInstance extends ToggleButton {
+}
+class CaptionButtonInstance extends CaptionButton {
+}
+class FullscreenButtonInstance extends FullscreenButton {
+}
+class LiveButtonInstance extends LiveButton {
+}
+class MuteButtonInstance extends MuteButton {
+}
+class PIPButtonInstance extends PIPButton {
+}
+class PlayButtonInstance extends PlayButton {
+}
+class AirPlayButtonInstance extends AirPlayButton {
+}
+class GoogleCastButtonInstance extends GoogleCastButton {
+}
+class SeekButtonInstance extends SeekButton {
+}
+class TooltipInstance extends Tooltip {
+}
+class TooltipTriggerInstance extends TooltipTrigger {
+}
+class TooltipContentInstance extends TooltipContent {
+}
+class SliderInstance extends Slider {
+}
+class TimeSliderInstance extends TimeSlider {
+}
+class VolumeSliderInstance extends VolumeSlider {
+}
+class AudioGainSliderInstance extends AudioGainSlider {
+}
+class SpeedSliderInstance extends SpeedSlider {
+}
+class QualitySliderInstance extends QualitySlider {
+}
+class SliderThumbnailInstance extends SliderThumbnail {
+}
+class SliderValueInstance extends SliderValue {
+}
+class SliderVideoInstance extends SliderVideo {
+}
+class SliderPreviewInstance extends SliderPreview {
+}
+class SliderChaptersInstance extends SliderChapters {
+}
+class MenuInstance extends Menu {
+}
+class MenuButtonInstance extends MenuButton {
+}
+class MenuItemsInstance extends MenuItems {
+}
+class MenuItemInstance extends MenuItem {
+}
+class MenuPortalInstance extends MenuPortal {
+}
+class RadioGroupInstance extends RadioGroup {
+}
+class RadioInstance extends Radio {
+}
+class CaptionsInstance extends Captions {
+}
+class GestureInstance extends Gesture {
+}
+class PosterInstance extends Poster {
+}
+class ThumbnailInstance extends Thumbnail {
+}
+class TimeInstance extends Time {
+}
+
+const Slot = React.forwardRef((props, forwardedRef) => {
+  const { children, ...slotProps } = props;
+  const childrenArray = React.Children.toArray(children);
+  const slottable = childrenArray.find(isSlottable);
+  if (slottable) {
+    const newElement = slottable.props.children;
+    const newChildren = childrenArray.map((child) => {
+      if (child === slottable) {
+        if (React.Children.count(newElement) > 1) return React.Children.only(null);
+        return React.isValidElement(newElement) ? newElement.props.children : null;
+      } else {
+        return child;
+      }
+    });
+    return /* @__PURE__ */ React.createElement(SlotClone, { ...slotProps, ref: forwardedRef }, React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null);
+  }
+  return /* @__PURE__ */ React.createElement(SlotClone, { ...slotProps, ref: forwardedRef }, children);
+});
+Slot.displayName = "Slot";
+const SlotClone = React.forwardRef((props, forwardedRef) => {
+  const { children, ...slotProps } = props;
+  if (React.isValidElement(children)) {
+    return React.cloneElement(children, {
+      ...mergeProps(slotProps, children.props),
+      ref: forwardedRef ? composeRefs(forwardedRef, children.ref) : children.ref
+    });
+  }
+  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
+});
+SlotClone.displayName = "SlotClone";
+const Slottable = ({ children }) => {
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
+};
+function isSlottable(child) {
+  return React.isValidElement(child) && child.type === Slottable;
+}
+function mergeProps(slotProps, childProps) {
+  const overrideProps = { ...childProps };
+  for (const propName in childProps) {
+    const slotPropValue = slotProps[propName];
+    const childPropValue = childProps[propName];
+    const isHandler = /^on[A-Z]/.test(propName);
+    if (isHandler) {
+      if (slotPropValue && childPropValue) {
+        overrideProps[propName] = (...args) => {
+          childPropValue(...args);
+          slotPropValue(...args);
+        };
+      } else if (slotPropValue) {
+        overrideProps[propName] = slotPropValue;
+      }
+    } else if (propName === "style") {
+      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
+    } else if (propName === "className") {
+      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
+    }
+  }
+  return { ...slotProps, ...overrideProps };
+}
+
+const NODES = ["button", "div", "span", "img", "video", "audio"];
+const Primitive = NODES.reduce((primitives, node) => {
+  const Node = React.forwardRef((props, forwardedRef) => {
+    const { asChild, ...primitiveProps } = props;
+    const Comp = asChild ? Slot : node;
+    return /* @__PURE__ */ React.createElement(Comp, { ...primitiveProps, ref: forwardedRef });
+  });
+  Node.displayName = `Primitive.${node}`;
+  return { ...primitives, [node]: Node };
+}, {});
+
+function isRemotionProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "REMOTION";
+}
+function isRemotionSrc(src) {
+  return src?.type === "video/remotion";
+}
+
+const sliderStateRecord = SliderInstance.state.record, initialSliderStore = Object.keys(sliderStateRecord).reduce(
+  (store, prop) => ({
+    ...store,
+    [prop]() {
+      return sliderStateRecord[prop];
+    }
+  }),
+  {}
+);
+function useSliderState(prop, ref) {
+  const $state = useStateContext(sliderState);
+  if (!$state && !ref) {
+    console.warn(
+      `[vidstack] \`useSliderState\` requires \`RefObject<SliderInstance>\` argument if called outside of a slider component`
+    );
+  }
+  return useSignal((ref?.current?.$state || $state || initialSliderStore)[prop]);
+}
+function useSliderStore(ref) {
+  const $state = useStateContext(sliderState);
+  if (!$state && !ref) {
+    console.warn(
+      `[vidstack] \`useSliderStore\` requires \`RefObject<SliderInstance>\` argument if called outside of a slider component`
+    );
+  }
+  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialSliderStore);
+}
+
+const mediaStateRecord = MediaPlayerInstance.state.record, initialMediaStore = Object.keys(mediaStateRecord).reduce(
+  (store, prop) => ({
+    ...store,
+    [prop]() {
+      return mediaStateRecord[prop];
+    }
+  }),
+  {}
+);
+function useMediaState(prop, ref) {
+  const $state = useStateContext(mediaState);
+  if (!$state && !ref) {
+    console.warn(
+      `[vidstack] \`useMediaState\` requires \`RefObject<MediaPlayerInstance>\` argument if called outside the \`<MediaPlayer>\` component`
+    );
+  }
+  return useSignal((ref?.current?.$state || $state || initialMediaStore)[prop]);
+}
+function useMediaStore(ref) {
+  const $state = useStateContext(mediaState);
+  if (!$state && !ref) {
+    console.warn(
+      `[vidstack] \`useMediaStore\` requires \`RefObject<MediaPlayerInstance>\` argument if called outside the \`<MediaPlayer>\` component`
+    );
+  }
+  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialMediaStore);
+}
+
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLAirPlayAdapter, HTMLMediaProvider, IS_CHROME, IS_IOS, IS_SERVER, List, ListSymbol, LiveButtonInstance, LocalMediaStorage, Logger, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaPlayerInstance, MediaProviderInstance, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, Primitive, QualitySliderInstance, QualitySymbol, RAFLoop, RadioGroupController, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrack, TextTrackList, TextTrackSymbol, ThumbnailInstance, ThumbnailsLoader, TimeInstance, TimeRange, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProvider, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, appendParamsToURL, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, coerceToError, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHLSSupported, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isRemotionProvider, isRemotionSrc, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, loadScript, mediaContext, mediaState, menuContext, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, preconnect, sliderState, softResetMediaState, sortVideoQualities, updateSliderPreviewPlacement, updateTimeIntervals, useMediaContext, useMediaState, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange };
diff --git a/dev/chunks/vidstack-CXTsWYwn.js b/dev/chunks/vidstack-Bi0kLSoB.js
similarity index 98%
rename from dev/chunks/vidstack-CXTsWYwn.js
rename to dev/chunks/vidstack-Bi0kLSoB.js
index 637c26b4998394cd9f12a527e8d28f0cb8eb4214..be8583e54b0dbc85c2ecf525dffaa6ce6e056ce9 100644
--- a/dev/chunks/vidstack-CXTsWYwn.js
+++ b/dev/chunks/vidstack-Bi0kLSoB.js
@@ -2,7 +2,7 @@
 
 import * as React from 'react';
 import { animationFrameThrottle, EventsController, listenEvent, effect } from './vidstack-CH225ns1.js';
-import { useMediaPlayer } from './vidstack-DM21n8Pk.js';
+import { useMediaPlayer } from './vidstack-DEqI2Hy1.js';
 
 function useClassName(el, className) {
   React.useEffect(() => {
diff --git a/dev/chunks/vidstack-DnVfQIbh.js b/dev/chunks/vidstack-Bk4a1y2Y.js
similarity index 98%
rename from dev/chunks/vidstack-DnVfQIbh.js
rename to dev/chunks/vidstack-Bk4a1y2Y.js
index 831f45940a0a7b6083e1062cee174d1aa4fffbf7..41ec958b1fbe1dea627df4f599c803c025a40987 100644
--- a/dev/chunks/vidstack-DnVfQIbh.js
+++ b/dev/chunks/vidstack-Bk4a1y2Y.js
@@ -1,6 +1,6 @@
 "use client"
 
-import { IS_CHROME, IS_IOS, canGoogleCastSrc, IS_SERVER, loadScript } from './vidstack-tCTk_Mpr.js';
+import { IS_CHROME, IS_IOS, canGoogleCastSrc, IS_SERVER, loadScript } from './vidstack-MAWt6ODZ.js';
 import { listenEvent, peek } from './vidstack-CH225ns1.js';
 
 function getCastFrameworkURL() {
@@ -130,7 +130,7 @@ class GoogleCastLoader {
     if (!this.#player) {
       throw Error("[vidstack] google cast player was not initialized");
     }
-    return new (await import('./vidstack-BM8_lxar.js')).GoogleCastProvider(this.#player, ctx);
+    return new (await import('./vidstack-B34LMCPL.js')).GoogleCastProvider(this.#player, ctx);
   }
   async #loadCastFramework(ctx) {
     if (hasLoadedCastFramework()) return;
diff --git a/dev/chunks/vidstack-DM21n8Pk.js b/dev/chunks/vidstack-Bn2Qk0ao.js
similarity index 99%
rename from dev/chunks/vidstack-DM21n8Pk.js
rename to dev/chunks/vidstack-Bn2Qk0ao.js
index 856dc54fc466eaf450db45ce1b9a8f7907579980..803899faa9a50df962824d313339da9e713d2214 100644
--- a/dev/chunks/vidstack-DM21n8Pk.js
+++ b/dev/chunks/vidstack-Bn2Qk0ao.js
@@ -2,7 +2,7 @@
 
 import * as React from 'react';
 import { useReactContext, createReactComponent, composeRefs, useSignal, noop, useStateContext, signal, effect, isString } from './vidstack-CH225ns1.js';
-import { mediaContext, Primitive, AirPlayButtonInstance, PlayButtonInstance, CaptionButtonInstance, FullscreenButtonInstance, MuteButtonInstance, PIPButtonInstance, SeekButtonInstance, LiveButtonInstance, SliderValueInstance, useSliderState, SliderInstance, SliderPreviewInstance, VolumeSliderInstance, IS_SERVER, ThumbnailInstance, TimeSliderInstance, SliderChaptersInstance, SliderThumbnailInstance, SliderVideoInstance, mediaState, RadioGroupInstance, RadioInstance, useMediaState, MenuInstance, MenuButtonInstance, MenuItemsInstance, MenuItemInstance, GestureInstance, TimeInstance, isTrackCaptionKind } from './vidstack-tCTk_Mpr.js';
+import { mediaContext, Primitive, AirPlayButtonInstance, PlayButtonInstance, CaptionButtonInstance, FullscreenButtonInstance, MuteButtonInstance, PIPButtonInstance, SeekButtonInstance, LiveButtonInstance, SliderValueInstance, useSliderState, SliderInstance, SliderPreviewInstance, VolumeSliderInstance, IS_SERVER, ThumbnailInstance, TimeSliderInstance, SliderChaptersInstance, SliderThumbnailInstance, SliderVideoInstance, mediaState, RadioGroupInstance, RadioInstance, useMediaState, MenuInstance, MenuButtonInstance, MenuItemsInstance, MenuItemInstance, GestureInstance, TimeInstance, isTrackCaptionKind } from './vidstack-DlEFWAGb.js';
 import { createPortal } from 'react-dom';
 
 function useMediaContext() {
diff --git a/dev/chunks/vidstack-Bofiwj54.js b/dev/chunks/vidstack-Bofiwj54.js
new file mode 100644
index 0000000000000000000000000000000000000000..6f67bad88809caf468662b714a63bbe32baf4055
--- /dev/null
+++ b/dev/chunks/vidstack-Bofiwj54.js
@@ -0,0 +1,34 @@
+"use client"
+
+import { scoped } from './vidstack-CH225ns1.js';
+import { HTMLMediaProvider, HTMLAirPlayAdapter } from './vidstack-MAWt6ODZ.js';
+import 'react';
+import '@floating-ui/dom';
+
+class AudioProvider extends HTMLMediaProvider {
+  $$PROVIDER_TYPE = "AUDIO";
+  get type() {
+    return "audio";
+  }
+  airPlay;
+  constructor(audio, ctx) {
+    super(audio, ctx);
+    scoped(() => {
+      this.airPlay = new HTMLAirPlayAdapter(this.media, ctx);
+    }, this.scope);
+  }
+  setup() {
+    super.setup();
+    if (this.type === "audio") this.ctx.notify("provider-setup", this);
+  }
+  /**
+   * The native HTML `<audio>` element.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement}
+   */
+  get audio() {
+    return this.media;
+  }
+}
+
+export { AudioProvider };
diff --git a/dev/chunks/vidstack-BwNhcxfT.js b/dev/chunks/vidstack-BwNhcxfT.js
new file mode 100644
index 0000000000000000000000000000000000000000..c101c4cc1a436c40cb359d478df539e79d0ef5f0
--- /dev/null
+++ b/dev/chunks/vidstack-BwNhcxfT.js
@@ -0,0 +1,375 @@
+"use client"
+
+import * as React from 'react';
+import { createReactComponent, composeRefs, listenEvent, useReactScope, scoped, signal, computed, effect, EventsController, useSignal } from './vidstack-CH225ns1.js';
+import { Primitive, MediaAnnouncerInstance, ControlsInstance, ControlsGroupInstance, TooltipInstance, TooltipTriggerInstance, TooltipContentInstance, GoogleCastButtonInstance, QualitySliderInstance, AudioGainSliderInstance, SpeedSliderInstance, useMediaState, watchActiveTextTrack, CaptionsInstance, formatTime, formatSpokenTime } from './vidstack-BdoOxmTD.js';
+import { sliderCallbacks, Preview, Steps, Thumb, Track as Track$1, TrackFill as TrackFill$1, Value, useMediaContext } from './vidstack-VrioNQ8t.js';
+
+const MediaAnnouncerBridge = createReactComponent(MediaAnnouncerInstance, {
+  events: ["onChange"]
+});
+const MediaAnnouncer = React.forwardRef(
+  ({ style, children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(MediaAnnouncerBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        style: { display: "contents", ...style },
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+MediaAnnouncer.displayName = "MediaAnnouncer";
+
+const ControlsBridge = createReactComponent(ControlsInstance);
+const Root$5 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ControlsBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Root$5.displayName = "Controls";
+const ControlsGroupBridge = createReactComponent(ControlsGroupInstance);
+const Group = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ControlsGroupBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Group.displayName = "ControlsGroup";
+
+var controls = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Group: Group,
+  Root: Root$5
+});
+
+const TooltipBridge = createReactComponent(TooltipInstance);
+function Root$4({ children, ...props }) {
+  return /* @__PURE__ */ React.createElement(TooltipBridge, { ...props }, children);
+}
+Root$4.displayName = "Tooltip";
+const TriggerBridge = createReactComponent(TooltipTriggerInstance);
+const Trigger = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(TriggerBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Trigger.displayName = "TooltipTrigger";
+const ContentBridge = createReactComponent(TooltipContentInstance);
+const Content = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(ContentBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Content.displayName = "TooltipContent";
+
+var tooltip = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Content: Content,
+  Root: Root$4,
+  Trigger: Trigger
+});
+
+const GoogleCastButtonBridge = createReactComponent(GoogleCastButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const GoogleCastButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(GoogleCastButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+GoogleCastButton.displayName = "GoogleCastButton";
+
+const QualitySliderBridge = createReactComponent(QualitySliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$3 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(QualitySliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$3.displayName = "QualitySlider";
+
+var qualitySlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$3,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const AudioGainSliderBridge = createReactComponent(AudioGainSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$2 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(AudioGainSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$2.displayName = "AudioGainSlider";
+
+var audioGainSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$2,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const SpeedSliderBridge = createReactComponent(SpeedSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$1 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SpeedSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$1.displayName = "SpeedSlider";
+
+var speedSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$1,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const Title = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const $title = useMediaState("title");
+  return /* @__PURE__ */ React.createElement(Primitive.span, { ...props, ref: forwardRef }, $title, children);
+});
+Title.displayName = "Title";
+
+function useActiveTextCues(track) {
+  const [activeCues, setActiveCues] = React.useState([]);
+  React.useEffect(() => {
+    if (!track) {
+      setActiveCues([]);
+      return;
+    }
+    function onCuesChange() {
+      if (track) setActiveCues(track.activeCues);
+    }
+    onCuesChange();
+    return listenEvent(track, "cue-change", onCuesChange);
+  }, [track]);
+  return activeCues;
+}
+
+function useActiveTextTrack(kind) {
+  const media = useMediaContext(), [track, setTrack] = React.useState(null);
+  React.useEffect(() => {
+    return watchActiveTextTrack(media.textTracks, kind, setTrack);
+  }, [kind]);
+  return track;
+}
+
+function useChapterTitle() {
+  const $track = useActiveTextTrack("chapters"), $cues = useActiveTextCues($track);
+  return $cues[0]?.text || "";
+}
+
+const ChapterTitle = React.forwardRef(
+  ({ defaultText = "", children, ...props }, forwardRef) => {
+    const $chapterTitle = useChapterTitle();
+    return /* @__PURE__ */ React.createElement(Primitive.span, { ...props, ref: forwardRef }, $chapterTitle || defaultText, children);
+  }
+);
+ChapterTitle.displayName = "ChapterTitle";
+
+const CaptionsBridge = createReactComponent(CaptionsInstance);
+const Captions = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(CaptionsBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Captions.displayName = "Captions";
+
+const Root = React.forwardRef(
+  ({ size = 96, children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(
+      "svg",
+      {
+        width: size,
+        height: size,
+        fill: "none",
+        viewBox: "0 0 120 120",
+        "aria-hidden": "true",
+        "data-part": "root",
+        ...props,
+        ref: forwardRef
+      },
+      children
+    );
+  }
+);
+const Track = React.forwardRef(
+  ({ width = 8, children, ...props }, ref) => /* @__PURE__ */ React.createElement(
+    "circle",
+    {
+      cx: "60",
+      cy: "60",
+      r: "54",
+      stroke: "currentColor",
+      strokeWidth: width,
+      "data-part": "track",
+      ...props,
+      ref
+    },
+    children
+  )
+);
+const TrackFill = React.forwardRef(
+  ({ width = 8, fillPercent = 50, children, ...props }, ref) => /* @__PURE__ */ React.createElement(
+    "circle",
+    {
+      cx: "60",
+      cy: "60",
+      r: "54",
+      stroke: "currentColor",
+      pathLength: "100",
+      strokeWidth: width,
+      strokeDasharray: 100,
+      strokeDashoffset: 100 - fillPercent,
+      "data-part": "track-fill",
+      ...props,
+      ref
+    },
+    children
+  )
+);
+
+var spinner = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Root: Root,
+  Track: Track,
+  TrackFill: TrackFill
+});
+
+function createSignal(initialValue, deps = []) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(() => signal(initialValue), scope), [scope, ...deps]);
+}
+function createComputed(compute, deps = []) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(() => computed(compute), scope), [scope, ...deps]);
+}
+function createEffect(compute, deps = []) {
+  const scope = useReactScope();
+  React.useEffect(() => scoped(() => effect(compute), scope), [scope, ...deps]);
+}
+function useScoped(compute) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(compute, scope), [scope]);
+}
+
+function useTextCues(track) {
+  const [cues, setCues] = React.useState([]);
+  React.useEffect(() => {
+    if (!track) return;
+    function onCuesChange() {
+      if (track) setCues([...track.cues]);
+    }
+    const events = new EventsController(track).add("add-cue", onCuesChange).add("remove-cue", onCuesChange);
+    onCuesChange();
+    return () => {
+      setCues([]);
+      events.abort();
+    };
+  }, [track]);
+  return cues;
+}
+
+function useChapterOptions() {
+  const media = useMediaContext(), track = useActiveTextTrack("chapters"), cues = useTextCues(track), $startTime = useSignal(media.$state.seekableStart), $endTime = useSignal(media.$state.seekableEnd);
+  useActiveTextCues(track);
+  return React.useMemo(() => {
+    const options = track ? cues.filter((cue) => cue.startTime <= $endTime && cue.endTime >= $startTime).map((cue, i) => {
+      let currentRef = null, stopProgressEffect;
+      return {
+        cue,
+        label: cue.text,
+        value: i.toString(),
+        startTimeText: formatTime(Math.max(0, cue.startTime - $startTime)),
+        durationText: formatSpokenTime(
+          Math.min($endTime, cue.endTime) - Math.max($startTime, cue.startTime)
+        ),
+        get selected() {
+          return cue === track.activeCues[0];
+        },
+        setProgressVar(ref) {
+          if (!ref || cue !== track.activeCues[0]) {
+            stopProgressEffect?.();
+            stopProgressEffect = void 0;
+            ref?.style.setProperty("--progress", "0%");
+            currentRef = null;
+            return;
+          }
+          if (currentRef === ref) return;
+          currentRef = ref;
+          stopProgressEffect?.();
+          stopProgressEffect = effect(() => {
+            const { realCurrentTime } = media.$state, time = realCurrentTime(), cueStartTime = Math.max($startTime, cue.startTime), duration = Math.min($endTime, cue.endTime) - cueStartTime, progress = Math.max(0, time - cueStartTime) / duration * 100;
+            ref.style.setProperty("--progress", progress.toFixed(3) + "%");
+          });
+        },
+        select(trigger) {
+          media.remote.seek(cue.startTime - $startTime, trigger);
+        }
+      };
+    }) : [];
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const index = options.findIndex((option) => option.selected);
+        return (index >= 0 ? index : 0).toString();
+      }
+    });
+    return options;
+  }, [cues, $startTime, $endTime]);
+}
+
+export { Captions, ChapterTitle, Content, GoogleCastButton, Group, MediaAnnouncer, Root$4 as Root, Root$2 as Root$1, Root$3 as Root$2, Root$1 as Root$3, Root$5 as Root$4, Root as Root$5, Title, Track, TrackFill, Trigger, audioGainSlider, controls, createComputed, createEffect, createSignal, qualitySlider, speedSlider, spinner, tooltip, useActiveTextCues, useActiveTextTrack, useChapterOptions, useChapterTitle, useScoped, useTextCues };
diff --git a/dev/chunks/vidstack-C2NXX4XZ.js b/dev/chunks/vidstack-C2NXX4XZ.js
new file mode 100644
index 0000000000000000000000000000000000000000..7ffb3cad89c7490cc862d8b7fd1a6a0c9a42a553
--- /dev/null
+++ b/dev/chunks/vidstack-C2NXX4XZ.js
@@ -0,0 +1,401 @@
+"use client"
+
+import { peek, listenEvent, effect, DOMEvent, isString, camelToKebabCase, isUndefined, isFunction } from './vidstack-CH225ns1.js';
+import { QualitySymbol, RAFLoop, TextTrack, TextTrackSymbol, ListSymbol, IS_CHROME, coerceToError, loadScript, VideoProvider, isHLSSupported, preconnect } from './vidstack-MAWt6ODZ.js';
+import 'react';
+import '@floating-ui/dom';
+
+const toDOMEventType = (type) => camelToKebabCase(type);
+class HLSController {
+  #video;
+  #ctx;
+  #instance = null;
+  #stopLiveSync = null;
+  config = {};
+  #callbacks = /* @__PURE__ */ new Set();
+  get instance() {
+    return this.#instance;
+  }
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+  }
+  setup(ctor) {
+    const { streamType } = this.#ctx.$state;
+    const isLive = peek(streamType).includes("live"), isLiveLowLatency = peek(streamType).includes("ll-");
+    this.#instance = new ctor({
+      lowLatencyMode: isLiveLowLatency,
+      backBufferLength: isLiveLowLatency ? 4 : isLive ? 8 : void 0,
+      renderTextTracksNatively: false,
+      ...this.config
+    });
+    const dispatcher = this.#dispatchHLSEvent.bind(this);
+    for (const event of Object.values(ctor.Events)) this.#instance.on(event, dispatcher);
+    this.#instance.on(ctor.Events.ERROR, this.#onError.bind(this));
+    for (const callback of this.#callbacks) callback(this.#instance);
+    this.#ctx.player.dispatch("hls-instance", {
+      detail: this.#instance
+    });
+    this.#instance.attachMedia(this.#video);
+    this.#instance.on(ctor.Events.AUDIO_TRACK_SWITCHED, this.#onAudioSwitch.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_SWITCHED, this.#onLevelSwitched.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_LOADED, this.#onLevelLoaded.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_UPDATED, this.#onLevelUpdated.bind(this));
+    this.#instance.on(ctor.Events.NON_NATIVE_TEXT_TRACKS_FOUND, this.#onTracksFound.bind(this));
+    this.#instance.on(ctor.Events.CUES_PARSED, this.#onCuesParsed.bind(this));
+    this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
+    listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
+    listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
+    this.#stopLiveSync = effect(this.#liveSync.bind(this));
+  }
+  #createDOMEvent(type, data) {
+    return new DOMEvent(toDOMEventType(type), { detail: data });
+  }
+  #liveSync() {
+    if (!this.#ctx.$state.live()) return;
+    const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
+    raf.start();
+    return raf.stop.bind(raf);
+  }
+  #liveSyncPosition() {
+    this.#ctx.$state.liveSyncPosition.set(this.#instance?.liveSyncPosition ?? Infinity);
+  }
+  #dispatchHLSEvent(type, data) {
+    this.#ctx.player?.dispatch(this.#createDOMEvent(type, data));
+  }
+  #onTracksFound(eventType, data) {
+    const event = this.#createDOMEvent(eventType, data);
+    let currentTrack = -1;
+    for (let i = 0; i < data.tracks.length; i++) {
+      const nonNativeTrack = data.tracks[i], init = nonNativeTrack.subtitleTrack ?? nonNativeTrack.closedCaptions, track = new TextTrack({
+        id: `hls-${nonNativeTrack.kind}-${i}`,
+        src: init?.url,
+        label: nonNativeTrack.label,
+        language: init?.lang,
+        kind: nonNativeTrack.kind,
+        default: nonNativeTrack.default
+      });
+      track[TextTrackSymbol.readyState] = 2;
+      track[TextTrackSymbol.onModeChange] = () => {
+        if (track.mode === "showing") {
+          this.#instance.subtitleTrack = i;
+          currentTrack = i;
+        } else if (currentTrack === i) {
+          this.#instance.subtitleTrack = -1;
+          currentTrack = -1;
+        }
+      };
+      this.#ctx.textTracks.add(track, event);
+    }
+  }
+  #onCuesParsed(eventType, data) {
+    const index = this.#instance?.subtitleTrack, track = this.#ctx.textTracks.getById(`hls-${data.type}-${index}`);
+    if (!track) return;
+    const event = this.#createDOMEvent(eventType, data);
+    for (const cue of data.cues) {
+      cue.positionAlign = "auto";
+      track.addCue(cue, event);
+    }
+  }
+  #onAudioSwitch(eventType, data) {
+    const track = this.#ctx.audioTracks[data.id];
+    if (track) {
+      const trigger = this.#createDOMEvent(eventType, data);
+      this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
+    }
+  }
+  #onLevelSwitched(eventType, data) {
+    const quality = this.#ctx.qualities[data.level];
+    if (quality) {
+      const trigger = this.#createDOMEvent(eventType, data);
+      this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+  }
+  #onLevelUpdated(eventType, data) {
+    if (data.details.totalduration > 0) {
+      this.#ctx.$state.inferredLiveDVRWindow.set(data.details.totalduration);
+    }
+  }
+  #onLevelLoaded(eventType, data) {
+    if (this.#ctx.$state.canPlay()) return;
+    const { type, live, totalduration: duration, targetduration } = data.details, trigger = this.#createDOMEvent(eventType, data);
+    this.#ctx.notify(
+      "stream-type-change",
+      live ? type === "EVENT" && Number.isFinite(duration) && targetduration >= 10 ? "live:dvr" : "live" : "on-demand",
+      trigger
+    );
+    this.#ctx.notify("duration-change", duration, trigger);
+    const media = this.#instance.media;
+    if (this.#instance.currentLevel === -1) {
+      this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
+    }
+    for (const remoteTrack of this.#instance.audioTracks) {
+      const localTrack = {
+        id: remoteTrack.id.toString(),
+        label: remoteTrack.name,
+        language: remoteTrack.lang || "",
+        kind: "main"
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
+    }
+    for (const level of this.#instance.levels) {
+      const videoQuality = {
+        id: level.id?.toString() ?? level.height + "p",
+        width: level.width,
+        height: level.height,
+        codec: level.codecSet,
+        bitrate: level.bitrate
+      };
+      this.#ctx.qualities[ListSymbol.add](videoQuality, trigger);
+    }
+    media.dispatchEvent(new DOMEvent("canplay", { trigger }));
+  }
+  #onError(eventType, data) {
+    {
+      this.#ctx.logger?.errorGroup(`[vidstack] HLS error \`${eventType}\``).labelledLog("Media Element", this.#instance?.media).labelledLog("HLS Instance", this.#instance).labelledLog("Event Type", eventType).labelledLog("Data", data).labelledLog("Src", peek(this.#ctx.$state.source)).labelledLog("Media Store", { ...this.#ctx.$state }).dispatch();
+    }
+    if (data.fatal) {
+      switch (data.type) {
+        case "mediaError":
+          this.#instance?.recoverMediaError();
+          break;
+        default:
+          this.#onFatalError(data.error);
+          break;
+      }
+    }
+  }
+  #onFatalError(error) {
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 1,
+      error
+    });
+  }
+  #enableAutoQuality() {
+    if (this.#instance) this.#instance.currentLevel = -1;
+  }
+  #onUserQualityChange() {
+    const { qualities } = this.#ctx;
+    if (!this.#instance || qualities.auto) return;
+    this.#instance[qualities.switch + "Level"] = qualities.selectedIndex;
+    if (IS_CHROME) {
+      this.#video.currentTime = this.#video.currentTime;
+    }
+  }
+  #onUserAudioChange() {
+    const { audioTracks } = this.#ctx;
+    if (this.#instance && this.#instance.audioTrack !== audioTracks.selectedIndex) {
+      this.#instance.audioTrack = audioTracks.selectedIndex;
+    }
+  }
+  onInstance(callback) {
+    this.#callbacks.add(callback);
+    return () => this.#callbacks.delete(callback);
+  }
+  loadSource(src) {
+    if (!isString(src.src)) return;
+    this.#instance?.loadSource(src.src);
+  }
+  destroy() {
+    this.#instance?.destroy();
+    this.#instance = null;
+    this.#stopLiveSync?.();
+    this.#stopLiveSync = null;
+    this.#ctx?.logger?.info("\u{1F3D7}\uFE0F Destroyed HLS instance");
+  }
+}
+
+class HLSLibLoader {
+  #lib;
+  #ctx;
+  #callback;
+  constructor(lib, ctx, callback) {
+    this.#lib = lib;
+    this.#ctx = ctx;
+    this.#callback = callback;
+    this.#startLoading();
+  }
+  async #startLoading() {
+    this.#ctx.logger?.info("\u{1F3D7}\uFE0F Loading HLS Library");
+    const callbacks = {
+      onLoadStart: this.#onLoadStart.bind(this),
+      onLoaded: this.#onLoaded.bind(this),
+      onLoadError: this.#onLoadError.bind(this)
+    };
+    let ctor = await loadHLSScript(this.#lib, callbacks);
+    if (isUndefined(ctor) && !isString(this.#lib)) ctor = await importHLS(this.#lib, callbacks);
+    if (!ctor) return null;
+    if (!ctor.isSupported()) {
+      const message = "[vidstack] `hls.js` is not supported in this environment";
+      this.#ctx.logger?.error(message);
+      this.#ctx.player.dispatch(new DOMEvent("hls-unsupported"));
+      this.#ctx.notify("error", { message, code: 4 });
+      return null;
+    }
+    return ctor;
+  }
+  #onLoadStart() {
+    {
+      this.#ctx.logger?.infoGroup("Starting to load `hls.js`").labelledLog("URL", this.#lib).dispatch();
+    }
+    this.#ctx.player.dispatch(new DOMEvent("hls-lib-load-start"));
+  }
+  #onLoaded(ctor) {
+    {
+      this.#ctx.logger?.infoGroup("Loaded `hls.js`").labelledLog("Library", this.#lib).labelledLog("Constructor", ctor).dispatch();
+    }
+    this.#ctx.player.dispatch(
+      new DOMEvent("hls-lib-loaded", {
+        detail: ctor
+      })
+    );
+    this.#callback(ctor);
+  }
+  #onLoadError(e) {
+    const error = coerceToError(e);
+    {
+      this.#ctx.logger?.errorGroup("[vidstack] Failed to load `hls.js`").labelledLog("Library", this.#lib).labelledLog("Error", e).dispatch();
+    }
+    this.#ctx.player.dispatch(
+      new DOMEvent("hls-lib-load-error", {
+        detail: error
+      })
+    );
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 4,
+      error
+    });
+  }
+}
+async function importHLS(loader, callbacks = {}) {
+  if (isUndefined(loader)) return void 0;
+  callbacks.onLoadStart?.();
+  if (loader.prototype && loader.prototype !== Function) {
+    callbacks.onLoaded?.(loader);
+    return loader;
+  }
+  try {
+    const ctor = (await loader())?.default;
+    if (ctor && !!ctor.isSupported) {
+      callbacks.onLoaded?.(ctor);
+    } else {
+      throw Error(
+        true ? "[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
+      );
+    }
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+async function loadHLSScript(src, callbacks = {}) {
+  if (!isString(src)) return void 0;
+  callbacks.onLoadStart?.();
+  try {
+    await loadScript(src);
+    if (!isFunction(window.Hls)) {
+      throw Error(
+        true ? "[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window" : ""
+      );
+    }
+    const ctor = window.Hls;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+
+const JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
+class HLSProvider extends VideoProvider {
+  $$PROVIDER_TYPE = "HLS";
+  #ctor = null;
+  #controller = new HLSController(this.video, this.ctx);
+  /**
+   * The `hls.js` constructor.
+   */
+  get ctor() {
+    return this.#ctor;
+  }
+  /**
+   * The current `hls.js` instance.
+   */
+  get instance() {
+    return this.#controller.instance;
+  }
+  /**
+   * Whether `hls.js` is supported in this environment.
+   */
+  static supported = isHLSSupported();
+  get type() {
+    return "hls";
+  }
+  get canLiveSync() {
+    return true;
+  }
+  #library = `${JS_DELIVR_CDN}/npm/hls.js@^1.5.0/dist/hls${".js" }`;
+  /**
+   * The `hls.js` configuration object.
+   *
+   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#fine-tuning}
+   */
+  get config() {
+    return this.#controller.config;
+  }
+  set config(config) {
+    this.#controller.config = config;
+  }
+  /**
+   * The `hls.js` constructor (supports dynamic imports) or a URL of where it can be found.
+   *
+   * @defaultValue `https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.min.js`
+   */
+  get library() {
+    return this.#library;
+  }
+  set library(library) {
+    this.#library = library;
+  }
+  preconnect() {
+    if (!isString(this.#library)) return;
+    preconnect(this.#library);
+  }
+  setup() {
+    super.setup();
+    new HLSLibLoader(this.#library, this.ctx, (ctor) => {
+      this.#ctor = ctor;
+      this.#controller.setup(ctor);
+      this.ctx.notify("provider-setup", this);
+      const src = peek(this.ctx.$state.source);
+      if (src) this.loadSource(src);
+    });
+  }
+  async loadSource(src, preload) {
+    if (!isString(src.src)) {
+      this.removeSource();
+      return;
+    }
+    this.media.preload = preload || "";
+    this.appendSource(src, "application/x-mpegurl");
+    this.#controller.loadSource(src);
+    this.currentSrc = src;
+  }
+  /**
+   * The given callback is invoked when a new `hls.js` instance is created and right before it's
+   * attached to media.
+   */
+  onInstance(callback) {
+    const instance = this.#controller.instance;
+    if (instance) callback(instance);
+    return this.#controller.onInstance(callback);
+  }
+  destroy() {
+    this.#controller.destroy();
+  }
+}
+
+export { HLSProvider };
diff --git a/dev/chunks/vidstack-C4ZyuPZU.js b/dev/chunks/vidstack-C4ZyuPZU.js
new file mode 100644
index 0000000000000000000000000000000000000000..f0169f58f901998348890506e1e14a8ddd303c6d
--- /dev/null
+++ b/dev/chunks/vidstack-C4ZyuPZU.js
@@ -0,0 +1,84 @@
+"use client"
+
+import * as React from 'react';
+import { animationFrameThrottle, EventsController, listenEvent, effect } from './vidstack-CH225ns1.js';
+import { useMediaPlayer } from './vidstack-Bn2Qk0ao.js';
+
+function useClassName(el, className) {
+  React.useEffect(() => {
+    if (!el || !className) return;
+    const tokens = className.split(" ");
+    for (const token of tokens) el.classList.add(token);
+    return () => {
+      for (const token of tokens) el.classList.remove(token);
+    };
+  }, [el, className]);
+}
+function useResizeObserver(el, callback) {
+  React.useEffect(() => {
+    if (!el) return;
+    callback();
+    const observer = new ResizeObserver(animationFrameThrottle(callback));
+    observer.observe(el);
+    return () => observer.disconnect();
+  }, [el, callback]);
+}
+function useTransitionActive(el) {
+  const [isActive, setIsActive] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("transitionstart", () => setIsActive(true)).add("transitionend", () => setIsActive(false));
+    return () => events.abort();
+  }, [el]);
+  return isActive;
+}
+function useMouseEnter(el) {
+  const [isMouseEnter, setIsMouseEnter] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("mouseenter", () => setIsMouseEnter(true)).add("mouseleave", () => setIsMouseEnter(false));
+    return () => events.abort();
+  }, [el]);
+  return isMouseEnter;
+}
+function useFocusIn(el) {
+  const [isFocusIn, setIsFocusIn] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("focusin", () => setIsFocusIn(true)).add("focusout", () => setIsFocusIn(false));
+    return () => events.abort();
+  }, [el]);
+  return isFocusIn;
+}
+function useActive(el) {
+  const isMouseEnter = useMouseEnter(el), isFocusIn = useFocusIn(el), prevMouseEnter = React.useRef(false);
+  if (prevMouseEnter.current && !isMouseEnter) return false;
+  prevMouseEnter.current = isMouseEnter;
+  return isMouseEnter || isFocusIn;
+}
+function useColorSchemePreference() {
+  const [colorScheme, setColorScheme] = React.useState("dark");
+  React.useEffect(() => {
+    const media = window.matchMedia("(prefers-color-scheme: light)");
+    function onChange() {
+      setColorScheme(media.matches ? "light" : "dark");
+    }
+    onChange();
+    return listenEvent(media, "change", onChange);
+  }, []);
+  return colorScheme;
+}
+
+function useLayoutName(name) {
+  const player = useMediaPlayer();
+  React.useEffect(() => {
+    if (!player) return;
+    return effect(() => {
+      const el = player.$el;
+      el?.setAttribute("data-layout", name);
+      return () => el?.removeAttribute("data-layout");
+    });
+  }, [player]);
+}
+
+export { useActive, useClassName, useColorSchemePreference, useLayoutName, useResizeObserver, useTransitionActive };
diff --git a/dev/chunks/vidstack-CGivFV1p.js b/dev/chunks/vidstack-CGivFV1p.js
new file mode 100644
index 0000000000000000000000000000000000000000..2fe9394bb3ac50c3f74f01345c069859b5b0d204
--- /dev/null
+++ b/dev/chunks/vidstack-CGivFV1p.js
@@ -0,0 +1,1371 @@
+"use client"
+
+import * as React from 'react';
+import { useSignal, isBoolean, composeRefs, uppercaseFirstChar, isUndefined, isString, signal, camelToKebabCase, onDispose, scoped, keysOf, effect, isArray, isKeyboardClick, listenEvent, toggleClass, useContext } from './vidstack-CH225ns1.js';
+import { createComputed, createSignal, MediaAnnouncer, Root, Trigger, Content, GoogleCastButton, Captions, useChapterOptions, Root$1 as Root$5, Root$2 as Root$6, Root$3 as Root$7, useScoped, Root$4 as Root$a, Group, useChapterTitle, createEffect, useActiveTextTrack, ChapterTitle as ChapterTitle$1, Title, Root$5 as Root$b, Track as Track$1, TrackFill as TrackFill$1 } from './vidstack-BwNhcxfT.js';
+import { useColorSchemePreference, useActive, useResizeObserver, useLayoutName, useTransitionActive } from './vidstack-Di-ZivLP.js';
+import { useMediaContext, MuteButton, PlayButton, CaptionButton, PIPButton, FullscreenButton, SeekButton, AirPlayButton, LiveButton, appendParamsToURL, Items, Root$3 as Root$1, Item, Root as Root$2, Img, Root$2 as Root$3, Button, Portal, Track, TrackFill, Thumb, Steps, useMediaPlayer, Root$5 as Root$4, useAudioOptions, useCaptionOptions, Root$4 as Root$8, Preview, Value, Root$1 as Root$9, Chapters, Progress, Thumbnail, ChapterTitle, Time, Gesture } from './vidstack-VrioNQ8t.js';
+import { useMediaState, isTrackCaptionKind, getDownloadFile, isRemotionSrc, IS_SERVER, useMediaContext as useMediaContext$1, sortVideoQualities, Primitive, mediaContext } from './vidstack-BdoOxmTD.js';
+import { flushSync } from 'react-dom';
+import { RemotionThumbnail, RemotionSliderThumbnail } from './vidstack-CaBvbWDV.js';
+
+const DefaultLayoutContext = React.createContext({});
+DefaultLayoutContext.displayName = "DefaultLayoutContext";
+function useDefaultLayoutContext() {
+  return React.useContext(DefaultLayoutContext);
+}
+function useDefaultLayoutWord(word) {
+  const { translations } = useDefaultLayoutContext();
+  return i18n(translations, word);
+}
+function i18n(translations, word) {
+  return translations?.[word] ?? word;
+}
+
+function useColorSchemeClass(colorScheme) {
+  const systemColorPreference = useColorSchemePreference();
+  if (colorScheme === "default") {
+    return null;
+  } else if (colorScheme === "system") {
+    return systemColorPreference;
+  } else {
+    return colorScheme;
+  }
+}
+
+function createDefaultMediaLayout({
+  type,
+  smLayoutWhen,
+  renderLayout
+}) {
+  const Layout = React.forwardRef(
+    ({
+      children,
+      className,
+      disableTimeSlider = false,
+      hideQualityBitrate = false,
+      icons,
+      colorScheme = "system",
+      download = null,
+      menuContainer = null,
+      menuGroup = "bottom",
+      noAudioGain = false,
+      audioGains = { min: 0, max: 300, step: 25 },
+      noGestures = false,
+      noKeyboardAnimations = false,
+      noModal = false,
+      noScrubGesture,
+      playbackRates = { min: 0, max: 2, step: 0.25 },
+      seekStep = 10,
+      showMenuDelay,
+      showTooltipDelay = 700,
+      sliderChaptersMinWidth = 325,
+      slots,
+      smallLayoutWhen = smLayoutWhen,
+      thumbnails = null,
+      translations,
+      ...props
+    }, forwardRef) => {
+      const media = useMediaContext(), $load = useSignal(media.$props.load), $canLoad = useMediaState("canLoad"), $viewType = useMediaState("viewType"), $streamType = useMediaState("streamType"), $smallWhen = createComputed(() => {
+        return isBoolean(smallLayoutWhen) ? smallLayoutWhen : smallLayoutWhen(media.player.state);
+      }, [smallLayoutWhen]), userPrefersAnnouncements = createSignal(true), userPrefersKeyboardAnimations = createSignal(true), isMatch = $viewType === type, isSmallLayout = $smallWhen(), isForcedLayout = isBoolean(smallLayoutWhen), isLoadLayout = $load === "play" && !$canLoad, canRender = $canLoad || isForcedLayout || isLoadLayout, colorSchemeClass = useColorSchemeClass(colorScheme), layoutEl = createSignal(null);
+      useSignal($smallWhen);
+      return /* @__PURE__ */ React.createElement(
+        "div",
+        {
+          ...props,
+          className: `vds-${type}-layout` + (colorSchemeClass ? ` ${colorSchemeClass}` : "") + (className ? ` ${className}` : ""),
+          "data-match": isMatch ? "" : null,
+          "data-sm": isSmallLayout ? "" : null,
+          "data-lg": !isSmallLayout ? "" : null,
+          "data-size": isSmallLayout ? "sm" : "lg",
+          "data-no-scrub-gesture": noScrubGesture ? "" : null,
+          ref: composeRefs(layoutEl.set, forwardRef)
+        },
+        canRender && isMatch ? /* @__PURE__ */ React.createElement(
+          DefaultLayoutContext.Provider,
+          {
+            value: {
+              disableTimeSlider,
+              hideQualityBitrate,
+              icons,
+              colorScheme,
+              download,
+              isSmallLayout,
+              menuContainer,
+              menuGroup,
+              noAudioGain,
+              audioGains,
+              layoutEl,
+              noGestures,
+              noKeyboardAnimations,
+              noModal,
+              noScrubGesture,
+              showMenuDelay,
+              showTooltipDelay,
+              sliderChaptersMinWidth,
+              slots,
+              seekStep,
+              playbackRates,
+              thumbnails,
+              translations,
+              userPrefersAnnouncements,
+              userPrefersKeyboardAnimations
+            }
+          },
+          renderLayout({ streamType: $streamType, isSmallLayout, isLoadLayout }),
+          children
+        ) : null
+      );
+    }
+  );
+  Layout.displayName = "DefaultMediaLayout";
+  return Layout;
+}
+
+function useDefaultAudioLayoutSlots() {
+  return React.useContext(DefaultLayoutContext).slots;
+}
+function useDefaultVideoLayoutSlots() {
+  return React.useContext(DefaultLayoutContext).slots;
+}
+function slot(slots, name, defaultValue) {
+  const slot2 = slots?.[name], capitalizedName = uppercaseFirstChar(name);
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slots?.[`before${capitalizedName}`], isUndefined(slot2) ? defaultValue : slot2, slots?.[`after${capitalizedName}`]);
+}
+
+function DefaultAnnouncer() {
+  const { userPrefersAnnouncements, translations } = useDefaultLayoutContext(), $userPrefersAnnouncements = useSignal(userPrefersAnnouncements);
+  if (!$userPrefersAnnouncements) return null;
+  return /* @__PURE__ */ React.createElement(MediaAnnouncer, { translations });
+}
+DefaultAnnouncer.displayName = "DefaultAnnouncer";
+
+function DefaultTooltip({ content, placement, children }) {
+  const { showTooltipDelay } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root, { showDelay: showTooltipDelay }, /* @__PURE__ */ React.createElement(Trigger, { asChild: true }, children), /* @__PURE__ */ React.createElement(Content, { className: "vds-tooltip-content", placement }, content));
+}
+DefaultTooltip.displayName = "DefaultTooltip";
+
+function DefaultPlayButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), playText = useDefaultLayoutWord("Play"), pauseText = useDefaultLayoutWord("Pause"), $paused = useMediaState("paused"), $ended = useMediaState("ended");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $paused ? playText : pauseText, placement: tooltip }, /* @__PURE__ */ React.createElement(PlayButton, { className: "vds-play-button vds-button", "aria-label": playText }, $ended ? /* @__PURE__ */ React.createElement(Icons.PlayButton.Replay, { className: "vds-icon" }) : $paused ? /* @__PURE__ */ React.createElement(Icons.PlayButton.Play, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.PlayButton.Pause, { className: "vds-icon" })));
+}
+DefaultPlayButton.displayName = "DefaultPlayButton";
+const DefaultMuteButton = React.forwardRef(
+  ({ tooltip }, forwardRef) => {
+    const { icons: Icons } = useDefaultLayoutContext(), muteText = useDefaultLayoutWord("Mute"), unmuteText = useDefaultLayoutWord("Unmute"), $muted = useMediaState("muted"), $volume = useMediaState("volume");
+    return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $muted ? unmuteText : muteText, placement: tooltip }, /* @__PURE__ */ React.createElement(MuteButton, { className: "vds-mute-button vds-button", "aria-label": muteText, ref: forwardRef }, $muted || $volume == 0 ? /* @__PURE__ */ React.createElement(Icons.MuteButton.Mute, { className: "vds-icon" }) : $volume < 0.5 ? /* @__PURE__ */ React.createElement(Icons.MuteButton.VolumeLow, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.MuteButton.VolumeHigh, { className: "vds-icon" })));
+  }
+);
+DefaultMuteButton.displayName = "DefaultMuteButton";
+function DefaultCaptionButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), captionsText = useDefaultLayoutWord("Captions"), onText = useDefaultLayoutWord("Closed-Captions On"), offText = useDefaultLayoutWord("Closed-Captions Off"), $track = useMediaState("textTrack"), isOn = $track && isTrackCaptionKind($track);
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: isOn ? onText : offText, placement: tooltip }, /* @__PURE__ */ React.createElement(CaptionButton, { className: "vds-caption-button vds-button", "aria-label": captionsText }, isOn ? /* @__PURE__ */ React.createElement(Icons.CaptionButton.On, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.CaptionButton.Off, { className: "vds-icon" })));
+}
+DefaultCaptionButton.displayName = "DefaultCaptionButton";
+function DefaultPIPButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), pipText = useDefaultLayoutWord("PiP"), enterText = useDefaultLayoutWord("Enter PiP"), exitText = useDefaultLayoutWord("Exit PiP"), $pip = useMediaState("pictureInPicture");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $pip ? exitText : enterText, placement: tooltip }, /* @__PURE__ */ React.createElement(PIPButton, { className: "vds-pip-button vds-button", "aria-label": pipText }, $pip ? /* @__PURE__ */ React.createElement(Icons.PIPButton.Exit, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.PIPButton.Enter, { className: "vds-icon" })));
+}
+DefaultPIPButton.displayName = "DefaultPIPButton";
+function DefaultFullscreenButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), fullscreenText = useDefaultLayoutWord("Fullscreen"), enterText = useDefaultLayoutWord("Enter Fullscreen"), exitText = useDefaultLayoutWord("Exit Fullscreen"), $fullscreen = useMediaState("fullscreen");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $fullscreen ? exitText : enterText, placement: tooltip }, /* @__PURE__ */ React.createElement(FullscreenButton, { className: "vds-fullscreen-button vds-button", "aria-label": fullscreenText }, $fullscreen ? /* @__PURE__ */ React.createElement(Icons.FullscreenButton.Exit, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.FullscreenButton.Enter, { className: "vds-icon" })));
+}
+DefaultFullscreenButton.displayName = "DefaultFullscreenButton";
+function DefaultSeekButton({
+  backward,
+  tooltip
+}) {
+  const { icons: Icons, seekStep } = useDefaultLayoutContext(), seekForwardText = useDefaultLayoutWord("Seek Forward"), seekBackwardText = useDefaultLayoutWord("Seek Backward"), seconds = (backward ? -1 : 1) * seekStep, label = seconds >= 0 ? seekForwardText : seekBackwardText;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: label, placement: tooltip }, /* @__PURE__ */ React.createElement(SeekButton, { className: "vds-seek-button vds-button", seconds, "aria-label": label }, seconds >= 0 ? /* @__PURE__ */ React.createElement(Icons.SeekButton.Forward, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.SeekButton.Backward, { className: "vds-icon" })));
+}
+DefaultSeekButton.displayName = "DefaultSeekButton";
+function DefaultAirPlayButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), airPlayText = useDefaultLayoutWord("AirPlay"), $state = useMediaState("remotePlaybackState"), stateText = useDefaultLayoutWord(uppercaseFirstChar($state)), label = `${airPlayText} ${stateText}`, Icon = ($state === "connecting" ? Icons.AirPlayButton.Connecting : $state === "connected" ? Icons.AirPlayButton.Connected : null) ?? Icons.AirPlayButton.Default;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: airPlayText, placement: tooltip }, /* @__PURE__ */ React.createElement(AirPlayButton, { className: "vds-airplay-button vds-button", "aria-label": label }, /* @__PURE__ */ React.createElement(Icon, { className: "vds-icon" })));
+}
+DefaultAirPlayButton.displayName = "DefaultAirPlayButton";
+function DefaultGoogleCastButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), googleCastText = useDefaultLayoutWord("Google Cast"), $state = useMediaState("remotePlaybackState"), stateText = useDefaultLayoutWord(uppercaseFirstChar($state)), label = `${googleCastText} ${stateText}`, Icon = ($state === "connecting" ? Icons.GoogleCastButton.Connecting : $state === "connected" ? Icons.GoogleCastButton.Connected : null) ?? Icons.GoogleCastButton.Default;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: googleCastText, placement: tooltip }, /* @__PURE__ */ React.createElement(GoogleCastButton, { className: "vds-google-cast-button vds-button", "aria-label": label }, /* @__PURE__ */ React.createElement(Icon, { className: "vds-icon" })));
+}
+DefaultGoogleCastButton.displayName = "DefaultGoogleCastButton";
+function DefaultLiveButton() {
+  const $live = useMediaState("live"), label = useDefaultLayoutWord("Skip To Live"), liveText = useDefaultLayoutWord("LIVE");
+  return $live ? /* @__PURE__ */ React.createElement(LiveButton, { className: "vds-live-button", "aria-label": label }, /* @__PURE__ */ React.createElement("span", { className: "vds-live-button-text" }, liveText)) : null;
+}
+DefaultLiveButton.displayName = "DefaultLiveButton";
+function DefaultDownloadButton() {
+  const { download, icons: Icons } = useDefaultLayoutContext(), $src = useMediaState("source"), $title = useMediaState("title"), file = getDownloadFile({
+    title: $title,
+    src: $src,
+    download
+  }), downloadText = useDefaultLayoutWord("Download");
+  return isString(file?.url) ? /* @__PURE__ */ React.createElement(DefaultTooltip, { content: downloadText, placement: "top" }, /* @__PURE__ */ React.createElement(
+    "a",
+    {
+      role: "button",
+      className: "vds-download-button vds-button",
+      "aria-label": downloadText,
+      href: appendParamsToURL(file.url, { download: file.name }),
+      download: file.name,
+      target: "_blank"
+    },
+    Icons.DownloadButton ? /* @__PURE__ */ React.createElement(Icons.DownloadButton.Default, { className: "vds-icon" }) : null
+  )) : null;
+}
+DefaultDownloadButton.displayName = "DefaultDownloadButton";
+
+function DefaultCaptions() {
+  const exampleText = useDefaultLayoutWord("Captions look like this");
+  return /* @__PURE__ */ React.createElement(Captions, { className: "vds-captions", exampleText });
+}
+DefaultCaptions.displayName = "DefaultCaptions";
+
+function DefaultControlsSpacer() {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-controls-spacer" });
+}
+DefaultControlsSpacer.displayName = "DefaultControlsSpacer";
+
+function useParentDialogEl() {
+  const { layoutEl } = useDefaultLayoutContext(), $layoutEl = useSignal(layoutEl);
+  return React.useMemo(() => $layoutEl?.closest("dialog"), [$layoutEl]);
+}
+
+function DefaultChaptersMenu({ tooltip, placement, portalClass = "" }) {
+  const {
+    showMenuDelay,
+    noModal,
+    isSmallLayout,
+    icons: Icons,
+    menuGroup,
+    menuContainer,
+    colorScheme
+  } = useDefaultLayoutContext(), chaptersText = useDefaultLayoutWord("Chapters"), options = useChapterOptions(), disabled = !options.length, { thumbnails } = useDefaultLayoutContext(), $src = useMediaState("currentSrc"), $viewType = useMediaState("viewType"), $offset = !isSmallLayout && menuGroup === "bottom" && $viewType === "video" ? 26 : 0, $RemotionThumbnail = useSignal(RemotionThumbnail), colorSchemeClass = useColorSchemeClass(colorScheme), [isOpen, setIsOpen] = React.useState(false), dialogEl = useParentDialogEl();
+  if (disabled) return null;
+  function onOpen() {
+    flushSync(() => {
+      setIsOpen(true);
+    });
+  }
+  function onClose() {
+    setIsOpen(false);
+  }
+  const Content = /* @__PURE__ */ React.createElement(
+    Items,
+    {
+      className: "vds-chapters-menu-items vds-menu-items",
+      placement,
+      offset: $offset
+    },
+    isOpen ? /* @__PURE__ */ React.createElement(
+      Root$1,
+      {
+        className: "vds-chapters-radio-group vds-radio-group",
+        value: options.selectedValue,
+        "data-thumbnails": thumbnails ? "" : null
+      },
+      options.map(
+        ({ cue, label, value, startTimeText, durationText, select, setProgressVar }) => /* @__PURE__ */ React.createElement(
+          Item,
+          {
+            className: "vds-chapter-radio vds-radio",
+            value,
+            key: value,
+            onSelect: select,
+            ref: setProgressVar
+          },
+          thumbnails ? /* @__PURE__ */ React.createElement(Root$2, { src: thumbnails, className: "vds-thumbnail", time: cue.startTime }, /* @__PURE__ */ React.createElement(Img, null)) : $RemotionThumbnail && isRemotionSrc($src) ? /* @__PURE__ */ React.createElement($RemotionThumbnail, { className: "vds-thumbnail", frame: cue.startTime * $src.fps }) : null,
+          /* @__PURE__ */ React.createElement("div", { className: "vds-chapter-radio-content" }, /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-label" }, label), /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-start-time" }, startTimeText), /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-duration" }, durationText))
+        )
+      )
+    ) : null
+  );
+  return /* @__PURE__ */ React.createElement(
+    Root$3,
+    {
+      className: "vds-chapters-menu vds-menu",
+      showDelay: showMenuDelay,
+      onOpen,
+      onClose
+    },
+    /* @__PURE__ */ React.createElement(DefaultTooltip, { content: chaptersText, placement: tooltip }, /* @__PURE__ */ React.createElement(
+      Button,
+      {
+        className: "vds-menu-button vds-button",
+        disabled,
+        "aria-label": chaptersText
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.Chapters, { className: "vds-icon" })
+    )),
+    noModal || !isSmallLayout ? Content : /* @__PURE__ */ React.createElement(
+      Portal,
+      {
+        container: menuContainer ?? dialogEl,
+        className: portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : ""),
+        disabled: "fullscreen",
+        "data-sm": isSmallLayout ? "" : null,
+        "data-lg": !isSmallLayout ? "" : null,
+        "data-size": isSmallLayout ? "sm" : "lg"
+      },
+      Content
+    )
+  );
+}
+DefaultChaptersMenu.displayName = "DefaultChaptersMenu";
+
+const FONT_COLOR_OPTION = {
+  type: "color"
+};
+const FONT_FAMILY_OPTION = {
+  type: "radio",
+  values: {
+    "Monospaced Serif": "mono-serif",
+    "Proportional Serif": "pro-serif",
+    "Monospaced Sans-Serif": "mono-sans",
+    "Proportional Sans-Serif": "pro-sans",
+    Casual: "casual",
+    Cursive: "cursive",
+    "Small Capitals": "capitals"
+  }
+};
+const FONT_SIZE_OPTION = {
+  type: "slider",
+  min: 0,
+  max: 400,
+  step: 25,
+  upIcon: null,
+  downIcon: null
+};
+const FONT_OPACITY_OPTION = {
+  type: "slider",
+  min: 0,
+  max: 100,
+  step: 5,
+  upIcon: null,
+  downIcon: null
+};
+const FONT_TEXT_SHADOW_OPTION = {
+  type: "radio",
+  values: ["None", "Drop Shadow", "Raised", "Depressed", "Outline"]
+};
+const FONT_DEFAULTS = {
+  fontFamily: "pro-sans",
+  fontSize: "100%",
+  textColor: "#ffffff",
+  textOpacity: "100%",
+  textShadow: "none",
+  textBg: "#000000",
+  textBgOpacity: "100%",
+  displayBg: "#000000",
+  displayBgOpacity: "0%"
+};
+const FONT_SIGNALS = Object.keys(FONT_DEFAULTS).reduce(
+  (prev, type) => ({
+    ...prev,
+    [type]: signal(FONT_DEFAULTS[type])
+  }),
+  {}
+);
+if (!IS_SERVER) {
+  for (const type of Object.keys(FONT_SIGNALS)) {
+    const value = localStorage.getItem(`vds-player:${camelToKebabCase(type)}`);
+    if (isString(value)) FONT_SIGNALS[type].set(value);
+  }
+}
+function onFontReset() {
+  for (const type of Object.keys(FONT_SIGNALS)) {
+    const defaultValue = FONT_DEFAULTS[type];
+    FONT_SIGNALS[type].set(defaultValue);
+  }
+}
+
+function hexToRgb(hex) {
+  const { style } = new Option();
+  style.color = hex;
+  return style.color.match(/\((.*?)\)/)[1].replace(/,/g, " ");
+}
+
+let isWatchingVars = false, players = /* @__PURE__ */ new Set();
+function updateFontCssVars() {
+  if (IS_SERVER) return;
+  const { player } = useMediaContext$1();
+  players.add(player);
+  onDispose(() => players.delete(player));
+  if (!isWatchingVars) {
+    scoped(() => {
+      for (const type of keysOf(FONT_SIGNALS)) {
+        const $value = FONT_SIGNALS[type], defaultValue = FONT_DEFAULTS[type], varName = `--media-user-${camelToKebabCase(type)}`, storageKey = `vds-player:${camelToKebabCase(type)}`;
+        effect(() => {
+          const value = $value(), isDefaultVarValue = value === defaultValue, varValue = !isDefaultVarValue ? getCssVarValue(player, type, value) : null;
+          for (const player2 of players) {
+            player2.el?.style.setProperty(varName, varValue);
+          }
+          if (isDefaultVarValue) {
+            localStorage.removeItem(storageKey);
+          } else {
+            localStorage.setItem(storageKey, value);
+          }
+        });
+      }
+    }, null);
+    isWatchingVars = true;
+  }
+}
+function getCssVarValue(player, type, value) {
+  switch (type) {
+    case "fontFamily":
+      const fontVariant = value === "capitals" ? "small-caps" : "";
+      player.el?.style.setProperty("--media-user-font-variant", fontVariant);
+      return getFontFamilyCSSVarValue(value);
+    case "fontSize":
+    case "textOpacity":
+    case "textBgOpacity":
+    case "displayBgOpacity":
+      return percentToRatio(value);
+    case "textColor":
+      return `rgb(${hexToRgb(value)} / var(--media-user-text-opacity, 1))`;
+    case "textShadow":
+      return getTextShadowCssVarValue(value);
+    case "textBg":
+      return `rgb(${hexToRgb(value)} / var(--media-user-text-bg-opacity, 1))`;
+    case "displayBg":
+      return `rgb(${hexToRgb(value)} / var(--media-user-display-bg-opacity, 1))`;
+  }
+}
+function percentToRatio(value) {
+  return (parseInt(value) / 100).toString();
+}
+function getFontFamilyCSSVarValue(value) {
+  switch (value) {
+    case "mono-serif":
+      return '"Courier New", Courier, "Nimbus Mono L", "Cutive Mono", monospace';
+    case "mono-sans":
+      return '"Deja Vu Sans Mono", "Lucida Console", Monaco, Consolas, "PT Mono", monospace';
+    case "pro-sans":
+      return 'Roboto, "Arial Unicode Ms", Arial, Helvetica, Verdana, "PT Sans Caption", sans-serif';
+    case "casual":
+      return '"Comic Sans MS", Impact, Handlee, fantasy';
+    case "cursive":
+      return '"Monotype Corsiva", "URW Chancery L", "Apple Chancery", "Dancing Script", cursive';
+    case "capitals":
+      return '"Arial Unicode Ms", Arial, Helvetica, Verdana, "Marcellus SC", sans-serif + font-variant=small-caps';
+    default:
+      return '"Times New Roman", Times, Georgia, Cambria, "PT Serif Caption", serif';
+  }
+}
+function getTextShadowCssVarValue(value) {
+  switch (value) {
+    case "drop shadow":
+      return "rgb(34, 34, 34) 1.86389px 1.86389px 2.79583px, rgb(34, 34, 34) 1.86389px 1.86389px 3.72778px, rgb(34, 34, 34) 1.86389px 1.86389px 4.65972px";
+    case "raised":
+      return "rgb(34, 34, 34) 1px 1px, rgb(34, 34, 34) 2px 2px";
+    case "depressed":
+      return "rgb(204, 204, 204) 1px 1px, rgb(34, 34, 34) -1px -1px";
+    case "outline":
+      return "rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px";
+    default:
+      return "";
+  }
+}
+
+function DefaultMenuSection({ label, value, children }) {
+  const id = React.useId();
+  if (!label) {
+    return /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section" }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-body" }, children));
+  }
+  return /* @__PURE__ */ React.createElement("section", { className: "vds-menu-section", role: "group", "aria-labelledby": id }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-title" }, /* @__PURE__ */ React.createElement("header", { id }, label), value ? /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-value" }, value) : null), /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-body" }, children));
+}
+DefaultMenuSection.displayName = "DefaultMenuSection";
+function DefaultMenuButton({ label, hint = "", Icon, disabled = false }) {
+  const { icons: Icons } = React.useContext(DefaultLayoutContext);
+  return /* @__PURE__ */ React.createElement(Button, { className: "vds-menu-item", disabled }, /* @__PURE__ */ React.createElement(Icons.Menu.ArrowLeft, { className: "vds-menu-close-icon vds-icon" }), Icon ? /* @__PURE__ */ React.createElement(Icon, { className: "vds-menu-item-icon vds-icon" }) : null, /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-label" }, label), /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-hint" }, hint), /* @__PURE__ */ React.createElement(Icons.Menu.ArrowRight, { className: "vds-menu-open-icon vds-icon" }));
+}
+DefaultMenuButton.displayName = "DefaultMenuButton";
+function DefaultMenuItem({ label, children }) {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-menu-item" }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-item-label" }, label), children);
+}
+DefaultMenuItem.displayName = "DefaultMenuItem";
+function DefaultMenuRadioGroup({ value, options, onChange }) {
+  const { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$1, { className: "vds-radio-group", value, onChange }, options.map((option) => /* @__PURE__ */ React.createElement(Item, { className: "vds-radio", value: option.value, key: option.value }, /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }), /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label", "data-part": "label" }, option.label))));
+}
+DefaultMenuRadioGroup.displayName = "DefaultMenuRadioGroup";
+function createRadioOptions(entries) {
+  return React.useMemo(
+    () => isArray(entries) ? entries.map((entry) => ({ label: entry, value: entry.toLowerCase() })) : Object.keys(entries).map((label) => ({ label, value: entries[label] })),
+    [entries]
+  );
+}
+
+function DefaultMenuSliderItem({
+  label,
+  value,
+  UpIcon,
+  DownIcon,
+  children,
+  isMin,
+  isMax
+}) {
+  const hasTitle = label || value, Content = /* @__PURE__ */ React.createElement(React.Fragment, null, DownIcon ? /* @__PURE__ */ React.createElement(DownIcon, { className: "vds-icon down" }) : null, children, UpIcon ? /* @__PURE__ */ React.createElement(UpIcon, { className: "vds-icon up" }) : null);
+  return /* @__PURE__ */ React.createElement(
+    "div",
+    {
+      className: `vds-menu-item vds-menu-slider-item${hasTitle ? " group" : ""}`,
+      "data-min": isMin ? "" : null,
+      "data-max": isMax ? "" : null
+    },
+    hasTitle ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-slider-title" }, label ? /* @__PURE__ */ React.createElement("div", null, label) : null, value ? /* @__PURE__ */ React.createElement("div", null, value) : null), /* @__PURE__ */ React.createElement("div", { className: "vds-menu-slider-body" }, Content)) : Content
+  );
+}
+DefaultMenuSliderItem.displayName = "DefaultMenuSliderItem";
+function DefaultSliderParts() {
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }));
+}
+DefaultSliderParts.displayName = "DefaultSliderParts";
+function DefaultSliderSteps() {
+  return /* @__PURE__ */ React.createElement(Steps, { className: "vds-slider-steps" }, (step) => /* @__PURE__ */ React.createElement("div", { className: "vds-slider-step", key: String(step) }));
+}
+DefaultSliderSteps.displayName = "DefaultSliderSteps";
+
+function DefaultFontMenu() {
+  const label = useDefaultLayoutWord("Caption Styles"), $hasCaptions = useMediaState("hasCaptions"), fontSectionLabel = useDefaultLayoutWord("Font"), textSectionLabel = useDefaultLayoutWord("Text"), textBgSectionLabel = useDefaultLayoutWord("Text Background"), displayBgSectionLabel = useDefaultLayoutWord("Display Background");
+  if (!$hasCaptions) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-font-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label }), /* @__PURE__ */ React.createElement(Items, { className: "vds-font-style-items vds-menu-items" }, /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: fontSectionLabel }, /* @__PURE__ */ React.createElement(DefaultFontFamilyMenu, null), /* @__PURE__ */ React.createElement(DefaultFontSizeSlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: textSectionLabel }, /* @__PURE__ */ React.createElement(DefaultTextColorInput, null), /* @__PURE__ */ React.createElement(DefaultTextShadowMenu, null), /* @__PURE__ */ React.createElement(DefaultTextOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: textBgSectionLabel }, /* @__PURE__ */ React.createElement(DefaultTextBgInput, null), /* @__PURE__ */ React.createElement(DefaultTextBgOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: displayBgSectionLabel }, /* @__PURE__ */ React.createElement(DefaultDisplayBgInput, null), /* @__PURE__ */ React.createElement(DefaultDisplayBgOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultResetMenuItem, null))));
+}
+DefaultFontMenu.displayName = "DefaultFontMenu";
+function DefaultFontFamilyMenu() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Family", type: "fontFamily", option: FONT_FAMILY_OPTION });
+}
+DefaultFontFamilyMenu.displayName = "DefaultFontFamilyMenu";
+function DefaultFontSizeSlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_SIZE_OPTION,
+    upIcon: Icons.Menu.FontSizeUp,
+    downIcon: Icons.Menu.FontSizeDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Size", type: "fontSize", option });
+}
+DefaultFontSizeSlider.displayName = "DefaultFontSizeSlider";
+function DefaultTextColorInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "textColor", option: FONT_COLOR_OPTION });
+}
+DefaultTextColorInput.displayName = "DefaultTextColorInput";
+function DefaultTextOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "textOpacity", option });
+}
+DefaultTextOpacitySlider.displayName = "DefaultTextOpacitySlider";
+function DefaultTextShadowMenu() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Shadow", type: "textShadow", option: FONT_TEXT_SHADOW_OPTION });
+}
+DefaultTextShadowMenu.displayName = "DefaultTextShadowMenu";
+function DefaultTextBgInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "textBg", option: FONT_COLOR_OPTION });
+}
+DefaultTextBgInput.displayName = "DefaultTextBgInput";
+function DefaultTextBgOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "textBgOpacity", option });
+}
+DefaultTextBgOpacitySlider.displayName = "DefaultTextBgOpacitySlider";
+function DefaultDisplayBgInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "displayBg", option: FONT_COLOR_OPTION });
+}
+DefaultDisplayBgInput.displayName = "DefaultDisplayBgInput";
+function DefaultDisplayBgOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "displayBgOpacity", option });
+}
+DefaultDisplayBgOpacitySlider.displayName = "DefaultDisplayBgOpacitySlider";
+function DefaultFontSetting({ label, option, type }) {
+  const player = useMediaPlayer(), $currentValue = FONT_SIGNALS[type], $value = useSignal($currentValue), translatedLabel = useDefaultLayoutWord(label);
+  const notify = React.useCallback(() => {
+    player?.dispatchEvent(new Event("vds-font-change"));
+  }, [player]);
+  const onChange = React.useCallback(
+    (newValue) => {
+      $currentValue.set(newValue);
+      notify();
+    },
+    [$currentValue, notify]
+  );
+  if (option.type === "color") {
+    let onColorChange2 = function(event) {
+      onChange(event.target.value);
+    };
+    return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label: translatedLabel }, /* @__PURE__ */ React.createElement("input", { className: "vds-color-picker", type: "color", value: $value, onChange: onColorChange2 }));
+  }
+  if (option.type === "slider") {
+    let onSliderValueChange2 = function(value) {
+      onChange(value + "%");
+    };
+    const { min, max, step, upIcon, downIcon } = option;
+    return /* @__PURE__ */ React.createElement(
+      DefaultMenuSliderItem,
+      {
+        label: translatedLabel,
+        value: $value,
+        UpIcon: upIcon,
+        DownIcon: downIcon,
+        isMin: $value === min + "%",
+        isMax: $value === max + "%"
+      },
+      /* @__PURE__ */ React.createElement(
+        Root$4,
+        {
+          className: "vds-slider",
+          min,
+          max,
+          step,
+          keyStep: step,
+          value: parseInt($value),
+          "aria-label": translatedLabel,
+          onValueChange: onSliderValueChange2,
+          onDragValueChange: onSliderValueChange2
+        },
+        /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+        /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+      )
+    );
+  }
+  if (option.type === "radio") {
+    return /* @__PURE__ */ React.createElement(
+      DefaultFontRadioGroup,
+      {
+        id: camelToKebabCase(type),
+        label: translatedLabel,
+        value: $value,
+        values: option.values,
+        onChange
+      }
+    );
+  }
+  return null;
+}
+DefaultFontSetting.displayName = "DefaultFontSetting";
+function DefaultFontRadioGroup({ id, label, value, values, onChange }) {
+  const radioOptions = createRadioOptions(values), { translations } = useDefaultLayoutContext(), hint = React.useMemo(() => {
+    const label2 = radioOptions.find((radio) => radio.value === value)?.label || "";
+    return i18n(translations, label2);
+  }, [value, radioOptions]);
+  return /* @__PURE__ */ React.createElement(Root$3, { className: `vds-${id}-menu vds-menu` }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, hint }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, /* @__PURE__ */ React.createElement(DefaultMenuRadioGroup, { value, options: radioOptions, onChange })));
+}
+DefaultFontRadioGroup.displayName = "DefaultFontRadioGroup";
+function DefaultResetMenuItem() {
+  const resetText = useDefaultLayoutWord("Reset");
+  return /* @__PURE__ */ React.createElement("button", { className: "vds-menu-item", role: "menuitem", onClick: onFontReset }, /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-label" }, resetText));
+}
+DefaultResetMenuItem.displayName = "DefaultResetMenuItem";
+
+function DefaultMenuCheckbox({
+  label,
+  checked,
+  storageKey,
+  defaultChecked = false,
+  onChange
+}) {
+  const [isChecked, setIsChecked] = React.useState(defaultChecked), [isActive, setIsActive] = React.useState(false);
+  React.useEffect(() => {
+    const savedValue = storageKey ? localStorage.getItem(storageKey) : null, checked2 = !!(savedValue ?? defaultChecked);
+    setIsChecked(checked2);
+    onChange?.(checked2);
+  }, []);
+  React.useEffect(() => {
+    if (isBoolean(checked)) setIsChecked(checked);
+  }, [checked]);
+  function onPress(event) {
+    if (event && "button" in event && event?.button === 1) return;
+    const toggledCheck = !isChecked;
+    setIsChecked(toggledCheck);
+    if (storageKey) localStorage.setItem(storageKey, toggledCheck ? "1" : "");
+    onChange?.(toggledCheck, event?.nativeEvent);
+    setIsActive(false);
+  }
+  function onActive(event) {
+    if (event.button !== 0) return;
+    setIsActive(true);
+  }
+  function onKeyDown(event) {
+    if (isKeyboardClick(event.nativeEvent)) onPress();
+  }
+  return /* @__PURE__ */ React.createElement(
+    "div",
+    {
+      className: "vds-menu-checkbox",
+      role: "menuitemcheckbox",
+      tabIndex: 0,
+      "aria-label": label,
+      "aria-checked": isChecked ? "true" : "false",
+      "data-active": isActive ? "" : null,
+      onPointerUp: onPress,
+      onPointerDown: onActive,
+      onKeyDown
+    }
+  );
+}
+DefaultMenuCheckbox.displayName = "DefaultMenuCheckbox";
+
+function DefaultAccessibilityMenu({ slots }) {
+  const label = useDefaultLayoutWord("Accessibility"), { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-accessibility-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Accessibility }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "accessibilityMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultAnnouncementsMenuCheckbox, null), /* @__PURE__ */ React.createElement(DefaultKeyboardAnimationsMenuCheckbox, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultFontMenu, null)), slot(slots, "accessibilityMenuItemsEnd", null)));
+}
+DefaultAccessibilityMenu.displayName = "DefaultAccessibilityMenu";
+function DefaultAnnouncementsMenuCheckbox() {
+  const { userPrefersAnnouncements } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Announcements");
+  function onChange(checked) {
+    userPrefersAnnouncements.set(checked);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      defaultChecked: true,
+      storageKey: "vds-player::announcements",
+      onChange
+    }
+  ));
+}
+DefaultAnnouncementsMenuCheckbox.displayName = "DefaultAnnouncementsMenuCheckbox";
+function DefaultKeyboardAnimationsMenuCheckbox() {
+  const $viewType = useMediaState("viewType"), { userPrefersKeyboardAnimations, noKeyboardAnimations } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Keyboard Animations");
+  if ($viewType !== "video" || noKeyboardAnimations) return null;
+  function onChange(checked) {
+    userPrefersKeyboardAnimations.set(checked);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      defaultChecked: true,
+      storageKey: "vds-player::keyboard-animations",
+      onChange
+    }
+  ));
+}
+DefaultKeyboardAnimationsMenuCheckbox.displayName = "DefaultKeyboardAnimationsMenuCheckbox";
+
+function DefaultAudioMenu({ slots }) {
+  const label = useDefaultLayoutWord("Audio"), $canSetAudioGain = useMediaState("canSetAudioGain"), $audioTracks = useMediaState("audioTracks"), { noAudioGain, icons: Icons } = useDefaultLayoutContext(), hasGainSlider = $canSetAudioGain && !noAudioGain, $disabled = !hasGainSlider && $audioTracks.length <= 1;
+  if ($disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-audio-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Audio }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "audioMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultAudioTracksMenu, null), hasGainSlider ? /* @__PURE__ */ React.createElement(DefaultAudioBoostMenuSection, null) : null, slot(slots, "audioMenuItemsEnd", null)));
+}
+DefaultAudioMenu.displayName = "DefaultAudioMenu";
+function DefaultAudioBoostMenuSection() {
+  const $audioGain = useMediaState("audioGain"), label = useDefaultLayoutWord("Boost"), value = Math.round((($audioGain ?? 1) - 1) * 100) + "%", $canSetAudioGain = useMediaState("canSetAudioGain"), { noAudioGain, icons: Icons } = useDefaultLayoutContext(), $disabled = !$canSetAudioGain || noAudioGain, min = useGainMin(), max = useGainMax();
+  if ($disabled) return null;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.AudioBoostUp,
+      DownIcon: Icons.Menu.AudioBoostDown,
+      isMin: (($audioGain ?? 1) - 1) * 100 <= min,
+      isMax: (($audioGain ?? 1) - 1) * 100 === max
+    },
+    /* @__PURE__ */ React.createElement(DefaultAudioGainSlider, null)
+  ));
+}
+DefaultAudioBoostMenuSection.displayName = "DefaultAudioBoostMenuSection";
+function useGainMin() {
+  const { audioGains } = useDefaultLayoutContext(), min = isArray(audioGains) ? audioGains[0] : audioGains?.min;
+  return min ?? 0;
+}
+function useGainMax() {
+  const { audioGains } = useDefaultLayoutContext(), max = isArray(audioGains) ? audioGains[audioGains.length - 1] : audioGains?.max;
+  return max ?? 300;
+}
+function useGainStep() {
+  const { audioGains } = useDefaultLayoutContext(), step = isArray(audioGains) ? audioGains[1] - audioGains[0] : audioGains?.step;
+  return step || 25;
+}
+function DefaultAudioGainSlider() {
+  const label = useDefaultLayoutWord("Audio Boost"), min = useGainMin(), max = useGainMax(), step = useGainStep();
+  return /* @__PURE__ */ React.createElement(
+    Root$5,
+    {
+      className: "vds-audio-gain-slider vds-slider",
+      "aria-label": label,
+      min,
+      max,
+      step,
+      keyStep: step
+    },
+    /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+    /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+  );
+}
+DefaultAudioGainSlider.displayName = "DefaultAudioGainSlider";
+function DefaultAudioTracksMenu() {
+  const { icons: Icons } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Track"), defaultText = useDefaultLayoutWord("Default"), $track = useMediaState("audioTrack"), options = useAudioOptions();
+  if (options.disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-audio-track-menu vds-menu" }, /* @__PURE__ */ React.createElement(
+    DefaultMenuButton,
+    {
+      label,
+      hint: $track?.label ?? defaultText,
+      disabled: options.disabled,
+      Icon: Icons.Menu.Audio
+    }
+  ), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, /* @__PURE__ */ React.createElement(
+    Root$1,
+    {
+      className: "vds-audio-radio-group vds-radio-group",
+      value: options.selectedValue
+    },
+    options.map(({ label: label2, value, select }) => /* @__PURE__ */ React.createElement(
+      Item,
+      {
+        className: "vds-audio-radio vds-radio",
+        value,
+        onSelect: select,
+        key: value
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }),
+      /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label" }, label2)
+    ))
+  )));
+}
+DefaultAudioTracksMenu.displayName = "DefaultAudioTracksMenu";
+
+function DefaultCaptionMenu({ slots }) {
+  const { icons: Icons } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Captions"), offText = useDefaultLayoutWord("Off"), options = useCaptionOptions({ off: offText }), hint = options.selectedTrack?.label ?? offText;
+  if (options.disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-captions-menu vds-menu" }, /* @__PURE__ */ React.createElement(
+    DefaultMenuButton,
+    {
+      label,
+      hint,
+      disabled: options.disabled,
+      Icon: Icons.Menu.Captions
+    }
+  ), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "captionsMenuItemsStart", null), /* @__PURE__ */ React.createElement(
+    Root$1,
+    {
+      className: "vds-captions-radio-group vds-radio-group",
+      value: options.selectedValue
+    },
+    options.map(({ label: label2, value, select }) => /* @__PURE__ */ React.createElement(
+      Item,
+      {
+        className: "vds-caption-radio vds-radio",
+        value,
+        onSelect: select,
+        key: value
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }),
+      /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label" }, label2)
+    ))
+  ), slot(slots, "captionsMenuItemsEnd", null)));
+}
+DefaultCaptionMenu.displayName = "DefaultCaptionMenu";
+
+function DefaultPlaybackMenu({ slots }) {
+  const label = useDefaultLayoutWord("Playback"), { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-playback-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Playback }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "playbackMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, slot(slots, "playbackMenuLoop", /* @__PURE__ */ React.createElement(DefaultLoopMenuCheckbox, null))), /* @__PURE__ */ React.createElement(DefaultSpeedMenuSection, null), /* @__PURE__ */ React.createElement(DefaultQualityMenuSection, null), slot(slots, "playbackMenuItemsEnd", null)));
+}
+DefaultPlaybackMenu.displayName = "DefaultPlaybackMenu";
+function DefaultLoopMenuCheckbox() {
+  const { remote } = useMediaContext(), label = useDefaultLayoutWord("Loop");
+  function onChange(checked, trigger) {
+    remote.userPrefersLoopChange(checked, trigger);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(DefaultMenuCheckbox, { label, storageKey: "vds-player::user-loop", onChange }));
+}
+DefaultLoopMenuCheckbox.displayName = "DefaultLoopMenuCheckbox";
+function DefaultAutoQualityMenuCheckbox() {
+  const { remote, qualities } = useMediaContext(), $autoQuality = useMediaState("autoQuality"), label = useDefaultLayoutWord("Auto");
+  function onChange(checked, trigger) {
+    if (checked) {
+      remote.requestAutoQuality(trigger);
+    } else {
+      remote.changeQuality(qualities.selectedIndex, trigger);
+    }
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      checked: $autoQuality,
+      onChange,
+      defaultChecked: $autoQuality
+    }
+  ));
+}
+DefaultAutoQualityMenuCheckbox.displayName = "DefaultAutoQualityMenuCheckbox";
+function DefaultQualityMenuSection() {
+  const { hideQualityBitrate, icons: Icons } = useDefaultLayoutContext(), $canSetQuality = useMediaState("canSetQuality"), $qualities = useMediaState("qualities"), $quality = useMediaState("quality"), label = useDefaultLayoutWord("Quality"), autoText = useDefaultLayoutWord("Auto"), sortedQualities = React.useMemo(() => sortVideoQualities($qualities), [$qualities]);
+  if (!$canSetQuality || $qualities.length <= 1) return null;
+  const height = $quality?.height, bitrate = !hideQualityBitrate ? $quality?.bitrate : null, bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null, value = height ? `${height}p${bitrateText ? ` (${bitrateText})` : ""}` : autoText, isMin = sortedQualities[0] === $quality, isMax = sortedQualities.at(-1) === $quality;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.QualityUp,
+      DownIcon: Icons.Menu.QualityDown,
+      isMin,
+      isMax
+    },
+    /* @__PURE__ */ React.createElement(DefaultQualitySlider, null)
+  ), /* @__PURE__ */ React.createElement(DefaultAutoQualityMenuCheckbox, null));
+}
+DefaultQualityMenuSection.displayName = "DefaultQualityMenuSection";
+function DefaultQualitySlider() {
+  const label = useDefaultLayoutWord("Quality");
+  return /* @__PURE__ */ React.createElement(Root$6, { className: "vds-quality-slider vds-slider", "aria-label": label }, /* @__PURE__ */ React.createElement(DefaultSliderParts, null), /* @__PURE__ */ React.createElement(DefaultSliderSteps, null));
+}
+DefaultQualitySlider.displayName = "DefaultQualitySlider";
+function DefaultSpeedMenuSection() {
+  const { icons: Icons } = useDefaultLayoutContext(), $playbackRate = useMediaState("playbackRate"), $canSetPlaybackRate = useMediaState("canSetPlaybackRate"), label = useDefaultLayoutWord("Speed"), normalText = useDefaultLayoutWord("Normal"), min = useSpeedMin(), max = useSpeedMax(), value = $playbackRate === 1 ? normalText : $playbackRate + "x";
+  if (!$canSetPlaybackRate) return null;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.SpeedUp,
+      DownIcon: Icons.Menu.SpeedDown,
+      isMin: $playbackRate === min,
+      isMax: $playbackRate === max
+    },
+    /* @__PURE__ */ React.createElement(DefaultSpeedSlider, null)
+  ));
+}
+function useSpeedMin() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[0] : rates?.min) ?? 0;
+}
+function useSpeedMax() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[rates.length - 1] : rates?.max) ?? 2;
+}
+function useSpeedStep() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[1] - rates[0] : rates?.step) || 0.25;
+}
+function DefaultSpeedSlider() {
+  const label = useDefaultLayoutWord("Speed"), min = useSpeedMin(), max = useSpeedMax(), step = useSpeedStep();
+  return /* @__PURE__ */ React.createElement(
+    Root$7,
+    {
+      className: "vds-speed-slider vds-slider",
+      "aria-label": label,
+      min,
+      max,
+      step,
+      keyStep: step
+    },
+    /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+    /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+  );
+}
+DefaultSpeedSlider.displayName = "DefaultSpeedSlider";
+
+function DefaultSettingsMenu({
+  tooltip,
+  placement,
+  portalClass = "",
+  slots
+}) {
+  const {
+    showMenuDelay,
+    icons: Icons,
+    isSmallLayout,
+    menuContainer,
+    menuGroup,
+    noModal,
+    colorScheme
+  } = useDefaultLayoutContext(), settingsText = useDefaultLayoutWord("Settings"), $viewType = useMediaState("viewType"), $offset = !isSmallLayout && menuGroup === "bottom" && $viewType === "video" ? 26 : 0, colorSchemeClass = useColorSchemeClass(colorScheme), [isOpen, setIsOpen] = React.useState(false), dialogEl = useParentDialogEl();
+  useScoped(updateFontCssVars);
+  function onOpen() {
+    flushSync(() => {
+      setIsOpen(true);
+    });
+  }
+  function onClose() {
+    setIsOpen(false);
+  }
+  const Content = /* @__PURE__ */ React.createElement(
+    Items,
+    {
+      className: "vds-settings-menu-items vds-menu-items",
+      placement,
+      offset: $offset
+    },
+    isOpen ? /* @__PURE__ */ React.createElement(React.Fragment, null, slot(slots, "settingsMenuItemsStart", null), slot(slots, "settingsMenuStartItems", null), /* @__PURE__ */ React.createElement(DefaultPlaybackMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultAccessibilityMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultAudioMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultCaptionMenu, { slots }), slot(slots, "settingsMenuEndItems", null), slot(slots, "settingsMenuItemsEnd", null)) : null
+  );
+  return /* @__PURE__ */ React.createElement(
+    Root$3,
+    {
+      className: "vds-settings-menu vds-menu",
+      showDelay: showMenuDelay,
+      onOpen,
+      onClose
+    },
+    /* @__PURE__ */ React.createElement(DefaultTooltip, { content: settingsText, placement: tooltip }, /* @__PURE__ */ React.createElement(Button, { className: "vds-menu-button vds-button", "aria-label": settingsText }, /* @__PURE__ */ React.createElement(Icons.Menu.Settings, { className: "vds-icon vds-rotate-icon" }))),
+    noModal || !isSmallLayout ? Content : /* @__PURE__ */ React.createElement(
+      Portal,
+      {
+        className: portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : ""),
+        container: menuContainer ?? dialogEl,
+        disabled: "fullscreen",
+        "data-sm": isSmallLayout ? "" : null,
+        "data-lg": !isSmallLayout ? "" : null,
+        "data-size": isSmallLayout ? "sm" : "lg",
+        "data-view-type": $viewType
+      },
+      Content
+    )
+  );
+}
+DefaultSettingsMenu.displayName = "DefaultSettingsMenu";
+
+function DefaultVolumePopup({ tooltip, orientation, slots }) {
+  const $pointer = useMediaState("pointer"), $muted = useMediaState("muted"), $canSetVolume = useMediaState("canSetVolume"), [rootEl, setRootEl] = React.useState(null), isRootActive = useActive(rootEl), muteButton = slot(slots, "muteButton", /* @__PURE__ */ React.createElement(DefaultMuteButton, { tooltip }));
+  if (!$canSetVolume) {
+    return muteButton;
+  }
+  return $pointer === "coarse" && !$muted ? null : /* @__PURE__ */ React.createElement("div", { className: "vds-volume", "data-active": isRootActive ? "" : null, ref: setRootEl }, muteButton, /* @__PURE__ */ React.createElement("div", { className: "vds-volume-popup" }, slot(slots, "volumeSlider", /* @__PURE__ */ React.createElement(DefaultVolumeSlider, { orientation }))));
+}
+DefaultVolumePopup.displayName = "DefaultVolumePopup";
+function DefaultVolumeSlider(props) {
+  const label = useDefaultLayoutWord("Volume");
+  return /* @__PURE__ */ React.createElement(Root$8, { className: "vds-volume-slider vds-slider", "aria-label": label, ...props }, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }), /* @__PURE__ */ React.createElement(Preview, { className: "vds-slider-preview", noClamp: true }, /* @__PURE__ */ React.createElement(Value, { className: "vds-slider-value" })));
+}
+DefaultVolumeSlider.displayName = "DefaultVolumeSlider";
+function DefaultTimeSlider() {
+  const [instance, setInstance] = React.useState(null), [width, setWidth] = React.useState(0), $src = useMediaState("currentSrc"), { thumbnails, sliderChaptersMinWidth, disableTimeSlider, seekStep, noScrubGesture } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Seek"), $RemotionSliderThumbnail = useSignal(RemotionSliderThumbnail);
+  const onResize = React.useCallback(() => {
+    const el = instance?.el;
+    el && setWidth(el.clientWidth);
+  }, [instance]);
+  useResizeObserver(instance?.el, onResize);
+  return /* @__PURE__ */ React.createElement(
+    Root$9,
+    {
+      className: "vds-time-slider vds-slider",
+      "aria-label": label,
+      disabled: disableTimeSlider,
+      noSwipeGesture: noScrubGesture,
+      keyStep: seekStep,
+      ref: setInstance
+    },
+    /* @__PURE__ */ React.createElement(
+      Chapters,
+      {
+        className: "vds-slider-chapters",
+        disabled: width < sliderChaptersMinWidth
+      },
+      (cues, forwardRef) => cues.map((cue) => /* @__PURE__ */ React.createElement("div", { className: "vds-slider-chapter", key: cue.startTime, ref: forwardRef }, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Progress, { className: "vds-slider-progress vds-slider-track" })))
+    ),
+    /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }),
+    /* @__PURE__ */ React.createElement(Preview, { className: "vds-slider-preview" }, thumbnails ? /* @__PURE__ */ React.createElement(
+      Thumbnail.Root,
+      {
+        src: thumbnails,
+        className: "vds-slider-thumbnail vds-thumbnail"
+      },
+      /* @__PURE__ */ React.createElement(Thumbnail.Img, null)
+    ) : $RemotionSliderThumbnail && isRemotionSrc($src) ? /* @__PURE__ */ React.createElement($RemotionSliderThumbnail, { className: "vds-slider-thumbnail vds-thumbnail" }) : null, /* @__PURE__ */ React.createElement(ChapterTitle, { className: "vds-slider-chapter-title" }), /* @__PURE__ */ React.createElement(Value, { className: "vds-slider-value" }))
+  );
+}
+DefaultTimeSlider.displayName = "DefaultTimeSlider";
+
+function DefaultTimeGroup({ slots }) {
+  const $duration = useMediaState("duration");
+  if (!$duration) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-time-group" }, slot(slots, "currentTime", /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "current" })), slot(slots, "timeSeparator", /* @__PURE__ */ React.createElement("div", { className: "vds-time-divider" }, "/")), slot(slots, "endTime", /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "duration" })));
+}
+DefaultTimeGroup.displayName = "DefaultTimeGroup";
+function DefaultTimeInfo({ slots }) {
+  const $live = useMediaState("live");
+  return $live ? slot(slots, "liveButton", /* @__PURE__ */ React.createElement(DefaultLiveButton, null)) : /* @__PURE__ */ React.createElement(DefaultTimeGroup, { slots });
+}
+DefaultTimeInfo.displayName = "DefaultTimeInfo";
+function DefaultTimeInvert({ slots }) {
+  const $live = useMediaState("live"), $duration = useMediaState("duration");
+  return $live ? slot(slots, "liveButton", /* @__PURE__ */ React.createElement(DefaultLiveButton, null)) : slot(
+    slots,
+    "endTime",
+    $duration ? /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "current", toggle: true, remainder: true }) : null
+  );
+}
+DefaultTimeInvert.displayName = "DefaultTimeInvert";
+
+const MediaLayout$1 = createDefaultMediaLayout({
+  type: "audio",
+  smLayoutWhen({ width }) {
+    return width < 576;
+  },
+  renderLayout: () => /* @__PURE__ */ React.createElement(AudioLayout, null)
+});
+function DefaultAudioLayout(props) {
+  const [scrubbing, setScrubbing] = React.useState(false), $pointer = useMediaState("pointer");
+  const onStartScrubbing = React.useCallback((event) => {
+    const { target } = event, hasTimeSlider = !!(target instanceof HTMLElement && target.closest(".vds-time-slider"));
+    if (!hasTimeSlider) return;
+    event.nativeEvent.stopImmediatePropagation();
+    setScrubbing(true);
+  }, []);
+  const onStopScrubbing = React.useCallback(() => {
+    setScrubbing(false);
+  }, []);
+  React.useEffect(() => {
+    if (scrubbing) return listenEvent(window, "pointerdown", onStopScrubbing);
+  }, [scrubbing, onStopScrubbing]);
+  return /* @__PURE__ */ React.createElement(
+    MediaLayout$1,
+    {
+      ...props,
+      "data-scrubbing": scrubbing ? "" : null,
+      onPointerDown: scrubbing ? (e) => e.stopPropagation() : void 0,
+      onPointerDownCapture: $pointer === "coarse" && !scrubbing ? onStartScrubbing : void 0
+    }
+  );
+}
+DefaultAudioLayout.displayName = "DefaultAudioLayout";
+function AudioLayout() {
+  const slots = useDefaultAudioLayoutSlots();
+  useLayoutName("audio");
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultCaptions, null), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "seekBackwardButton", /* @__PURE__ */ React.createElement(DefaultSeekButton, { backward: true, tooltip: "top start" })), slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top center" })), slot(slots, "seekForwardButton", /* @__PURE__ */ React.createElement(DefaultSeekButton, { tooltip: "top center" })), /* @__PURE__ */ React.createElement(DefaultAudioTitle, null), slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null)), /* @__PURE__ */ React.createElement(DefaultTimeInvert, { slots }), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "vertical", tooltip: "top", slots }), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "top center" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), /* @__PURE__ */ React.createElement(DefaultAudioMenus, { slots }))));
+}
+AudioLayout.displayName = "AudioLayout";
+function DefaultAudioMenus({ slots }) {
+  const { isSmallLayout, noModal } = useDefaultLayoutContext(), placement = noModal ? "top end" : !isSmallLayout ? "top end" : null;
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slot(
+    slots,
+    "chaptersMenu",
+    /* @__PURE__ */ React.createElement(DefaultChaptersMenu, { tooltip: "top", placement, portalClass: "vds-audio-layout" })
+  ), slot(
+    slots,
+    "settingsMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultSettingsMenu,
+      {
+        tooltip: "top end",
+        placement,
+        portalClass: "vds-audio-layout",
+        slots
+      }
+    )
+  ));
+}
+DefaultAudioMenus.displayName = "DefaultAudioMenus";
+function DefaultAudioTitle() {
+  const [rootEl, setRootEl] = React.useState(null), media = useMediaContext(), { translations } = useDefaultLayoutContext(), [isTextOverflowing, setIsTextOverflowing] = React.useState(false);
+  const isContinued = createComputed(() => {
+    const { started, currentTime } = media.$state;
+    return started() || currentTime() > 0;
+  });
+  const $title = useSignal(
+    createComputed(() => {
+      const { title, ended } = media.$state;
+      if (!title()) return "";
+      const word = ended() ? "Replay" : isContinued() ? "Continue" : "Play";
+      return `${i18n(translations, word)}: ${title()}`;
+    })
+  );
+  const chapterTitle = useChapterTitle(), $isContinued = useSignal(isContinued), $chapterTitle = $isContinued ? chapterTitle : "", isTransitionActive = useTransitionActive(rootEl);
+  React.useEffect(() => {
+    if (isTransitionActive && document.activeElement === document.body) {
+      media.player.el?.focus({ preventScroll: true });
+    }
+  }, []);
+  const onResize = React.useCallback(() => {
+    const el = rootEl, isOverflowing = !!el && !isTransitionActive && el.clientWidth < el.children[0].clientWidth;
+    if (el) toggleClass(el, "vds-marquee", isOverflowing);
+    setIsTextOverflowing(isOverflowing);
+  }, [rootEl, isTransitionActive]);
+  useResizeObserver(rootEl, onResize);
+  return $title ? /* @__PURE__ */ React.createElement("span", { className: "vds-title", title: $title, ref: setRootEl }, /* @__PURE__ */ React.createElement(AudioTitle, { title: $title, chapterTitle: $chapterTitle }), isTextOverflowing && !isTransitionActive ? /* @__PURE__ */ React.createElement(AudioTitle, { title: $title, chapterTitle: $chapterTitle }) : null) : /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null);
+}
+DefaultAudioTitle.displayName = "DefaultAudioTitle";
+function AudioTitle({ title, chapterTitle }) {
+  const slots = useDefaultAudioLayoutSlots();
+  return /* @__PURE__ */ React.createElement("span", { className: "vds-title-text" }, slot(slots, "title", title), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-title" }, chapterTitle)));
+}
+AudioTitle.displayName = "AudioTitle";
+
+const DefaultKeyboardDisplay = React.forwardRef(
+  ({ icons: Icons, ...props }, forwardRef) => {
+    const [visible, setVisible] = React.useState(false), [Icon, setIcon] = React.useState(null), [count, setCount] = React.useState(0), $lastKeyboardAction = useMediaState("lastKeyboardAction");
+    React.useEffect(() => {
+      setCount((n) => n + 1);
+    }, [$lastKeyboardAction]);
+    const actionDataAttr = React.useMemo(() => {
+      const action = $lastKeyboardAction?.action;
+      return action && visible ? camelToKebabCase(action) : null;
+    }, [visible, $lastKeyboardAction]);
+    const className = React.useMemo(
+      () => `vds-kb-action${!visible ? " hidden" : ""}${props.className ? ` ${props.className}` : ""}`,
+      [visible]
+    );
+    const $$text = createComputed(getText), $text = useSignal($$text);
+    createEffect(() => {
+      const Icon2 = getIcon(Icons);
+      setIcon(() => Icon2);
+    }, [Icons]);
+    React.useEffect(() => {
+      setVisible(!!$lastKeyboardAction);
+      const id = setTimeout(() => setVisible(false), 500);
+      return () => {
+        setVisible(false);
+        window.clearTimeout(id);
+      };
+    }, [$lastKeyboardAction]);
+    return Icon ? /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props,
+        className,
+        "data-action": actionDataAttr,
+        ref: forwardRef
+      },
+      /* @__PURE__ */ React.createElement("div", { className: "vds-kb-text-wrapper" }, /* @__PURE__ */ React.createElement("div", { className: "vds-kb-text" }, $text)),
+      /* @__PURE__ */ React.createElement("div", { className: "vds-kb-bezel", key: count }, /* @__PURE__ */ React.createElement("div", { className: "vds-kb-icon" }, /* @__PURE__ */ React.createElement(Icon, null)))
+    ) : null;
+  }
+);
+DefaultKeyboardDisplay.displayName = "DefaultKeyboardDisplay";
+function getText() {
+  const { $state } = useContext(mediaContext), action = $state.lastKeyboardAction()?.action, audioGain = $state.audioGain() ?? 1;
+  switch (action) {
+    case "toggleMuted":
+      return $state.muted() ? "0%" : getVolumeText($state.volume(), audioGain);
+    case "volumeUp":
+    case "volumeDown":
+      return getVolumeText($state.volume(), audioGain);
+    default:
+      return "";
+  }
+}
+function getVolumeText(volume, gain) {
+  return `${Math.round(volume * gain * 100)}%`;
+}
+function getIcon(Icons) {
+  const { $state } = useContext(mediaContext), action = $state.lastKeyboardAction()?.action;
+  switch (action) {
+    case "togglePaused":
+      return !$state.paused() ? Icons.Play : Icons.Pause;
+    case "toggleMuted":
+      return $state.muted() || $state.volume() === 0 ? Icons.Mute : $state.volume() >= 0.5 ? Icons.VolumeUp : Icons.VolumeDown;
+    case "toggleFullscreen":
+      return $state.fullscreen() ? Icons.EnterFullscreen : Icons.ExitFullscreen;
+    case "togglePictureInPicture":
+      return $state.pictureInPicture() ? Icons.EnterPiP : Icons.ExitPiP;
+    case "toggleCaptions":
+      return $state.hasCaptions() ? $state.textTrack() ? Icons.CaptionsOn : Icons.CaptionsOff : null;
+    case "volumeUp":
+      return Icons.VolumeUp;
+    case "volumeDown":
+      return Icons.VolumeDown;
+    case "seekForward":
+      return Icons.SeekForward;
+    case "seekBackward":
+      return Icons.SeekBackward;
+    default:
+      return null;
+  }
+}
+
+function DefaultTitle() {
+  const $started = useMediaState("started"), $title = useMediaState("title"), $hasChapters = useActiveTextTrack("chapters");
+  return $hasChapters && ($started || !$title) ? /* @__PURE__ */ React.createElement(ChapterTitle$1, { className: "vds-chapter-title" }) : /* @__PURE__ */ React.createElement(Title, { className: "vds-chapter-title" });
+}
+DefaultTitle.displayName = "DefaultTitle";
+
+const MediaLayout = createDefaultMediaLayout({
+  type: "video",
+  smLayoutWhen({ width, height }) {
+    return width < 576 || height < 380;
+  },
+  renderLayout(props) {
+    return /* @__PURE__ */ React.createElement(VideoLayout, { ...props });
+  }
+});
+function DefaultVideoLayout(props) {
+  return /* @__PURE__ */ React.createElement(MediaLayout, { ...props });
+}
+DefaultVideoLayout.displayName = "DefaultVideoLayout";
+function VideoLayout({ streamType, isLoadLayout, isSmallLayout }) {
+  useLayoutName("video");
+  return isLoadLayout ? /* @__PURE__ */ React.createElement(DefaultVideoLoadLayout, null) : streamType === "unknown" ? /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null) : isSmallLayout ? /* @__PURE__ */ React.createElement(DefaultVideoSmallLayout, null) : /* @__PURE__ */ React.createElement(DefaultVideoLargeLayout, null);
+}
+VideoLayout.displayName = "VideoLayout";
+function DefaultVideoLargeLayout() {
+  const { menuGroup } = useDefaultLayoutContext(), baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.largeLayout };
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultVideoGestures, null), /* @__PURE__ */ React.createElement(DefaultVideoKeyboardDisplay, null), slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "captions", /* @__PURE__ */ React.createElement(DefaultCaptions, null)), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "topControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupEnd", null), menuGroup === "top" && /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "centerControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null))), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top start" })), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "horizontal", tooltip: "top", slots }), /* @__PURE__ */ React.createElement(DefaultTimeInfo, { slots }), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement(DefaultTitle, null)), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "top" })), menuGroup === "bottom" && /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots }), slot(slots, "airPlayButton", /* @__PURE__ */ React.createElement(DefaultAirPlayButton, { tooltip: "top" })), slot(slots, "googleCastButton", /* @__PURE__ */ React.createElement(DefaultGoogleCastButton, { tooltip: "top" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), slot(slots, "pipButton", /* @__PURE__ */ React.createElement(DefaultPIPButton, { tooltip: "top" })), slot(slots, "fullscreenButton", /* @__PURE__ */ React.createElement(DefaultFullscreenButton, { tooltip: "top end" })))));
+}
+DefaultVideoLargeLayout.displayName = "DefaultVideoLargeLayout";
+function DefaultVideoSmallLayout() {
+  const baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.smallLayout };
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultVideoGestures, null), /* @__PURE__ */ React.createElement(DefaultVideoKeyboardDisplay, null), slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "captions", /* @__PURE__ */ React.createElement(DefaultCaptions, null)), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "topControlsGroupStart", null), slot(slots, "airPlayButton", /* @__PURE__ */ React.createElement(DefaultAirPlayButton, { tooltip: "top start" })), slot(slots, "googleCastButton", /* @__PURE__ */ React.createElement(DefaultGoogleCastButton, { tooltip: "top start" })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "bottom" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots }), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "vertical", tooltip: "bottom end", slots }), slot(slots, "topControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group", style: { pointerEvents: "none" } }, slot(slots, "centerControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupCenter", null), slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top" })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, /* @__PURE__ */ React.createElement(DefaultTimeInfo, { slots }), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement(DefaultTitle, null)), slot(slots, "fullscreenButton", /* @__PURE__ */ React.createElement(DefaultFullscreenButton, { tooltip: "top end" }))), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null)))), slot(slots, "startDuration", /* @__PURE__ */ React.createElement(DefaultVideoStartDuration, null)));
+}
+DefaultVideoSmallLayout.displayName = "DefaultVideoSmallLayout";
+function DefaultVideoStartDuration() {
+  const $duration = useMediaState("duration");
+  if ($duration === 0) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-start-duration" }, /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "duration" }));
+}
+DefaultVideoStartDuration.displayName = "DefaultVideoStartDuration";
+function DefaultVideoGestures() {
+  const { noGestures } = useDefaultLayoutContext();
+  if (noGestures) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-gestures" }, /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "pointerup", action: "toggle:paused" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "pointerup", action: "toggle:controls" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "toggle:fullscreen" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "seek:-10" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "seek:10" }));
+}
+DefaultVideoGestures.displayName = "DefaultVideoGestures";
+function DefaultBufferingIndicator() {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-buffering-indicator" }, /* @__PURE__ */ React.createElement(Root$b, { className: "vds-buffering-spinner" }, /* @__PURE__ */ React.createElement(Track$1, { className: "vds-buffering-track" }), /* @__PURE__ */ React.createElement(TrackFill$1, { className: "vds-buffering-track-fill" })));
+}
+DefaultBufferingIndicator.displayName = "DefaultBufferingIndicator";
+function DefaultVideoMenus({ slots }) {
+  const { isSmallLayout, noModal, menuGroup } = useDefaultLayoutContext(), side = menuGroup === "top" || isSmallLayout ? "bottom" : "top", tooltip = `${side} end`, placement = noModal ? `${side} end` : !isSmallLayout ? `${side} end` : null;
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slot(
+    slots,
+    "chaptersMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultChaptersMenu,
+      {
+        tooltip,
+        placement,
+        portalClass: "vds-video-layout"
+      }
+    )
+  ), slot(
+    slots,
+    "settingsMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultSettingsMenu,
+      {
+        tooltip,
+        placement,
+        portalClass: "vds-video-layout",
+        slots
+      }
+    )
+  ));
+}
+DefaultVideoMenus.displayName = "DefaultVideoMenus";
+function DefaultVideoLoadLayout() {
+  const { isSmallLayout } = useDefaultLayoutContext(), baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.[isSmallLayout ? "smallLayout" : "largeLayout"] };
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-load-container" }, slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "loadButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top" })));
+}
+DefaultVideoLoadLayout.displayName = "DefaultVideoLoadLayout";
+function DefaultVideoKeyboardDisplay() {
+  const { noKeyboardAnimations, icons, userPrefersKeyboardAnimations } = useDefaultLayoutContext(), $userPrefersKeyboardAnimations = useSignal(userPrefersKeyboardAnimations), disabled = noKeyboardAnimations || !$userPrefersKeyboardAnimations;
+  if (disabled || !icons.KeyboardDisplay) return null;
+  return /* @__PURE__ */ React.createElement(DefaultKeyboardDisplay, { icons: icons.KeyboardDisplay });
+}
+DefaultVideoKeyboardDisplay.displayName = "DefaultVideoKeyboardDisplay";
+
+export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultLayoutContext, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions, i18n, useDefaultLayoutContext, useDefaultLayoutWord };
diff --git a/dev/chunks/vidstack-Cm3xcWXU.js b/dev/chunks/vidstack-Cm3xcWXU.js
new file mode 100644
index 0000000000000000000000000000000000000000..47fabff109f8e78cdaa7ab6faacfe08aa34444de
--- /dev/null
+++ b/dev/chunks/vidstack-Cm3xcWXU.js
@@ -0,0 +1,548 @@
+"use client"
+
+import { createScope, signal, effect, peek, isString, deferredPromise, listenEvent, isArray } from './vidstack-CH225ns1.js';
+import { TimeRange, RAFLoop, preconnect, ListSymbol, TextTrack, QualitySymbol } from './vidstack-DlEFWAGb.js';
+import { EmbedProvider } from './vidstack-OQaRvsDl.js';
+import { resolveVimeoVideoId, getVimeoVideoInfo } from './vidstack-krOAtKMi.js';
+import 'react';
+import '@floating-ui/dom';
+
+const trackedVimeoEvents = [
+  "bufferend",
+  "bufferstart",
+  // 'cuechange',
+  "durationchange",
+  "ended",
+  "enterpictureinpicture",
+  "error",
+  "fullscreenchange",
+  "leavepictureinpicture",
+  "loaded",
+  // 'loadeddata',
+  // 'loadedmetadata',
+  // 'loadstart',
+  "playProgress",
+  "loadProgress",
+  "pause",
+  "play",
+  "playbackratechange",
+  // 'progress',
+  "qualitychange",
+  "seeked",
+  "seeking",
+  // 'texttrackchange',
+  "timeupdate",
+  "volumechange",
+  "waiting"
+  // 'adstarted',
+  // 'adcompleted',
+  // 'aderror',
+  // 'adskipped',
+  // 'adallcompleted',
+  // 'adclicked',
+  // 'chapterchange',
+  // 'chromecastconnected',
+  // 'remoteplaybackavailabilitychange',
+  // 'remoteplaybackconnecting',
+  // 'remoteplaybackconnect',
+  // 'remoteplaybackdisconnect',
+  // 'liveeventended',
+  // 'liveeventstarted',
+  // 'livestreamoffline',
+  // 'livestreamonline',
+];
+
+class VimeoProvider extends EmbedProvider {
+  $$PROVIDER_TYPE = "VIMEO";
+  scope = createScope();
+  fullscreen;
+  #ctx;
+  #videoId = signal("");
+  #pro = signal(false);
+  #hash = null;
+  #currentSrc = null;
+  #fullscreenActive = false;
+  #seekableRange = new TimeRange(0, 0);
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #currentCue = null;
+  #chaptersTrack = null;
+  #promises = /* @__PURE__ */ new Map();
+  #videoInfoPromise = null;
+  constructor(iframe, ctx) {
+    super(iframe);
+    this.#ctx = ctx;
+    const self = this;
+    this.fullscreen = {
+      get active() {
+        return self.#fullscreenActive;
+      },
+      supported: true,
+      enter: () => this.#remote("requestFullscreen"),
+      exit: () => this.#remote("exitFullscreen")
+    };
+  }
+  /**
+   * Whether tracking session data should be enabled on the embed, including cookies and analytics.
+   * This is turned off by default to be GDPR-compliant.
+   *
+   * @defaultValue `false`
+   */
+  cookies = false;
+  title = true;
+  byline = true;
+  portrait = true;
+  color = "00ADEF";
+  get type() {
+    return "vimeo";
+  }
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  get videoId() {
+    return this.#videoId();
+  }
+  get hash() {
+    return this.#hash;
+  }
+  get isPro() {
+    return this.#pro();
+  }
+  preconnect() {
+    preconnect(this.getOrigin());
+  }
+  setup() {
+    super.setup();
+    effect(this.#watchVideoId.bind(this));
+    effect(this.#watchVideoInfo.bind(this));
+    effect(this.#watchPro.bind(this));
+    this.#ctx.notify("provider-setup", this);
+  }
+  destroy() {
+    this.#reset();
+    this.fullscreen = void 0;
+    const message = "provider destroyed";
+    for (const promises of this.#promises.values()) {
+      for (const { reject } of promises) reject(message);
+    }
+    this.#promises.clear();
+    this.#remote("destroy");
+  }
+  async play() {
+    return this.#remote("play");
+  }
+  async pause() {
+    return this.#remote("pause");
+  }
+  setMuted(muted) {
+    this.#remote("setMuted", muted);
+  }
+  setCurrentTime(time) {
+    this.#remote("seekTo", time);
+    this.#ctx.notify("seeking", time);
+  }
+  setVolume(volume) {
+    this.#remote("setVolume", volume);
+    this.#remote("setMuted", peek(this.#ctx.$state.muted));
+  }
+  setPlaybackRate(rate) {
+    this.#remote("setPlaybackRate", rate);
+  }
+  async loadSource(src) {
+    if (!isString(src.src)) {
+      this.#currentSrc = null;
+      this.#hash = null;
+      this.#videoId.set("");
+      return;
+    }
+    const { videoId, hash } = resolveVimeoVideoId(src.src);
+    this.#videoId.set(videoId ?? "");
+    this.#hash = hash ?? null;
+    this.#currentSrc = src;
+  }
+  #watchVideoId() {
+    this.#reset();
+    const videoId = this.#videoId();
+    if (!videoId) {
+      this.src.set("");
+      return;
+    }
+    this.src.set(`${this.getOrigin()}/video/${videoId}`);
+    this.#ctx.notify("load-start");
+  }
+  #watchVideoInfo() {
+    const videoId = this.#videoId();
+    if (!videoId) return;
+    const promise = deferredPromise(), abort = new AbortController();
+    this.#videoInfoPromise = promise;
+    getVimeoVideoInfo(videoId, abort, this.#hash).then((info) => {
+      promise.resolve(info);
+    }).catch((e) => {
+      promise.reject();
+      {
+        this.#ctx.logger?.warnGroup(`Failed to fetch vimeo video info for id \`${videoId}\`.`).labelledLog("Error", e).dispatch();
+      }
+    });
+    return () => {
+      promise.reject();
+      abort.abort();
+    };
+  }
+  #watchPro() {
+    const isPro = this.#pro(), { $state, qualities } = this.#ctx;
+    $state.canSetPlaybackRate.set(isPro);
+    qualities[ListSymbol.setReadonly](!isPro);
+    if (isPro) {
+      return listenEvent(qualities, "change", () => {
+        if (qualities.auto) return;
+        const id = qualities.selected?.id;
+        if (id) this.#remote("setQuality", id);
+      });
+    }
+  }
+  getOrigin() {
+    return "https://player.vimeo.com";
+  }
+  buildParams() {
+    const { keyDisabled } = this.#ctx.$props, { playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
+    return {
+      title: this.title,
+      byline: this.byline,
+      color: this.color,
+      portrait: this.portrait,
+      controls: showControls,
+      h: this.hash,
+      keyboard: showControls && !keyDisabled(),
+      transparent: true,
+      playsinline: playsInline(),
+      dnt: !this.cookies
+    };
+  }
+  #onAnimationFrame() {
+    this.#remote("getCurrentTime");
+  }
+  // Embed will sometimes dispatch 0 at end of playback.
+  #preventTimeUpdates = false;
+  #onTimeUpdate(time, trigger) {
+    if (this.#preventTimeUpdates && time === 0) return;
+    const { realCurrentTime, paused, bufferedEnd, seekableEnd, live } = this.#ctx.$state;
+    if (realCurrentTime() === time) return;
+    const prevTime = realCurrentTime();
+    this.#ctx.notify("time-change", time, trigger);
+    if (Math.abs(prevTime - time) > 1.5) {
+      this.#ctx.notify("seeking", time, trigger);
+      if (!paused() && bufferedEnd() < time) {
+        this.#ctx.notify("waiting", void 0, trigger);
+      }
+    }
+    if (!live() && seekableEnd() - time < 0.01) {
+      this.#ctx.notify("end", void 0, trigger);
+      this.#preventTimeUpdates = true;
+      setTimeout(() => {
+        this.#preventTimeUpdates = false;
+      }, 500);
+    }
+  }
+  #onSeeked(time, trigger) {
+    this.#ctx.notify("seeked", time, trigger);
+  }
+  #onLoaded(trigger) {
+    const videoId = this.#videoId();
+    this.#videoInfoPromise?.promise.then((info) => {
+      if (!info) return;
+      const { title, poster, duration, pro } = info;
+      this.#pro.set(pro);
+      this.#ctx.notify("title-change", title, trigger);
+      this.#ctx.notify("poster-change", poster, trigger);
+      this.#ctx.notify("duration-change", duration, trigger);
+      this.#onReady(duration, trigger);
+    }).catch(() => {
+      if (videoId !== this.#videoId()) return;
+      this.#remote("getVideoTitle");
+      this.#remote("getDuration");
+    });
+  }
+  #onReady(duration, trigger) {
+    const { nativeControls } = this.#ctx.$state, showEmbedControls = nativeControls();
+    this.#seekableRange = new TimeRange(0, duration);
+    const detail = {
+      buffered: new TimeRange(0, 0),
+      seekable: this.#seekableRange,
+      duration
+    };
+    this.#ctx.delegate.ready(detail, trigger);
+    if (!showEmbedControls) {
+      this.#remote("_hideOverlay");
+    }
+    this.#remote("getQualities");
+    this.#remote("getChapters");
+  }
+  #onMethod(method, data, trigger) {
+    switch (method) {
+      case "getVideoTitle":
+        const videoTitle = data;
+        this.#ctx.notify("title-change", videoTitle, trigger);
+        break;
+      case "getDuration":
+        const duration = data;
+        if (!this.#ctx.$state.canPlay()) {
+          this.#onReady(duration, trigger);
+        } else {
+          this.#ctx.notify("duration-change", duration, trigger);
+        }
+        break;
+      case "getCurrentTime":
+        this.#onTimeUpdate(data, trigger);
+        break;
+      case "getBuffered":
+        if (isArray(data) && data.length) {
+          this.#onLoadProgress(data[data.length - 1][1], trigger);
+        }
+        break;
+      case "setMuted":
+        this.#onVolumeChange(peek(this.#ctx.$state.volume), data, trigger);
+        break;
+      // case 'getTextTracks':
+      //   this.#onTextTracksChange(data as VimeoTextTrack[], trigger);
+      //   break;
+      case "getChapters":
+        this.#onChaptersChange(data);
+        break;
+      case "getQualities":
+        this.#onQualitiesChange(data, trigger);
+        break;
+    }
+    this.#getPromise(method)?.resolve();
+  }
+  #attachListeners() {
+    for (const type of trackedVimeoEvents) {
+      this.#remote("addEventListener", type);
+    }
+  }
+  #onPause(trigger) {
+    this.#timeRAF.stop();
+    this.#ctx.notify("pause", void 0, trigger);
+  }
+  #onPlay(trigger) {
+    this.#timeRAF.start();
+    this.#ctx.notify("play", void 0, trigger);
+  }
+  #onPlayProgress(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (!paused() && !this.#preventTimeUpdates) {
+      this.#ctx.notify("playing", void 0, trigger);
+    }
+  }
+  #onLoadProgress(buffered, trigger) {
+    const detail = {
+      buffered: new TimeRange(0, buffered),
+      seekable: this.#seekableRange
+    };
+    this.#ctx.notify("progress", detail, trigger);
+  }
+  #onBufferStart(trigger) {
+    this.#ctx.notify("waiting", void 0, trigger);
+  }
+  #onBufferEnd(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (!paused()) this.#ctx.notify("playing", void 0, trigger);
+  }
+  #onWaiting(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (paused()) {
+      this.#ctx.notify("play", void 0, trigger);
+    }
+    this.#ctx.notify("waiting", void 0, trigger);
+  }
+  #onVolumeChange(volume, muted, trigger) {
+    const detail = { volume, muted };
+    this.#ctx.notify("volume-change", detail, trigger);
+  }
+  // #onTextTrackChange(track: VimeoTextTrack, trigger: Event) {
+  //   const textTrack = this.#ctx.textTracks.toArray().find((t) => t.language === track.language);
+  //   if (textTrack) textTrack.mode = track.mode;
+  // }
+  // #onTextTracksChange(tracks: VimeoTextTrack[], trigger: Event) {
+  //   for (const init of tracks) {
+  //     const textTrack = new TextTrack({
+  //       ...init,
+  //       label: init.label.replace('auto-generated', 'auto'),
+  //     });
+  //     textTrack[TextTrackSymbol.readyState] = 2;
+  //     this.#ctx.textTracks.add(textTrack, trigger);
+  //     textTrack.setMode(init.mode, trigger);
+  //   }
+  // }
+  // #onCueChange(cue: VimeoTextCue, trigger: Event) {
+  //   const { textTracks, $state } = this.#ctx,
+  //     { currentTime } = $state,
+  //     track = textTracks.selected;
+  //   if (this.#currentCue) track?.removeCue(this.#currentCue, trigger);
+  //   this.#currentCue = new window.VTTCue(currentTime(), Number.MAX_SAFE_INTEGER, cue.text);
+  //   track?.addCue(this.#currentCue, trigger);
+  // }
+  #onChaptersChange(chapters) {
+    this.#removeChapters();
+    if (!chapters.length) return;
+    const track = new TextTrack({
+      kind: "chapters",
+      default: true
+    }), { seekableEnd } = this.#ctx.$state;
+    for (let i = 0; i < chapters.length; i++) {
+      const chapter = chapters[i], nextChapter = chapters[i + 1];
+      track.addCue(
+        new window.VTTCue(
+          chapter.startTime,
+          nextChapter?.startTime ?? seekableEnd(),
+          chapter.title
+        )
+      );
+    }
+    this.#chaptersTrack = track;
+    this.#ctx.textTracks.add(track);
+  }
+  #removeChapters() {
+    if (!this.#chaptersTrack) return;
+    this.#ctx.textTracks.remove(this.#chaptersTrack);
+    this.#chaptersTrack = null;
+  }
+  #onQualitiesChange(qualities, trigger) {
+    this.#ctx.qualities[QualitySymbol.enableAuto] = qualities.some((q) => q.id === "auto") ? () => this.#remote("setQuality", "auto") : void 0;
+    for (const quality of qualities) {
+      if (quality.id === "auto") continue;
+      const height = +quality.id.slice(0, -1);
+      if (isNaN(height)) continue;
+      this.#ctx.qualities[ListSymbol.add](
+        {
+          id: quality.id,
+          width: height * (16 / 9),
+          height,
+          codec: "avc1,h.264",
+          bitrate: -1
+        },
+        trigger
+      );
+    }
+    this.#onQualityChange(
+      qualities.find((q) => q.active),
+      trigger
+    );
+  }
+  #onQualityChange({ id } = {}, trigger) {
+    if (!id) return;
+    const isAuto = id === "auto", newQuality = this.#ctx.qualities.getById(id);
+    if (isAuto) {
+      this.#ctx.qualities[QualitySymbol.setAuto](isAuto, trigger);
+      this.#ctx.qualities[ListSymbol.select](void 0, true, trigger);
+    } else {
+      this.#ctx.qualities[ListSymbol.select](newQuality ?? void 0, true, trigger);
+    }
+  }
+  #onEvent(event, payload, trigger) {
+    switch (event) {
+      case "ready":
+        this.#attachListeners();
+        break;
+      case "loaded":
+        this.#onLoaded(trigger);
+        break;
+      case "play":
+        this.#onPlay(trigger);
+        break;
+      case "playProgress":
+        this.#onPlayProgress(trigger);
+        break;
+      case "pause":
+        this.#onPause(trigger);
+        break;
+      case "loadProgress":
+        this.#onLoadProgress(payload.seconds, trigger);
+        break;
+      case "waiting":
+        this.#onWaiting(trigger);
+        break;
+      case "bufferstart":
+        this.#onBufferStart(trigger);
+        break;
+      case "bufferend":
+        this.#onBufferEnd(trigger);
+        break;
+      case "volumechange":
+        this.#onVolumeChange(payload.volume, peek(this.#ctx.$state.muted), trigger);
+        break;
+      case "durationchange":
+        this.#seekableRange = new TimeRange(0, payload.duration);
+        this.#ctx.notify("duration-change", payload.duration, trigger);
+        break;
+      case "playbackratechange":
+        this.#ctx.notify("rate-change", payload.playbackRate, trigger);
+        break;
+      case "qualitychange":
+        this.#onQualityChange(payload, trigger);
+        break;
+      case "fullscreenchange":
+        this.#fullscreenActive = payload.fullscreen;
+        this.#ctx.notify("fullscreen-change", payload.fullscreen, trigger);
+        break;
+      case "enterpictureinpicture":
+        this.#ctx.notify("picture-in-picture-change", true, trigger);
+        break;
+      case "leavepictureinpicture":
+        this.#ctx.notify("picture-in-picture-change", false, trigger);
+        break;
+      case "ended":
+        this.#ctx.notify("end", void 0, trigger);
+        break;
+      case "error":
+        this.#onError(payload, trigger);
+        break;
+      case "seek":
+      case "seeked":
+        this.#onSeeked(payload.seconds, trigger);
+        break;
+    }
+  }
+  #onError(error, trigger) {
+    const { message, method } = error;
+    if (method === "setPlaybackRate") {
+      this.#pro.set(false);
+    }
+    if (method) {
+      this.#getPromise(method)?.reject(message);
+    }
+    {
+      this.#ctx.logger?.errorGroup(`[vimeo]: ${message}`).labelledLog("Error", error).labelledLog("Provider", this).labelledLog("Event", trigger).dispatch();
+    }
+  }
+  onMessage(message, event) {
+    if (message.event) {
+      this.#onEvent(message.event, message.data, event);
+    } else if (message.method) {
+      this.#onMethod(message.method, message.value, event);
+    }
+  }
+  onLoad() {
+  }
+  async #remote(command, arg) {
+    let promise = deferredPromise(), promises = this.#promises.get(command);
+    if (!promises) this.#promises.set(command, promises = []);
+    promises.push(promise);
+    this.postMessage({
+      method: command,
+      value: arg
+    });
+    return promise.promise;
+  }
+  #reset() {
+    this.#timeRAF.stop();
+    this.#seekableRange = new TimeRange(0, 0);
+    this.#videoInfoPromise = null;
+    this.#currentCue = null;
+    this.#pro.set(false);
+    this.#removeChapters();
+  }
+  #getPromise(command) {
+    return this.#promises.get(command)?.shift();
+  }
+}
+
+export { VimeoProvider };
diff --git a/dev/chunks/vidstack-Cm9GcCaL.js b/dev/chunks/vidstack-Cm9GcCaL.js
new file mode 100644
index 0000000000000000000000000000000000000000..b32c62185ea900cafca685d808a962f86b81bc65
--- /dev/null
+++ b/dev/chunks/vidstack-Cm9GcCaL.js
@@ -0,0 +1,180 @@
+"use client"
+
+import { IS_CHROME, IS_IOS, canGoogleCastSrc, IS_SERVER, loadScript } from './vidstack-DlEFWAGb.js';
+import { listenEvent, peek } from './vidstack-CH225ns1.js';
+
+function getCastFrameworkURL() {
+  return "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";
+}
+function hasLoadedCastFramework() {
+  return !!window.cast?.framework;
+}
+function isCastAvailable() {
+  return !!window.chrome?.cast?.isAvailable;
+}
+function isCastConnected() {
+  return getCastContext().getCastState() === cast.framework.CastState.CONNECTED;
+}
+function getCastContext() {
+  return window.cast.framework.CastContext.getInstance();
+}
+function getCastSession() {
+  return getCastContext().getCurrentSession();
+}
+function getCastSessionMedia() {
+  return getCastSession()?.getSessionObj().media[0];
+}
+function hasActiveCastSession(src) {
+  const contentId = getCastSessionMedia()?.media.contentId;
+  return contentId === src?.src;
+}
+function getDefaultCastOptions() {
+  return {
+    language: "en-US",
+    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
+    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
+    resumeSavedSession: true,
+    androidReceiverCompatible: true
+  };
+}
+function getCastErrorMessage(code) {
+  const defaultMessage = `Google Cast Error Code: ${code}`;
+  {
+    switch (code) {
+      case chrome.cast.ErrorCode.API_NOT_INITIALIZED:
+        return "The API is not initialized.";
+      case chrome.cast.ErrorCode.CANCEL:
+        return "The operation was canceled by the user";
+      case chrome.cast.ErrorCode.CHANNEL_ERROR:
+        return "A channel to the receiver is not available.";
+      case chrome.cast.ErrorCode.EXTENSION_MISSING:
+        return "The Cast extension is not available.";
+      case chrome.cast.ErrorCode.INVALID_PARAMETER:
+        return "The parameters to the operation were not valid.";
+      case chrome.cast.ErrorCode.RECEIVER_UNAVAILABLE:
+        return "No receiver was compatible with the session request.";
+      case chrome.cast.ErrorCode.SESSION_ERROR:
+        return "A session could not be created, or a session was invalid.";
+      case chrome.cast.ErrorCode.TIMEOUT:
+        return "The operation timed out.";
+      default:
+        return defaultMessage;
+    }
+  }
+}
+function listenCastContextEvent(type, handler) {
+  return listenEvent(getCastContext(), type, handler);
+}
+
+class GoogleCastLoader {
+  name = "google-cast";
+  target;
+  #player;
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
+   */
+  get cast() {
+    return getCastContext();
+  }
+  mediaType() {
+    return "video";
+  }
+  canPlay(src) {
+    return IS_CHROME && !IS_IOS && canGoogleCastSrc(src);
+  }
+  async prompt(ctx) {
+    let loadEvent, openEvent, errorEvent;
+    try {
+      loadEvent = await this.#loadCastFramework(ctx);
+      if (!this.#player) {
+        this.#player = new cast.framework.RemotePlayer();
+        new cast.framework.RemotePlayerController(this.#player);
+      }
+      openEvent = ctx.player.createEvent("google-cast-prompt-open", {
+        trigger: loadEvent
+      });
+      ctx.player.dispatchEvent(openEvent);
+      this.#notifyRemoteStateChange(ctx, "connecting", openEvent);
+      await this.#showPrompt(peek(ctx.$props.googleCast));
+      ctx.$state.remotePlaybackInfo.set({
+        deviceName: getCastSession()?.getCastDevice().friendlyName
+      });
+      if (isCastConnected()) this.#notifyRemoteStateChange(ctx, "connected", openEvent);
+    } catch (code) {
+      const error = code instanceof Error ? code : this.#createError(
+        (code + "").toUpperCase(),
+        "Prompt failed."
+      );
+      errorEvent = ctx.player.createEvent("google-cast-prompt-error", {
+        detail: error,
+        trigger: openEvent ?? loadEvent,
+        cancelable: true
+      });
+      ctx.player.dispatch(errorEvent);
+      this.#notifyRemoteStateChange(
+        ctx,
+        isCastConnected() ? "connected" : "disconnected",
+        errorEvent
+      );
+      throw error;
+    } finally {
+      ctx.player.dispatch("google-cast-prompt-close", {
+        trigger: errorEvent ?? openEvent ?? loadEvent
+      });
+    }
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load google cast provider server-side");
+    }
+    if (!this.#player) {
+      throw Error("[vidstack] google cast player was not initialized");
+    }
+    return new (await import('./vidstack-DQ_pDMim.js')).GoogleCastProvider(this.#player, ctx);
+  }
+  async #loadCastFramework(ctx) {
+    if (hasLoadedCastFramework()) return;
+    const loadStartEvent = ctx.player.createEvent("google-cast-load-start");
+    ctx.player.dispatch(loadStartEvent);
+    await loadScript(getCastFrameworkURL());
+    await customElements.whenDefined("google-cast-launcher");
+    const loadedEvent = ctx.player.createEvent("google-cast-loaded", { trigger: loadStartEvent });
+    ctx.player.dispatch(loadedEvent);
+    if (!isCastAvailable()) {
+      throw this.#createError("CAST_NOT_AVAILABLE", "Google Cast not available on this platform.");
+    }
+    return loadedEvent;
+  }
+  async #showPrompt(options) {
+    this.#setOptions(options);
+    const errorCode = await this.cast.requestSession();
+    if (errorCode) {
+      throw this.#createError(
+        errorCode.toUpperCase(),
+        getCastErrorMessage(errorCode)
+      );
+    }
+  }
+  #setOptions(options) {
+    this.cast?.setOptions({
+      ...getDefaultCastOptions(),
+      ...options
+    });
+  }
+  #notifyRemoteStateChange(ctx, state, trigger) {
+    const detail = { type: "google-cast", state };
+    ctx.notify("remote-playback-change", detail, trigger);
+  }
+  #createError(code, message) {
+    const error = Error(message);
+    error.code = code;
+    return error;
+  }
+}
+
+var loader = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  GoogleCastLoader: GoogleCastLoader
+});
+
+export { getCastContext, getCastErrorMessage, getCastSession, getCastSessionMedia, hasActiveCastSession, listenCastContextEvent, loader };
diff --git a/dev/chunks/vidstack-D5DLwsk3.js b/dev/chunks/vidstack-D5DLwsk3.js
new file mode 100644
index 0000000000000000000000000000000000000000..8b7d8d110808d353165baaa4fc5b98c04e85a218
--- /dev/null
+++ b/dev/chunks/vidstack-D5DLwsk3.js
@@ -0,0 +1,1371 @@
+"use client"
+
+import * as React from 'react';
+import { useSignal, isBoolean, composeRefs, uppercaseFirstChar, isUndefined, isString, signal, camelToKebabCase, onDispose, scoped, keysOf, effect, isArray, isKeyboardClick, listenEvent, toggleClass, useContext } from './vidstack-CH225ns1.js';
+import { createComputed, createSignal, MediaAnnouncer, Root, Trigger, Content, GoogleCastButton, Captions, useChapterOptions, Root$1 as Root$5, Root$2 as Root$6, Root$3 as Root$7, useScoped, Root$4 as Root$a, Group, useChapterTitle, createEffect, useActiveTextTrack, ChapterTitle as ChapterTitle$1, Title, Root$5 as Root$b, Track as Track$1, TrackFill as TrackFill$1 } from './vidstack-BHkwyNav.js';
+import { useColorSchemePreference, useActive, useResizeObserver, useLayoutName, useTransitionActive } from './vidstack-Bi0kLSoB.js';
+import { useMediaContext, MuteButton, PlayButton, CaptionButton, PIPButton, FullscreenButton, SeekButton, AirPlayButton, LiveButton, appendParamsToURL, Items, Root$3 as Root$1, Item, Root as Root$2, Img, Root$2 as Root$3, Button, Portal, Track, TrackFill, Thumb, Steps, useMediaPlayer, Root$5 as Root$4, useAudioOptions, useCaptionOptions, Root$4 as Root$8, Preview, Value, Root$1 as Root$9, Chapters, Progress, Thumbnail, ChapterTitle, Time, Gesture } from './vidstack-DEqI2Hy1.js';
+import { useMediaState, isTrackCaptionKind, getDownloadFile, isRemotionSrc, IS_SERVER, useMediaContext as useMediaContext$1, sortVideoQualities, Primitive, mediaContext } from './vidstack-MAWt6ODZ.js';
+import { flushSync } from 'react-dom';
+import { RemotionThumbnail, RemotionSliderThumbnail } from './vidstack-CaBvbWDV.js';
+
+const DefaultLayoutContext = React.createContext({});
+DefaultLayoutContext.displayName = "DefaultLayoutContext";
+function useDefaultLayoutContext() {
+  return React.useContext(DefaultLayoutContext);
+}
+function useDefaultLayoutWord(word) {
+  const { translations } = useDefaultLayoutContext();
+  return i18n(translations, word);
+}
+function i18n(translations, word) {
+  return translations?.[word] ?? word;
+}
+
+function useColorSchemeClass(colorScheme) {
+  const systemColorPreference = useColorSchemePreference();
+  if (colorScheme === "default") {
+    return null;
+  } else if (colorScheme === "system") {
+    return systemColorPreference;
+  } else {
+    return colorScheme;
+  }
+}
+
+function createDefaultMediaLayout({
+  type,
+  smLayoutWhen,
+  renderLayout
+}) {
+  const Layout = React.forwardRef(
+    ({
+      children,
+      className,
+      disableTimeSlider = false,
+      hideQualityBitrate = false,
+      icons,
+      colorScheme = "system",
+      download = null,
+      menuContainer = null,
+      menuGroup = "bottom",
+      noAudioGain = false,
+      audioGains = { min: 0, max: 300, step: 25 },
+      noGestures = false,
+      noKeyboardAnimations = false,
+      noModal = false,
+      noScrubGesture,
+      playbackRates = { min: 0, max: 2, step: 0.25 },
+      seekStep = 10,
+      showMenuDelay,
+      showTooltipDelay = 700,
+      sliderChaptersMinWidth = 325,
+      slots,
+      smallLayoutWhen = smLayoutWhen,
+      thumbnails = null,
+      translations,
+      ...props
+    }, forwardRef) => {
+      const media = useMediaContext(), $load = useSignal(media.$props.load), $canLoad = useMediaState("canLoad"), $viewType = useMediaState("viewType"), $streamType = useMediaState("streamType"), $smallWhen = createComputed(() => {
+        return isBoolean(smallLayoutWhen) ? smallLayoutWhen : smallLayoutWhen(media.player.state);
+      }, [smallLayoutWhen]), userPrefersAnnouncements = createSignal(true), userPrefersKeyboardAnimations = createSignal(true), isMatch = $viewType === type, isSmallLayout = $smallWhen(), isForcedLayout = isBoolean(smallLayoutWhen), isLoadLayout = $load === "play" && !$canLoad, canRender = $canLoad || isForcedLayout || isLoadLayout, colorSchemeClass = useColorSchemeClass(colorScheme), layoutEl = createSignal(null);
+      useSignal($smallWhen);
+      return /* @__PURE__ */ React.createElement(
+        "div",
+        {
+          ...props,
+          className: `vds-${type}-layout` + (colorSchemeClass ? ` ${colorSchemeClass}` : "") + (className ? ` ${className}` : ""),
+          "data-match": isMatch ? "" : null,
+          "data-sm": isSmallLayout ? "" : null,
+          "data-lg": !isSmallLayout ? "" : null,
+          "data-size": isSmallLayout ? "sm" : "lg",
+          "data-no-scrub-gesture": noScrubGesture ? "" : null,
+          ref: composeRefs(layoutEl.set, forwardRef)
+        },
+        canRender && isMatch ? /* @__PURE__ */ React.createElement(
+          DefaultLayoutContext.Provider,
+          {
+            value: {
+              disableTimeSlider,
+              hideQualityBitrate,
+              icons,
+              colorScheme,
+              download,
+              isSmallLayout,
+              menuContainer,
+              menuGroup,
+              noAudioGain,
+              audioGains,
+              layoutEl,
+              noGestures,
+              noKeyboardAnimations,
+              noModal,
+              noScrubGesture,
+              showMenuDelay,
+              showTooltipDelay,
+              sliderChaptersMinWidth,
+              slots,
+              seekStep,
+              playbackRates,
+              thumbnails,
+              translations,
+              userPrefersAnnouncements,
+              userPrefersKeyboardAnimations
+            }
+          },
+          renderLayout({ streamType: $streamType, isSmallLayout, isLoadLayout }),
+          children
+        ) : null
+      );
+    }
+  );
+  Layout.displayName = "DefaultMediaLayout";
+  return Layout;
+}
+
+function useDefaultAudioLayoutSlots() {
+  return React.useContext(DefaultLayoutContext).slots;
+}
+function useDefaultVideoLayoutSlots() {
+  return React.useContext(DefaultLayoutContext).slots;
+}
+function slot(slots, name, defaultValue) {
+  const slot2 = slots?.[name], capitalizedName = uppercaseFirstChar(name);
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slots?.[`before${capitalizedName}`], isUndefined(slot2) ? defaultValue : slot2, slots?.[`after${capitalizedName}`]);
+}
+
+function DefaultAnnouncer() {
+  const { userPrefersAnnouncements, translations } = useDefaultLayoutContext(), $userPrefersAnnouncements = useSignal(userPrefersAnnouncements);
+  if (!$userPrefersAnnouncements) return null;
+  return /* @__PURE__ */ React.createElement(MediaAnnouncer, { translations });
+}
+DefaultAnnouncer.displayName = "DefaultAnnouncer";
+
+function DefaultTooltip({ content, placement, children }) {
+  const { showTooltipDelay } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root, { showDelay: showTooltipDelay }, /* @__PURE__ */ React.createElement(Trigger, { asChild: true }, children), /* @__PURE__ */ React.createElement(Content, { className: "vds-tooltip-content", placement }, content));
+}
+DefaultTooltip.displayName = "DefaultTooltip";
+
+function DefaultPlayButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), playText = useDefaultLayoutWord("Play"), pauseText = useDefaultLayoutWord("Pause"), $paused = useMediaState("paused"), $ended = useMediaState("ended");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $paused ? playText : pauseText, placement: tooltip }, /* @__PURE__ */ React.createElement(PlayButton, { className: "vds-play-button vds-button", "aria-label": playText }, $ended ? /* @__PURE__ */ React.createElement(Icons.PlayButton.Replay, { className: "vds-icon" }) : $paused ? /* @__PURE__ */ React.createElement(Icons.PlayButton.Play, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.PlayButton.Pause, { className: "vds-icon" })));
+}
+DefaultPlayButton.displayName = "DefaultPlayButton";
+const DefaultMuteButton = React.forwardRef(
+  ({ tooltip }, forwardRef) => {
+    const { icons: Icons } = useDefaultLayoutContext(), muteText = useDefaultLayoutWord("Mute"), unmuteText = useDefaultLayoutWord("Unmute"), $muted = useMediaState("muted"), $volume = useMediaState("volume");
+    return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $muted ? unmuteText : muteText, placement: tooltip }, /* @__PURE__ */ React.createElement(MuteButton, { className: "vds-mute-button vds-button", "aria-label": muteText, ref: forwardRef }, $muted || $volume == 0 ? /* @__PURE__ */ React.createElement(Icons.MuteButton.Mute, { className: "vds-icon" }) : $volume < 0.5 ? /* @__PURE__ */ React.createElement(Icons.MuteButton.VolumeLow, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.MuteButton.VolumeHigh, { className: "vds-icon" })));
+  }
+);
+DefaultMuteButton.displayName = "DefaultMuteButton";
+function DefaultCaptionButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), captionsText = useDefaultLayoutWord("Captions"), onText = useDefaultLayoutWord("Closed-Captions On"), offText = useDefaultLayoutWord("Closed-Captions Off"), $track = useMediaState("textTrack"), isOn = $track && isTrackCaptionKind($track);
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: isOn ? onText : offText, placement: tooltip }, /* @__PURE__ */ React.createElement(CaptionButton, { className: "vds-caption-button vds-button", "aria-label": captionsText }, isOn ? /* @__PURE__ */ React.createElement(Icons.CaptionButton.On, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.CaptionButton.Off, { className: "vds-icon" })));
+}
+DefaultCaptionButton.displayName = "DefaultCaptionButton";
+function DefaultPIPButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), pipText = useDefaultLayoutWord("PiP"), enterText = useDefaultLayoutWord("Enter PiP"), exitText = useDefaultLayoutWord("Exit PiP"), $pip = useMediaState("pictureInPicture");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $pip ? exitText : enterText, placement: tooltip }, /* @__PURE__ */ React.createElement(PIPButton, { className: "vds-pip-button vds-button", "aria-label": pipText }, $pip ? /* @__PURE__ */ React.createElement(Icons.PIPButton.Exit, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.PIPButton.Enter, { className: "vds-icon" })));
+}
+DefaultPIPButton.displayName = "DefaultPIPButton";
+function DefaultFullscreenButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), fullscreenText = useDefaultLayoutWord("Fullscreen"), enterText = useDefaultLayoutWord("Enter Fullscreen"), exitText = useDefaultLayoutWord("Exit Fullscreen"), $fullscreen = useMediaState("fullscreen");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $fullscreen ? exitText : enterText, placement: tooltip }, /* @__PURE__ */ React.createElement(FullscreenButton, { className: "vds-fullscreen-button vds-button", "aria-label": fullscreenText }, $fullscreen ? /* @__PURE__ */ React.createElement(Icons.FullscreenButton.Exit, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.FullscreenButton.Enter, { className: "vds-icon" })));
+}
+DefaultFullscreenButton.displayName = "DefaultFullscreenButton";
+function DefaultSeekButton({
+  backward,
+  tooltip
+}) {
+  const { icons: Icons, seekStep } = useDefaultLayoutContext(), seekForwardText = useDefaultLayoutWord("Seek Forward"), seekBackwardText = useDefaultLayoutWord("Seek Backward"), seconds = (backward ? -1 : 1) * seekStep, label = seconds >= 0 ? seekForwardText : seekBackwardText;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: label, placement: tooltip }, /* @__PURE__ */ React.createElement(SeekButton, { className: "vds-seek-button vds-button", seconds, "aria-label": label }, seconds >= 0 ? /* @__PURE__ */ React.createElement(Icons.SeekButton.Forward, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.SeekButton.Backward, { className: "vds-icon" })));
+}
+DefaultSeekButton.displayName = "DefaultSeekButton";
+function DefaultAirPlayButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), airPlayText = useDefaultLayoutWord("AirPlay"), $state = useMediaState("remotePlaybackState"), stateText = useDefaultLayoutWord(uppercaseFirstChar($state)), label = `${airPlayText} ${stateText}`, Icon = ($state === "connecting" ? Icons.AirPlayButton.Connecting : $state === "connected" ? Icons.AirPlayButton.Connected : null) ?? Icons.AirPlayButton.Default;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: airPlayText, placement: tooltip }, /* @__PURE__ */ React.createElement(AirPlayButton, { className: "vds-airplay-button vds-button", "aria-label": label }, /* @__PURE__ */ React.createElement(Icon, { className: "vds-icon" })));
+}
+DefaultAirPlayButton.displayName = "DefaultAirPlayButton";
+function DefaultGoogleCastButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), googleCastText = useDefaultLayoutWord("Google Cast"), $state = useMediaState("remotePlaybackState"), stateText = useDefaultLayoutWord(uppercaseFirstChar($state)), label = `${googleCastText} ${stateText}`, Icon = ($state === "connecting" ? Icons.GoogleCastButton.Connecting : $state === "connected" ? Icons.GoogleCastButton.Connected : null) ?? Icons.GoogleCastButton.Default;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: googleCastText, placement: tooltip }, /* @__PURE__ */ React.createElement(GoogleCastButton, { className: "vds-google-cast-button vds-button", "aria-label": label }, /* @__PURE__ */ React.createElement(Icon, { className: "vds-icon" })));
+}
+DefaultGoogleCastButton.displayName = "DefaultGoogleCastButton";
+function DefaultLiveButton() {
+  const $live = useMediaState("live"), label = useDefaultLayoutWord("Skip To Live"), liveText = useDefaultLayoutWord("LIVE");
+  return $live ? /* @__PURE__ */ React.createElement(LiveButton, { className: "vds-live-button", "aria-label": label }, /* @__PURE__ */ React.createElement("span", { className: "vds-live-button-text" }, liveText)) : null;
+}
+DefaultLiveButton.displayName = "DefaultLiveButton";
+function DefaultDownloadButton() {
+  const { download, icons: Icons } = useDefaultLayoutContext(), $src = useMediaState("source"), $title = useMediaState("title"), file = getDownloadFile({
+    title: $title,
+    src: $src,
+    download
+  }), downloadText = useDefaultLayoutWord("Download");
+  return isString(file?.url) ? /* @__PURE__ */ React.createElement(DefaultTooltip, { content: downloadText, placement: "top" }, /* @__PURE__ */ React.createElement(
+    "a",
+    {
+      role: "button",
+      className: "vds-download-button vds-button",
+      "aria-label": downloadText,
+      href: appendParamsToURL(file.url, { download: file.name }),
+      download: file.name,
+      target: "_blank"
+    },
+    Icons.DownloadButton ? /* @__PURE__ */ React.createElement(Icons.DownloadButton.Default, { className: "vds-icon" }) : null
+  )) : null;
+}
+DefaultDownloadButton.displayName = "DefaultDownloadButton";
+
+function DefaultCaptions() {
+  const exampleText = useDefaultLayoutWord("Captions look like this");
+  return /* @__PURE__ */ React.createElement(Captions, { className: "vds-captions", exampleText });
+}
+DefaultCaptions.displayName = "DefaultCaptions";
+
+function DefaultControlsSpacer() {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-controls-spacer" });
+}
+DefaultControlsSpacer.displayName = "DefaultControlsSpacer";
+
+function useParentDialogEl() {
+  const { layoutEl } = useDefaultLayoutContext(), $layoutEl = useSignal(layoutEl);
+  return React.useMemo(() => $layoutEl?.closest("dialog"), [$layoutEl]);
+}
+
+function DefaultChaptersMenu({ tooltip, placement, portalClass = "" }) {
+  const {
+    showMenuDelay,
+    noModal,
+    isSmallLayout,
+    icons: Icons,
+    menuGroup,
+    menuContainer,
+    colorScheme
+  } = useDefaultLayoutContext(), chaptersText = useDefaultLayoutWord("Chapters"), options = useChapterOptions(), disabled = !options.length, { thumbnails } = useDefaultLayoutContext(), $src = useMediaState("currentSrc"), $viewType = useMediaState("viewType"), $offset = !isSmallLayout && menuGroup === "bottom" && $viewType === "video" ? 26 : 0, $RemotionThumbnail = useSignal(RemotionThumbnail), colorSchemeClass = useColorSchemeClass(colorScheme), [isOpen, setIsOpen] = React.useState(false), dialogEl = useParentDialogEl();
+  if (disabled) return null;
+  function onOpen() {
+    flushSync(() => {
+      setIsOpen(true);
+    });
+  }
+  function onClose() {
+    setIsOpen(false);
+  }
+  const Content = /* @__PURE__ */ React.createElement(
+    Items,
+    {
+      className: "vds-chapters-menu-items vds-menu-items",
+      placement,
+      offset: $offset
+    },
+    isOpen ? /* @__PURE__ */ React.createElement(
+      Root$1,
+      {
+        className: "vds-chapters-radio-group vds-radio-group",
+        value: options.selectedValue,
+        "data-thumbnails": thumbnails ? "" : null
+      },
+      options.map(
+        ({ cue, label, value, startTimeText, durationText, select, setProgressVar }) => /* @__PURE__ */ React.createElement(
+          Item,
+          {
+            className: "vds-chapter-radio vds-radio",
+            value,
+            key: value,
+            onSelect: select,
+            ref: setProgressVar
+          },
+          thumbnails ? /* @__PURE__ */ React.createElement(Root$2, { src: thumbnails, className: "vds-thumbnail", time: cue.startTime }, /* @__PURE__ */ React.createElement(Img, null)) : $RemotionThumbnail && isRemotionSrc($src) ? /* @__PURE__ */ React.createElement($RemotionThumbnail, { className: "vds-thumbnail", frame: cue.startTime * $src.fps }) : null,
+          /* @__PURE__ */ React.createElement("div", { className: "vds-chapter-radio-content" }, /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-label" }, label), /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-start-time" }, startTimeText), /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-duration" }, durationText))
+        )
+      )
+    ) : null
+  );
+  return /* @__PURE__ */ React.createElement(
+    Root$3,
+    {
+      className: "vds-chapters-menu vds-menu",
+      showDelay: showMenuDelay,
+      onOpen,
+      onClose
+    },
+    /* @__PURE__ */ React.createElement(DefaultTooltip, { content: chaptersText, placement: tooltip }, /* @__PURE__ */ React.createElement(
+      Button,
+      {
+        className: "vds-menu-button vds-button",
+        disabled,
+        "aria-label": chaptersText
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.Chapters, { className: "vds-icon" })
+    )),
+    noModal || !isSmallLayout ? Content : /* @__PURE__ */ React.createElement(
+      Portal,
+      {
+        container: menuContainer ?? dialogEl,
+        className: portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : ""),
+        disabled: "fullscreen",
+        "data-sm": isSmallLayout ? "" : null,
+        "data-lg": !isSmallLayout ? "" : null,
+        "data-size": isSmallLayout ? "sm" : "lg"
+      },
+      Content
+    )
+  );
+}
+DefaultChaptersMenu.displayName = "DefaultChaptersMenu";
+
+const FONT_COLOR_OPTION = {
+  type: "color"
+};
+const FONT_FAMILY_OPTION = {
+  type: "radio",
+  values: {
+    "Monospaced Serif": "mono-serif",
+    "Proportional Serif": "pro-serif",
+    "Monospaced Sans-Serif": "mono-sans",
+    "Proportional Sans-Serif": "pro-sans",
+    Casual: "casual",
+    Cursive: "cursive",
+    "Small Capitals": "capitals"
+  }
+};
+const FONT_SIZE_OPTION = {
+  type: "slider",
+  min: 0,
+  max: 400,
+  step: 25,
+  upIcon: null,
+  downIcon: null
+};
+const FONT_OPACITY_OPTION = {
+  type: "slider",
+  min: 0,
+  max: 100,
+  step: 5,
+  upIcon: null,
+  downIcon: null
+};
+const FONT_TEXT_SHADOW_OPTION = {
+  type: "radio",
+  values: ["None", "Drop Shadow", "Raised", "Depressed", "Outline"]
+};
+const FONT_DEFAULTS = {
+  fontFamily: "pro-sans",
+  fontSize: "100%",
+  textColor: "#ffffff",
+  textOpacity: "100%",
+  textShadow: "none",
+  textBg: "#000000",
+  textBgOpacity: "100%",
+  displayBg: "#000000",
+  displayBgOpacity: "0%"
+};
+const FONT_SIGNALS = Object.keys(FONT_DEFAULTS).reduce(
+  (prev, type) => ({
+    ...prev,
+    [type]: signal(FONT_DEFAULTS[type])
+  }),
+  {}
+);
+if (!IS_SERVER) {
+  for (const type of Object.keys(FONT_SIGNALS)) {
+    const value = localStorage.getItem(`vds-player:${camelToKebabCase(type)}`);
+    if (isString(value)) FONT_SIGNALS[type].set(value);
+  }
+}
+function onFontReset() {
+  for (const type of Object.keys(FONT_SIGNALS)) {
+    const defaultValue = FONT_DEFAULTS[type];
+    FONT_SIGNALS[type].set(defaultValue);
+  }
+}
+
+function hexToRgb(hex) {
+  const { style } = new Option();
+  style.color = hex;
+  return style.color.match(/\((.*?)\)/)[1].replace(/,/g, " ");
+}
+
+let isWatchingVars = false, players = /* @__PURE__ */ new Set();
+function updateFontCssVars() {
+  if (IS_SERVER) return;
+  const { player } = useMediaContext$1();
+  players.add(player);
+  onDispose(() => players.delete(player));
+  if (!isWatchingVars) {
+    scoped(() => {
+      for (const type of keysOf(FONT_SIGNALS)) {
+        const $value = FONT_SIGNALS[type], defaultValue = FONT_DEFAULTS[type], varName = `--media-user-${camelToKebabCase(type)}`, storageKey = `vds-player:${camelToKebabCase(type)}`;
+        effect(() => {
+          const value = $value(), isDefaultVarValue = value === defaultValue, varValue = !isDefaultVarValue ? getCssVarValue(player, type, value) : null;
+          for (const player2 of players) {
+            player2.el?.style.setProperty(varName, varValue);
+          }
+          if (isDefaultVarValue) {
+            localStorage.removeItem(storageKey);
+          } else {
+            localStorage.setItem(storageKey, value);
+          }
+        });
+      }
+    }, null);
+    isWatchingVars = true;
+  }
+}
+function getCssVarValue(player, type, value) {
+  switch (type) {
+    case "fontFamily":
+      const fontVariant = value === "capitals" ? "small-caps" : "";
+      player.el?.style.setProperty("--media-user-font-variant", fontVariant);
+      return getFontFamilyCSSVarValue(value);
+    case "fontSize":
+    case "textOpacity":
+    case "textBgOpacity":
+    case "displayBgOpacity":
+      return percentToRatio(value);
+    case "textColor":
+      return `rgb(${hexToRgb(value)} / var(--media-user-text-opacity, 1))`;
+    case "textShadow":
+      return getTextShadowCssVarValue(value);
+    case "textBg":
+      return `rgb(${hexToRgb(value)} / var(--media-user-text-bg-opacity, 1))`;
+    case "displayBg":
+      return `rgb(${hexToRgb(value)} / var(--media-user-display-bg-opacity, 1))`;
+  }
+}
+function percentToRatio(value) {
+  return (parseInt(value) / 100).toString();
+}
+function getFontFamilyCSSVarValue(value) {
+  switch (value) {
+    case "mono-serif":
+      return '"Courier New", Courier, "Nimbus Mono L", "Cutive Mono", monospace';
+    case "mono-sans":
+      return '"Deja Vu Sans Mono", "Lucida Console", Monaco, Consolas, "PT Mono", monospace';
+    case "pro-sans":
+      return 'Roboto, "Arial Unicode Ms", Arial, Helvetica, Verdana, "PT Sans Caption", sans-serif';
+    case "casual":
+      return '"Comic Sans MS", Impact, Handlee, fantasy';
+    case "cursive":
+      return '"Monotype Corsiva", "URW Chancery L", "Apple Chancery", "Dancing Script", cursive';
+    case "capitals":
+      return '"Arial Unicode Ms", Arial, Helvetica, Verdana, "Marcellus SC", sans-serif + font-variant=small-caps';
+    default:
+      return '"Times New Roman", Times, Georgia, Cambria, "PT Serif Caption", serif';
+  }
+}
+function getTextShadowCssVarValue(value) {
+  switch (value) {
+    case "drop shadow":
+      return "rgb(34, 34, 34) 1.86389px 1.86389px 2.79583px, rgb(34, 34, 34) 1.86389px 1.86389px 3.72778px, rgb(34, 34, 34) 1.86389px 1.86389px 4.65972px";
+    case "raised":
+      return "rgb(34, 34, 34) 1px 1px, rgb(34, 34, 34) 2px 2px";
+    case "depressed":
+      return "rgb(204, 204, 204) 1px 1px, rgb(34, 34, 34) -1px -1px";
+    case "outline":
+      return "rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px";
+    default:
+      return "";
+  }
+}
+
+function DefaultMenuSection({ label, value, children }) {
+  const id = React.useId();
+  if (!label) {
+    return /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section" }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-body" }, children));
+  }
+  return /* @__PURE__ */ React.createElement("section", { className: "vds-menu-section", role: "group", "aria-labelledby": id }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-title" }, /* @__PURE__ */ React.createElement("header", { id }, label), value ? /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-value" }, value) : null), /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-body" }, children));
+}
+DefaultMenuSection.displayName = "DefaultMenuSection";
+function DefaultMenuButton({ label, hint = "", Icon, disabled = false }) {
+  const { icons: Icons } = React.useContext(DefaultLayoutContext);
+  return /* @__PURE__ */ React.createElement(Button, { className: "vds-menu-item", disabled }, /* @__PURE__ */ React.createElement(Icons.Menu.ArrowLeft, { className: "vds-menu-close-icon vds-icon" }), Icon ? /* @__PURE__ */ React.createElement(Icon, { className: "vds-menu-item-icon vds-icon" }) : null, /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-label" }, label), /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-hint" }, hint), /* @__PURE__ */ React.createElement(Icons.Menu.ArrowRight, { className: "vds-menu-open-icon vds-icon" }));
+}
+DefaultMenuButton.displayName = "DefaultMenuButton";
+function DefaultMenuItem({ label, children }) {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-menu-item" }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-item-label" }, label), children);
+}
+DefaultMenuItem.displayName = "DefaultMenuItem";
+function DefaultMenuRadioGroup({ value, options, onChange }) {
+  const { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$1, { className: "vds-radio-group", value, onChange }, options.map((option) => /* @__PURE__ */ React.createElement(Item, { className: "vds-radio", value: option.value, key: option.value }, /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }), /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label", "data-part": "label" }, option.label))));
+}
+DefaultMenuRadioGroup.displayName = "DefaultMenuRadioGroup";
+function createRadioOptions(entries) {
+  return React.useMemo(
+    () => isArray(entries) ? entries.map((entry) => ({ label: entry, value: entry.toLowerCase() })) : Object.keys(entries).map((label) => ({ label, value: entries[label] })),
+    [entries]
+  );
+}
+
+function DefaultMenuSliderItem({
+  label,
+  value,
+  UpIcon,
+  DownIcon,
+  children,
+  isMin,
+  isMax
+}) {
+  const hasTitle = label || value, Content = /* @__PURE__ */ React.createElement(React.Fragment, null, DownIcon ? /* @__PURE__ */ React.createElement(DownIcon, { className: "vds-icon down" }) : null, children, UpIcon ? /* @__PURE__ */ React.createElement(UpIcon, { className: "vds-icon up" }) : null);
+  return /* @__PURE__ */ React.createElement(
+    "div",
+    {
+      className: `vds-menu-item vds-menu-slider-item${hasTitle ? " group" : ""}`,
+      "data-min": isMin ? "" : null,
+      "data-max": isMax ? "" : null
+    },
+    hasTitle ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-slider-title" }, label ? /* @__PURE__ */ React.createElement("div", null, label) : null, value ? /* @__PURE__ */ React.createElement("div", null, value) : null), /* @__PURE__ */ React.createElement("div", { className: "vds-menu-slider-body" }, Content)) : Content
+  );
+}
+DefaultMenuSliderItem.displayName = "DefaultMenuSliderItem";
+function DefaultSliderParts() {
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }));
+}
+DefaultSliderParts.displayName = "DefaultSliderParts";
+function DefaultSliderSteps() {
+  return /* @__PURE__ */ React.createElement(Steps, { className: "vds-slider-steps" }, (step) => /* @__PURE__ */ React.createElement("div", { className: "vds-slider-step", key: String(step) }));
+}
+DefaultSliderSteps.displayName = "DefaultSliderSteps";
+
+function DefaultFontMenu() {
+  const label = useDefaultLayoutWord("Caption Styles"), $hasCaptions = useMediaState("hasCaptions"), fontSectionLabel = useDefaultLayoutWord("Font"), textSectionLabel = useDefaultLayoutWord("Text"), textBgSectionLabel = useDefaultLayoutWord("Text Background"), displayBgSectionLabel = useDefaultLayoutWord("Display Background");
+  if (!$hasCaptions) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-font-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label }), /* @__PURE__ */ React.createElement(Items, { className: "vds-font-style-items vds-menu-items" }, /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: fontSectionLabel }, /* @__PURE__ */ React.createElement(DefaultFontFamilyMenu, null), /* @__PURE__ */ React.createElement(DefaultFontSizeSlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: textSectionLabel }, /* @__PURE__ */ React.createElement(DefaultTextColorInput, null), /* @__PURE__ */ React.createElement(DefaultTextShadowMenu, null), /* @__PURE__ */ React.createElement(DefaultTextOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: textBgSectionLabel }, /* @__PURE__ */ React.createElement(DefaultTextBgInput, null), /* @__PURE__ */ React.createElement(DefaultTextBgOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: displayBgSectionLabel }, /* @__PURE__ */ React.createElement(DefaultDisplayBgInput, null), /* @__PURE__ */ React.createElement(DefaultDisplayBgOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultResetMenuItem, null))));
+}
+DefaultFontMenu.displayName = "DefaultFontMenu";
+function DefaultFontFamilyMenu() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Family", type: "fontFamily", option: FONT_FAMILY_OPTION });
+}
+DefaultFontFamilyMenu.displayName = "DefaultFontFamilyMenu";
+function DefaultFontSizeSlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_SIZE_OPTION,
+    upIcon: Icons.Menu.FontSizeUp,
+    downIcon: Icons.Menu.FontSizeDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Size", type: "fontSize", option });
+}
+DefaultFontSizeSlider.displayName = "DefaultFontSizeSlider";
+function DefaultTextColorInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "textColor", option: FONT_COLOR_OPTION });
+}
+DefaultTextColorInput.displayName = "DefaultTextColorInput";
+function DefaultTextOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "textOpacity", option });
+}
+DefaultTextOpacitySlider.displayName = "DefaultTextOpacitySlider";
+function DefaultTextShadowMenu() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Shadow", type: "textShadow", option: FONT_TEXT_SHADOW_OPTION });
+}
+DefaultTextShadowMenu.displayName = "DefaultTextShadowMenu";
+function DefaultTextBgInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "textBg", option: FONT_COLOR_OPTION });
+}
+DefaultTextBgInput.displayName = "DefaultTextBgInput";
+function DefaultTextBgOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "textBgOpacity", option });
+}
+DefaultTextBgOpacitySlider.displayName = "DefaultTextBgOpacitySlider";
+function DefaultDisplayBgInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "displayBg", option: FONT_COLOR_OPTION });
+}
+DefaultDisplayBgInput.displayName = "DefaultDisplayBgInput";
+function DefaultDisplayBgOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "displayBgOpacity", option });
+}
+DefaultDisplayBgOpacitySlider.displayName = "DefaultDisplayBgOpacitySlider";
+function DefaultFontSetting({ label, option, type }) {
+  const player = useMediaPlayer(), $currentValue = FONT_SIGNALS[type], $value = useSignal($currentValue), translatedLabel = useDefaultLayoutWord(label);
+  const notify = React.useCallback(() => {
+    player?.dispatchEvent(new Event("vds-font-change"));
+  }, [player]);
+  const onChange = React.useCallback(
+    (newValue) => {
+      $currentValue.set(newValue);
+      notify();
+    },
+    [$currentValue, notify]
+  );
+  if (option.type === "color") {
+    let onColorChange2 = function(event) {
+      onChange(event.target.value);
+    };
+    return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label: translatedLabel }, /* @__PURE__ */ React.createElement("input", { className: "vds-color-picker", type: "color", value: $value, onChange: onColorChange2 }));
+  }
+  if (option.type === "slider") {
+    let onSliderValueChange2 = function(value) {
+      onChange(value + "%");
+    };
+    const { min, max, step, upIcon, downIcon } = option;
+    return /* @__PURE__ */ React.createElement(
+      DefaultMenuSliderItem,
+      {
+        label: translatedLabel,
+        value: $value,
+        UpIcon: upIcon,
+        DownIcon: downIcon,
+        isMin: $value === min + "%",
+        isMax: $value === max + "%"
+      },
+      /* @__PURE__ */ React.createElement(
+        Root$4,
+        {
+          className: "vds-slider",
+          min,
+          max,
+          step,
+          keyStep: step,
+          value: parseInt($value),
+          "aria-label": translatedLabel,
+          onValueChange: onSliderValueChange2,
+          onDragValueChange: onSliderValueChange2
+        },
+        /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+        /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+      )
+    );
+  }
+  if (option.type === "radio") {
+    return /* @__PURE__ */ React.createElement(
+      DefaultFontRadioGroup,
+      {
+        id: camelToKebabCase(type),
+        label: translatedLabel,
+        value: $value,
+        values: option.values,
+        onChange
+      }
+    );
+  }
+  return null;
+}
+DefaultFontSetting.displayName = "DefaultFontSetting";
+function DefaultFontRadioGroup({ id, label, value, values, onChange }) {
+  const radioOptions = createRadioOptions(values), { translations } = useDefaultLayoutContext(), hint = React.useMemo(() => {
+    const label2 = radioOptions.find((radio) => radio.value === value)?.label || "";
+    return i18n(translations, label2);
+  }, [value, radioOptions]);
+  return /* @__PURE__ */ React.createElement(Root$3, { className: `vds-${id}-menu vds-menu` }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, hint }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, /* @__PURE__ */ React.createElement(DefaultMenuRadioGroup, { value, options: radioOptions, onChange })));
+}
+DefaultFontRadioGroup.displayName = "DefaultFontRadioGroup";
+function DefaultResetMenuItem() {
+  const resetText = useDefaultLayoutWord("Reset");
+  return /* @__PURE__ */ React.createElement("button", { className: "vds-menu-item", role: "menuitem", onClick: onFontReset }, /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-label" }, resetText));
+}
+DefaultResetMenuItem.displayName = "DefaultResetMenuItem";
+
+function DefaultMenuCheckbox({
+  label,
+  checked,
+  storageKey,
+  defaultChecked = false,
+  onChange
+}) {
+  const [isChecked, setIsChecked] = React.useState(defaultChecked), [isActive, setIsActive] = React.useState(false);
+  React.useEffect(() => {
+    const savedValue = storageKey ? localStorage.getItem(storageKey) : null, checked2 = !!(savedValue ?? defaultChecked);
+    setIsChecked(checked2);
+    onChange?.(checked2);
+  }, []);
+  React.useEffect(() => {
+    if (isBoolean(checked)) setIsChecked(checked);
+  }, [checked]);
+  function onPress(event) {
+    if (event && "button" in event && event?.button === 1) return;
+    const toggledCheck = !isChecked;
+    setIsChecked(toggledCheck);
+    if (storageKey) localStorage.setItem(storageKey, toggledCheck ? "1" : "");
+    onChange?.(toggledCheck, event?.nativeEvent);
+    setIsActive(false);
+  }
+  function onActive(event) {
+    if (event.button !== 0) return;
+    setIsActive(true);
+  }
+  function onKeyDown(event) {
+    if (isKeyboardClick(event.nativeEvent)) onPress();
+  }
+  return /* @__PURE__ */ React.createElement(
+    "div",
+    {
+      className: "vds-menu-checkbox",
+      role: "menuitemcheckbox",
+      tabIndex: 0,
+      "aria-label": label,
+      "aria-checked": isChecked ? "true" : "false",
+      "data-active": isActive ? "" : null,
+      onPointerUp: onPress,
+      onPointerDown: onActive,
+      onKeyDown
+    }
+  );
+}
+DefaultMenuCheckbox.displayName = "DefaultMenuCheckbox";
+
+function DefaultAccessibilityMenu({ slots }) {
+  const label = useDefaultLayoutWord("Accessibility"), { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-accessibility-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Accessibility }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "accessibilityMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultAnnouncementsMenuCheckbox, null), /* @__PURE__ */ React.createElement(DefaultKeyboardAnimationsMenuCheckbox, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultFontMenu, null)), slot(slots, "accessibilityMenuItemsEnd", null)));
+}
+DefaultAccessibilityMenu.displayName = "DefaultAccessibilityMenu";
+function DefaultAnnouncementsMenuCheckbox() {
+  const { userPrefersAnnouncements } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Announcements");
+  function onChange(checked) {
+    userPrefersAnnouncements.set(checked);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      defaultChecked: true,
+      storageKey: "vds-player::announcements",
+      onChange
+    }
+  ));
+}
+DefaultAnnouncementsMenuCheckbox.displayName = "DefaultAnnouncementsMenuCheckbox";
+function DefaultKeyboardAnimationsMenuCheckbox() {
+  const $viewType = useMediaState("viewType"), { userPrefersKeyboardAnimations, noKeyboardAnimations } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Keyboard Animations");
+  if ($viewType !== "video" || noKeyboardAnimations) return null;
+  function onChange(checked) {
+    userPrefersKeyboardAnimations.set(checked);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      defaultChecked: true,
+      storageKey: "vds-player::keyboard-animations",
+      onChange
+    }
+  ));
+}
+DefaultKeyboardAnimationsMenuCheckbox.displayName = "DefaultKeyboardAnimationsMenuCheckbox";
+
+function DefaultAudioMenu({ slots }) {
+  const label = useDefaultLayoutWord("Audio"), $canSetAudioGain = useMediaState("canSetAudioGain"), $audioTracks = useMediaState("audioTracks"), { noAudioGain, icons: Icons } = useDefaultLayoutContext(), hasGainSlider = $canSetAudioGain && !noAudioGain, $disabled = !hasGainSlider && $audioTracks.length <= 1;
+  if ($disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-audio-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Audio }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "audioMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultAudioTracksMenu, null), hasGainSlider ? /* @__PURE__ */ React.createElement(DefaultAudioBoostMenuSection, null) : null, slot(slots, "audioMenuItemsEnd", null)));
+}
+DefaultAudioMenu.displayName = "DefaultAudioMenu";
+function DefaultAudioBoostMenuSection() {
+  const $audioGain = useMediaState("audioGain"), label = useDefaultLayoutWord("Boost"), value = Math.round((($audioGain ?? 1) - 1) * 100) + "%", $canSetAudioGain = useMediaState("canSetAudioGain"), { noAudioGain, icons: Icons } = useDefaultLayoutContext(), $disabled = !$canSetAudioGain || noAudioGain, min = useGainMin(), max = useGainMax();
+  if ($disabled) return null;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.AudioBoostUp,
+      DownIcon: Icons.Menu.AudioBoostDown,
+      isMin: (($audioGain ?? 1) - 1) * 100 <= min,
+      isMax: (($audioGain ?? 1) - 1) * 100 === max
+    },
+    /* @__PURE__ */ React.createElement(DefaultAudioGainSlider, null)
+  ));
+}
+DefaultAudioBoostMenuSection.displayName = "DefaultAudioBoostMenuSection";
+function useGainMin() {
+  const { audioGains } = useDefaultLayoutContext(), min = isArray(audioGains) ? audioGains[0] : audioGains?.min;
+  return min ?? 0;
+}
+function useGainMax() {
+  const { audioGains } = useDefaultLayoutContext(), max = isArray(audioGains) ? audioGains[audioGains.length - 1] : audioGains?.max;
+  return max ?? 300;
+}
+function useGainStep() {
+  const { audioGains } = useDefaultLayoutContext(), step = isArray(audioGains) ? audioGains[1] - audioGains[0] : audioGains?.step;
+  return step || 25;
+}
+function DefaultAudioGainSlider() {
+  const label = useDefaultLayoutWord("Audio Boost"), min = useGainMin(), max = useGainMax(), step = useGainStep();
+  return /* @__PURE__ */ React.createElement(
+    Root$5,
+    {
+      className: "vds-audio-gain-slider vds-slider",
+      "aria-label": label,
+      min,
+      max,
+      step,
+      keyStep: step
+    },
+    /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+    /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+  );
+}
+DefaultAudioGainSlider.displayName = "DefaultAudioGainSlider";
+function DefaultAudioTracksMenu() {
+  const { icons: Icons } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Track"), defaultText = useDefaultLayoutWord("Default"), $track = useMediaState("audioTrack"), options = useAudioOptions();
+  if (options.disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-audio-track-menu vds-menu" }, /* @__PURE__ */ React.createElement(
+    DefaultMenuButton,
+    {
+      label,
+      hint: $track?.label ?? defaultText,
+      disabled: options.disabled,
+      Icon: Icons.Menu.Audio
+    }
+  ), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, /* @__PURE__ */ React.createElement(
+    Root$1,
+    {
+      className: "vds-audio-radio-group vds-radio-group",
+      value: options.selectedValue
+    },
+    options.map(({ label: label2, value, select }) => /* @__PURE__ */ React.createElement(
+      Item,
+      {
+        className: "vds-audio-radio vds-radio",
+        value,
+        onSelect: select,
+        key: value
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }),
+      /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label" }, label2)
+    ))
+  )));
+}
+DefaultAudioTracksMenu.displayName = "DefaultAudioTracksMenu";
+
+function DefaultCaptionMenu({ slots }) {
+  const { icons: Icons } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Captions"), offText = useDefaultLayoutWord("Off"), options = useCaptionOptions({ off: offText }), hint = options.selectedTrack?.label ?? offText;
+  if (options.disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-captions-menu vds-menu" }, /* @__PURE__ */ React.createElement(
+    DefaultMenuButton,
+    {
+      label,
+      hint,
+      disabled: options.disabled,
+      Icon: Icons.Menu.Captions
+    }
+  ), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "captionsMenuItemsStart", null), /* @__PURE__ */ React.createElement(
+    Root$1,
+    {
+      className: "vds-captions-radio-group vds-radio-group",
+      value: options.selectedValue
+    },
+    options.map(({ label: label2, value, select }) => /* @__PURE__ */ React.createElement(
+      Item,
+      {
+        className: "vds-caption-radio vds-radio",
+        value,
+        onSelect: select,
+        key: value
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }),
+      /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label" }, label2)
+    ))
+  ), slot(slots, "captionsMenuItemsEnd", null)));
+}
+DefaultCaptionMenu.displayName = "DefaultCaptionMenu";
+
+function DefaultPlaybackMenu({ slots }) {
+  const label = useDefaultLayoutWord("Playback"), { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-playback-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Playback }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "playbackMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, slot(slots, "playbackMenuLoop", /* @__PURE__ */ React.createElement(DefaultLoopMenuCheckbox, null))), /* @__PURE__ */ React.createElement(DefaultSpeedMenuSection, null), /* @__PURE__ */ React.createElement(DefaultQualityMenuSection, null), slot(slots, "playbackMenuItemsEnd", null)));
+}
+DefaultPlaybackMenu.displayName = "DefaultPlaybackMenu";
+function DefaultLoopMenuCheckbox() {
+  const { remote } = useMediaContext(), label = useDefaultLayoutWord("Loop");
+  function onChange(checked, trigger) {
+    remote.userPrefersLoopChange(checked, trigger);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(DefaultMenuCheckbox, { label, storageKey: "vds-player::user-loop", onChange }));
+}
+DefaultLoopMenuCheckbox.displayName = "DefaultLoopMenuCheckbox";
+function DefaultAutoQualityMenuCheckbox() {
+  const { remote, qualities } = useMediaContext(), $autoQuality = useMediaState("autoQuality"), label = useDefaultLayoutWord("Auto");
+  function onChange(checked, trigger) {
+    if (checked) {
+      remote.requestAutoQuality(trigger);
+    } else {
+      remote.changeQuality(qualities.selectedIndex, trigger);
+    }
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      checked: $autoQuality,
+      onChange,
+      defaultChecked: $autoQuality
+    }
+  ));
+}
+DefaultAutoQualityMenuCheckbox.displayName = "DefaultAutoQualityMenuCheckbox";
+function DefaultQualityMenuSection() {
+  const { hideQualityBitrate, icons: Icons } = useDefaultLayoutContext(), $canSetQuality = useMediaState("canSetQuality"), $qualities = useMediaState("qualities"), $quality = useMediaState("quality"), label = useDefaultLayoutWord("Quality"), autoText = useDefaultLayoutWord("Auto"), sortedQualities = React.useMemo(() => sortVideoQualities($qualities), [$qualities]);
+  if (!$canSetQuality || $qualities.length <= 1) return null;
+  const height = $quality?.height, bitrate = !hideQualityBitrate ? $quality?.bitrate : null, bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null, value = height ? `${height}p${bitrateText ? ` (${bitrateText})` : ""}` : autoText, isMin = sortedQualities[0] === $quality, isMax = sortedQualities.at(-1) === $quality;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.QualityUp,
+      DownIcon: Icons.Menu.QualityDown,
+      isMin,
+      isMax
+    },
+    /* @__PURE__ */ React.createElement(DefaultQualitySlider, null)
+  ), /* @__PURE__ */ React.createElement(DefaultAutoQualityMenuCheckbox, null));
+}
+DefaultQualityMenuSection.displayName = "DefaultQualityMenuSection";
+function DefaultQualitySlider() {
+  const label = useDefaultLayoutWord("Quality");
+  return /* @__PURE__ */ React.createElement(Root$6, { className: "vds-quality-slider vds-slider", "aria-label": label }, /* @__PURE__ */ React.createElement(DefaultSliderParts, null), /* @__PURE__ */ React.createElement(DefaultSliderSteps, null));
+}
+DefaultQualitySlider.displayName = "DefaultQualitySlider";
+function DefaultSpeedMenuSection() {
+  const { icons: Icons } = useDefaultLayoutContext(), $playbackRate = useMediaState("playbackRate"), $canSetPlaybackRate = useMediaState("canSetPlaybackRate"), label = useDefaultLayoutWord("Speed"), normalText = useDefaultLayoutWord("Normal"), min = useSpeedMin(), max = useSpeedMax(), value = $playbackRate === 1 ? normalText : $playbackRate + "x";
+  if (!$canSetPlaybackRate) return null;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.SpeedUp,
+      DownIcon: Icons.Menu.SpeedDown,
+      isMin: $playbackRate === min,
+      isMax: $playbackRate === max
+    },
+    /* @__PURE__ */ React.createElement(DefaultSpeedSlider, null)
+  ));
+}
+function useSpeedMin() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[0] : rates?.min) ?? 0;
+}
+function useSpeedMax() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[rates.length - 1] : rates?.max) ?? 2;
+}
+function useSpeedStep() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[1] - rates[0] : rates?.step) || 0.25;
+}
+function DefaultSpeedSlider() {
+  const label = useDefaultLayoutWord("Speed"), min = useSpeedMin(), max = useSpeedMax(), step = useSpeedStep();
+  return /* @__PURE__ */ React.createElement(
+    Root$7,
+    {
+      className: "vds-speed-slider vds-slider",
+      "aria-label": label,
+      min,
+      max,
+      step,
+      keyStep: step
+    },
+    /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+    /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+  );
+}
+DefaultSpeedSlider.displayName = "DefaultSpeedSlider";
+
+function DefaultSettingsMenu({
+  tooltip,
+  placement,
+  portalClass = "",
+  slots
+}) {
+  const {
+    showMenuDelay,
+    icons: Icons,
+    isSmallLayout,
+    menuContainer,
+    menuGroup,
+    noModal,
+    colorScheme
+  } = useDefaultLayoutContext(), settingsText = useDefaultLayoutWord("Settings"), $viewType = useMediaState("viewType"), $offset = !isSmallLayout && menuGroup === "bottom" && $viewType === "video" ? 26 : 0, colorSchemeClass = useColorSchemeClass(colorScheme), [isOpen, setIsOpen] = React.useState(false), dialogEl = useParentDialogEl();
+  useScoped(updateFontCssVars);
+  function onOpen() {
+    flushSync(() => {
+      setIsOpen(true);
+    });
+  }
+  function onClose() {
+    setIsOpen(false);
+  }
+  const Content = /* @__PURE__ */ React.createElement(
+    Items,
+    {
+      className: "vds-settings-menu-items vds-menu-items",
+      placement,
+      offset: $offset
+    },
+    isOpen ? /* @__PURE__ */ React.createElement(React.Fragment, null, slot(slots, "settingsMenuItemsStart", null), slot(slots, "settingsMenuStartItems", null), /* @__PURE__ */ React.createElement(DefaultPlaybackMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultAccessibilityMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultAudioMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultCaptionMenu, { slots }), slot(slots, "settingsMenuEndItems", null), slot(slots, "settingsMenuItemsEnd", null)) : null
+  );
+  return /* @__PURE__ */ React.createElement(
+    Root$3,
+    {
+      className: "vds-settings-menu vds-menu",
+      showDelay: showMenuDelay,
+      onOpen,
+      onClose
+    },
+    /* @__PURE__ */ React.createElement(DefaultTooltip, { content: settingsText, placement: tooltip }, /* @__PURE__ */ React.createElement(Button, { className: "vds-menu-button vds-button", "aria-label": settingsText }, /* @__PURE__ */ React.createElement(Icons.Menu.Settings, { className: "vds-icon vds-rotate-icon" }))),
+    noModal || !isSmallLayout ? Content : /* @__PURE__ */ React.createElement(
+      Portal,
+      {
+        className: portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : ""),
+        container: menuContainer ?? dialogEl,
+        disabled: "fullscreen",
+        "data-sm": isSmallLayout ? "" : null,
+        "data-lg": !isSmallLayout ? "" : null,
+        "data-size": isSmallLayout ? "sm" : "lg",
+        "data-view-type": $viewType
+      },
+      Content
+    )
+  );
+}
+DefaultSettingsMenu.displayName = "DefaultSettingsMenu";
+
+function DefaultVolumePopup({ tooltip, orientation, slots }) {
+  const $pointer = useMediaState("pointer"), $muted = useMediaState("muted"), $canSetVolume = useMediaState("canSetVolume"), [rootEl, setRootEl] = React.useState(null), isRootActive = useActive(rootEl), muteButton = slot(slots, "muteButton", /* @__PURE__ */ React.createElement(DefaultMuteButton, { tooltip }));
+  if (!$canSetVolume) {
+    return muteButton;
+  }
+  return $pointer === "coarse" && !$muted ? null : /* @__PURE__ */ React.createElement("div", { className: "vds-volume", "data-active": isRootActive ? "" : null, ref: setRootEl }, muteButton, /* @__PURE__ */ React.createElement("div", { className: "vds-volume-popup" }, slot(slots, "volumeSlider", /* @__PURE__ */ React.createElement(DefaultVolumeSlider, { orientation }))));
+}
+DefaultVolumePopup.displayName = "DefaultVolumePopup";
+function DefaultVolumeSlider(props) {
+  const label = useDefaultLayoutWord("Volume");
+  return /* @__PURE__ */ React.createElement(Root$8, { className: "vds-volume-slider vds-slider", "aria-label": label, ...props }, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }), /* @__PURE__ */ React.createElement(Preview, { className: "vds-slider-preview", noClamp: true }, /* @__PURE__ */ React.createElement(Value, { className: "vds-slider-value" })));
+}
+DefaultVolumeSlider.displayName = "DefaultVolumeSlider";
+function DefaultTimeSlider() {
+  const [instance, setInstance] = React.useState(null), [width, setWidth] = React.useState(0), $src = useMediaState("currentSrc"), { thumbnails, sliderChaptersMinWidth, disableTimeSlider, seekStep, noScrubGesture } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Seek"), $RemotionSliderThumbnail = useSignal(RemotionSliderThumbnail);
+  const onResize = React.useCallback(() => {
+    const el = instance?.el;
+    el && setWidth(el.clientWidth);
+  }, [instance]);
+  useResizeObserver(instance?.el, onResize);
+  return /* @__PURE__ */ React.createElement(
+    Root$9,
+    {
+      className: "vds-time-slider vds-slider",
+      "aria-label": label,
+      disabled: disableTimeSlider,
+      noSwipeGesture: noScrubGesture,
+      keyStep: seekStep,
+      ref: setInstance
+    },
+    /* @__PURE__ */ React.createElement(
+      Chapters,
+      {
+        className: "vds-slider-chapters",
+        disabled: width < sliderChaptersMinWidth
+      },
+      (cues, forwardRef) => cues.map((cue) => /* @__PURE__ */ React.createElement("div", { className: "vds-slider-chapter", key: cue.startTime, ref: forwardRef }, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Progress, { className: "vds-slider-progress vds-slider-track" })))
+    ),
+    /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }),
+    /* @__PURE__ */ React.createElement(Preview, { className: "vds-slider-preview" }, thumbnails ? /* @__PURE__ */ React.createElement(
+      Thumbnail.Root,
+      {
+        src: thumbnails,
+        className: "vds-slider-thumbnail vds-thumbnail"
+      },
+      /* @__PURE__ */ React.createElement(Thumbnail.Img, null)
+    ) : $RemotionSliderThumbnail && isRemotionSrc($src) ? /* @__PURE__ */ React.createElement($RemotionSliderThumbnail, { className: "vds-slider-thumbnail vds-thumbnail" }) : null, /* @__PURE__ */ React.createElement(ChapterTitle, { className: "vds-slider-chapter-title" }), /* @__PURE__ */ React.createElement(Value, { className: "vds-slider-value" }))
+  );
+}
+DefaultTimeSlider.displayName = "DefaultTimeSlider";
+
+function DefaultTimeGroup({ slots }) {
+  const $duration = useMediaState("duration");
+  if (!$duration) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-time-group" }, slot(slots, "currentTime", /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "current" })), slot(slots, "timeSeparator", /* @__PURE__ */ React.createElement("div", { className: "vds-time-divider" }, "/")), slot(slots, "endTime", /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "duration" })));
+}
+DefaultTimeGroup.displayName = "DefaultTimeGroup";
+function DefaultTimeInfo({ slots }) {
+  const $live = useMediaState("live");
+  return $live ? slot(slots, "liveButton", /* @__PURE__ */ React.createElement(DefaultLiveButton, null)) : /* @__PURE__ */ React.createElement(DefaultTimeGroup, { slots });
+}
+DefaultTimeInfo.displayName = "DefaultTimeInfo";
+function DefaultTimeInvert({ slots }) {
+  const $live = useMediaState("live"), $duration = useMediaState("duration");
+  return $live ? slot(slots, "liveButton", /* @__PURE__ */ React.createElement(DefaultLiveButton, null)) : slot(
+    slots,
+    "endTime",
+    $duration ? /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "current", toggle: true, remainder: true }) : null
+  );
+}
+DefaultTimeInvert.displayName = "DefaultTimeInvert";
+
+const MediaLayout$1 = createDefaultMediaLayout({
+  type: "audio",
+  smLayoutWhen({ width }) {
+    return width < 576;
+  },
+  renderLayout: () => /* @__PURE__ */ React.createElement(AudioLayout, null)
+});
+function DefaultAudioLayout(props) {
+  const [scrubbing, setScrubbing] = React.useState(false), $pointer = useMediaState("pointer");
+  const onStartScrubbing = React.useCallback((event) => {
+    const { target } = event, hasTimeSlider = !!(target instanceof HTMLElement && target.closest(".vds-time-slider"));
+    if (!hasTimeSlider) return;
+    event.nativeEvent.stopImmediatePropagation();
+    setScrubbing(true);
+  }, []);
+  const onStopScrubbing = React.useCallback(() => {
+    setScrubbing(false);
+  }, []);
+  React.useEffect(() => {
+    if (scrubbing) return listenEvent(window, "pointerdown", onStopScrubbing);
+  }, [scrubbing, onStopScrubbing]);
+  return /* @__PURE__ */ React.createElement(
+    MediaLayout$1,
+    {
+      ...props,
+      "data-scrubbing": scrubbing ? "" : null,
+      onPointerDown: scrubbing ? (e) => e.stopPropagation() : void 0,
+      onPointerDownCapture: $pointer === "coarse" && !scrubbing ? onStartScrubbing : void 0
+    }
+  );
+}
+DefaultAudioLayout.displayName = "DefaultAudioLayout";
+function AudioLayout() {
+  const slots = useDefaultAudioLayoutSlots();
+  useLayoutName("audio");
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultCaptions, null), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "seekBackwardButton", /* @__PURE__ */ React.createElement(DefaultSeekButton, { backward: true, tooltip: "top start" })), slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top center" })), slot(slots, "seekForwardButton", /* @__PURE__ */ React.createElement(DefaultSeekButton, { tooltip: "top center" })), /* @__PURE__ */ React.createElement(DefaultAudioTitle, null), slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null)), /* @__PURE__ */ React.createElement(DefaultTimeInvert, { slots }), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "vertical", tooltip: "top", slots }), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "top center" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), /* @__PURE__ */ React.createElement(DefaultAudioMenus, { slots }))));
+}
+AudioLayout.displayName = "AudioLayout";
+function DefaultAudioMenus({ slots }) {
+  const { isSmallLayout, noModal } = useDefaultLayoutContext(), placement = noModal ? "top end" : !isSmallLayout ? "top end" : null;
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slot(
+    slots,
+    "chaptersMenu",
+    /* @__PURE__ */ React.createElement(DefaultChaptersMenu, { tooltip: "top", placement, portalClass: "vds-audio-layout" })
+  ), slot(
+    slots,
+    "settingsMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultSettingsMenu,
+      {
+        tooltip: "top end",
+        placement,
+        portalClass: "vds-audio-layout",
+        slots
+      }
+    )
+  ));
+}
+DefaultAudioMenus.displayName = "DefaultAudioMenus";
+function DefaultAudioTitle() {
+  const [rootEl, setRootEl] = React.useState(null), media = useMediaContext(), { translations } = useDefaultLayoutContext(), [isTextOverflowing, setIsTextOverflowing] = React.useState(false);
+  const isContinued = createComputed(() => {
+    const { started, currentTime } = media.$state;
+    return started() || currentTime() > 0;
+  });
+  const $title = useSignal(
+    createComputed(() => {
+      const { title, ended } = media.$state;
+      if (!title()) return "";
+      const word = ended() ? "Replay" : isContinued() ? "Continue" : "Play";
+      return `${i18n(translations, word)}: ${title()}`;
+    })
+  );
+  const chapterTitle = useChapterTitle(), $isContinued = useSignal(isContinued), $chapterTitle = $isContinued ? chapterTitle : "", isTransitionActive = useTransitionActive(rootEl);
+  React.useEffect(() => {
+    if (isTransitionActive && document.activeElement === document.body) {
+      media.player.el?.focus({ preventScroll: true });
+    }
+  }, []);
+  const onResize = React.useCallback(() => {
+    const el = rootEl, isOverflowing = !!el && !isTransitionActive && el.clientWidth < el.children[0].clientWidth;
+    if (el) toggleClass(el, "vds-marquee", isOverflowing);
+    setIsTextOverflowing(isOverflowing);
+  }, [rootEl, isTransitionActive]);
+  useResizeObserver(rootEl, onResize);
+  return $title ? /* @__PURE__ */ React.createElement("span", { className: "vds-title", title: $title, ref: setRootEl }, /* @__PURE__ */ React.createElement(AudioTitle, { title: $title, chapterTitle: $chapterTitle }), isTextOverflowing && !isTransitionActive ? /* @__PURE__ */ React.createElement(AudioTitle, { title: $title, chapterTitle: $chapterTitle }) : null) : /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null);
+}
+DefaultAudioTitle.displayName = "DefaultAudioTitle";
+function AudioTitle({ title, chapterTitle }) {
+  const slots = useDefaultAudioLayoutSlots();
+  return /* @__PURE__ */ React.createElement("span", { className: "vds-title-text" }, slot(slots, "title", title), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-title" }, chapterTitle)));
+}
+AudioTitle.displayName = "AudioTitle";
+
+const DefaultKeyboardDisplay = React.forwardRef(
+  ({ icons: Icons, ...props }, forwardRef) => {
+    const [visible, setVisible] = React.useState(false), [Icon, setIcon] = React.useState(null), [count, setCount] = React.useState(0), $lastKeyboardAction = useMediaState("lastKeyboardAction");
+    React.useEffect(() => {
+      setCount((n) => n + 1);
+    }, [$lastKeyboardAction]);
+    const actionDataAttr = React.useMemo(() => {
+      const action = $lastKeyboardAction?.action;
+      return action && visible ? camelToKebabCase(action) : null;
+    }, [visible, $lastKeyboardAction]);
+    const className = React.useMemo(
+      () => `vds-kb-action${!visible ? " hidden" : ""}${props.className ? ` ${props.className}` : ""}`,
+      [visible]
+    );
+    const $$text = createComputed(getText), $text = useSignal($$text);
+    createEffect(() => {
+      const Icon2 = getIcon(Icons);
+      setIcon(() => Icon2);
+    }, [Icons]);
+    React.useEffect(() => {
+      setVisible(!!$lastKeyboardAction);
+      const id = setTimeout(() => setVisible(false), 500);
+      return () => {
+        setVisible(false);
+        window.clearTimeout(id);
+      };
+    }, [$lastKeyboardAction]);
+    return Icon ? /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props,
+        className,
+        "data-action": actionDataAttr,
+        ref: forwardRef
+      },
+      /* @__PURE__ */ React.createElement("div", { className: "vds-kb-text-wrapper" }, /* @__PURE__ */ React.createElement("div", { className: "vds-kb-text" }, $text)),
+      /* @__PURE__ */ React.createElement("div", { className: "vds-kb-bezel", key: count }, /* @__PURE__ */ React.createElement("div", { className: "vds-kb-icon" }, /* @__PURE__ */ React.createElement(Icon, null)))
+    ) : null;
+  }
+);
+DefaultKeyboardDisplay.displayName = "DefaultKeyboardDisplay";
+function getText() {
+  const { $state } = useContext(mediaContext), action = $state.lastKeyboardAction()?.action, audioGain = $state.audioGain() ?? 1;
+  switch (action) {
+    case "toggleMuted":
+      return $state.muted() ? "0%" : getVolumeText($state.volume(), audioGain);
+    case "volumeUp":
+    case "volumeDown":
+      return getVolumeText($state.volume(), audioGain);
+    default:
+      return "";
+  }
+}
+function getVolumeText(volume, gain) {
+  return `${Math.round(volume * gain * 100)}%`;
+}
+function getIcon(Icons) {
+  const { $state } = useContext(mediaContext), action = $state.lastKeyboardAction()?.action;
+  switch (action) {
+    case "togglePaused":
+      return !$state.paused() ? Icons.Play : Icons.Pause;
+    case "toggleMuted":
+      return $state.muted() || $state.volume() === 0 ? Icons.Mute : $state.volume() >= 0.5 ? Icons.VolumeUp : Icons.VolumeDown;
+    case "toggleFullscreen":
+      return $state.fullscreen() ? Icons.EnterFullscreen : Icons.ExitFullscreen;
+    case "togglePictureInPicture":
+      return $state.pictureInPicture() ? Icons.EnterPiP : Icons.ExitPiP;
+    case "toggleCaptions":
+      return $state.hasCaptions() ? $state.textTrack() ? Icons.CaptionsOn : Icons.CaptionsOff : null;
+    case "volumeUp":
+      return Icons.VolumeUp;
+    case "volumeDown":
+      return Icons.VolumeDown;
+    case "seekForward":
+      return Icons.SeekForward;
+    case "seekBackward":
+      return Icons.SeekBackward;
+    default:
+      return null;
+  }
+}
+
+function DefaultTitle() {
+  const $started = useMediaState("started"), $title = useMediaState("title"), $hasChapters = useActiveTextTrack("chapters");
+  return $hasChapters && ($started || !$title) ? /* @__PURE__ */ React.createElement(ChapterTitle$1, { className: "vds-chapter-title" }) : /* @__PURE__ */ React.createElement(Title, { className: "vds-chapter-title" });
+}
+DefaultTitle.displayName = "DefaultTitle";
+
+const MediaLayout = createDefaultMediaLayout({
+  type: "video",
+  smLayoutWhen({ width, height }) {
+    return width < 576 || height < 380;
+  },
+  renderLayout(props) {
+    return /* @__PURE__ */ React.createElement(VideoLayout, { ...props });
+  }
+});
+function DefaultVideoLayout(props) {
+  return /* @__PURE__ */ React.createElement(MediaLayout, { ...props });
+}
+DefaultVideoLayout.displayName = "DefaultVideoLayout";
+function VideoLayout({ streamType, isLoadLayout, isSmallLayout }) {
+  useLayoutName("video");
+  return isLoadLayout ? /* @__PURE__ */ React.createElement(DefaultVideoLoadLayout, null) : streamType === "unknown" ? /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null) : isSmallLayout ? /* @__PURE__ */ React.createElement(DefaultVideoSmallLayout, null) : /* @__PURE__ */ React.createElement(DefaultVideoLargeLayout, null);
+}
+VideoLayout.displayName = "VideoLayout";
+function DefaultVideoLargeLayout() {
+  const { menuGroup } = useDefaultLayoutContext(), baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.largeLayout };
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultVideoGestures, null), /* @__PURE__ */ React.createElement(DefaultVideoKeyboardDisplay, null), slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "captions", /* @__PURE__ */ React.createElement(DefaultCaptions, null)), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "topControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupEnd", null), menuGroup === "top" && /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "centerControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null))), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top start" })), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "horizontal", tooltip: "top", slots }), /* @__PURE__ */ React.createElement(DefaultTimeInfo, { slots }), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement(DefaultTitle, null)), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "top" })), menuGroup === "bottom" && /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots }), slot(slots, "airPlayButton", /* @__PURE__ */ React.createElement(DefaultAirPlayButton, { tooltip: "top" })), slot(slots, "googleCastButton", /* @__PURE__ */ React.createElement(DefaultGoogleCastButton, { tooltip: "top" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), slot(slots, "pipButton", /* @__PURE__ */ React.createElement(DefaultPIPButton, { tooltip: "top" })), slot(slots, "fullscreenButton", /* @__PURE__ */ React.createElement(DefaultFullscreenButton, { tooltip: "top end" })))));
+}
+DefaultVideoLargeLayout.displayName = "DefaultVideoLargeLayout";
+function DefaultVideoSmallLayout() {
+  const baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.smallLayout };
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultVideoGestures, null), /* @__PURE__ */ React.createElement(DefaultVideoKeyboardDisplay, null), slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "captions", /* @__PURE__ */ React.createElement(DefaultCaptions, null)), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "topControlsGroupStart", null), slot(slots, "airPlayButton", /* @__PURE__ */ React.createElement(DefaultAirPlayButton, { tooltip: "top start" })), slot(slots, "googleCastButton", /* @__PURE__ */ React.createElement(DefaultGoogleCastButton, { tooltip: "top start" })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "bottom" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots }), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "vertical", tooltip: "bottom end", slots }), slot(slots, "topControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group", style: { pointerEvents: "none" } }, slot(slots, "centerControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupCenter", null), slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top" })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, /* @__PURE__ */ React.createElement(DefaultTimeInfo, { slots }), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement(DefaultTitle, null)), slot(slots, "fullscreenButton", /* @__PURE__ */ React.createElement(DefaultFullscreenButton, { tooltip: "top end" }))), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null)))), slot(slots, "startDuration", /* @__PURE__ */ React.createElement(DefaultVideoStartDuration, null)));
+}
+DefaultVideoSmallLayout.displayName = "DefaultVideoSmallLayout";
+function DefaultVideoStartDuration() {
+  const $duration = useMediaState("duration");
+  if ($duration === 0) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-start-duration" }, /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "duration" }));
+}
+DefaultVideoStartDuration.displayName = "DefaultVideoStartDuration";
+function DefaultVideoGestures() {
+  const { noGestures } = useDefaultLayoutContext();
+  if (noGestures) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-gestures" }, /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "pointerup", action: "toggle:paused" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "pointerup", action: "toggle:controls" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "toggle:fullscreen" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "seek:-10" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "seek:10" }));
+}
+DefaultVideoGestures.displayName = "DefaultVideoGestures";
+function DefaultBufferingIndicator() {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-buffering-indicator" }, /* @__PURE__ */ React.createElement(Root$b, { className: "vds-buffering-spinner" }, /* @__PURE__ */ React.createElement(Track$1, { className: "vds-buffering-track" }), /* @__PURE__ */ React.createElement(TrackFill$1, { className: "vds-buffering-track-fill" })));
+}
+DefaultBufferingIndicator.displayName = "DefaultBufferingIndicator";
+function DefaultVideoMenus({ slots }) {
+  const { isSmallLayout, noModal, menuGroup } = useDefaultLayoutContext(), side = menuGroup === "top" || isSmallLayout ? "bottom" : "top", tooltip = `${side} end`, placement = noModal ? `${side} end` : !isSmallLayout ? `${side} end` : null;
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slot(
+    slots,
+    "chaptersMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultChaptersMenu,
+      {
+        tooltip,
+        placement,
+        portalClass: "vds-video-layout"
+      }
+    )
+  ), slot(
+    slots,
+    "settingsMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultSettingsMenu,
+      {
+        tooltip,
+        placement,
+        portalClass: "vds-video-layout",
+        slots
+      }
+    )
+  ));
+}
+DefaultVideoMenus.displayName = "DefaultVideoMenus";
+function DefaultVideoLoadLayout() {
+  const { isSmallLayout } = useDefaultLayoutContext(), baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.[isSmallLayout ? "smallLayout" : "largeLayout"] };
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-load-container" }, slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "loadButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top" })));
+}
+DefaultVideoLoadLayout.displayName = "DefaultVideoLoadLayout";
+function DefaultVideoKeyboardDisplay() {
+  const { noKeyboardAnimations, icons, userPrefersKeyboardAnimations } = useDefaultLayoutContext(), $userPrefersKeyboardAnimations = useSignal(userPrefersKeyboardAnimations), disabled = noKeyboardAnimations || !$userPrefersKeyboardAnimations;
+  if (disabled || !icons.KeyboardDisplay) return null;
+  return /* @__PURE__ */ React.createElement(DefaultKeyboardDisplay, { icons: icons.KeyboardDisplay });
+}
+DefaultVideoKeyboardDisplay.displayName = "DefaultVideoKeyboardDisplay";
+
+export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultLayoutContext, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions, i18n, useDefaultLayoutContext, useDefaultLayoutWord };
diff --git a/dev/chunks/vidstack-DAPCj1_J.js b/dev/chunks/vidstack-DAPCj1_J.js
new file mode 100644
index 0000000000000000000000000000000000000000..52f49ae0023b02c239214b1541b3c0cd0ffaf9ad
--- /dev/null
+++ b/dev/chunks/vidstack-DAPCj1_J.js
@@ -0,0 +1,477 @@
+"use client"
+
+import { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from './vidstack-CH225ns1.js';
+import { ListSymbol, TimeRange, RAFLoop } from './vidstack-BdoOxmTD.js';
+import { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-DSyHdZcv.js';
+import 'react';
+import '@floating-ui/dom';
+
+class GoogleCastMediaInfoBuilder {
+  #info;
+  constructor(src) {
+    this.#info = new chrome.cast.media.MediaInfo(src.src, src.type);
+  }
+  build() {
+    return this.#info;
+  }
+  setStreamType(streamType) {
+    if (streamType.includes("live")) {
+      this.#info.streamType = chrome.cast.media.StreamType.LIVE;
+    } else {
+      this.#info.streamType = chrome.cast.media.StreamType.BUFFERED;
+    }
+    return this;
+  }
+  setTracks(tracks) {
+    this.#info.tracks = tracks.map(this.#buildCastTrack);
+    return this;
+  }
+  setMetadata(title, poster) {
+    this.#info.metadata = new chrome.cast.media.GenericMediaMetadata();
+    this.#info.metadata.title = title;
+    this.#info.metadata.images = [{ url: poster }];
+    return this;
+  }
+  #buildCastTrack(track, trackId) {
+    const castTrack = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);
+    castTrack.name = track.label;
+    castTrack.trackContentId = track.src;
+    castTrack.trackContentType = "text/vtt";
+    castTrack.language = track.language;
+    castTrack.subtype = track.kind.toUpperCase();
+    return castTrack;
+  }
+}
+
+const REMOTE_TRACK_TEXT_TYPE = chrome.cast.media.TrackType.TEXT, REMOTE_TRACK_AUDIO_TYPE = chrome.cast.media.TrackType.AUDIO;
+class GoogleCastTracksManager {
+  #cast;
+  #ctx;
+  #onNewLocalTracks;
+  constructor(cast, ctx, onNewLocalTracks) {
+    this.#cast = cast;
+    this.#ctx = ctx;
+    this.#onNewLocalTracks = onNewLocalTracks;
+  }
+  setup() {
+    const syncRemoteActiveIds = this.syncRemoteActiveIds.bind(this);
+    listenEvent(this.#ctx.audioTracks, "change", syncRemoteActiveIds);
+    listenEvent(this.#ctx.textTracks, "mode-change", syncRemoteActiveIds);
+    effect(this.#syncLocalTracks.bind(this));
+  }
+  getLocalTextTracks() {
+    return this.#ctx.$state.textTracks().filter((track) => track.src && track.type === "vtt");
+  }
+  #getLocalAudioTracks() {
+    return this.#ctx.$state.audioTracks();
+  }
+  #getRemoteTracks(type) {
+    const tracks = this.#cast.mediaInfo?.tracks ?? [];
+    return type ? tracks.filter((track) => track.type === type) : tracks;
+  }
+  #getRemoteActiveIds() {
+    const activeIds = [], activeLocalAudioTrack = this.#getLocalAudioTracks().find((track) => track.selected), activeLocalTextTracks = this.getLocalTextTracks().filter((track) => track.mode === "showing");
+    if (activeLocalAudioTrack) {
+      const remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteAudioTrack = this.#findRemoteTrack(remoteAudioTracks, activeLocalAudioTrack);
+      if (remoteAudioTrack) activeIds.push(remoteAudioTrack.trackId);
+    }
+    if (activeLocalTextTracks?.length) {
+      const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+      if (remoteTextTracks.length) {
+        for (const localTrack of activeLocalTextTracks) {
+          const remoteTextTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
+          if (remoteTextTrack) activeIds.push(remoteTextTrack.trackId);
+        }
+      }
+    }
+    return activeIds;
+  }
+  #syncLocalTracks() {
+    const localTextTracks = this.getLocalTextTracks();
+    if (!this.#cast.isMediaLoaded) return;
+    const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+    for (const localTrack of localTextTracks) {
+      const hasRemoteTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
+      if (!hasRemoteTrack) {
+        untrack(() => this.#onNewLocalTracks?.());
+        break;
+      }
+    }
+  }
+  syncRemoteTracks(event) {
+    if (!this.#cast.isMediaLoaded) return;
+    const localAudioTracks = this.#getLocalAudioTracks(), localTextTracks = this.getLocalTextTracks(), remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+    for (const remoteAudioTrack of remoteAudioTracks) {
+      const hasLocalTrack = this.#findLocalTrack(localAudioTracks, remoteAudioTrack);
+      if (hasLocalTrack) continue;
+      const localAudioTrack = {
+        id: remoteAudioTrack.trackId.toString(),
+        label: remoteAudioTrack.name,
+        language: remoteAudioTrack.language,
+        kind: remoteAudioTrack.subtype ?? "main",
+        selected: false
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localAudioTrack, event);
+    }
+    for (const remoteTextTrack of remoteTextTracks) {
+      const hasLocalTrack = this.#findLocalTrack(localTextTracks, remoteTextTrack);
+      if (hasLocalTrack) continue;
+      const localTextTrack = {
+        id: remoteTextTrack.trackId.toString(),
+        src: remoteTextTrack.trackContentId,
+        label: remoteTextTrack.name,
+        language: remoteTextTrack.language,
+        kind: remoteTextTrack.subtype.toLowerCase()
+      };
+      this.#ctx.textTracks.add(localTextTrack, event);
+    }
+  }
+  syncRemoteActiveIds(event) {
+    if (!this.#cast.isMediaLoaded) return;
+    const activeIds = this.#getRemoteActiveIds(), editRequest = new chrome.cast.media.EditTracksInfoRequest(activeIds);
+    this.#editTracksInfo(editRequest).catch((error) => {
+      {
+        this.#ctx.logger?.errorGroup("[vidstack] failed to edit cast tracks info").labelledLog("Edit Request", editRequest).labelledLog("Error", error).dispatch();
+      }
+    });
+  }
+  #editTracksInfo(request) {
+    const media = getCastSessionMedia();
+    return new Promise((resolve, reject) => media?.editTracksInfo(request, resolve, reject));
+  }
+  #findLocalTrack(localTracks, remoteTrack) {
+    return localTracks.find((localTrack) => this.#isMatch(localTrack, remoteTrack));
+  }
+  #findRemoteTrack(remoteTracks, localTrack) {
+    return remoteTracks.find((remoteTrack) => this.#isMatch(localTrack, remoteTrack));
+  }
+  // Note: we can't rely on id matching because they will differ between local/remote. A local
+  // track id might not even exist.
+  #isMatch(localTrack, remoteTrack) {
+    return remoteTrack.name === localTrack.label && remoteTrack.language === localTrack.language && remoteTrack.subtype.toLowerCase() === localTrack.kind.toLowerCase();
+  }
+}
+
+class GoogleCastProvider {
+  $$PROVIDER_TYPE = "GOOGLE_CAST";
+  scope = createScope();
+  #player;
+  #ctx;
+  #tracks;
+  #currentSrc = null;
+  #state = "disconnected";
+  #currentTime = 0;
+  #played = 0;
+  #seekableRange = new TimeRange(0, 0);
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #playerEventHandlers;
+  #reloadInfo = null;
+  #isIdle = false;
+  constructor(player, ctx) {
+    this.#player = player;
+    this.#ctx = ctx;
+    this.#tracks = new GoogleCastTracksManager(player, ctx, this.#onNewLocalTracks.bind(this));
+  }
+  get type() {
+    return "google-cast";
+  }
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  /**
+   * The Google Cast remote player.
+   *
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.RemotePlayer}
+   */
+  get player() {
+    return this.#player;
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
+   */
+  get cast() {
+    return getCastContext();
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastSession}
+   */
+  get session() {
+    return getCastSession();
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media.Media}
+   */
+  get media() {
+    return getCastSessionMedia();
+  }
+  /**
+   * Whether the current Google Cast session belongs to this provider.
+   */
+  get hasActiveSession() {
+    return hasActiveCastSession(this.#currentSrc);
+  }
+  setup() {
+    this.#attachCastContextEventListeners();
+    this.#attachCastPlayerEventListeners();
+    this.#tracks.setup();
+    this.#ctx.notify("provider-setup", this);
+  }
+  #attachCastContextEventListeners() {
+    listenCastContextEvent(
+      cast.framework.CastContextEventType.CAST_STATE_CHANGED,
+      this.#onCastStateChange.bind(this)
+    );
+  }
+  #attachCastPlayerEventListeners() {
+    const Event2 = cast.framework.RemotePlayerEventType, handlers = {
+      [Event2.IS_CONNECTED_CHANGED]: this.#onCastStateChange,
+      [Event2.IS_MEDIA_LOADED_CHANGED]: this.#onMediaLoadedChange,
+      [Event2.CAN_CONTROL_VOLUME_CHANGED]: this.#onCanControlVolumeChange,
+      [Event2.CAN_SEEK_CHANGED]: this.#onCanSeekChange,
+      [Event2.DURATION_CHANGED]: this.#onDurationChange,
+      [Event2.IS_MUTED_CHANGED]: this.#onVolumeChange,
+      [Event2.VOLUME_LEVEL_CHANGED]: this.#onVolumeChange,
+      [Event2.IS_PAUSED_CHANGED]: this.#onPausedChange,
+      [Event2.LIVE_SEEKABLE_RANGE_CHANGED]: this.#onProgress,
+      [Event2.PLAYER_STATE_CHANGED]: this.#onPlayerStateChange
+    };
+    this.#playerEventHandlers = handlers;
+    const handler = this.#onRemotePlayerEvent.bind(this);
+    for (const type of keysOf(handlers)) {
+      this.#player.controller.addEventListener(type, handler);
+    }
+    onDispose(() => {
+      for (const type of keysOf(handlers)) {
+        this.#player.controller.removeEventListener(type, handler);
+      }
+    });
+  }
+  async play() {
+    if (!this.#player.isPaused && !this.#isIdle) return;
+    if (this.#isIdle) {
+      await this.#reload(false, 0);
+      return;
+    }
+    this.#player.controller?.playOrPause();
+  }
+  async pause() {
+    if (this.#player.isPaused) return;
+    this.#player.controller?.playOrPause();
+  }
+  getMediaStatus(request) {
+    return new Promise((resolve, reject) => {
+      this.media?.getStatus(request, resolve, reject);
+    });
+  }
+  setMuted(muted) {
+    const hasChanged = muted && !this.#player.isMuted || !muted && this.#player.isMuted;
+    if (hasChanged) this.#player.controller?.muteOrUnmute();
+  }
+  setCurrentTime(time) {
+    this.#player.currentTime = time;
+    this.#ctx.notify("seeking", time);
+    this.#player.controller?.seek();
+  }
+  setVolume(volume) {
+    this.#player.volumeLevel = volume;
+    this.#player.controller?.setVolumeLevel();
+  }
+  async loadSource(src) {
+    if (this.#reloadInfo?.src !== src) this.#reloadInfo = null;
+    if (hasActiveCastSession(src)) {
+      this.#resumeSession();
+      this.#currentSrc = src;
+      return;
+    }
+    this.#ctx.notify("load-start");
+    const loadRequest = this.#buildLoadRequest(src), errorCode = await this.session.loadMedia(loadRequest);
+    if (errorCode) {
+      this.#currentSrc = null;
+      this.#ctx.notify("error", Error(getCastErrorMessage(errorCode)));
+      return;
+    }
+    this.#currentSrc = src;
+  }
+  destroy() {
+    this.#reset();
+    this.#endSession();
+  }
+  #reset() {
+    if (!this.#reloadInfo) {
+      this.#played = 0;
+      this.#seekableRange = new TimeRange(0, 0);
+    }
+    this.#timeRAF.stop();
+    this.#currentTime = 0;
+    this.#reloadInfo = null;
+  }
+  #resumeSession() {
+    const resumeSessionEvent = new DOMEvent("resume-session", { detail: this.session });
+    this.#onMediaLoadedChange(resumeSessionEvent);
+    const { muted, volume, savedState } = this.#ctx.$state, localState = savedState();
+    this.setCurrentTime(Math.max(this.#player.currentTime, localState?.currentTime ?? 0));
+    this.setMuted(muted());
+    this.setVolume(volume());
+    if (localState?.paused === false) this.play();
+  }
+  #endSession() {
+    this.cast.endCurrentSession(true);
+    const { remotePlaybackLoader } = this.#ctx.$state;
+    remotePlaybackLoader.set(null);
+  }
+  #disconnectFromReceiver() {
+    const { savedState } = this.#ctx.$state;
+    savedState.set({
+      paused: this.#player.isPaused,
+      currentTime: this.#player.currentTime
+    });
+    this.#endSession();
+  }
+  #onAnimationFrame() {
+    this.#onCurrentTimeChange();
+  }
+  #onRemotePlayerEvent(event) {
+    this.#playerEventHandlers[event.type].call(this, event);
+  }
+  #onCastStateChange(data) {
+    const castState = this.cast.getCastState(), state = castState === cast.framework.CastState.CONNECTED ? "connected" : castState === cast.framework.CastState.CONNECTING ? "connecting" : "disconnected";
+    if (this.#state === state) return;
+    const detail = { type: "google-cast", state }, trigger = this.#createEvent(data);
+    this.#state = state;
+    this.#ctx.notify("remote-playback-change", detail, trigger);
+    if (state === "disconnected") {
+      this.#disconnectFromReceiver();
+    }
+  }
+  #onMediaLoadedChange(event) {
+    const hasLoaded = !!this.#player.isMediaLoaded;
+    if (!hasLoaded) return;
+    const src = peek(this.#ctx.$state.source);
+    Promise.resolve().then(() => {
+      if (src !== peek(this.#ctx.$state.source) || !this.#player.isMediaLoaded) return;
+      this.#reset();
+      const duration = this.#player.duration;
+      this.#seekableRange = new TimeRange(0, duration);
+      const detail = {
+        provider: this,
+        duration,
+        buffered: new TimeRange(0, 0),
+        seekable: this.#getSeekableRange()
+      }, trigger = this.#createEvent(event);
+      this.#ctx.notify("loaded-metadata", void 0, trigger);
+      this.#ctx.notify("loaded-data", void 0, trigger);
+      this.#ctx.notify("can-play", detail, trigger);
+      this.#onCanControlVolumeChange();
+      this.#onCanSeekChange(event);
+      const { volume, muted } = this.#ctx.$state;
+      this.setVolume(volume());
+      this.setMuted(muted());
+      this.#timeRAF.start();
+      this.#tracks.syncRemoteTracks(trigger);
+      this.#tracks.syncRemoteActiveIds(trigger);
+    });
+  }
+  #onCanControlVolumeChange() {
+    this.#ctx.$state.canSetVolume.set(this.#player.canControlVolume);
+  }
+  #onCanSeekChange(event) {
+    const trigger = this.#createEvent(event);
+    this.#ctx.notify("stream-type-change", this.#getStreamType(), trigger);
+  }
+  #getStreamType() {
+    const streamType = this.#player.mediaInfo?.streamType;
+    return streamType === chrome.cast.media.StreamType.LIVE ? this.#player.canSeek ? "live:dvr" : "live" : "on-demand";
+  }
+  #onCurrentTimeChange() {
+    if (this.#reloadInfo) return;
+    const currentTime = this.#player.currentTime;
+    if (currentTime === this.#currentTime) return;
+    this.#ctx.notify("time-change", currentTime);
+    if (currentTime > this.#played) {
+      this.#played = currentTime;
+      this.#onProgress();
+    }
+    if (this.#ctx.$state.seeking()) {
+      this.#ctx.notify("seeked", currentTime);
+    }
+    this.#currentTime = currentTime;
+  }
+  #onDurationChange(event) {
+    if (!this.#player.isMediaLoaded || this.#reloadInfo) return;
+    const duration = this.#player.duration, trigger = this.#createEvent(event);
+    this.#seekableRange = new TimeRange(0, duration);
+    this.#ctx.notify("duration-change", duration, trigger);
+  }
+  #onVolumeChange(event) {
+    if (!this.#player.isMediaLoaded) return;
+    const detail = {
+      muted: this.#player.isMuted,
+      volume: this.#player.volumeLevel
+    }, trigger = this.#createEvent(event);
+    this.#ctx.notify("volume-change", detail, trigger);
+  }
+  #onPausedChange(event) {
+    const trigger = this.#createEvent(event);
+    if (this.#player.isPaused) {
+      this.#ctx.notify("pause", void 0, trigger);
+    } else {
+      this.#ctx.notify("play", void 0, trigger);
+    }
+  }
+  #onProgress(event) {
+    const detail = {
+      seekable: this.#getSeekableRange(),
+      buffered: new TimeRange(0, this.#played)
+    }, trigger = event ? this.#createEvent(event) : void 0;
+    this.#ctx.notify("progress", detail, trigger);
+  }
+  #onPlayerStateChange(event) {
+    const state = this.#player.playerState, PlayerState = chrome.cast.media.PlayerState;
+    this.#isIdle = state === PlayerState.IDLE;
+    if (state === PlayerState.PAUSED) return;
+    const trigger = this.#createEvent(event);
+    switch (state) {
+      case PlayerState.PLAYING:
+        this.#ctx.notify("playing", void 0, trigger);
+        break;
+      case PlayerState.BUFFERING:
+        this.#ctx.notify("waiting", void 0, trigger);
+        break;
+      case PlayerState.IDLE:
+        this.#timeRAF.stop();
+        this.#ctx.notify("pause");
+        this.#ctx.notify("end");
+        break;
+    }
+  }
+  #getSeekableRange() {
+    return this.#player.liveSeekableRange ? new TimeRange(this.#player.liveSeekableRange.start, this.#player.liveSeekableRange.end) : this.#seekableRange;
+  }
+  #createEvent(detail) {
+    return detail instanceof Event ? detail : new DOMEvent(detail.type, { detail });
+  }
+  #buildMediaInfo(src) {
+    const { streamType, title, poster } = this.#ctx.$state;
+    return new GoogleCastMediaInfoBuilder(src).setMetadata(title(), poster()).setStreamType(streamType()).setTracks(this.#tracks.getLocalTextTracks()).build();
+  }
+  #buildLoadRequest(src) {
+    const mediaInfo = this.#buildMediaInfo(src), request = new chrome.cast.media.LoadRequest(mediaInfo), savedState = this.#ctx.$state.savedState();
+    request.autoplay = (this.#reloadInfo?.paused ?? savedState?.paused) === false;
+    request.currentTime = this.#reloadInfo?.time ?? savedState?.currentTime ?? 0;
+    return request;
+  }
+  async #reload(paused, time) {
+    const src = peek(this.#ctx.$state.source);
+    this.#reloadInfo = { src, paused, time };
+    await this.loadSource(src);
+  }
+  #onNewLocalTracks() {
+    this.#reload(this.#player.isPaused, this.#player.currentTime).catch((error) => {
+      {
+        this.#ctx.logger?.errorGroup("[vidstack] cast failed to load new local tracks").labelledLog("Error", error).dispatch();
+      }
+    });
+  }
+}
+
+export { GoogleCastProvider };
diff --git a/dev/chunks/vidstack-DEqI2Hy1.js b/dev/chunks/vidstack-DEqI2Hy1.js
new file mode 100644
index 0000000000000000000000000000000000000000..9d5d19dc43ec6b3db7501a25d263fd5c79300e9a
--- /dev/null
+++ b/dev/chunks/vidstack-DEqI2Hy1.js
@@ -0,0 +1,668 @@
+"use client"
+
+import * as React from 'react';
+import { useReactContext, createReactComponent, composeRefs, useSignal, noop, useStateContext, signal, effect, isString } from './vidstack-CH225ns1.js';
+import { mediaContext, Primitive, AirPlayButtonInstance, PlayButtonInstance, CaptionButtonInstance, FullscreenButtonInstance, MuteButtonInstance, PIPButtonInstance, SeekButtonInstance, LiveButtonInstance, SliderValueInstance, useSliderState, SliderInstance, SliderPreviewInstance, VolumeSliderInstance, IS_SERVER, ThumbnailInstance, TimeSliderInstance, SliderChaptersInstance, SliderThumbnailInstance, SliderVideoInstance, mediaState, RadioGroupInstance, RadioInstance, useMediaState, MenuInstance, MenuButtonInstance, MenuItemsInstance, MenuItemInstance, GestureInstance, TimeInstance, isTrackCaptionKind } from './vidstack-MAWt6ODZ.js';
+import { createPortal } from 'react-dom';
+
+function useMediaContext() {
+  return useReactContext(mediaContext);
+}
+
+const AirPlayButtonBridge = createReactComponent(AirPlayButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const AirPlayButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(AirPlayButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+AirPlayButton.displayName = "AirPlayButton";
+
+const PlayButtonBridge = createReactComponent(PlayButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const PlayButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PlayButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+PlayButton.displayName = "PlayButton";
+
+const CaptionButtonBridge = createReactComponent(CaptionButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const CaptionButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(CaptionButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+CaptionButton.displayName = "CaptionButton";
+
+const FullscreenButtonBridge = createReactComponent(FullscreenButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const FullscreenButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(FullscreenButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+FullscreenButton.displayName = "FullscreenButton";
+
+const MuteButtonBridge = createReactComponent(MuteButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const MuteButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(MuteButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+MuteButton.displayName = "MuteButton";
+
+const PIPButtonBridge = createReactComponent(PIPButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const PIPButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PIPButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+PIPButton.displayName = "PIPButton";
+
+const SeekButtonBridge = createReactComponent(SeekButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const SeekButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SeekButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+SeekButton.displayName = "SeekButton";
+
+const LiveButtonBridge = createReactComponent(LiveButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const LiveButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(LiveButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+LiveButton.displayName = "LiveButton";
+
+const sliderCallbacks = [
+  "onDragStart",
+  "onDragEnd",
+  "onDragValueChange",
+  "onValueChange",
+  "onPointerValueChange"
+];
+
+const SliderValueBridge = createReactComponent(SliderValueInstance);
+
+const SliderBridge = createReactComponent(SliderInstance, {
+  events: sliderCallbacks
+});
+const Root$5 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(SliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+});
+Root$5.displayName = "Slider";
+const Thumb = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Thumb.displayName = "SliderThumb";
+const Track = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Track.displayName = "SliderTrack";
+const TrackFill = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+TrackFill.displayName = "SliderTrackFill";
+const PreviewBridge = createReactComponent(SliderPreviewInstance);
+const Preview = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PreviewBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Preview.displayName = "SliderPreview";
+const Value = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(SliderValueBridge, { ...props }, (props2, instance) => {
+    const $text = useSignal(() => instance.getValueText(), instance);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props2, ref: forwardRef }, $text, children);
+  });
+});
+Value.displayName = "SliderValue";
+const Steps = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const $min = useSliderState("min"), $max = useSliderState("max"), $step = useSliderState("step"), steps = ($max - $min) / $step;
+  return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, Array.from({ length: Math.floor(steps) + 1 }).map((_, step) => children(step)));
+});
+Steps.displayName = "SliderSteps";
+
+var slider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$5,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value
+});
+
+const VolumeSliderBridge = createReactComponent(VolumeSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$4 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(VolumeSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$4.displayName = "VolumeSlider";
+
+var volumeSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$4,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value
+});
+
+function createVTTCue(startTime = 0, endTime = 0, text = "") {
+  if (IS_SERVER) {
+    return {
+      startTime,
+      endTime,
+      text,
+      addEventListener: noop,
+      removeEventListener: noop,
+      dispatchEvent: noop
+    };
+  }
+  return new window.VTTCue(startTime, endTime, text);
+}
+function appendParamsToURL(baseUrl, params) {
+  const url = new URL(baseUrl);
+  for (const key of Object.keys(params)) {
+    url.searchParams.set(key, params[key] + "");
+  }
+  return url.toString();
+}
+
+const ThumbnailBridge = createReactComponent(ThumbnailInstance);
+const Root$3 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ThumbnailBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Root$3.displayName = "Thumbnail";
+const Img = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const { src, img, crossOrigin } = useStateContext(ThumbnailInstance.state), $src = useSignal(src), $crossOrigin = useSignal(crossOrigin);
+  return /* @__PURE__ */ React.createElement(
+    Primitive.img,
+    {
+      crossOrigin: $crossOrigin,
+      ...props,
+      src: $src || void 0,
+      ref: composeRefs(img.set, forwardRef)
+    },
+    children
+  );
+});
+Img.displayName = "ThumbnailImg";
+
+var thumbnail = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Img: Img,
+  Root: Root$3
+});
+
+const TimeSliderContext = React.createContext({
+  $chapters: signal(null)
+});
+TimeSliderContext.displayName = "TimeSliderContext";
+const TimeSliderBridge = createReactComponent(TimeSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$2 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    const $chapters = React.useMemo(() => signal(null), []);
+    return /* @__PURE__ */ React.createElement(TimeSliderContext.Provider, { value: { $chapters } }, /* @__PURE__ */ React.createElement(TimeSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children)));
+  }
+);
+Root$2.displayName = "TimeSlider";
+const SliderChaptersBridge = createReactComponent(SliderChaptersInstance);
+const Chapters = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SliderChaptersBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      /* @__PURE__ */ React.createElement(ChapterTracks, { instance }, children)
+    ));
+  }
+);
+Chapters.displayName = "SliderChapters";
+function ChapterTracks({ instance, children }) {
+  const $cues = useSignal(() => instance.cues, instance), refs = React.useRef([]), emptyCue = React.useRef(), { $chapters } = React.useContext(TimeSliderContext);
+  if (!emptyCue.current) {
+    emptyCue.current = createVTTCue();
+  }
+  React.useEffect(() => {
+    $chapters.set(instance);
+    return () => void $chapters.set(null);
+  }, [instance]);
+  React.useEffect(() => {
+    instance.setRefs(refs.current);
+  }, [$cues]);
+  return children($cues.length ? $cues : [emptyCue.current], (el) => {
+    if (!el) {
+      refs.current.length = 0;
+      return;
+    }
+    refs.current.push(el);
+  });
+}
+ChapterTracks.displayName = "SliderChapterTracks";
+const ChapterTitle = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    const { $chapters } = React.useContext(TimeSliderContext), [title, setTitle] = React.useState();
+    React.useEffect(() => {
+      return effect(() => {
+        const chapters = $chapters(), cue = chapters?.activePointerCue || chapters?.activeCue;
+        setTitle(cue?.text || "");
+      });
+    }, []);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, title, children);
+  }
+);
+ChapterTitle.displayName = "SliderChapterTitle";
+const Progress = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Progress.displayName = "SliderProgress";
+const SliderThumbnailBridge = createReactComponent(SliderThumbnailInstance);
+const ThumbnailRoot = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SliderThumbnailBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2, ref: composeRefs(props2.ref, forwardRef) }, children));
+  }
+);
+ThumbnailRoot.displayName = "SliderThumbnail";
+const Thumbnail = {
+  Root: ThumbnailRoot,
+  Img: Img
+};
+const VideoBridge = createReactComponent(SliderVideoInstance, {
+  events: ["onCanPlay", "onError"]
+});
+const Video = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(VideoBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+      VideoProvider,
+      {
+        ...props2,
+        instance,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Video.displayName = "SliderVideo";
+const VideoProvider = React.forwardRef(
+  ({ instance, children, ...props }, forwardRef) => {
+    const { canLoad } = useStateContext(mediaState), { src, video, crossOrigin } = instance.$state, $src = useSignal(src), $canLoad = useSignal(canLoad), $crossOrigin = useSignal(crossOrigin);
+    return /* @__PURE__ */ React.createElement(
+      Primitive.video,
+      {
+        style: { maxWidth: "unset" },
+        ...props,
+        src: $src || void 0,
+        muted: true,
+        playsInline: true,
+        preload: $canLoad ? "auto" : "none",
+        crossOrigin: $crossOrigin || void 0,
+        ref: composeRefs(video.set, forwardRef)
+      },
+      children
+    );
+  }
+);
+VideoProvider.displayName = "SliderVideoProvider";
+
+var timeSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  ChapterTitle: ChapterTitle,
+  Chapters: Chapters,
+  Preview: Preview,
+  Progress: Progress,
+  Root: Root$2,
+  Steps: Steps,
+  Thumb: Thumb,
+  Thumbnail: Thumbnail,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value,
+  Video: Video
+});
+
+const RadioGroupBridge = createReactComponent(RadioGroupInstance, {
+  events: ["onChange"]
+});
+const Root$1 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(RadioGroupBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$1.displayName = "RadioGroup";
+const ItemBridge$1 = createReactComponent(RadioInstance, {
+  events: ["onChange", "onSelect"]
+});
+const Item$1 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemBridge$1, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Item$1.displayName = "RadioItem";
+
+var radioGroup = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Item: Item$1,
+  Root: Root$1
+});
+
+const MenuBridge = createReactComponent(MenuInstance, {
+  events: ["onOpen", "onClose"],
+  domEventsRegex: /^onMedia/
+});
+const Root = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(MenuBridge, { ...props, ref: forwardRef }, (props2, instance) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      style: { display: !instance.isSubmenu ? "contents" : void 0, ...props2.style }
+    },
+    children
+  ));
+});
+Root.displayName = "Menu";
+const ButtonBridge = createReactComponent(MenuButtonInstance, {
+  events: ["onSelect"]
+});
+const Button = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(ButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Button.displayName = "MenuButton";
+const Portal = React.forwardRef(
+  ({ container = null, disabled = false, children, ...props }, forwardRef) => {
+    let fullscreen = useMediaState("fullscreen"), shouldPortal = disabled === "fullscreen" ? !fullscreen : !disabled;
+    const target = React.useMemo(() => {
+      if (IS_SERVER) return null;
+      const node = isString(container) ? document.querySelector(container) : container;
+      return node ?? document.body;
+    }, [container]);
+    return !target || !shouldPortal ? children : createPortal(
+      /* @__PURE__ */ React.createElement(
+        Primitive.div,
+        {
+          ...props,
+          style: { display: "contents", ...props.style },
+          ref: forwardRef
+        },
+        children
+      ),
+      target
+    );
+  }
+);
+Portal.displayName = "MenuPortal";
+const ItemsBridge = createReactComponent(MenuItemsInstance);
+const Items = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemsBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Items.displayName = "MenuItems";
+const ItemBridge = createReactComponent(MenuItemInstance);
+const Item = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Item.displayName = "MenuItem";
+
+var menu = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Button: Button,
+  Content: Items,
+  Item: Item,
+  Items: Items,
+  Portal: Portal,
+  Radio: Item$1,
+  RadioGroup: Root$1,
+  Root: Root
+});
+
+const GestureBridge = createReactComponent(GestureInstance, {
+  events: ["onWillTrigger", "onTrigger"]
+});
+const Gesture = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(GestureBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Gesture.displayName = "Gesture";
+
+const TimeBridge = createReactComponent(TimeInstance);
+const Time = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(TimeBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+    TimeText,
+    {
+      ...props2,
+      instance,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Time.displayName = "Time";
+const TimeText = React.forwardRef(
+  ({ instance, children, ...props }, forwardRef) => {
+    const { timeText } = instance.$state, $timeText = useSignal(timeText);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, $timeText, children);
+  }
+);
+TimeText.displayName = "TimeText";
+
+function useMediaPlayer() {
+  const context = useMediaContext();
+  if (!context) {
+    throw Error(
+      "[vidstack] no media context was found - was this called outside of `<MediaPlayer>`?"
+    );
+  }
+  return context?.player || null;
+}
+
+function useAudioOptions() {
+  const media = useMediaContext(), { audioTracks, audioTrack } = media.$state, $audioTracks = useSignal(audioTracks);
+  useSignal(audioTrack);
+  return React.useMemo(() => {
+    const options = $audioTracks.map((track) => ({
+      track,
+      label: track.label,
+      value: getTrackValue$1(track),
+      get selected() {
+        return audioTrack() === track;
+      },
+      select(trigger) {
+        const index = audioTracks().indexOf(track);
+        if (index >= 0) media.remote.changeAudioTrack(index, trigger);
+      }
+    }));
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return options.length <= 1;
+      }
+    });
+    Object.defineProperty(options, "selectedTrack", {
+      get() {
+        return audioTrack();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const track = audioTrack();
+        return track ? getTrackValue$1(track) : void 0;
+      }
+    });
+    return options;
+  }, [$audioTracks]);
+}
+function getTrackValue$1(track) {
+  return track.label.toLowerCase();
+}
+
+function useCaptionOptions({ off = true } = {}) {
+  const media = useMediaContext(), { textTracks, textTrack } = media.$state, $textTracks = useSignal(textTracks);
+  useSignal(textTrack);
+  return React.useMemo(() => {
+    const captionTracks = $textTracks.filter(isTrackCaptionKind), options = captionTracks.map((track) => ({
+      track,
+      label: track.label,
+      value: getTrackValue(track),
+      get selected() {
+        return textTrack() === track;
+      },
+      select(trigger) {
+        const index = textTracks().indexOf(track);
+        if (index >= 0) media.remote.changeTextTrackMode(index, "showing", trigger);
+      }
+    }));
+    if (off) {
+      options.unshift({
+        track: null,
+        label: isString(off) ? off : "Off",
+        value: "off",
+        get selected() {
+          return !textTrack();
+        },
+        select(trigger) {
+          media.remote.toggleCaptions(trigger);
+        }
+      });
+    }
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !captionTracks.length;
+      }
+    });
+    Object.defineProperty(options, "selectedTrack", {
+      get() {
+        return textTrack();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const track = textTrack();
+        return track ? getTrackValue(track) : "off";
+      }
+    });
+    return options;
+  }, [$textTracks]);
+}
+function getTrackValue(track) {
+  return track.id + ":" + track.kind + "-" + track.label.toLowerCase();
+}
+
+export { AirPlayButton, Button, CaptionButton, ChapterTitle, Chapters, FullscreenButton, Gesture, Img, Item$1 as Item, Items, LiveButton, MuteButton, PIPButton, PlayButton, Portal, Preview, Progress, Root$3 as Root, Root$2 as Root$1, Root as Root$2, Root$1 as Root$3, Root$4, Root$5, SeekButton, Steps, Thumb, Thumbnail, Time, Track, TrackFill, Value, appendParamsToURL, menu, radioGroup, slider, sliderCallbacks, thumbnail, timeSlider, useAudioOptions, useCaptionOptions, useMediaContext, useMediaPlayer, volumeSlider };
diff --git a/dev/chunks/vidstack-DFnQvu5z.js b/dev/chunks/vidstack-DK-SOT4L.js
similarity index 99%
rename from dev/chunks/vidstack-DFnQvu5z.js
rename to dev/chunks/vidstack-DK-SOT4L.js
index a60d9f3892cc86c670bb6ca2b90df1237899d6da..ac27a774d66b48d4039dffdb85f91defa93fde77 100644
--- a/dev/chunks/vidstack-DFnQvu5z.js
+++ b/dev/chunks/vidstack-DK-SOT4L.js
@@ -1,8 +1,8 @@
 "use client"
 
 import * as React from 'react';
-import { RadioGroupController, useMediaContext, menuContext, MediaRemoteControl, MediaPlayerInstance, sortVideoQualities } from './vidstack-tCTk_Mpr.js';
-import { useMediaContext as useMediaContext$1 } from './vidstack-DM21n8Pk.js';
+import { RadioGroupController, useMediaContext, menuContext, MediaRemoteControl, MediaPlayerInstance, sortVideoQualities } from './vidstack-MAWt6ODZ.js';
+import { useMediaContext as useMediaContext$1 } from './vidstack-DEqI2Hy1.js';
 import { prop, method, Component, hasProvidedContext, useContext, effect, useSignal, isString } from './vidstack-CH225ns1.js';
 
 const DEFAULT_PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
diff --git a/dev/chunks/vidstack-DQ_pDMim.js b/dev/chunks/vidstack-DQ_pDMim.js
new file mode 100644
index 0000000000000000000000000000000000000000..b80da96a5bf748e3f64bff21150a696e447b7f85
--- /dev/null
+++ b/dev/chunks/vidstack-DQ_pDMim.js
@@ -0,0 +1,477 @@
+"use client"
+
+import { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from './vidstack-CH225ns1.js';
+import { ListSymbol, TimeRange, RAFLoop } from './vidstack-DlEFWAGb.js';
+import { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-Cm9GcCaL.js';
+import 'react';
+import '@floating-ui/dom';
+
+class GoogleCastMediaInfoBuilder {
+  #info;
+  constructor(src) {
+    this.#info = new chrome.cast.media.MediaInfo(src.src, src.type);
+  }
+  build() {
+    return this.#info;
+  }
+  setStreamType(streamType) {
+    if (streamType.includes("live")) {
+      this.#info.streamType = chrome.cast.media.StreamType.LIVE;
+    } else {
+      this.#info.streamType = chrome.cast.media.StreamType.BUFFERED;
+    }
+    return this;
+  }
+  setTracks(tracks) {
+    this.#info.tracks = tracks.map(this.#buildCastTrack);
+    return this;
+  }
+  setMetadata(title, poster) {
+    this.#info.metadata = new chrome.cast.media.GenericMediaMetadata();
+    this.#info.metadata.title = title;
+    this.#info.metadata.images = [{ url: poster }];
+    return this;
+  }
+  #buildCastTrack(track, trackId) {
+    const castTrack = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);
+    castTrack.name = track.label;
+    castTrack.trackContentId = track.src;
+    castTrack.trackContentType = "text/vtt";
+    castTrack.language = track.language;
+    castTrack.subtype = track.kind.toUpperCase();
+    return castTrack;
+  }
+}
+
+const REMOTE_TRACK_TEXT_TYPE = chrome.cast.media.TrackType.TEXT, REMOTE_TRACK_AUDIO_TYPE = chrome.cast.media.TrackType.AUDIO;
+class GoogleCastTracksManager {
+  #cast;
+  #ctx;
+  #onNewLocalTracks;
+  constructor(cast, ctx, onNewLocalTracks) {
+    this.#cast = cast;
+    this.#ctx = ctx;
+    this.#onNewLocalTracks = onNewLocalTracks;
+  }
+  setup() {
+    const syncRemoteActiveIds = this.syncRemoteActiveIds.bind(this);
+    listenEvent(this.#ctx.audioTracks, "change", syncRemoteActiveIds);
+    listenEvent(this.#ctx.textTracks, "mode-change", syncRemoteActiveIds);
+    effect(this.#syncLocalTracks.bind(this));
+  }
+  getLocalTextTracks() {
+    return this.#ctx.$state.textTracks().filter((track) => track.src && track.type === "vtt");
+  }
+  #getLocalAudioTracks() {
+    return this.#ctx.$state.audioTracks();
+  }
+  #getRemoteTracks(type) {
+    const tracks = this.#cast.mediaInfo?.tracks ?? [];
+    return type ? tracks.filter((track) => track.type === type) : tracks;
+  }
+  #getRemoteActiveIds() {
+    const activeIds = [], activeLocalAudioTrack = this.#getLocalAudioTracks().find((track) => track.selected), activeLocalTextTracks = this.getLocalTextTracks().filter((track) => track.mode === "showing");
+    if (activeLocalAudioTrack) {
+      const remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteAudioTrack = this.#findRemoteTrack(remoteAudioTracks, activeLocalAudioTrack);
+      if (remoteAudioTrack) activeIds.push(remoteAudioTrack.trackId);
+    }
+    if (activeLocalTextTracks?.length) {
+      const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+      if (remoteTextTracks.length) {
+        for (const localTrack of activeLocalTextTracks) {
+          const remoteTextTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
+          if (remoteTextTrack) activeIds.push(remoteTextTrack.trackId);
+        }
+      }
+    }
+    return activeIds;
+  }
+  #syncLocalTracks() {
+    const localTextTracks = this.getLocalTextTracks();
+    if (!this.#cast.isMediaLoaded) return;
+    const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+    for (const localTrack of localTextTracks) {
+      const hasRemoteTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
+      if (!hasRemoteTrack) {
+        untrack(() => this.#onNewLocalTracks?.());
+        break;
+      }
+    }
+  }
+  syncRemoteTracks(event) {
+    if (!this.#cast.isMediaLoaded) return;
+    const localAudioTracks = this.#getLocalAudioTracks(), localTextTracks = this.getLocalTextTracks(), remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+    for (const remoteAudioTrack of remoteAudioTracks) {
+      const hasLocalTrack = this.#findLocalTrack(localAudioTracks, remoteAudioTrack);
+      if (hasLocalTrack) continue;
+      const localAudioTrack = {
+        id: remoteAudioTrack.trackId.toString(),
+        label: remoteAudioTrack.name,
+        language: remoteAudioTrack.language,
+        kind: remoteAudioTrack.subtype ?? "main",
+        selected: false
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localAudioTrack, event);
+    }
+    for (const remoteTextTrack of remoteTextTracks) {
+      const hasLocalTrack = this.#findLocalTrack(localTextTracks, remoteTextTrack);
+      if (hasLocalTrack) continue;
+      const localTextTrack = {
+        id: remoteTextTrack.trackId.toString(),
+        src: remoteTextTrack.trackContentId,
+        label: remoteTextTrack.name,
+        language: remoteTextTrack.language,
+        kind: remoteTextTrack.subtype.toLowerCase()
+      };
+      this.#ctx.textTracks.add(localTextTrack, event);
+    }
+  }
+  syncRemoteActiveIds(event) {
+    if (!this.#cast.isMediaLoaded) return;
+    const activeIds = this.#getRemoteActiveIds(), editRequest = new chrome.cast.media.EditTracksInfoRequest(activeIds);
+    this.#editTracksInfo(editRequest).catch((error) => {
+      {
+        this.#ctx.logger?.errorGroup("[vidstack] failed to edit cast tracks info").labelledLog("Edit Request", editRequest).labelledLog("Error", error).dispatch();
+      }
+    });
+  }
+  #editTracksInfo(request) {
+    const media = getCastSessionMedia();
+    return new Promise((resolve, reject) => media?.editTracksInfo(request, resolve, reject));
+  }
+  #findLocalTrack(localTracks, remoteTrack) {
+    return localTracks.find((localTrack) => this.#isMatch(localTrack, remoteTrack));
+  }
+  #findRemoteTrack(remoteTracks, localTrack) {
+    return remoteTracks.find((remoteTrack) => this.#isMatch(localTrack, remoteTrack));
+  }
+  // Note: we can't rely on id matching because they will differ between local/remote. A local
+  // track id might not even exist.
+  #isMatch(localTrack, remoteTrack) {
+    return remoteTrack.name === localTrack.label && remoteTrack.language === localTrack.language && remoteTrack.subtype.toLowerCase() === localTrack.kind.toLowerCase();
+  }
+}
+
+class GoogleCastProvider {
+  $$PROVIDER_TYPE = "GOOGLE_CAST";
+  scope = createScope();
+  #player;
+  #ctx;
+  #tracks;
+  #currentSrc = null;
+  #state = "disconnected";
+  #currentTime = 0;
+  #played = 0;
+  #seekableRange = new TimeRange(0, 0);
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #playerEventHandlers;
+  #reloadInfo = null;
+  #isIdle = false;
+  constructor(player, ctx) {
+    this.#player = player;
+    this.#ctx = ctx;
+    this.#tracks = new GoogleCastTracksManager(player, ctx, this.#onNewLocalTracks.bind(this));
+  }
+  get type() {
+    return "google-cast";
+  }
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  /**
+   * The Google Cast remote player.
+   *
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.RemotePlayer}
+   */
+  get player() {
+    return this.#player;
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
+   */
+  get cast() {
+    return getCastContext();
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastSession}
+   */
+  get session() {
+    return getCastSession();
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media.Media}
+   */
+  get media() {
+    return getCastSessionMedia();
+  }
+  /**
+   * Whether the current Google Cast session belongs to this provider.
+   */
+  get hasActiveSession() {
+    return hasActiveCastSession(this.#currentSrc);
+  }
+  setup() {
+    this.#attachCastContextEventListeners();
+    this.#attachCastPlayerEventListeners();
+    this.#tracks.setup();
+    this.#ctx.notify("provider-setup", this);
+  }
+  #attachCastContextEventListeners() {
+    listenCastContextEvent(
+      cast.framework.CastContextEventType.CAST_STATE_CHANGED,
+      this.#onCastStateChange.bind(this)
+    );
+  }
+  #attachCastPlayerEventListeners() {
+    const Event2 = cast.framework.RemotePlayerEventType, handlers = {
+      [Event2.IS_CONNECTED_CHANGED]: this.#onCastStateChange,
+      [Event2.IS_MEDIA_LOADED_CHANGED]: this.#onMediaLoadedChange,
+      [Event2.CAN_CONTROL_VOLUME_CHANGED]: this.#onCanControlVolumeChange,
+      [Event2.CAN_SEEK_CHANGED]: this.#onCanSeekChange,
+      [Event2.DURATION_CHANGED]: this.#onDurationChange,
+      [Event2.IS_MUTED_CHANGED]: this.#onVolumeChange,
+      [Event2.VOLUME_LEVEL_CHANGED]: this.#onVolumeChange,
+      [Event2.IS_PAUSED_CHANGED]: this.#onPausedChange,
+      [Event2.LIVE_SEEKABLE_RANGE_CHANGED]: this.#onProgress,
+      [Event2.PLAYER_STATE_CHANGED]: this.#onPlayerStateChange
+    };
+    this.#playerEventHandlers = handlers;
+    const handler = this.#onRemotePlayerEvent.bind(this);
+    for (const type of keysOf(handlers)) {
+      this.#player.controller.addEventListener(type, handler);
+    }
+    onDispose(() => {
+      for (const type of keysOf(handlers)) {
+        this.#player.controller.removeEventListener(type, handler);
+      }
+    });
+  }
+  async play() {
+    if (!this.#player.isPaused && !this.#isIdle) return;
+    if (this.#isIdle) {
+      await this.#reload(false, 0);
+      return;
+    }
+    this.#player.controller?.playOrPause();
+  }
+  async pause() {
+    if (this.#player.isPaused) return;
+    this.#player.controller?.playOrPause();
+  }
+  getMediaStatus(request) {
+    return new Promise((resolve, reject) => {
+      this.media?.getStatus(request, resolve, reject);
+    });
+  }
+  setMuted(muted) {
+    const hasChanged = muted && !this.#player.isMuted || !muted && this.#player.isMuted;
+    if (hasChanged) this.#player.controller?.muteOrUnmute();
+  }
+  setCurrentTime(time) {
+    this.#player.currentTime = time;
+    this.#ctx.notify("seeking", time);
+    this.#player.controller?.seek();
+  }
+  setVolume(volume) {
+    this.#player.volumeLevel = volume;
+    this.#player.controller?.setVolumeLevel();
+  }
+  async loadSource(src) {
+    if (this.#reloadInfo?.src !== src) this.#reloadInfo = null;
+    if (hasActiveCastSession(src)) {
+      this.#resumeSession();
+      this.#currentSrc = src;
+      return;
+    }
+    this.#ctx.notify("load-start");
+    const loadRequest = this.#buildLoadRequest(src), errorCode = await this.session.loadMedia(loadRequest);
+    if (errorCode) {
+      this.#currentSrc = null;
+      this.#ctx.notify("error", Error(getCastErrorMessage(errorCode)));
+      return;
+    }
+    this.#currentSrc = src;
+  }
+  destroy() {
+    this.#reset();
+    this.#endSession();
+  }
+  #reset() {
+    if (!this.#reloadInfo) {
+      this.#played = 0;
+      this.#seekableRange = new TimeRange(0, 0);
+    }
+    this.#timeRAF.stop();
+    this.#currentTime = 0;
+    this.#reloadInfo = null;
+  }
+  #resumeSession() {
+    const resumeSessionEvent = new DOMEvent("resume-session", { detail: this.session });
+    this.#onMediaLoadedChange(resumeSessionEvent);
+    const { muted, volume, savedState } = this.#ctx.$state, localState = savedState();
+    this.setCurrentTime(Math.max(this.#player.currentTime, localState?.currentTime ?? 0));
+    this.setMuted(muted());
+    this.setVolume(volume());
+    if (localState?.paused === false) this.play();
+  }
+  #endSession() {
+    this.cast.endCurrentSession(true);
+    const { remotePlaybackLoader } = this.#ctx.$state;
+    remotePlaybackLoader.set(null);
+  }
+  #disconnectFromReceiver() {
+    const { savedState } = this.#ctx.$state;
+    savedState.set({
+      paused: this.#player.isPaused,
+      currentTime: this.#player.currentTime
+    });
+    this.#endSession();
+  }
+  #onAnimationFrame() {
+    this.#onCurrentTimeChange();
+  }
+  #onRemotePlayerEvent(event) {
+    this.#playerEventHandlers[event.type].call(this, event);
+  }
+  #onCastStateChange(data) {
+    const castState = this.cast.getCastState(), state = castState === cast.framework.CastState.CONNECTED ? "connected" : castState === cast.framework.CastState.CONNECTING ? "connecting" : "disconnected";
+    if (this.#state === state) return;
+    const detail = { type: "google-cast", state }, trigger = this.#createEvent(data);
+    this.#state = state;
+    this.#ctx.notify("remote-playback-change", detail, trigger);
+    if (state === "disconnected") {
+      this.#disconnectFromReceiver();
+    }
+  }
+  #onMediaLoadedChange(event) {
+    const hasLoaded = !!this.#player.isMediaLoaded;
+    if (!hasLoaded) return;
+    const src = peek(this.#ctx.$state.source);
+    Promise.resolve().then(() => {
+      if (src !== peek(this.#ctx.$state.source) || !this.#player.isMediaLoaded) return;
+      this.#reset();
+      const duration = this.#player.duration;
+      this.#seekableRange = new TimeRange(0, duration);
+      const detail = {
+        provider: this,
+        duration,
+        buffered: new TimeRange(0, 0),
+        seekable: this.#getSeekableRange()
+      }, trigger = this.#createEvent(event);
+      this.#ctx.notify("loaded-metadata", void 0, trigger);
+      this.#ctx.notify("loaded-data", void 0, trigger);
+      this.#ctx.notify("can-play", detail, trigger);
+      this.#onCanControlVolumeChange();
+      this.#onCanSeekChange(event);
+      const { volume, muted } = this.#ctx.$state;
+      this.setVolume(volume());
+      this.setMuted(muted());
+      this.#timeRAF.start();
+      this.#tracks.syncRemoteTracks(trigger);
+      this.#tracks.syncRemoteActiveIds(trigger);
+    });
+  }
+  #onCanControlVolumeChange() {
+    this.#ctx.$state.canSetVolume.set(this.#player.canControlVolume);
+  }
+  #onCanSeekChange(event) {
+    const trigger = this.#createEvent(event);
+    this.#ctx.notify("stream-type-change", this.#getStreamType(), trigger);
+  }
+  #getStreamType() {
+    const streamType = this.#player.mediaInfo?.streamType;
+    return streamType === chrome.cast.media.StreamType.LIVE ? this.#player.canSeek ? "live:dvr" : "live" : "on-demand";
+  }
+  #onCurrentTimeChange() {
+    if (this.#reloadInfo) return;
+    const currentTime = this.#player.currentTime;
+    if (currentTime === this.#currentTime) return;
+    this.#ctx.notify("time-change", currentTime);
+    if (currentTime > this.#played) {
+      this.#played = currentTime;
+      this.#onProgress();
+    }
+    if (this.#ctx.$state.seeking()) {
+      this.#ctx.notify("seeked", currentTime);
+    }
+    this.#currentTime = currentTime;
+  }
+  #onDurationChange(event) {
+    if (!this.#player.isMediaLoaded || this.#reloadInfo) return;
+    const duration = this.#player.duration, trigger = this.#createEvent(event);
+    this.#seekableRange = new TimeRange(0, duration);
+    this.#ctx.notify("duration-change", duration, trigger);
+  }
+  #onVolumeChange(event) {
+    if (!this.#player.isMediaLoaded) return;
+    const detail = {
+      muted: this.#player.isMuted,
+      volume: this.#player.volumeLevel
+    }, trigger = this.#createEvent(event);
+    this.#ctx.notify("volume-change", detail, trigger);
+  }
+  #onPausedChange(event) {
+    const trigger = this.#createEvent(event);
+    if (this.#player.isPaused) {
+      this.#ctx.notify("pause", void 0, trigger);
+    } else {
+      this.#ctx.notify("play", void 0, trigger);
+    }
+  }
+  #onProgress(event) {
+    const detail = {
+      seekable: this.#getSeekableRange(),
+      buffered: new TimeRange(0, this.#played)
+    }, trigger = event ? this.#createEvent(event) : void 0;
+    this.#ctx.notify("progress", detail, trigger);
+  }
+  #onPlayerStateChange(event) {
+    const state = this.#player.playerState, PlayerState = chrome.cast.media.PlayerState;
+    this.#isIdle = state === PlayerState.IDLE;
+    if (state === PlayerState.PAUSED) return;
+    const trigger = this.#createEvent(event);
+    switch (state) {
+      case PlayerState.PLAYING:
+        this.#ctx.notify("playing", void 0, trigger);
+        break;
+      case PlayerState.BUFFERING:
+        this.#ctx.notify("waiting", void 0, trigger);
+        break;
+      case PlayerState.IDLE:
+        this.#timeRAF.stop();
+        this.#ctx.notify("pause");
+        this.#ctx.notify("end");
+        break;
+    }
+  }
+  #getSeekableRange() {
+    return this.#player.liveSeekableRange ? new TimeRange(this.#player.liveSeekableRange.start, this.#player.liveSeekableRange.end) : this.#seekableRange;
+  }
+  #createEvent(detail) {
+    return detail instanceof Event ? detail : new DOMEvent(detail.type, { detail });
+  }
+  #buildMediaInfo(src) {
+    const { streamType, title, poster } = this.#ctx.$state;
+    return new GoogleCastMediaInfoBuilder(src).setMetadata(title(), poster()).setStreamType(streamType()).setTracks(this.#tracks.getLocalTextTracks()).build();
+  }
+  #buildLoadRequest(src) {
+    const mediaInfo = this.#buildMediaInfo(src), request = new chrome.cast.media.LoadRequest(mediaInfo), savedState = this.#ctx.$state.savedState();
+    request.autoplay = (this.#reloadInfo?.paused ?? savedState?.paused) === false;
+    request.currentTime = this.#reloadInfo?.time ?? savedState?.currentTime ?? 0;
+    return request;
+  }
+  async #reload(paused, time) {
+    const src = peek(this.#ctx.$state.source);
+    this.#reloadInfo = { src, paused, time };
+    await this.loadSource(src);
+  }
+  #onNewLocalTracks() {
+    this.#reload(this.#player.isPaused, this.#player.currentTime).catch((error) => {
+      {
+        this.#ctx.logger?.errorGroup("[vidstack] cast failed to load new local tracks").labelledLog("Error", error).dispatch();
+      }
+    });
+  }
+}
+
+export { GoogleCastProvider };
diff --git a/dev/chunks/vidstack-DRj2Nonb.js b/dev/chunks/vidstack-DRj2Nonb.js
new file mode 100644
index 0000000000000000000000000000000000000000..1b630de753a03aa45533635968deb0c9ee83f019
--- /dev/null
+++ b/dev/chunks/vidstack-DRj2Nonb.js
@@ -0,0 +1,548 @@
+"use client"
+
+import { createScope, signal, effect, peek, isString, deferredPromise, listenEvent, isArray } from './vidstack-CH225ns1.js';
+import { TimeRange, RAFLoop, preconnect, ListSymbol, TextTrack, QualitySymbol } from './vidstack-BdoOxmTD.js';
+import { EmbedProvider } from './vidstack-saV39v1d.js';
+import { resolveVimeoVideoId, getVimeoVideoInfo } from './vidstack-krOAtKMi.js';
+import 'react';
+import '@floating-ui/dom';
+
+const trackedVimeoEvents = [
+  "bufferend",
+  "bufferstart",
+  // 'cuechange',
+  "durationchange",
+  "ended",
+  "enterpictureinpicture",
+  "error",
+  "fullscreenchange",
+  "leavepictureinpicture",
+  "loaded",
+  // 'loadeddata',
+  // 'loadedmetadata',
+  // 'loadstart',
+  "playProgress",
+  "loadProgress",
+  "pause",
+  "play",
+  "playbackratechange",
+  // 'progress',
+  "qualitychange",
+  "seeked",
+  "seeking",
+  // 'texttrackchange',
+  "timeupdate",
+  "volumechange",
+  "waiting"
+  // 'adstarted',
+  // 'adcompleted',
+  // 'aderror',
+  // 'adskipped',
+  // 'adallcompleted',
+  // 'adclicked',
+  // 'chapterchange',
+  // 'chromecastconnected',
+  // 'remoteplaybackavailabilitychange',
+  // 'remoteplaybackconnecting',
+  // 'remoteplaybackconnect',
+  // 'remoteplaybackdisconnect',
+  // 'liveeventended',
+  // 'liveeventstarted',
+  // 'livestreamoffline',
+  // 'livestreamonline',
+];
+
+class VimeoProvider extends EmbedProvider {
+  $$PROVIDER_TYPE = "VIMEO";
+  scope = createScope();
+  fullscreen;
+  #ctx;
+  #videoId = signal("");
+  #pro = signal(false);
+  #hash = null;
+  #currentSrc = null;
+  #fullscreenActive = false;
+  #seekableRange = new TimeRange(0, 0);
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #currentCue = null;
+  #chaptersTrack = null;
+  #promises = /* @__PURE__ */ new Map();
+  #videoInfoPromise = null;
+  constructor(iframe, ctx) {
+    super(iframe);
+    this.#ctx = ctx;
+    const self = this;
+    this.fullscreen = {
+      get active() {
+        return self.#fullscreenActive;
+      },
+      supported: true,
+      enter: () => this.#remote("requestFullscreen"),
+      exit: () => this.#remote("exitFullscreen")
+    };
+  }
+  /**
+   * Whether tracking session data should be enabled on the embed, including cookies and analytics.
+   * This is turned off by default to be GDPR-compliant.
+   *
+   * @defaultValue `false`
+   */
+  cookies = false;
+  title = true;
+  byline = true;
+  portrait = true;
+  color = "00ADEF";
+  get type() {
+    return "vimeo";
+  }
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  get videoId() {
+    return this.#videoId();
+  }
+  get hash() {
+    return this.#hash;
+  }
+  get isPro() {
+    return this.#pro();
+  }
+  preconnect() {
+    preconnect(this.getOrigin());
+  }
+  setup() {
+    super.setup();
+    effect(this.#watchVideoId.bind(this));
+    effect(this.#watchVideoInfo.bind(this));
+    effect(this.#watchPro.bind(this));
+    this.#ctx.notify("provider-setup", this);
+  }
+  destroy() {
+    this.#reset();
+    this.fullscreen = void 0;
+    const message = "provider destroyed";
+    for (const promises of this.#promises.values()) {
+      for (const { reject } of promises) reject(message);
+    }
+    this.#promises.clear();
+    this.#remote("destroy");
+  }
+  async play() {
+    return this.#remote("play");
+  }
+  async pause() {
+    return this.#remote("pause");
+  }
+  setMuted(muted) {
+    this.#remote("setMuted", muted);
+  }
+  setCurrentTime(time) {
+    this.#remote("seekTo", time);
+    this.#ctx.notify("seeking", time);
+  }
+  setVolume(volume) {
+    this.#remote("setVolume", volume);
+    this.#remote("setMuted", peek(this.#ctx.$state.muted));
+  }
+  setPlaybackRate(rate) {
+    this.#remote("setPlaybackRate", rate);
+  }
+  async loadSource(src) {
+    if (!isString(src.src)) {
+      this.#currentSrc = null;
+      this.#hash = null;
+      this.#videoId.set("");
+      return;
+    }
+    const { videoId, hash } = resolveVimeoVideoId(src.src);
+    this.#videoId.set(videoId ?? "");
+    this.#hash = hash ?? null;
+    this.#currentSrc = src;
+  }
+  #watchVideoId() {
+    this.#reset();
+    const videoId = this.#videoId();
+    if (!videoId) {
+      this.src.set("");
+      return;
+    }
+    this.src.set(`${this.getOrigin()}/video/${videoId}`);
+    this.#ctx.notify("load-start");
+  }
+  #watchVideoInfo() {
+    const videoId = this.#videoId();
+    if (!videoId) return;
+    const promise = deferredPromise(), abort = new AbortController();
+    this.#videoInfoPromise = promise;
+    getVimeoVideoInfo(videoId, abort, this.#hash).then((info) => {
+      promise.resolve(info);
+    }).catch((e) => {
+      promise.reject();
+      {
+        this.#ctx.logger?.warnGroup(`Failed to fetch vimeo video info for id \`${videoId}\`.`).labelledLog("Error", e).dispatch();
+      }
+    });
+    return () => {
+      promise.reject();
+      abort.abort();
+    };
+  }
+  #watchPro() {
+    const isPro = this.#pro(), { $state, qualities } = this.#ctx;
+    $state.canSetPlaybackRate.set(isPro);
+    qualities[ListSymbol.setReadonly](!isPro);
+    if (isPro) {
+      return listenEvent(qualities, "change", () => {
+        if (qualities.auto) return;
+        const id = qualities.selected?.id;
+        if (id) this.#remote("setQuality", id);
+      });
+    }
+  }
+  getOrigin() {
+    return "https://player.vimeo.com";
+  }
+  buildParams() {
+    const { keyDisabled } = this.#ctx.$props, { playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
+    return {
+      title: this.title,
+      byline: this.byline,
+      color: this.color,
+      portrait: this.portrait,
+      controls: showControls,
+      h: this.hash,
+      keyboard: showControls && !keyDisabled(),
+      transparent: true,
+      playsinline: playsInline(),
+      dnt: !this.cookies
+    };
+  }
+  #onAnimationFrame() {
+    this.#remote("getCurrentTime");
+  }
+  // Embed will sometimes dispatch 0 at end of playback.
+  #preventTimeUpdates = false;
+  #onTimeUpdate(time, trigger) {
+    if (this.#preventTimeUpdates && time === 0) return;
+    const { realCurrentTime, paused, bufferedEnd, seekableEnd, live } = this.#ctx.$state;
+    if (realCurrentTime() === time) return;
+    const prevTime = realCurrentTime();
+    this.#ctx.notify("time-change", time, trigger);
+    if (Math.abs(prevTime - time) > 1.5) {
+      this.#ctx.notify("seeking", time, trigger);
+      if (!paused() && bufferedEnd() < time) {
+        this.#ctx.notify("waiting", void 0, trigger);
+      }
+    }
+    if (!live() && seekableEnd() - time < 0.01) {
+      this.#ctx.notify("end", void 0, trigger);
+      this.#preventTimeUpdates = true;
+      setTimeout(() => {
+        this.#preventTimeUpdates = false;
+      }, 500);
+    }
+  }
+  #onSeeked(time, trigger) {
+    this.#ctx.notify("seeked", time, trigger);
+  }
+  #onLoaded(trigger) {
+    const videoId = this.#videoId();
+    this.#videoInfoPromise?.promise.then((info) => {
+      if (!info) return;
+      const { title, poster, duration, pro } = info;
+      this.#pro.set(pro);
+      this.#ctx.notify("title-change", title, trigger);
+      this.#ctx.notify("poster-change", poster, trigger);
+      this.#ctx.notify("duration-change", duration, trigger);
+      this.#onReady(duration, trigger);
+    }).catch(() => {
+      if (videoId !== this.#videoId()) return;
+      this.#remote("getVideoTitle");
+      this.#remote("getDuration");
+    });
+  }
+  #onReady(duration, trigger) {
+    const { nativeControls } = this.#ctx.$state, showEmbedControls = nativeControls();
+    this.#seekableRange = new TimeRange(0, duration);
+    const detail = {
+      buffered: new TimeRange(0, 0),
+      seekable: this.#seekableRange,
+      duration
+    };
+    this.#ctx.delegate.ready(detail, trigger);
+    if (!showEmbedControls) {
+      this.#remote("_hideOverlay");
+    }
+    this.#remote("getQualities");
+    this.#remote("getChapters");
+  }
+  #onMethod(method, data, trigger) {
+    switch (method) {
+      case "getVideoTitle":
+        const videoTitle = data;
+        this.#ctx.notify("title-change", videoTitle, trigger);
+        break;
+      case "getDuration":
+        const duration = data;
+        if (!this.#ctx.$state.canPlay()) {
+          this.#onReady(duration, trigger);
+        } else {
+          this.#ctx.notify("duration-change", duration, trigger);
+        }
+        break;
+      case "getCurrentTime":
+        this.#onTimeUpdate(data, trigger);
+        break;
+      case "getBuffered":
+        if (isArray(data) && data.length) {
+          this.#onLoadProgress(data[data.length - 1][1], trigger);
+        }
+        break;
+      case "setMuted":
+        this.#onVolumeChange(peek(this.#ctx.$state.volume), data, trigger);
+        break;
+      // case 'getTextTracks':
+      //   this.#onTextTracksChange(data as VimeoTextTrack[], trigger);
+      //   break;
+      case "getChapters":
+        this.#onChaptersChange(data);
+        break;
+      case "getQualities":
+        this.#onQualitiesChange(data, trigger);
+        break;
+    }
+    this.#getPromise(method)?.resolve();
+  }
+  #attachListeners() {
+    for (const type of trackedVimeoEvents) {
+      this.#remote("addEventListener", type);
+    }
+  }
+  #onPause(trigger) {
+    this.#timeRAF.stop();
+    this.#ctx.notify("pause", void 0, trigger);
+  }
+  #onPlay(trigger) {
+    this.#timeRAF.start();
+    this.#ctx.notify("play", void 0, trigger);
+  }
+  #onPlayProgress(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (!paused() && !this.#preventTimeUpdates) {
+      this.#ctx.notify("playing", void 0, trigger);
+    }
+  }
+  #onLoadProgress(buffered, trigger) {
+    const detail = {
+      buffered: new TimeRange(0, buffered),
+      seekable: this.#seekableRange
+    };
+    this.#ctx.notify("progress", detail, trigger);
+  }
+  #onBufferStart(trigger) {
+    this.#ctx.notify("waiting", void 0, trigger);
+  }
+  #onBufferEnd(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (!paused()) this.#ctx.notify("playing", void 0, trigger);
+  }
+  #onWaiting(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (paused()) {
+      this.#ctx.notify("play", void 0, trigger);
+    }
+    this.#ctx.notify("waiting", void 0, trigger);
+  }
+  #onVolumeChange(volume, muted, trigger) {
+    const detail = { volume, muted };
+    this.#ctx.notify("volume-change", detail, trigger);
+  }
+  // #onTextTrackChange(track: VimeoTextTrack, trigger: Event) {
+  //   const textTrack = this.#ctx.textTracks.toArray().find((t) => t.language === track.language);
+  //   if (textTrack) textTrack.mode = track.mode;
+  // }
+  // #onTextTracksChange(tracks: VimeoTextTrack[], trigger: Event) {
+  //   for (const init of tracks) {
+  //     const textTrack = new TextTrack({
+  //       ...init,
+  //       label: init.label.replace('auto-generated', 'auto'),
+  //     });
+  //     textTrack[TextTrackSymbol.readyState] = 2;
+  //     this.#ctx.textTracks.add(textTrack, trigger);
+  //     textTrack.setMode(init.mode, trigger);
+  //   }
+  // }
+  // #onCueChange(cue: VimeoTextCue, trigger: Event) {
+  //   const { textTracks, $state } = this.#ctx,
+  //     { currentTime } = $state,
+  //     track = textTracks.selected;
+  //   if (this.#currentCue) track?.removeCue(this.#currentCue, trigger);
+  //   this.#currentCue = new window.VTTCue(currentTime(), Number.MAX_SAFE_INTEGER, cue.text);
+  //   track?.addCue(this.#currentCue, trigger);
+  // }
+  #onChaptersChange(chapters) {
+    this.#removeChapters();
+    if (!chapters.length) return;
+    const track = new TextTrack({
+      kind: "chapters",
+      default: true
+    }), { seekableEnd } = this.#ctx.$state;
+    for (let i = 0; i < chapters.length; i++) {
+      const chapter = chapters[i], nextChapter = chapters[i + 1];
+      track.addCue(
+        new window.VTTCue(
+          chapter.startTime,
+          nextChapter?.startTime ?? seekableEnd(),
+          chapter.title
+        )
+      );
+    }
+    this.#chaptersTrack = track;
+    this.#ctx.textTracks.add(track);
+  }
+  #removeChapters() {
+    if (!this.#chaptersTrack) return;
+    this.#ctx.textTracks.remove(this.#chaptersTrack);
+    this.#chaptersTrack = null;
+  }
+  #onQualitiesChange(qualities, trigger) {
+    this.#ctx.qualities[QualitySymbol.enableAuto] = qualities.some((q) => q.id === "auto") ? () => this.#remote("setQuality", "auto") : void 0;
+    for (const quality of qualities) {
+      if (quality.id === "auto") continue;
+      const height = +quality.id.slice(0, -1);
+      if (isNaN(height)) continue;
+      this.#ctx.qualities[ListSymbol.add](
+        {
+          id: quality.id,
+          width: height * (16 / 9),
+          height,
+          codec: "avc1,h.264",
+          bitrate: -1
+        },
+        trigger
+      );
+    }
+    this.#onQualityChange(
+      qualities.find((q) => q.active),
+      trigger
+    );
+  }
+  #onQualityChange({ id } = {}, trigger) {
+    if (!id) return;
+    const isAuto = id === "auto", newQuality = this.#ctx.qualities.getById(id);
+    if (isAuto) {
+      this.#ctx.qualities[QualitySymbol.setAuto](isAuto, trigger);
+      this.#ctx.qualities[ListSymbol.select](void 0, true, trigger);
+    } else {
+      this.#ctx.qualities[ListSymbol.select](newQuality ?? void 0, true, trigger);
+    }
+  }
+  #onEvent(event, payload, trigger) {
+    switch (event) {
+      case "ready":
+        this.#attachListeners();
+        break;
+      case "loaded":
+        this.#onLoaded(trigger);
+        break;
+      case "play":
+        this.#onPlay(trigger);
+        break;
+      case "playProgress":
+        this.#onPlayProgress(trigger);
+        break;
+      case "pause":
+        this.#onPause(trigger);
+        break;
+      case "loadProgress":
+        this.#onLoadProgress(payload.seconds, trigger);
+        break;
+      case "waiting":
+        this.#onWaiting(trigger);
+        break;
+      case "bufferstart":
+        this.#onBufferStart(trigger);
+        break;
+      case "bufferend":
+        this.#onBufferEnd(trigger);
+        break;
+      case "volumechange":
+        this.#onVolumeChange(payload.volume, peek(this.#ctx.$state.muted), trigger);
+        break;
+      case "durationchange":
+        this.#seekableRange = new TimeRange(0, payload.duration);
+        this.#ctx.notify("duration-change", payload.duration, trigger);
+        break;
+      case "playbackratechange":
+        this.#ctx.notify("rate-change", payload.playbackRate, trigger);
+        break;
+      case "qualitychange":
+        this.#onQualityChange(payload, trigger);
+        break;
+      case "fullscreenchange":
+        this.#fullscreenActive = payload.fullscreen;
+        this.#ctx.notify("fullscreen-change", payload.fullscreen, trigger);
+        break;
+      case "enterpictureinpicture":
+        this.#ctx.notify("picture-in-picture-change", true, trigger);
+        break;
+      case "leavepictureinpicture":
+        this.#ctx.notify("picture-in-picture-change", false, trigger);
+        break;
+      case "ended":
+        this.#ctx.notify("end", void 0, trigger);
+        break;
+      case "error":
+        this.#onError(payload, trigger);
+        break;
+      case "seek":
+      case "seeked":
+        this.#onSeeked(payload.seconds, trigger);
+        break;
+    }
+  }
+  #onError(error, trigger) {
+    const { message, method } = error;
+    if (method === "setPlaybackRate") {
+      this.#pro.set(false);
+    }
+    if (method) {
+      this.#getPromise(method)?.reject(message);
+    }
+    {
+      this.#ctx.logger?.errorGroup(`[vimeo]: ${message}`).labelledLog("Error", error).labelledLog("Provider", this).labelledLog("Event", trigger).dispatch();
+    }
+  }
+  onMessage(message, event) {
+    if (message.event) {
+      this.#onEvent(message.event, message.data, event);
+    } else if (message.method) {
+      this.#onMethod(message.method, message.value, event);
+    }
+  }
+  onLoad() {
+  }
+  async #remote(command, arg) {
+    let promise = deferredPromise(), promises = this.#promises.get(command);
+    if (!promises) this.#promises.set(command, promises = []);
+    promises.push(promise);
+    this.postMessage({
+      method: command,
+      value: arg
+    });
+    return promise.promise;
+  }
+  #reset() {
+    this.#timeRAF.stop();
+    this.#seekableRange = new TimeRange(0, 0);
+    this.#videoInfoPromise = null;
+    this.#currentCue = null;
+    this.#pro.set(false);
+    this.#removeChapters();
+  }
+  #getPromise(command) {
+    return this.#promises.get(command)?.shift();
+  }
+}
+
+export { VimeoProvider };
diff --git a/dev/chunks/vidstack-DSyHdZcv.js b/dev/chunks/vidstack-DSyHdZcv.js
new file mode 100644
index 0000000000000000000000000000000000000000..e056826fa5b7dc0727b34684755df7adb5dcab42
--- /dev/null
+++ b/dev/chunks/vidstack-DSyHdZcv.js
@@ -0,0 +1,180 @@
+"use client"
+
+import { IS_CHROME, IS_IOS, canGoogleCastSrc, IS_SERVER, loadScript } from './vidstack-BdoOxmTD.js';
+import { listenEvent, peek } from './vidstack-CH225ns1.js';
+
+function getCastFrameworkURL() {
+  return "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";
+}
+function hasLoadedCastFramework() {
+  return !!window.cast?.framework;
+}
+function isCastAvailable() {
+  return !!window.chrome?.cast?.isAvailable;
+}
+function isCastConnected() {
+  return getCastContext().getCastState() === cast.framework.CastState.CONNECTED;
+}
+function getCastContext() {
+  return window.cast.framework.CastContext.getInstance();
+}
+function getCastSession() {
+  return getCastContext().getCurrentSession();
+}
+function getCastSessionMedia() {
+  return getCastSession()?.getSessionObj().media[0];
+}
+function hasActiveCastSession(src) {
+  const contentId = getCastSessionMedia()?.media.contentId;
+  return contentId === src?.src;
+}
+function getDefaultCastOptions() {
+  return {
+    language: "en-US",
+    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
+    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
+    resumeSavedSession: true,
+    androidReceiverCompatible: true
+  };
+}
+function getCastErrorMessage(code) {
+  const defaultMessage = `Google Cast Error Code: ${code}`;
+  {
+    switch (code) {
+      case chrome.cast.ErrorCode.API_NOT_INITIALIZED:
+        return "The API is not initialized.";
+      case chrome.cast.ErrorCode.CANCEL:
+        return "The operation was canceled by the user";
+      case chrome.cast.ErrorCode.CHANNEL_ERROR:
+        return "A channel to the receiver is not available.";
+      case chrome.cast.ErrorCode.EXTENSION_MISSING:
+        return "The Cast extension is not available.";
+      case chrome.cast.ErrorCode.INVALID_PARAMETER:
+        return "The parameters to the operation were not valid.";
+      case chrome.cast.ErrorCode.RECEIVER_UNAVAILABLE:
+        return "No receiver was compatible with the session request.";
+      case chrome.cast.ErrorCode.SESSION_ERROR:
+        return "A session could not be created, or a session was invalid.";
+      case chrome.cast.ErrorCode.TIMEOUT:
+        return "The operation timed out.";
+      default:
+        return defaultMessage;
+    }
+  }
+}
+function listenCastContextEvent(type, handler) {
+  return listenEvent(getCastContext(), type, handler);
+}
+
+class GoogleCastLoader {
+  name = "google-cast";
+  target;
+  #player;
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
+   */
+  get cast() {
+    return getCastContext();
+  }
+  mediaType() {
+    return "video";
+  }
+  canPlay(src) {
+    return IS_CHROME && !IS_IOS && canGoogleCastSrc(src);
+  }
+  async prompt(ctx) {
+    let loadEvent, openEvent, errorEvent;
+    try {
+      loadEvent = await this.#loadCastFramework(ctx);
+      if (!this.#player) {
+        this.#player = new cast.framework.RemotePlayer();
+        new cast.framework.RemotePlayerController(this.#player);
+      }
+      openEvent = ctx.player.createEvent("google-cast-prompt-open", {
+        trigger: loadEvent
+      });
+      ctx.player.dispatchEvent(openEvent);
+      this.#notifyRemoteStateChange(ctx, "connecting", openEvent);
+      await this.#showPrompt(peek(ctx.$props.googleCast));
+      ctx.$state.remotePlaybackInfo.set({
+        deviceName: getCastSession()?.getCastDevice().friendlyName
+      });
+      if (isCastConnected()) this.#notifyRemoteStateChange(ctx, "connected", openEvent);
+    } catch (code) {
+      const error = code instanceof Error ? code : this.#createError(
+        (code + "").toUpperCase(),
+        "Prompt failed."
+      );
+      errorEvent = ctx.player.createEvent("google-cast-prompt-error", {
+        detail: error,
+        trigger: openEvent ?? loadEvent,
+        cancelable: true
+      });
+      ctx.player.dispatch(errorEvent);
+      this.#notifyRemoteStateChange(
+        ctx,
+        isCastConnected() ? "connected" : "disconnected",
+        errorEvent
+      );
+      throw error;
+    } finally {
+      ctx.player.dispatch("google-cast-prompt-close", {
+        trigger: errorEvent ?? openEvent ?? loadEvent
+      });
+    }
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load google cast provider server-side");
+    }
+    if (!this.#player) {
+      throw Error("[vidstack] google cast player was not initialized");
+    }
+    return new (await import('./vidstack-DAPCj1_J.js')).GoogleCastProvider(this.#player, ctx);
+  }
+  async #loadCastFramework(ctx) {
+    if (hasLoadedCastFramework()) return;
+    const loadStartEvent = ctx.player.createEvent("google-cast-load-start");
+    ctx.player.dispatch(loadStartEvent);
+    await loadScript(getCastFrameworkURL());
+    await customElements.whenDefined("google-cast-launcher");
+    const loadedEvent = ctx.player.createEvent("google-cast-loaded", { trigger: loadStartEvent });
+    ctx.player.dispatch(loadedEvent);
+    if (!isCastAvailable()) {
+      throw this.#createError("CAST_NOT_AVAILABLE", "Google Cast not available on this platform.");
+    }
+    return loadedEvent;
+  }
+  async #showPrompt(options) {
+    this.#setOptions(options);
+    const errorCode = await this.cast.requestSession();
+    if (errorCode) {
+      throw this.#createError(
+        errorCode.toUpperCase(),
+        getCastErrorMessage(errorCode)
+      );
+    }
+  }
+  #setOptions(options) {
+    this.cast?.setOptions({
+      ...getDefaultCastOptions(),
+      ...options
+    });
+  }
+  #notifyRemoteStateChange(ctx, state, trigger) {
+    const detail = { type: "google-cast", state };
+    ctx.notify("remote-playback-change", detail, trigger);
+  }
+  #createError(code, message) {
+    const error = Error(message);
+    error.code = code;
+    return error;
+  }
+}
+
+var loader = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  GoogleCastLoader: GoogleCastLoader
+});
+
+export { getCastContext, getCastErrorMessage, getCastSession, getCastSessionMedia, hasActiveCastSession, listenCastContextEvent, loader };
diff --git a/dev/chunks/vidstack-Db_TLB3K.js b/dev/chunks/vidstack-Db_TLB3K.js
new file mode 100644
index 0000000000000000000000000000000000000000..cfb2e0a18827ff03c5f71d3958bc8878888f7261
--- /dev/null
+++ b/dev/chunks/vidstack-Db_TLB3K.js
@@ -0,0 +1,643 @@
+"use client"
+
+import * as React from 'react';
+import { createDisposalBin, listenEvent, isNumber, isUndefined, isNull, isNil, createScope, signal, peek, effect, tick, isFunction, useSignal, deferredPromise } from './vidstack-CH225ns1.js';
+import { Composition, Internals } from 'remotion';
+import { RemotionLayoutEngine, REMOTION_PROVIDER_ID, RemotionContextProvider, ErrorBoundary } from '../player/vidstack-remotion.js';
+import { isRemotionSrc, TimeRange } from './vidstack-DlEFWAGb.js';
+import { NoReactInternals } from 'remotion/no-react';
+import './vidstack-CaBvbWDV.js';
+import '@floating-ui/dom';
+
+class RemotionPlaybackEngine {
+  #src;
+  #onFrameChange;
+  #onEnd;
+  #disposal = createDisposalBin();
+  #frame = 0;
+  #framesAdvanced = 0;
+  #playbackRate = 1;
+  #playing = false;
+  #rafId = -1;
+  #timerId = -1;
+  #startedAt = 0;
+  #isRunningInBackground = false;
+  get frame() {
+    return this.#frame;
+  }
+  set frame(frame) {
+    this.#frame = frame;
+    this.#onFrameChange(frame);
+  }
+  constructor(src, onFrameChange, onEnd) {
+    this.#src = src;
+    this.#onFrameChange = onFrameChange;
+    this.#onEnd = onEnd;
+    this.#frame = src.initialFrame ?? 0;
+    this.#disposal.add(
+      listenEvent(document, "visibilitychange", this.#onVisibilityChange.bind(this))
+    );
+  }
+  play() {
+    this.#framesAdvanced = 0;
+    this.#playing = true;
+    this.#startedAt = performance.now();
+    this.#tick();
+  }
+  stop() {
+    this.#playing = false;
+    if (this.#rafId >= 0) {
+      cancelAnimationFrame(this.#rafId);
+      this.#rafId = -1;
+    }
+    if (this.#timerId >= 0) {
+      clearTimeout(this.#timerId);
+      this.#timerId = -1;
+    }
+  }
+  setPlaybackRate(rate) {
+    this.#playbackRate = rate;
+  }
+  destroy() {
+    this.#disposal.empty();
+    this.stop();
+  }
+  #update() {
+    const { nextFrame, framesToAdvance, ended } = this.#calculateNextFrame();
+    this.#framesAdvanced += framesToAdvance;
+    if (nextFrame !== this.#frame) {
+      this.#onFrameChange(nextFrame);
+      this.#frame = nextFrame;
+    }
+    if (ended) {
+      this.#frame = this.#src.outFrame;
+      this.stop();
+      this.#onEnd();
+    }
+  }
+  #tick = () => {
+    this.#update();
+    if (this.#playing) {
+      this.#queueNextFrame(this.#tick);
+    }
+  };
+  #queueNextFrame(callback) {
+    if (this.#isRunningInBackground) {
+      this.#timerId = window.setTimeout(callback, 1e3 / this.#src.fps);
+    } else {
+      this.#rafId = requestAnimationFrame(callback);
+    }
+  }
+  #calculateNextFrame() {
+    const round = this.#playbackRate < 0 ? Math.ceil : Math.floor, time = performance.now() - this.#startedAt, framesToAdvance = round(time * this.#playbackRate / (1e3 / this.#src.fps)) - this.#framesAdvanced, nextFrame = framesToAdvance + this.#frame, isCurrentFrameOutOfBounds = this.#frame > this.#src.outFrame || this.#frame < this.#src.inFrame, isNextFrameOutOfBounds = nextFrame > this.#src.outFrame || nextFrame < this.#src.inFrame, ended = isNextFrameOutOfBounds && !isCurrentFrameOutOfBounds;
+    if (this.#playbackRate > 0 && !ended) {
+      if (isNextFrameOutOfBounds) {
+        return {
+          nextFrame: this.#src.inFrame,
+          framesToAdvance,
+          ended
+        };
+      }
+      return { nextFrame, framesToAdvance, ended };
+    }
+    if (isNextFrameOutOfBounds) {
+      return {
+        nextFrame: this.#src.outFrame,
+        framesToAdvance,
+        ended
+      };
+    }
+    return { nextFrame, framesToAdvance, ended };
+  }
+  #onVisibilityChange() {
+    this.#isRunningInBackground = document.visibilityState === "hidden";
+    if (this.#playing) {
+      this.stop();
+      this.play();
+    }
+  }
+}
+
+function validateRemotionResource({
+  src,
+  compositionWidth: width,
+  compositionHeight: height,
+  fps,
+  durationInFrames,
+  initialFrame,
+  inFrame,
+  outFrame,
+  numberOfSharedAudioTags
+}) {
+  validateComponent(src);
+  validateInitialFrame(initialFrame, durationInFrames);
+  validateDimension(width, "compositionWidth", "of the remotion source");
+  validateDimension(height, "compositionHeight", "of the remotion source");
+  validateDurationInFrames(durationInFrames, {
+    component: "of the remotion source",
+    allowFloats: false
+  });
+  validateFps(fps, "of the remotion source", false);
+  validateInOutFrames(inFrame, outFrame, durationInFrames);
+  validateSharedNumberOfAudioTags(numberOfSharedAudioTags);
+}
+const validateFps = NoReactInternals.validateFps;
+const validateDimension = NoReactInternals.validateDimension;
+const validateDurationInFrames = NoReactInternals.validateDurationInFrames;
+function validateInitialFrame(initialFrame, frames) {
+  if (!isNumber(frames)) {
+    throw new Error(
+      `[vidstack] \`durationInFrames\` must be a number, but is ${JSON.stringify(frames)}`
+    );
+  }
+  if (isUndefined(initialFrame)) {
+    return;
+  }
+  if (!isNumber(initialFrame)) {
+    throw new Error(
+      `[vidstack] \`initialFrame\` must be a number, but is ${JSON.stringify(initialFrame)}`
+    );
+  }
+  if (Number.isNaN(initialFrame)) {
+    throw new Error(`[vidstack] \`initialFrame\` must be a number, but is NaN`);
+  }
+  if (!Number.isFinite(initialFrame)) {
+    throw new Error(`[vidstack] \`initialFrame\` must be a number, but is Infinity`);
+  }
+  if (initialFrame % 1 !== 0) {
+    throw new Error(
+      `[vidstack] \`initialFrame\` must be an integer, but is ${JSON.stringify(initialFrame)}`
+    );
+  }
+  if (initialFrame > frames - 1) {
+    throw new Error(
+      `[vidstack] \`initialFrame\` must be less or equal than \`durationInFrames - 1\`, but is ${JSON.stringify(
+        initialFrame
+      )}`
+    );
+  }
+}
+function validateSingleFrame(frame, variableName) {
+  if (isNil(frame)) {
+    return frame ?? null;
+  }
+  if (!isNumber(frame)) {
+    throw new TypeError(
+      `[vidstack] \`${variableName}\` must be a number, but is ${JSON.stringify(frame)}`
+    );
+  }
+  if (Number.isNaN(frame)) {
+    throw new TypeError(
+      `[vidstack] \`${variableName}\` must not be NaN, but is ${JSON.stringify(frame)}`
+    );
+  }
+  if (!Number.isFinite(frame)) {
+    throw new TypeError(
+      `[vidstack] \`${variableName}\` must be finite, but is ${JSON.stringify(frame)}`
+    );
+  }
+  if (frame % 1 !== 0) {
+    throw new TypeError(
+      `[vidstack] \`${variableName}\` must be an integer, but is ${JSON.stringify(frame)}`
+    );
+  }
+  return frame;
+}
+function validateInOutFrames(inFrame, outFrame, frames) {
+  const validatedInFrame = validateSingleFrame(inFrame, "inFrame"), validatedOutFrame = validateSingleFrame(outFrame, "outFrame");
+  if (isNull(validatedInFrame) && isNull(validatedOutFrame)) {
+    return;
+  }
+  if (!isNull(validatedInFrame) && validatedInFrame > frames - 1) {
+    throw new Error(
+      `[vidstack] \`inFrame\` must be less than (durationInFrames - 1), but is \`${validatedInFrame}\``
+    );
+  }
+  if (!isNull(validatedOutFrame) && validatedOutFrame > frames) {
+    throw new Error(
+      `[vidstack] \`outFrame\` must be less than (durationInFrames), but is \`${validatedOutFrame}\``
+    );
+  }
+  if (!isNull(validatedInFrame) && validatedInFrame < 0) {
+    throw new Error(
+      `[vidstack] \`inFrame\` must be greater than 0, but is \`${validatedInFrame}\``
+    );
+  }
+  if (!isNull(validatedOutFrame) && validatedOutFrame <= 0) {
+    throw new Error(
+      `[vidstack] \`outFrame\` must be greater than 0, but is \`${validatedOutFrame}\`. If you want to render a single frame, use \`<RemotionThumbnail />\` instead.`
+    );
+  }
+  if (!isNull(validatedOutFrame) && !isNull(validatedInFrame) && validatedOutFrame <= validatedInFrame) {
+    throw new Error(
+      "[vidstack] `outFrame` must be greater than `inFrame`, but is " + validatedOutFrame + " <= " + validatedInFrame
+    );
+  }
+}
+function validateSharedNumberOfAudioTags(tags) {
+  if (isUndefined(tags)) return;
+  if (tags % 1 !== 0 || !Number.isFinite(tags) || Number.isNaN(tags) || tags < 0) {
+    throw new TypeError(
+      `[vidstack] \`numberOfSharedAudioTags\` must be an integer but got \`${tags}\` instead`
+    );
+  }
+}
+function validatePlaybackRate(playbackRate) {
+  if (playbackRate > 4) {
+    throw new Error(
+      `[vidstack] The highest possible playback rate with Remotion is 4. You passed: ${playbackRate}`
+    );
+  }
+  if (playbackRate < -4) {
+    throw new Error(
+      `[vidstack] The lowest possible playback rate with Remotion is -4. You passed: ${playbackRate}`
+    );
+  }
+  if (playbackRate === 0) {
+    throw new Error(`[vidstack] A playback rate of 0 is not supported.`);
+  }
+}
+function validateComponent(src) {
+  if (src.type === Composition) {
+    throw new TypeError(
+      `[vidstack] \`src\` should not be an instance of \`<Composition/>\`. Pass the React component directly, and set the duration, fps and dimensions as source props.`
+    );
+  }
+  if (src === Composition) {
+    throw new TypeError(
+      `[vidstack] \`src\` must not be the \`Composition\` component. Pass your own React component directly, and set the duration, fps and dimensions as source props.`
+    );
+  }
+}
+
+class RemotionProvider {
+  $$PROVIDER_TYPE = "REMOTION";
+  scope = createScope();
+  #src = signal(null);
+  #setup = false;
+  #loadStart = false;
+  #audio = null;
+  #waiting = signal(false);
+  #waitingPromise = null;
+  #mediaTags = signal([]);
+  #mediaElements = signal([]);
+  #bufferingElements = /* @__PURE__ */ new Set();
+  #timeline = null;
+  #frame = signal({ [REMOTION_PROVIDER_ID]: 0 });
+  #layoutEngine = new RemotionLayoutEngine();
+  #playbackEngine = null;
+  #container;
+  #ctx;
+  #setTimeline;
+  #setMediaVolume = {
+    setMediaMuted: this.setMuted.bind(this),
+    setMediaVolume: this.setVolume.bind(this)
+  };
+  get type() {
+    return "remotion";
+  }
+  get currentSrc() {
+    return peek(this.#src);
+  }
+  get frame() {
+    return this.#frame();
+  }
+  constructor(container, ctx) {
+    this.#container = container;
+    this.#ctx = ctx;
+    this.#setTimeline = {
+      setFrame: this.#setFrame.bind(this),
+      setPlaying: this.#setPlaying.bind(this)
+    };
+    this.#layoutEngine.setContainer(container);
+  }
+  setup() {
+    effect(this.#watchWaiting.bind(this));
+    effect(this.#watchMediaTags.bind(this));
+    effect(this.#watchMediaElements.bind(this));
+  }
+  #watchMediaTags() {
+    this.#mediaTags();
+    this.#discoverMediaElements();
+  }
+  #discoverMediaElements() {
+    const elements = [...this.#container.querySelectorAll("audio,video")];
+    this.#mediaElements.set(elements);
+  }
+  #watchMediaElements() {
+    const elements = this.#mediaElements();
+    for (const tag of elements) {
+      const onWait = this.#onWaitFor.bind(this, tag), onStopWaiting = this.#onStopWaitingFor.bind(this, tag);
+      if (tag.currentSrc && tag.readyState < 4) {
+        this.#onWaitFor(tag);
+        listenEvent(tag, "canplay", onStopWaiting);
+      }
+      listenEvent(tag, "waiting", onWait);
+      listenEvent(tag, "playing", onStopWaiting);
+    }
+    for (const el of this.#bufferingElements) {
+      if (!elements.includes(el)) this.#onStopWaitingFor(el);
+    }
+  }
+  #onFrameChange(frame) {
+    const { inFrame, fps } = this.#src(), { seeking } = this.#ctx.$state, time = Math.max(0, frame - inFrame) / fps;
+    this.#frame.set((record) => ({
+      ...record,
+      [REMOTION_PROVIDER_ID]: frame
+    }));
+    this.#ctx.notify("time-change", time);
+    if (seeking()) {
+      tick();
+      this.#ctx.notify("seeked", time);
+    }
+  }
+  #onFrameEnd() {
+    this.pause();
+    this.#ctx.notify("end");
+  }
+  async play() {
+    const { ended } = this.#ctx.$state;
+    if (peek(ended)) {
+      this.#setFrame({ [REMOTION_PROVIDER_ID]: 0 });
+    }
+    try {
+      const mediaElements = peek(this.#mediaElements);
+      if (mediaElements.length) {
+        await Promise.all(mediaElements.map((media) => media.play()));
+      }
+      this.#ctx.notify("play");
+      tick();
+      if (this.#waitingPromise) {
+        this.#ctx.notify("waiting");
+        return this.#waitingPromise.promise;
+      } else {
+        this.#playbackEngine?.play();
+        this.#ctx.notify("playing");
+      }
+    } catch (error) {
+      throw error;
+    }
+  }
+  async pause() {
+    this.#ctx.$state;
+    this.#playbackEngine?.stop();
+    this.#ctx.notify("pause");
+  }
+  setMuted(value) {
+    if (!this.#ctx) return;
+    const { muted, volume } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.setMuted(value(muted()));
+      return;
+    }
+    this.#ctx.notify("volume-change", {
+      volume: peek(volume),
+      muted: value
+    });
+  }
+  setCurrentTime(time) {
+    const { fps } = this.#src(), frame = time * fps;
+    this.#ctx.notify("seeking", time);
+    this.#setFrame({ [REMOTION_PROVIDER_ID]: frame });
+  }
+  setVolume(value) {
+    if (!this.#ctx) return;
+    const { volume, muted } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.setVolume(value(volume()));
+      return;
+    }
+    this.#ctx.notify("volume-change", {
+      volume: value,
+      muted: peek(muted)
+    });
+  }
+  setPlaybackRate(rate) {
+    if (isFunction(rate)) {
+      const { playbackRate } = this.#ctx.$state;
+      this.setPlaybackRate(rate(peek(playbackRate)));
+      return;
+    }
+    validatePlaybackRate(rate);
+    this.#playbackEngine?.setPlaybackRate(rate);
+    this.#ctx.notify("rate-change", rate);
+  }
+  async loadSource(src) {
+    if (!isRemotionSrc(src)) return;
+    const onUserError = src.onError, resolvedSrc = {
+      compositionWidth: 1920,
+      compositionHeight: 1080,
+      fps: 30,
+      initialFrame: 0,
+      inFrame: 0,
+      outFrame: src.durationInFrames,
+      numberOfSharedAudioTags: 5,
+      inputProps: {},
+      ...src,
+      onError: (error) => {
+        {
+          this.#ctx.logger?.errorGroup(`[vidstack] ${error.message}`).labelledLog("Source", peek(this.#src)).labelledLog("Error", error).dispatch();
+        }
+        this.pause();
+        this.#ctx.notify("error", {
+          message: error.message,
+          code: 1
+        });
+        onUserError?.(error);
+      }
+    };
+    this.#src.set(resolvedSrc);
+    for (const prop of Object.keys(resolvedSrc)) {
+      src[prop] = resolvedSrc[prop];
+    }
+    this.changeSrc(resolvedSrc);
+  }
+  destroy() {
+    this.changeSrc(null);
+  }
+  changeSrc(src) {
+    this.#playbackEngine?.destroy();
+    this.#waiting.set(false);
+    this.#waitingPromise?.reject("src changed");
+    this.#waitingPromise = null;
+    this.#audio = null;
+    this.#timeline = null;
+    this.#playbackEngine = null;
+    this.#mediaTags.set([]);
+    this.#bufferingElements.clear();
+    this.#frame.set({ [REMOTION_PROVIDER_ID]: 0 });
+    this.#layoutEngine.setSrc(src);
+    if (src) {
+      this.#timeline = this.#createTimelineContextValue();
+      this.#playbackEngine = new RemotionPlaybackEngine(
+        src,
+        this.#onFrameChange.bind(this),
+        this.#onFrameEnd.bind(this)
+      );
+    }
+  }
+  render = () => {
+    const $src = useSignal(this.#src);
+    if (!$src) {
+      throw Error(
+        "[vidstack] attempting to render remotion provider without src" 
+      );
+    }
+    React.useEffect(() => {
+      if (!isRemotionSrc($src)) return;
+      validateRemotionResource($src);
+      const rafId = requestAnimationFrame(() => {
+        if (!this.#setup) {
+          this.#ctx.notify("provider-setup", this);
+          this.#setup = true;
+        }
+        if (!this.#loadStart) {
+          this.#ctx.notify("load-start");
+          this.#loadStart = true;
+        }
+        this.#discoverMediaElements();
+        tick();
+        if (!this.#waiting()) this.#ready($src);
+      });
+      return () => {
+        cancelAnimationFrame(rafId);
+        this.#loadStart = false;
+      };
+    }, [$src]);
+    const Component = Internals.useLazyComponent({
+      component: $src.src
+    });
+    const { $state } = this.#ctx, $volume = useSignal($state.volume), $isMuted = useSignal($state.muted);
+    const mediaVolume = React.useMemo(() => {
+      const { muted, volume } = this.#ctx.$state;
+      return { mediaMuted: muted(), mediaVolume: volume() };
+    }, [$isMuted, $volume]);
+    return /* @__PURE__ */ React.createElement(
+      RemotionContextProvider,
+      {
+        src: $src,
+        component: Component,
+        timeline: this.#timeline,
+        mediaVolume,
+        setMediaVolume: this.#setMediaVolume
+      },
+      /* @__PURE__ */ React.createElement(Internals.Timeline.SetTimelineContext.Provider, { value: this.#setTimeline }, React.createElement(this.renderVideo, { src: $src }))
+    );
+  };
+  renderVideo = ({ src }) => {
+    const video = Internals.useVideo(), Video = video ? video.component : null, audioContext = React.useContext(Internals.SharedAudioContext);
+    const { $state } = this.#ctx;
+    useSignal(this.#frame);
+    useSignal($state.playing);
+    useSignal($state.playbackRate);
+    React.useEffect(() => {
+      this.#audio = audioContext;
+      return () => {
+        this.#audio = null;
+      };
+    }, [audioContext]);
+    const LoadingContent = React.useMemo(() => src.renderLoading?.(), [src]);
+    const Content = Video ? /* @__PURE__ */ React.createElement(ErrorBoundary, { fallback: src.errorFallback, onError: src.onError }, /* @__PURE__ */ React.createElement(Internals.ClipComposition, null, /* @__PURE__ */ React.createElement(Video, { ...video?.props, ...src.inputProps }))) : null;
+    return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: LoadingContent }, Content);
+  };
+  #ready(src) {
+    if (!src) return;
+    const { outFrame, inFrame, fps } = src, duration = (outFrame - inFrame) / fps;
+    this.#ctx.notify("loaded-metadata");
+    this.#ctx.notify("loaded-data");
+    this.#ctx.delegate.ready({
+      duration,
+      seekable: new TimeRange(0, duration),
+      buffered: new TimeRange(0, duration)
+    });
+    if (src.initialFrame) {
+      this.#setFrame({
+        [REMOTION_PROVIDER_ID]: src.initialFrame
+      });
+    }
+  }
+  #onWaitFor(el) {
+    this.#bufferingElements.add(el);
+    this.#waiting.set(true);
+    if (!this.#waitingPromise) {
+      this.#waitingPromise = deferredPromise();
+    }
+  }
+  #onStopWaitingFor(el) {
+    this.#bufferingElements.delete(el);
+    if (this.#bufferingElements.size) return;
+    this.#waiting.set(false);
+    this.#waitingPromise?.resolve();
+    this.#waitingPromise = null;
+    const { canPlay } = this.#ctx.$state;
+    if (!peek(canPlay)) {
+      this.#ready(peek(this.#src));
+    }
+  }
+  #watchWaiting() {
+    this.#waiting();
+    const { paused } = this.#ctx.$state;
+    if (peek(paused)) return;
+    if (this.#waiting()) {
+      this.#playbackEngine?.stop();
+      this.#ctx.notify("waiting");
+    } else {
+      this.#playbackEngine?.play();
+      this.#ctx.notify("playing");
+    }
+  }
+  #setFrame(value) {
+    if (isFunction(value)) {
+      this.#setFrame(value(this.#frame()));
+      return;
+    }
+    this.#frame.set((record) => ({ ...record, ...value }));
+    const nextFrame = value[REMOTION_PROVIDER_ID];
+    if (this.#playbackEngine && this.#playbackEngine.frame !== nextFrame) {
+      this.#playbackEngine.frame = nextFrame;
+    }
+  }
+  #setPlaying(value) {
+    const { playing } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.#setPlaying(value(playing()));
+      return;
+    }
+    if (value) {
+      this.play();
+    } else if (!value) {
+      this.pause();
+    }
+  }
+  #createTimelineContextValue() {
+    const { playing, playbackRate } = this.#ctx.$state, frame = this.#frame, mediaTags = this.#mediaTags, setPlaybackRate = this.setPlaybackRate.bind(this);
+    return {
+      rootId: REMOTION_PROVIDER_ID,
+      get frame() {
+        return frame();
+      },
+      get playing() {
+        return playing();
+      },
+      get playbackRate() {
+        return playbackRate();
+      },
+      imperativePlaying: {
+        get current() {
+          return playing();
+        }
+      },
+      setPlaybackRate,
+      audioAndVideoTags: {
+        get current() {
+          return mediaTags();
+        },
+        set current(tags) {
+          mediaTags.set(tags);
+        }
+      }
+    };
+  }
+}
+
+export { RemotionProvider };
diff --git a/dev/chunks/vidstack-Di-ZivLP.js b/dev/chunks/vidstack-Di-ZivLP.js
new file mode 100644
index 0000000000000000000000000000000000000000..52b719d86836b87bf6785c2991c31a01bd5184dd
--- /dev/null
+++ b/dev/chunks/vidstack-Di-ZivLP.js
@@ -0,0 +1,84 @@
+"use client"
+
+import * as React from 'react';
+import { animationFrameThrottle, EventsController, listenEvent, effect } from './vidstack-CH225ns1.js';
+import { useMediaPlayer } from './vidstack-VrioNQ8t.js';
+
+function useClassName(el, className) {
+  React.useEffect(() => {
+    if (!el || !className) return;
+    const tokens = className.split(" ");
+    for (const token of tokens) el.classList.add(token);
+    return () => {
+      for (const token of tokens) el.classList.remove(token);
+    };
+  }, [el, className]);
+}
+function useResizeObserver(el, callback) {
+  React.useEffect(() => {
+    if (!el) return;
+    callback();
+    const observer = new ResizeObserver(animationFrameThrottle(callback));
+    observer.observe(el);
+    return () => observer.disconnect();
+  }, [el, callback]);
+}
+function useTransitionActive(el) {
+  const [isActive, setIsActive] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("transitionstart", () => setIsActive(true)).add("transitionend", () => setIsActive(false));
+    return () => events.abort();
+  }, [el]);
+  return isActive;
+}
+function useMouseEnter(el) {
+  const [isMouseEnter, setIsMouseEnter] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("mouseenter", () => setIsMouseEnter(true)).add("mouseleave", () => setIsMouseEnter(false));
+    return () => events.abort();
+  }, [el]);
+  return isMouseEnter;
+}
+function useFocusIn(el) {
+  const [isFocusIn, setIsFocusIn] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("focusin", () => setIsFocusIn(true)).add("focusout", () => setIsFocusIn(false));
+    return () => events.abort();
+  }, [el]);
+  return isFocusIn;
+}
+function useActive(el) {
+  const isMouseEnter = useMouseEnter(el), isFocusIn = useFocusIn(el), prevMouseEnter = React.useRef(false);
+  if (prevMouseEnter.current && !isMouseEnter) return false;
+  prevMouseEnter.current = isMouseEnter;
+  return isMouseEnter || isFocusIn;
+}
+function useColorSchemePreference() {
+  const [colorScheme, setColorScheme] = React.useState("dark");
+  React.useEffect(() => {
+    const media = window.matchMedia("(prefers-color-scheme: light)");
+    function onChange() {
+      setColorScheme(media.matches ? "light" : "dark");
+    }
+    onChange();
+    return listenEvent(media, "change", onChange);
+  }, []);
+  return colorScheme;
+}
+
+function useLayoutName(name) {
+  const player = useMediaPlayer();
+  React.useEffect(() => {
+    if (!player) return;
+    return effect(() => {
+      const el = player.$el;
+      el?.setAttribute("data-layout", name);
+      return () => el?.removeAttribute("data-layout");
+    });
+  }, [player]);
+}
+
+export { useActive, useClassName, useColorSchemePreference, useLayoutName, useResizeObserver, useTransitionActive };
diff --git a/dev/chunks/vidstack-DlEFWAGb.js b/dev/chunks/vidstack-DlEFWAGb.js
new file mode 100644
index 0000000000000000000000000000000000000000..ff8d3a5548e4f36144f441e24b56e37ebcee6b54
--- /dev/null
+++ b/dev/chunks/vidstack-DlEFWAGb.js
@@ -0,0 +1,11675 @@
+"use client"
+
+import * as React from 'react';
+import { isString, isNumber, isFunction, isUndefined, waitTimeout, isArray, isBoolean, isNull, deferredPromise, listenEvent, scoped, getScope, EventsTarget, DOMEvent, State, fscreen, tick, createContext, useContext, Component, functionThrottle, setAttribute, effect, isTouchEvent, isDOMNode, EventsController, isKeyboardClick, setStyle, onDispose, untrack, functionDebounce, ViewController, signal, peek, isKeyboardEvent, isNil, createScope, camelToKebabCase, waitIdlePeriod, prop, method, provideContext, animationFrameThrottle, uppercaseFirstChar, computed, noop, ariaBool as ariaBool$1, isWriteSignal, hasProvidedContext, isObject, useState, r, wasEnterKeyPressed, isPointerEvent, isMouseEvent, kebabToCamelCase, composeRefs, useStateContext, useSignal, useSignalRecord } from './vidstack-CH225ns1.js';
+import { autoUpdate, computePosition, flip, shift } from '@floating-ui/dom';
+
+function isVideoQualitySrc(src) {
+  return !isString(src) && "width" in src && "height" in src && isNumber(src.width) && isNumber(src.height);
+}
+
+const IS_SERVER = typeof document === "undefined";
+
+const UA = IS_SERVER ? "" : navigator?.userAgent.toLowerCase() || "";
+const IS_IOS = !IS_SERVER && /iphone|ipad|ipod|ios|crios|fxios/i.test(UA);
+const IS_IPHONE = !IS_SERVER && /(iphone|ipod)/gi.test(navigator?.platform || "");
+const IS_CHROME = !IS_SERVER && !!window.chrome;
+const IS_SAFARI = !IS_SERVER && (!!window.safari || IS_IOS);
+function canOrientScreen() {
+  return canRotateScreen() && isFunction(screen.orientation.unlock);
+}
+function canRotateScreen() {
+  return !IS_SERVER && !isUndefined(window.screen.orientation) && !isUndefined(window.screen.orientation.lock);
+}
+function canPlayAudioType(audio, type) {
+  if (IS_SERVER) return false;
+  if (!audio) audio = document.createElement("audio");
+  return audio.canPlayType(type).length > 0;
+}
+function canPlayVideoType(video, type) {
+  if (IS_SERVER) return false;
+  if (!video) video = document.createElement("video");
+  return video.canPlayType(type).length > 0;
+}
+function canPlayHLSNatively(video) {
+  if (IS_SERVER) return false;
+  if (!video) video = document.createElement("video");
+  return video.canPlayType("application/vnd.apple.mpegurl").length > 0;
+}
+function canUsePictureInPicture(video) {
+  if (IS_SERVER) return false;
+  return !!document.pictureInPictureEnabled && !video?.disablePictureInPicture;
+}
+function canUseVideoPresentation(video) {
+  if (IS_SERVER) return false;
+  return isFunction(video?.webkitSupportsPresentationMode) && isFunction(video?.webkitSetPresentationMode);
+}
+async function canChangeVolume() {
+  const video = document.createElement("video");
+  video.volume = 0.5;
+  await waitTimeout(0);
+  return video.volume === 0.5;
+}
+function getMediaSource() {
+  return IS_SERVER ? void 0 : window?.ManagedMediaSource ?? window?.MediaSource ?? window?.WebKitMediaSource;
+}
+function getSourceBuffer() {
+  return IS_SERVER ? void 0 : window?.SourceBuffer ?? window?.WebKitSourceBuffer;
+}
+function isHLSSupported() {
+  if (IS_SERVER) return false;
+  const MediaSource = getMediaSource();
+  if (isUndefined(MediaSource)) return false;
+  const isTypeSupported = MediaSource && isFunction(MediaSource.isTypeSupported) && MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
+  const SourceBuffer = getSourceBuffer();
+  const isSourceBufferValid = isUndefined(SourceBuffer) || !isUndefined(SourceBuffer.prototype) && isFunction(SourceBuffer.prototype.appendBuffer) && isFunction(SourceBuffer.prototype.remove);
+  return !!isTypeSupported && !!isSourceBufferValid;
+}
+function isDASHSupported() {
+  return isHLSSupported();
+}
+
+class TimeRange {
+  #ranges;
+  get length() {
+    return this.#ranges.length;
+  }
+  constructor(start, end) {
+    if (isArray(start)) {
+      this.#ranges = start;
+    } else if (!isUndefined(start) && !isUndefined(end)) {
+      this.#ranges = [[start, end]];
+    } else {
+      this.#ranges = [];
+    }
+  }
+  start(index) {
+    throwIfEmpty(this.#ranges.length);
+    throwIfOutOfRange("start", index, this.#ranges.length - 1);
+    return this.#ranges[index][0] ?? Infinity;
+  }
+  end(index) {
+    throwIfEmpty(this.#ranges.length);
+    throwIfOutOfRange("end", index, this.#ranges.length - 1);
+    return this.#ranges[index][1] ?? Infinity;
+  }
+}
+function getTimeRangesStart(range) {
+  if (!range.length) return null;
+  let min = range.start(0);
+  for (let i = 1; i < range.length; i++) {
+    const value = range.start(i);
+    if (value < min) min = value;
+  }
+  return min;
+}
+function getTimeRangesEnd(range) {
+  if (!range.length) return null;
+  let max = range.end(0);
+  for (let i = 1; i < range.length; i++) {
+    const value = range.end(i);
+    if (value > max) max = value;
+  }
+  return max;
+}
+function throwIfEmpty(length) {
+  if (!length) throw new Error("`TimeRanges` object is empty." );
+}
+function throwIfOutOfRange(fnName, index, end) {
+  if (!isNumber(index) || index < 0 || index > end) {
+    throw new Error(
+      `Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${end}).`
+    );
+  }
+}
+function normalizeTimeIntervals(intervals) {
+  if (intervals.length <= 1) {
+    return intervals;
+  }
+  intervals.sort((a, b) => a[0] - b[0]);
+  let normalized = [], current = intervals[0];
+  for (let i = 1; i < intervals.length; i++) {
+    const next = intervals[i];
+    if (current[1] >= next[0] - 1) {
+      current = [current[0], Math.max(current[1], next[1])];
+    } else {
+      normalized.push(current);
+      current = next;
+    }
+  }
+  normalized.push(current);
+  return normalized;
+}
+function updateTimeIntervals(intervals, interval, value) {
+  let start = interval[0], end = interval[1];
+  if (value < start) {
+    return [value, -1];
+  } else if (value === start) {
+    return interval;
+  } else if (start === -1) {
+    interval[0] = value;
+    return interval;
+  } else if (value > start) {
+    interval[1] = value;
+    if (end === -1) intervals.push(interval);
+  }
+  normalizeTimeIntervals(intervals);
+  return interval;
+}
+
+const AUDIO_EXTENSIONS = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx|flac)($|\?)/i;
+const AUDIO_TYPES = /* @__PURE__ */ new Set([
+  "audio/mpeg",
+  "audio/ogg",
+  "audio/3gp",
+  "audio/mp3",
+  "audio/webm",
+  "audio/flac",
+  "audio/m4a",
+  "audio/m4b",
+  "audio/mp4a",
+  "audio/mp4"
+]);
+const VIDEO_EXTENSIONS = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i;
+const VIDEO_TYPES = /* @__PURE__ */ new Set([
+  "video/mp4",
+  "video/webm",
+  "video/3gp",
+  "video/ogg",
+  "video/avi",
+  "video/mpeg"
+]);
+const HLS_VIDEO_EXTENSIONS = /\.(m3u8)($|\?)/i;
+const DASH_VIDEO_EXTENSIONS = /\.(mpd)($|\?)/i;
+const HLS_VIDEO_TYPES = /* @__PURE__ */ new Set([
+  // Apple sanctioned
+  "application/vnd.apple.mpegurl",
+  // Apple sanctioned for backwards compatibility
+  "audio/mpegurl",
+  // Very common
+  "audio/x-mpegurl",
+  // Very common
+  "application/x-mpegurl",
+  // Included for completeness
+  "video/x-mpegurl",
+  "video/mpegurl",
+  "application/mpegurl"
+]);
+const DASH_VIDEO_TYPES = /* @__PURE__ */ new Set(["application/dash+xml"]);
+function isAudioSrc({ src, type }) {
+  return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
+}
+function isVideoSrc(src) {
+  return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && (IS_SERVER || canPlayHLSNatively()) : src.type === "video/object";
+}
+function isHLSSrc({ src, type }) {
+  return isString(src) && HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type);
+}
+function isDASHSrc({ src, type }) {
+  return isString(src) && DASH_VIDEO_EXTENSIONS.test(src) || DASH_VIDEO_TYPES.has(type);
+}
+function canGoogleCastSrc(src) {
+  return isString(src.src) && (isAudioSrc(src) || isVideoSrc(src) || isHLSSrc(src));
+}
+function isMediaStream(src) {
+  return !IS_SERVER && typeof window.MediaStream !== "undefined" && src instanceof window.MediaStream;
+}
+
+function appendParamsToURL(baseUrl, params) {
+  const url = new URL(baseUrl);
+  for (const key of Object.keys(params)) {
+    url.searchParams.set(key, params[key] + "");
+  }
+  return url.toString();
+}
+function preconnect(url, rel = "preconnect") {
+  if (IS_SERVER) return false;
+  const exists = document.querySelector(`link[href="${url}"]`);
+  if (!isNull(exists)) return true;
+  const link = document.createElement("link");
+  link.rel = rel;
+  link.href = url;
+  link.crossOrigin = "true";
+  document.head.append(link);
+  return true;
+}
+const pendingRequests = {};
+function loadScript(src) {
+  if (pendingRequests[src]) return pendingRequests[src].promise;
+  const promise = deferredPromise(), exists = document.querySelector(`script[src="${src}"]`);
+  if (!isNull(exists)) {
+    promise.resolve();
+    return promise.promise;
+  }
+  pendingRequests[src] = promise;
+  const script = document.createElement("script");
+  script.src = src;
+  script.onload = () => {
+    promise.resolve();
+    delete pendingRequests[src];
+  };
+  script.onerror = () => {
+    promise.reject();
+    delete pendingRequests[src];
+  };
+  setTimeout(() => document.head.append(script), 0);
+  return promise.promise;
+}
+function getRequestCredentials(crossOrigin) {
+  return crossOrigin === "use-credentials" ? "include" : isString(crossOrigin) ? "same-origin" : void 0;
+}
+function getDownloadFile({
+  title,
+  src,
+  download
+}) {
+  const url = isBoolean(download) || download === "" ? src.src : isString(download) ? download : download?.url;
+  if (!isValidFileDownload({ url, src, download })) return null;
+  return {
+    url,
+    name: !isBoolean(download) && !isString(download) && download?.filename || title.toLowerCase() || "media"
+  };
+}
+function isValidFileDownload({
+  url,
+  src,
+  download
+}) {
+  return isString(url) && (download && download !== true || isAudioSrc(src) || isVideoSrc(src));
+}
+
+const CROSS_ORIGIN = Symbol("TEXT_TRACK_CROSS_ORIGIN" ), READY_STATE = Symbol("TEXT_TRACK_READY_STATE" ), UPDATE_ACTIVE_CUES = Symbol("TEXT_TRACK_UPDATE_ACTIVE_CUES" ), CAN_LOAD = Symbol("TEXT_TRACK_CAN_LOAD" ), ON_MODE_CHANGE = Symbol("TEXT_TRACK_ON_MODE_CHANGE" ), NATIVE = Symbol("TEXT_TRACK_NATIVE" ), NATIVE_HLS = Symbol("TEXT_TRACK_NATIVE_HLS" );
+const TextTrackSymbol = {
+  crossOrigin: CROSS_ORIGIN,
+  readyState: READY_STATE,
+  updateActiveCues: UPDATE_ACTIVE_CUES,
+  canLoad: CAN_LOAD,
+  onModeChange: ON_MODE_CHANGE,
+  native: NATIVE,
+  nativeHLS: NATIVE_HLS
+};
+
+function findActiveCue(cues, time) {
+  for (let i = 0, len = cues.length; i < len; i++) {
+    if (isCueActive(cues[i], time)) return cues[i];
+  }
+  return null;
+}
+function isCueActive(cue, time) {
+  return time >= cue.startTime && time < cue.endTime;
+}
+function watchActiveTextTrack(tracks, kind, onChange) {
+  let currentTrack = null, scope = getScope();
+  function onModeChange() {
+    const kinds = isString(kind) ? [kind] : kind, track = tracks.toArray().find((track2) => kinds.includes(track2.kind) && track2.mode === "showing");
+    if (track === currentTrack) return;
+    if (!track) {
+      onChange(null);
+      currentTrack = null;
+      return;
+    }
+    if (track.readyState == 2) {
+      onChange(track);
+    } else {
+      onChange(null);
+      scoped(() => {
+        const off = listenEvent(
+          track,
+          "load",
+          () => {
+            onChange(track);
+            off();
+          },
+          { once: true }
+        );
+      }, scope);
+    }
+    currentTrack = track;
+  }
+  onModeChange();
+  return listenEvent(tracks, "mode-change", onModeChange);
+}
+function watchCueTextChange(tracks, kind, callback) {
+  watchActiveTextTrack(tracks, kind, (track) => {
+    if (!track) {
+      callback("");
+      return;
+    }
+    const onCueChange = () => {
+      const activeCue = track?.activeCues[0];
+      callback(activeCue?.text || "");
+    };
+    onCueChange();
+    listenEvent(track, "cue-change", onCueChange);
+  });
+}
+
+class TextTrack extends EventsTarget {
+  static createId(track) {
+    return `vds-${track.type}-${track.kind}-${track.src ?? track.label ?? "?"}`;
+  }
+  src;
+  content;
+  type;
+  encoding;
+  id = "";
+  label = "";
+  language = "";
+  kind;
+  default = false;
+  #canLoad = false;
+  #currentTime = 0;
+  #mode = "disabled";
+  #metadata = {};
+  #regions = [];
+  #cues = [];
+  #activeCues = [];
+  /** @internal */
+  [TextTrackSymbol.readyState] = 0;
+  /** @internal */
+  [TextTrackSymbol.crossOrigin];
+  /** @internal */
+  [TextTrackSymbol.onModeChange] = null;
+  /** @internal */
+  [TextTrackSymbol.native] = null;
+  get metadata() {
+    return this.#metadata;
+  }
+  get regions() {
+    return this.#regions;
+  }
+  get cues() {
+    return this.#cues;
+  }
+  get activeCues() {
+    return this.#activeCues;
+  }
+  /**
+   * - 0: Not Loading
+   * - 1: Loading
+   * - 2: Ready
+   * - 3: Error
+   */
+  get readyState() {
+    return this[TextTrackSymbol.readyState];
+  }
+  get mode() {
+    return this.#mode;
+  }
+  set mode(mode) {
+    this.setMode(mode);
+  }
+  constructor(init) {
+    super();
+    for (const prop of Object.keys(init)) this[prop] = init[prop];
+    if (!this.type) this.type = "vtt";
+    if (!IS_SERVER && init.content) {
+      this.#parseContent(init);
+    } else if (!init.src) {
+      this[TextTrackSymbol.readyState] = 2;
+    }
+    if (isTrackCaptionKind(this) && !this.label) {
+      console.warn(`[vidstack] captions text track created without label: \`${this.src}\``);
+    }
+  }
+  addCue(cue, trigger) {
+    let i = 0, length = this.#cues.length;
+    for (i = 0; i < length; i++) if (cue.endTime <= this.#cues[i].startTime) break;
+    if (i === length) this.#cues.push(cue);
+    else this.#cues.splice(i, 0, cue);
+    if (!(cue instanceof TextTrackCue)) {
+      this[TextTrackSymbol.native]?.track.addCue(cue);
+    }
+    this.dispatchEvent(new DOMEvent("add-cue", { detail: cue, trigger }));
+    if (isCueActive(cue, this.#currentTime)) {
+      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+    }
+  }
+  removeCue(cue, trigger) {
+    const index = this.#cues.indexOf(cue);
+    if (index >= 0) {
+      const isActive = this.#activeCues.includes(cue);
+      this.#cues.splice(index, 1);
+      this[TextTrackSymbol.native]?.track.removeCue(cue);
+      this.dispatchEvent(new DOMEvent("remove-cue", { detail: cue, trigger }));
+      if (isActive) {
+        this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+      }
+    }
+  }
+  setMode(mode, trigger) {
+    if (this.#mode === mode) return;
+    this.#mode = mode;
+    if (mode === "disabled") {
+      this.#activeCues = [];
+      this.#activeCuesChanged();
+    } else if (this.readyState === 2) {
+      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+    } else {
+      this.#load();
+    }
+    this.dispatchEvent(new DOMEvent("mode-change", { detail: this, trigger }));
+    this[TextTrackSymbol.onModeChange]?.();
+  }
+  /** @internal */
+  [TextTrackSymbol.updateActiveCues](currentTime, trigger) {
+    this.#currentTime = currentTime;
+    if (this.mode === "disabled" || !this.#cues.length) return;
+    const activeCues = [];
+    for (let i = 0, length = this.#cues.length; i < length; i++) {
+      const cue = this.#cues[i];
+      if (isCueActive(cue, currentTime)) activeCues.push(cue);
+    }
+    let changed = activeCues.length !== this.#activeCues.length;
+    if (!changed) {
+      for (let i = 0; i < activeCues.length; i++) {
+        if (!this.#activeCues.includes(activeCues[i])) {
+          changed = true;
+          break;
+        }
+      }
+    }
+    this.#activeCues = activeCues;
+    if (changed) this.#activeCuesChanged(trigger);
+  }
+  /** @internal */
+  [TextTrackSymbol.canLoad]() {
+    this.#canLoad = true;
+    if (this.#mode !== "disabled") this.#load();
+  }
+  #parseContent(init) {
+    import('media-captions').then(({ parseText, VTTCue, VTTRegion }) => {
+      if (!isString(init.content) || init.type === "json") {
+        this.#parseJSON(init.content, VTTCue, VTTRegion);
+        if (this.readyState !== 3) this.#ready();
+      } else {
+        parseText(init.content, { type: init.type }).then(({ cues, regions }) => {
+          this.#cues = cues;
+          this.#regions = regions;
+          this.#ready();
+        });
+      }
+    });
+  }
+  async #load() {
+    if (!this.#canLoad || this[TextTrackSymbol.readyState] > 0) return;
+    this[TextTrackSymbol.readyState] = 1;
+    this.dispatchEvent(new DOMEvent("load-start"));
+    if (!this.src) {
+      this.#ready();
+      return;
+    }
+    try {
+      const { parseResponse, VTTCue, VTTRegion } = await import('media-captions'), crossOrigin = this[TextTrackSymbol.crossOrigin]?.();
+      const response = fetch(this.src, {
+        headers: this.type === "json" ? { "Content-Type": "application/json" } : void 0,
+        credentials: getRequestCredentials(crossOrigin)
+      });
+      if (this.type === "json") {
+        this.#parseJSON(await (await response).text(), VTTCue, VTTRegion);
+      } else if (this.type === "lrc") {
+        this.#parseLRC(await (await response).text(), VTTCue);
+      } else {
+        const { errors, metadata, regions, cues } = await parseResponse(response, {
+          type: this.type,
+          encoding: this.encoding
+        });
+        if (errors[0]?.code === 0) {
+          throw errors[0];
+        } else {
+          this.#metadata = metadata;
+          this.#regions = regions;
+          this.#cues = cues;
+        }
+      }
+      this.#ready();
+    } catch (error) {
+      this.#error(error);
+    }
+  }
+  #ready() {
+    this[TextTrackSymbol.readyState] = 2;
+    if (!this.src || this.type !== "vtt") {
+      const native = this[TextTrackSymbol.native];
+      if (native && !native.managed) {
+        for (const cue of this.#cues) native.track.addCue(cue);
+      }
+    }
+    const loadEvent = new DOMEvent("load");
+    this[TextTrackSymbol.updateActiveCues](this.#currentTime, loadEvent);
+    this.dispatchEvent(loadEvent);
+  }
+  #error(error) {
+    this[TextTrackSymbol.readyState] = 3;
+    this.dispatchEvent(new DOMEvent("error", { detail: error }));
+  }
+  #parseLRC(lrc, VTTCue) {
+    try {
+      const { cues } = parseLRCCaptionsFile(lrc, VTTCue);
+      this.#cues = cues;
+    } catch (error) {
+      {
+        console.error(`[vidstack] failed to parse LRC captions at: \`${this.src}\`
+
+`, error);
+      }
+      this.#error(error);
+    }
+  }
+  #parseJSON(json, VTTCue, VTTRegion) {
+    try {
+      const { regions, cues } = parseJSONCaptionsFile(json, VTTCue, VTTRegion);
+      this.#regions = regions;
+      this.#cues = cues;
+    } catch (error) {
+      {
+        console.error(`[vidstack] failed to parse JSON captions at: \`${this.src}\`
+
+`, error);
+      }
+      this.#error(error);
+    }
+  }
+  #activeCuesChanged(trigger) {
+    this.dispatchEvent(new DOMEvent("cue-change", { trigger }));
+  }
+}
+const captionRE = /captions|subtitles/;
+function isTrackCaptionKind(track) {
+  return captionRE.test(track.kind);
+}
+function parseLRCCaptionsFile(content, Cue) {
+  const lines = content.trim().split("\n");
+  const cues = [];
+  const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
+  const computedTime = (times) => +(parseInt(times[0]) * 60) + parseInt(times[1]) + parseInt(times[2].padEnd(3, "0")) / 1e3;
+  for (let i = 0; i < lines.length; i++) {
+    const line = lines[i];
+    const match = timeRegex.exec(line);
+    if (match) {
+      const [fullMatch, minutes, seconds, milliseconds] = match;
+      const text = line.slice(fullMatch.length).trim();
+      const startTime = computedTime([minutes, seconds, milliseconds]);
+      let endTime = startTime + 5;
+      for (let j = i + 1; j < lines.length; j++) {
+        const nextMatch = timeRegex.exec(lines[j]);
+        if (nextMatch) {
+          endTime = computedTime([nextMatch[1], nextMatch[2], nextMatch[3]]);
+          break;
+        }
+      }
+      const cue = new Cue(startTime, endTime, text);
+      cues.push(cue);
+    }
+  }
+  return { cues };
+}
+function parseJSONCaptionsFile(json, Cue, Region) {
+  const content = isString(json) ? JSON.parse(json) : json;
+  let regions = [], cues = [];
+  if (content.regions && Region) {
+    regions = content.regions.map((region) => Object.assign(new Region(), region));
+  }
+  if (content.cues || isArray(content)) {
+    cues = (isArray(content) ? content : content.cues).filter((content2) => isNumber(content2.startTime) && isNumber(content2.endTime)).map((cue) => Object.assign(new Cue(0, 0, ""), cue));
+  }
+  return { regions, cues };
+}
+
+const mediaState = new State({
+  artist: "",
+  artwork: null,
+  audioTrack: null,
+  audioTracks: [],
+  autoPlay: false,
+  autoPlayError: null,
+  audioGain: null,
+  buffered: new TimeRange(),
+  canLoad: false,
+  canLoadPoster: false,
+  canFullscreen: false,
+  canOrientScreen: canOrientScreen(),
+  canPictureInPicture: false,
+  canPlay: false,
+  clipStartTime: 0,
+  clipEndTime: 0,
+  controls: false,
+  get iOSControls() {
+    return IS_IPHONE && this.mediaType === "video" && (!this.playsInline || !fscreen.fullscreenEnabled && this.fullscreen);
+  },
+  get nativeControls() {
+    return this.controls || this.iOSControls;
+  },
+  controlsVisible: false,
+  get controlsHidden() {
+    return !this.controlsVisible;
+  },
+  crossOrigin: null,
+  ended: false,
+  error: null,
+  fullscreen: false,
+  get loop() {
+    return this.providedLoop || this.userPrefersLoop;
+  },
+  logLevel: "warn" ,
+  mediaType: "unknown",
+  muted: false,
+  paused: true,
+  played: new TimeRange(),
+  playing: false,
+  playsInline: false,
+  pictureInPicture: false,
+  preload: "metadata",
+  playbackRate: 1,
+  qualities: [],
+  quality: null,
+  autoQuality: false,
+  canSetQuality: true,
+  canSetPlaybackRate: true,
+  canSetVolume: false,
+  canSetAudioGain: false,
+  seekable: new TimeRange(),
+  seeking: false,
+  source: { src: "", type: "" },
+  sources: [],
+  started: false,
+  textTracks: [],
+  textTrack: null,
+  get hasCaptions() {
+    return this.textTracks.filter(isTrackCaptionKind).length > 0;
+  },
+  volume: 1,
+  waiting: false,
+  realCurrentTime: 0,
+  get currentTime() {
+    return this.ended ? this.duration : this.clipStartTime > 0 ? Math.max(0, Math.min(this.realCurrentTime - this.clipStartTime, this.duration)) : this.realCurrentTime;
+  },
+  providedDuration: -1,
+  intrinsicDuration: 0,
+  get duration() {
+    return this.seekableWindow;
+  },
+  get title() {
+    return this.providedTitle || this.inferredTitle;
+  },
+  get poster() {
+    return this.providedPoster || this.inferredPoster;
+  },
+  get viewType() {
+    return this.providedViewType !== "unknown" ? this.providedViewType : this.inferredViewType;
+  },
+  get streamType() {
+    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
+  },
+  get currentSrc() {
+    return this.source;
+  },
+  get bufferedStart() {
+    const start = getTimeRangesStart(this.buffered) ?? 0;
+    return Math.max(start, this.clipStartTime);
+  },
+  get bufferedEnd() {
+    const end = getTimeRangesEnd(this.buffered) ?? 0;
+    return Math.min(this.seekableEnd, Math.max(0, end - this.clipStartTime));
+  },
+  get bufferedWindow() {
+    return Math.max(0, this.bufferedEnd - this.bufferedStart);
+  },
+  get seekableStart() {
+    if (this.isLiveDVR && this.liveDVRWindow > 0) {
+      return Math.max(0, this.seekableEnd - this.liveDVRWindow);
+    }
+    const start = getTimeRangesStart(this.seekable) ?? 0;
+    return Math.max(start, this.clipStartTime);
+  },
+  get seekableEnd() {
+    if (this.providedDuration > 0) return this.providedDuration;
+    const end = this.liveSyncPosition > 0 ? this.liveSyncPosition : this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
+    return this.clipEndTime > 0 ? Math.min(this.clipEndTime, end) : end;
+  },
+  get seekableWindow() {
+    const window = this.seekableEnd - this.seekableStart;
+    return !isNaN(window) ? Math.max(0, window) : Infinity;
+  },
+  // ~~ remote playback ~~
+  canAirPlay: false,
+  canGoogleCast: false,
+  remotePlaybackState: "disconnected",
+  remotePlaybackType: "none",
+  remotePlaybackLoader: null,
+  remotePlaybackInfo: null,
+  get isAirPlayConnected() {
+    return this.remotePlaybackType === "airplay" && this.remotePlaybackState === "connected";
+  },
+  get isGoogleCastConnected() {
+    return this.remotePlaybackType === "google-cast" && this.remotePlaybackState === "connected";
+  },
+  // ~~ responsive design ~~
+  pointer: "fine",
+  orientation: "landscape",
+  width: 0,
+  height: 0,
+  mediaWidth: 0,
+  mediaHeight: 0,
+  lastKeyboardAction: null,
+  // ~~ user props ~~
+  userBehindLiveEdge: false,
+  // ~~ live props ~~
+  liveEdgeTolerance: 10,
+  minLiveDVRWindow: 60,
+  get canSeek() {
+    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.duration) && (!this.isLiveDVR || this.duration >= this.liveDVRWindow);
+  },
+  get live() {
+    return this.streamType.includes("live") || !Number.isFinite(this.duration);
+  },
+  get liveEdgeStart() {
+    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, this.seekableEnd - this.liveEdgeTolerance) : 0;
+  },
+  get liveEdge() {
+    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
+  },
+  get liveEdgeWindow() {
+    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
+  },
+  get isLiveDVR() {
+    return /:dvr/.test(this.streamType);
+  },
+  get liveDVRWindow() {
+    return Math.max(this.inferredLiveDVRWindow, this.minLiveDVRWindow);
+  },
+  // ~~ internal props ~~
+  autoPlaying: false,
+  providedTitle: "",
+  inferredTitle: "",
+  providedLoop: false,
+  userPrefersLoop: false,
+  providedPoster: "",
+  inferredPoster: "",
+  inferredViewType: "unknown",
+  providedViewType: "unknown",
+  providedStreamType: "unknown",
+  inferredStreamType: "unknown",
+  liveSyncPosition: null,
+  inferredLiveDVRWindow: 0,
+  savedState: null
+});
+const RESET_ON_SRC_QUALITY_CHANGE = /* @__PURE__ */ new Set([
+  "autoPlayError",
+  "autoPlaying",
+  "buffered",
+  "canPlay",
+  "error",
+  "paused",
+  "played",
+  "playing",
+  "seekable",
+  "seeking",
+  "waiting"
+]);
+const RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
+  ...RESET_ON_SRC_QUALITY_CHANGE,
+  "ended",
+  "inferredPoster",
+  "inferredStreamType",
+  "inferredTitle",
+  "intrinsicDuration",
+  "inferredLiveDVRWindow",
+  "liveSyncPosition",
+  "realCurrentTime",
+  "savedState",
+  "started",
+  "userBehindLiveEdge"
+]);
+function softResetMediaState($media, isSourceQualityChange = false) {
+  const filter = isSourceQualityChange ? RESET_ON_SRC_QUALITY_CHANGE : RESET_ON_SRC_CHANGE;
+  mediaState.reset($media, (prop) => filter.has(prop));
+  tick();
+}
+function boundTime(time, store) {
+  const clippedTime = time + store.clipStartTime(), isStart = Math.floor(time) === Math.floor(store.seekableStart()), isEnd = Math.floor(clippedTime) === Math.floor(store.seekableEnd());
+  if (isStart) {
+    return store.seekableStart();
+  }
+  if (isEnd) {
+    return store.seekableEnd();
+  }
+  if (store.isLiveDVR() && store.liveDVRWindow() > 0 && clippedTime < store.seekableEnd() - store.liveDVRWindow()) {
+    return store.bufferedStart();
+  }
+  return Math.min(Math.max(store.seekableStart() + 0.1, clippedTime), store.seekableEnd() - 0.1);
+}
+
+const mediaContext = createContext();
+function useMediaContext() {
+  return useContext(mediaContext);
+}
+
+const GROUPED_LOG = Symbol("GROUPED_LOG" );
+class GroupedLog {
+  constructor(logger, level, title, root, parent) {
+    this.logger = logger;
+    this.level = level;
+    this.title = title;
+    this.root = root;
+    this.parent = parent;
+  }
+  [GROUPED_LOG] = true;
+  logs = [];
+  log(...data) {
+    this.logs.push({ data });
+    return this;
+  }
+  labelledLog(label, ...data) {
+    this.logs.push({ label, data });
+    return this;
+  }
+  groupStart(title) {
+    return new GroupedLog(this.logger, this.level, title, this.root ?? this, this);
+  }
+  groupEnd() {
+    this.parent?.logs.push(this);
+    return this.parent ?? this;
+  }
+  dispatch() {
+    return this.logger.dispatch(this.level, this.root ?? this);
+  }
+}
+function isGroupedLog(data) {
+  return !!data?.[GROUPED_LOG];
+}
+
+class Logger {
+  #target = null;
+  error(...data) {
+    return this.dispatch("error", ...data);
+  }
+  warn(...data) {
+    return this.dispatch("warn", ...data);
+  }
+  info(...data) {
+    return this.dispatch("info", ...data);
+  }
+  debug(...data) {
+    return this.dispatch("debug", ...data);
+  }
+  errorGroup(title) {
+    return new GroupedLog(this, "error", title);
+  }
+  warnGroup(title) {
+    return new GroupedLog(this, "warn", title);
+  }
+  infoGroup(title) {
+    return new GroupedLog(this, "info", title);
+  }
+  debugGroup(title) {
+    return new GroupedLog(this, "debug", title);
+  }
+  setTarget(newTarget) {
+    this.#target = newTarget;
+  }
+  dispatch(level, ...data) {
+    return this.#target?.dispatchEvent(
+      new DOMEvent("vds-log", {
+        bubbles: true,
+        composed: true,
+        detail: { level, data }
+      })
+    ) || false;
+  }
+}
+
+class MediaRemoteControl {
+  #target = null;
+  #player = null;
+  #prevTrackIndex = -1;
+  #logger;
+  constructor(logger = new Logger() ) {
+    this.#logger = logger;
+  }
+  /**
+   * Set the target from which to dispatch media requests events from. The events should bubble
+   * up from this target to the player element.
+   *
+   * @example
+   * ```ts
+   * const button = document.querySelector('button');
+   * remote.setTarget(button);
+   * ```
+   */
+  setTarget(target) {
+    this.#target = target;
+    this.#logger?.setTarget(target);
+  }
+  /**
+   * Returns the current player element. This method will attempt to find the player by
+   * searching up from either the given `target` or default target set via `remote.setTarget`.
+   *
+   * @example
+   * ```ts
+   * const player = remote.getPlayer();
+   * ```
+   */
+  getPlayer(target) {
+    if (this.#player) return this.#player;
+    (target ?? this.#target)?.dispatchEvent(
+      new DOMEvent("find-media-player", {
+        detail: (player) => void (this.#player = player),
+        bubbles: true,
+        composed: true
+      })
+    );
+    return this.#player;
+  }
+  /**
+   * Set the current player element so the remote can support toggle methods such as
+   * `togglePaused` as they rely on the current media state.
+   */
+  setPlayer(player) {
+    this.#player = player;
+  }
+  /**
+   * Dispatch a request to start the media loading process. This will only work if the media
+   * player has been initialized with a custom loading strategy `load="custom">`.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoading(trigger) {
+    this.#dispatchRequest("media-start-loading", trigger);
+  }
+  /**
+   * Dispatch a request to start the poster loading process. This will only work if the media
+   * player has been initialized with a custom poster loading strategy `posterLoad="custom">`.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoadingPoster(trigger) {
+    this.#dispatchRequest("media-poster-start-loading", trigger);
+  }
+  /**
+   * Dispatch a request to connect to AirPlay.
+   *
+   * @see {@link https://www.apple.com/au/airplay}
+   */
+  requestAirPlay(trigger) {
+    this.#dispatchRequest("media-airplay-request", trigger);
+  }
+  /**
+   * Dispatch a request to connect to Google Cast.
+   *
+   * @see {@link https://developers.google.com/cast/docs/overview}
+   */
+  requestGoogleCast(trigger) {
+    this.#dispatchRequest("media-google-cast-request", trigger);
+  }
+  /**
+   * Dispatch a request to begin/resume media playback.
+   */
+  play(trigger) {
+    this.#dispatchRequest("media-play-request", trigger);
+  }
+  /**
+   * Dispatch a request to pause media playback.
+   */
+  pause(trigger) {
+    this.#dispatchRequest("media-pause-request", trigger);
+  }
+  /**
+   * Dispatch a request to set the media volume to mute (0).
+   */
+  mute(trigger) {
+    this.#dispatchRequest("media-mute-request", trigger);
+  }
+  /**
+   * Dispatch a request to unmute the media volume and set it back to it's previous state.
+   */
+  unmute(trigger) {
+    this.#dispatchRequest("media-unmute-request", trigger);
+  }
+  /**
+   * Dispatch a request to enter fullscreen.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  enterFullscreen(target, trigger) {
+    this.#dispatchRequest("media-enter-fullscreen-request", trigger, target);
+  }
+  /**
+   * Dispatch a request to exit fullscreen.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  exitFullscreen(target, trigger) {
+    this.#dispatchRequest("media-exit-fullscreen-request", trigger, target);
+  }
+  /**
+   * Dispatch a request to lock the screen orientation.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/screen-orientation#remote-control}
+   */
+  lockScreenOrientation(lockType, trigger) {
+    this.#dispatchRequest("media-orientation-lock-request", trigger, lockType);
+  }
+  /**
+   * Dispatch a request to unlock the screen orientation.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/screen-orientation#remote-control}
+   */
+  unlockScreenOrientation(trigger) {
+    this.#dispatchRequest("media-orientation-unlock-request", trigger);
+  }
+  /**
+   * Dispatch a request to enter picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  enterPictureInPicture(trigger) {
+    this.#dispatchRequest("media-enter-pip-request", trigger);
+  }
+  /**
+   * Dispatch a request to exit picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  exitPictureInPicture(trigger) {
+    this.#dispatchRequest("media-exit-pip-request", trigger);
+  }
+  /**
+   * Notify the media player that a seeking process is happening and to seek to the given `time`.
+   */
+  seeking(time, trigger) {
+    this.#dispatchRequest("media-seeking-request", trigger, time);
+  }
+  /**
+   * Notify the media player that a seeking operation has completed and to seek to the given `time`.
+   * This is generally called after a series of `remote.seeking()` calls.
+   */
+  seek(time, trigger) {
+    this.#dispatchRequest("media-seek-request", trigger, time);
+  }
+  seekToLiveEdge(trigger) {
+    this.#dispatchRequest("media-live-edge-request", trigger);
+  }
+  /**
+   * Dispatch a request to update the length of the media in seconds.
+   *
+   * @example
+   * ```ts
+   * remote.changeDuration(100); // 100 seconds
+   * ```
+   */
+  changeDuration(duration, trigger) {
+    this.#dispatchRequest("media-duration-change-request", trigger, duration);
+  }
+  /**
+   * Dispatch a request to update the clip start time. This is the time at which media playback
+   * should start at.
+   *
+   * @example
+   * ```ts
+   * remote.changeClipStart(100); // start at 100 seconds
+   * ```
+   */
+  changeClipStart(startTime, trigger) {
+    this.#dispatchRequest("media-clip-start-change-request", trigger, startTime);
+  }
+  /**
+   * Dispatch a request to update the clip end time. This is the time at which media playback
+   * should end at.
+   *
+   * @example
+   * ```ts
+   * remote.changeClipEnd(100); // end at 100 seconds
+   * ```
+   */
+  changeClipEnd(endTime, trigger) {
+    this.#dispatchRequest("media-clip-end-change-request", trigger, endTime);
+  }
+  /**
+   * Dispatch a request to update the media volume to the given `volume` level which is a value
+   * between 0 and 1.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/audio-gain#remote-control}
+   * @example
+   * ```ts
+   * remote.changeVolume(0); // 0%
+   * remote.changeVolume(0.05); // 5%
+   * remote.changeVolume(0.5); // 50%
+   * remote.changeVolume(0.75); // 70%
+   * remote.changeVolume(1); // 100%
+   * ```
+   */
+  changeVolume(volume, trigger) {
+    this.#dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
+  }
+  /**
+   * Dispatch a request to change the current audio track.
+   *
+   * @example
+   * ```ts
+   * remote.changeAudioTrack(1); // track at index 1
+   * ```
+   */
+  changeAudioTrack(index, trigger) {
+    this.#dispatchRequest("media-audio-track-change-request", trigger, index);
+  }
+  /**
+   * Dispatch a request to change the video quality. The special value `-1` represents auto quality
+   * selection.
+   *
+   * @example
+   * ```ts
+   * remote.changeQuality(-1); // auto
+   * remote.changeQuality(1); // quality at index 1
+   * ```
+   */
+  changeQuality(index, trigger) {
+    this.#dispatchRequest("media-quality-change-request", trigger, index);
+  }
+  /**
+   * Request auto quality selection.
+   */
+  requestAutoQuality(trigger) {
+    this.changeQuality(-1, trigger);
+  }
+  /**
+   * Dispatch a request to change the mode of the text track at the given index.
+   *
+   * @example
+   * ```ts
+   * remote.changeTextTrackMode(1, 'showing'); // track at index 1
+   * ```
+   */
+  changeTextTrackMode(index, mode, trigger) {
+    this.#dispatchRequest("media-text-track-change-request", trigger, {
+      index,
+      mode
+    });
+  }
+  /**
+   * Dispatch a request to change the media playback rate.
+   *
+   * @example
+   * ```ts
+   * remote.changePlaybackRate(0.5); // Half the normal speed
+   * remote.changePlaybackRate(1); // Normal speed
+   * remote.changePlaybackRate(1.5); // 50% faster than normal
+   * remote.changePlaybackRate(2); // Double the normal speed
+   * ```
+   */
+  changePlaybackRate(rate, trigger) {
+    this.#dispatchRequest("media-rate-change-request", trigger, rate);
+  }
+  /**
+   * Dispatch a request to change the media audio gain.
+   *
+   * @example
+   * ```ts
+   * remote.changeAudioGain(1); // Disable audio gain
+   * remote.changeAudioGain(1.5); // 50% louder
+   * remote.changeAudioGain(2); // 100% louder
+   * ```
+   */
+  changeAudioGain(gain, trigger) {
+    this.#dispatchRequest("media-audio-gain-change-request", trigger, gain);
+  }
+  /**
+   * Dispatch a request to resume idle tracking on controls.
+   */
+  resumeControls(trigger) {
+    this.#dispatchRequest("media-resume-controls-request", trigger);
+  }
+  /**
+   * Dispatch a request to pause controls idle tracking. Pausing tracking will result in the
+   * controls being visible until `remote.resumeControls()` is called. This method
+   * is generally used when building custom controls and you'd like to prevent the UI from
+   * disappearing.
+   *
+   * @example
+   * ```ts
+   * // Prevent controls hiding while menu is being interacted with.
+   * function onSettingsOpen() {
+   *   remote.pauseControls();
+   * }
+   *
+   * function onSettingsClose() {
+   *   remote.resumeControls();
+   * }
+   * ```
+   */
+  pauseControls(trigger) {
+    this.#dispatchRequest("media-pause-controls-request", trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media playback state.
+   */
+  togglePaused(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.togglePaused.name);
+      return;
+    }
+    if (player.state.paused) this.play(trigger);
+    else this.pause(trigger);
+  }
+  /**
+   * Dispatch a request to toggle the controls visibility.
+   */
+  toggleControls(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.toggleControls.name);
+      return;
+    }
+    if (!player.controls.showing) {
+      player.controls.show(0, trigger);
+    } else {
+      player.controls.hide(0, trigger);
+    }
+  }
+  /**
+   * Dispatch a request to toggle the media muted state.
+   */
+  toggleMuted(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.toggleMuted.name);
+      return;
+    }
+    if (player.state.muted) this.unmute(trigger);
+    else this.mute(trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media fullscreen state.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  toggleFullscreen(target, trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.toggleFullscreen.name);
+      return;
+    }
+    if (player.state.fullscreen) this.exitFullscreen(target, trigger);
+    else this.enterFullscreen(target, trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  togglePictureInPicture(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.togglePictureInPicture.name);
+      return;
+    }
+    if (player.state.pictureInPicture) this.exitPictureInPicture(trigger);
+    else this.enterPictureInPicture(trigger);
+  }
+  /**
+   * Show captions.
+   */
+  showCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.showCaptions.name);
+      return;
+    }
+    let tracks = player.state.textTracks, index = this.#prevTrackIndex;
+    if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
+      index = -1;
+    }
+    if (index === -1) {
+      index = tracks.findIndex((track) => isTrackCaptionKind(track) && track.default);
+    }
+    if (index === -1) {
+      index = tracks.findIndex((track) => isTrackCaptionKind(track));
+    }
+    if (index >= 0) this.changeTextTrackMode(index, "showing", trigger);
+    this.#prevTrackIndex = -1;
+  }
+  /**
+   * Turn captions off.
+   */
+  disableCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.disableCaptions.name);
+      return;
+    }
+    const tracks = player.state.textTracks, track = player.state.textTrack;
+    if (track) {
+      const index = tracks.indexOf(track);
+      this.changeTextTrackMode(index, "disabled", trigger);
+      this.#prevTrackIndex = index;
+    }
+  }
+  /**
+   * Dispatch a request to toggle the current captions mode.
+   */
+  toggleCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      this.#noPlayerWarning(this.toggleCaptions.name);
+      return;
+    }
+    if (player.state.textTrack) {
+      this.disableCaptions();
+    } else {
+      this.showCaptions();
+    }
+  }
+  userPrefersLoopChange(prefersLoop, trigger) {
+    this.#dispatchRequest("media-user-loop-change-request", trigger, prefersLoop);
+  }
+  #dispatchRequest(type, trigger, detail) {
+    const request = new DOMEvent(type, {
+      bubbles: true,
+      composed: true,
+      cancelable: true,
+      detail,
+      trigger
+    });
+    let target = trigger?.target || null;
+    if (target && target instanceof Component) target = target.el;
+    const shouldUsePlayer = !target || target === document || target === window || target === document.body || this.#player?.el && target instanceof Node && !this.#player.el.contains(target);
+    target = shouldUsePlayer ? this.#target ?? this.getPlayer()?.el : target ?? this.#target;
+    {
+      this.#logger?.debugGroup(`\u{1F4E8} dispatching \`${type}\``).labelledLog("Target", target).labelledLog("Player", this.#player).labelledLog("Request Event", request).labelledLog("Trigger Event", trigger).dispatch();
+    }
+    if (this.#player) {
+      if (type === "media-play-request" && !this.#player.state.canLoad) {
+        target?.dispatchEvent(request);
+      } else {
+        this.#player.canPlayQueue.enqueue(type, () => target?.dispatchEvent(request));
+      }
+    } else {
+      target?.dispatchEvent(request);
+    }
+  }
+  #noPlayerWarning(method) {
+    {
+      console.warn(
+        `[vidstack] attempted to call \`MediaRemoteControl.${method}\`() that requires player but failed because remote could not find a parent player element from target`
+      );
+    }
+  }
+}
+
+class LocalMediaStorage {
+  playerId = "vds-player";
+  mediaId = null;
+  #data = {
+    volume: null,
+    muted: null,
+    audioGain: null,
+    time: null,
+    lang: null,
+    captions: null,
+    rate: null,
+    quality: null
+  };
+  async getVolume() {
+    return this.#data.volume;
+  }
+  async setVolume(volume) {
+    this.#data.volume = volume;
+    this.save();
+  }
+  async getMuted() {
+    return this.#data.muted;
+  }
+  async setMuted(muted) {
+    this.#data.muted = muted;
+    this.save();
+  }
+  async getTime() {
+    return this.#data.time;
+  }
+  async setTime(time, ended) {
+    const shouldClear = time < 0;
+    this.#data.time = !shouldClear ? time : null;
+    if (shouldClear || ended) this.saveTime();
+    else this.saveTimeThrottled();
+  }
+  async getLang() {
+    return this.#data.lang;
+  }
+  async setLang(lang) {
+    this.#data.lang = lang;
+    this.save();
+  }
+  async getCaptions() {
+    return this.#data.captions;
+  }
+  async setCaptions(enabled) {
+    this.#data.captions = enabled;
+    this.save();
+  }
+  async getPlaybackRate() {
+    return this.#data.rate;
+  }
+  async setPlaybackRate(rate) {
+    this.#data.rate = rate;
+    this.save();
+  }
+  async getAudioGain() {
+    return this.#data.audioGain;
+  }
+  async setAudioGain(gain) {
+    this.#data.audioGain = gain;
+    this.save();
+  }
+  async getVideoQuality() {
+    return this.#data.quality;
+  }
+  async setVideoQuality(quality) {
+    this.#data.quality = quality;
+    this.save();
+  }
+  onChange(src, mediaId, playerId = "vds-player") {
+    const savedData = playerId ? localStorage.getItem(playerId) : null, savedTime = mediaId ? localStorage.getItem(mediaId) : null;
+    this.playerId = playerId;
+    this.mediaId = mediaId;
+    this.#data = {
+      volume: null,
+      muted: null,
+      audioGain: null,
+      lang: null,
+      captions: null,
+      rate: null,
+      quality: null,
+      ...savedData ? JSON.parse(savedData) : {},
+      time: savedTime ? +savedTime : null
+    };
+  }
+  save() {
+    if (IS_SERVER || !this.playerId) return;
+    const data = JSON.stringify({ ...this.#data, time: void 0 });
+    localStorage.setItem(this.playerId, data);
+  }
+  saveTimeThrottled = functionThrottle(this.saveTime.bind(this), 1e3);
+  saveTime() {
+    if (IS_SERVER || !this.mediaId) return;
+    const data = (this.#data.time ?? 0).toString();
+    localStorage.setItem(this.mediaId, data);
+  }
+}
+
+const ADD = Symbol("LIST_ADD" ), REMOVE = Symbol("LIST_REMOVE" ), RESET = Symbol("LIST_RESET" ), SELECT = Symbol("LIST_SELECT" ), READONLY = Symbol("LIST_READONLY" ), SET_READONLY = Symbol("LIST_SET_READONLY" ), ON_RESET = Symbol("LIST_ON_RESET" ), ON_REMOVE = Symbol("LIST_ON_REMOVE" ), ON_USER_SELECT = Symbol("LIST_ON_USER_SELECT" );
+const ListSymbol = {
+  add: ADD,
+  remove: REMOVE,
+  reset: RESET,
+  select: SELECT,
+  readonly: READONLY,
+  setReadonly: SET_READONLY,
+  onReset: ON_RESET,
+  onRemove: ON_REMOVE,
+  onUserSelect: ON_USER_SELECT
+};
+
+class List extends EventsTarget {
+  items = [];
+  /** @internal */
+  [ListSymbol.readonly] = false;
+  get length() {
+    return this.items.length;
+  }
+  get readonly() {
+    return this[ListSymbol.readonly];
+  }
+  /**
+   * Returns the index of the first occurrence of the given item, or -1 if it is not present.
+   */
+  indexOf(item) {
+    return this.items.indexOf(item);
+  }
+  /**
+   * Returns an item matching the given `id`, or `null` if not present.
+   */
+  getById(id) {
+    if (id === "") return null;
+    return this.items.find((item) => item.id === id) ?? null;
+  }
+  /**
+   * Transform list to an array.
+   */
+  toArray() {
+    return [...this.items];
+  }
+  [Symbol.iterator]() {
+    return this.items.values();
+  }
+  /** @internal */
+  [ListSymbol.add](item, trigger) {
+    const index = this.items.length;
+    if (!("" + index in this)) {
+      Object.defineProperty(this, index, {
+        get() {
+          return this.items[index];
+        }
+      });
+    }
+    if (this.items.includes(item)) return;
+    this.items.push(item);
+    this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
+  }
+  /** @internal */
+  [ListSymbol.remove](item, trigger) {
+    const index = this.items.indexOf(item);
+    if (index >= 0) {
+      this[ListSymbol.onRemove]?.(item, trigger);
+      this.items.splice(index, 1);
+      this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
+    }
+  }
+  /** @internal */
+  [ListSymbol.reset](trigger) {
+    for (const item of [...this.items]) this[ListSymbol.remove](item, trigger);
+    this.items = [];
+    this[ListSymbol.setReadonly](false, trigger);
+    this[ListSymbol.onReset]?.();
+  }
+  /** @internal */
+  [ListSymbol.setReadonly](readonly, trigger) {
+    if (this[ListSymbol.readonly] === readonly) return;
+    this[ListSymbol.readonly] = readonly;
+    this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
+  }
+}
+
+const SELECTED = Symbol("SELECTED" );
+class SelectList extends List {
+  get selected() {
+    return this.items.find((item) => item.selected) ?? null;
+  }
+  get selectedIndex() {
+    return this.items.findIndex((item) => item.selected);
+  }
+  /** @internal */
+  [ListSymbol.onRemove](item, trigger) {
+    this[ListSymbol.select](item, false, trigger);
+  }
+  /** @internal */
+  [ListSymbol.add](item, trigger) {
+    item[SELECTED] = false;
+    Object.defineProperty(item, "selected", {
+      get() {
+        return this[SELECTED];
+      },
+      set: (selected) => {
+        if (this.readonly) return;
+        this[ListSymbol.onUserSelect]?.();
+        this[ListSymbol.select](item, selected);
+      }
+    });
+    super[ListSymbol.add](item, trigger);
+  }
+  /** @internal */
+  [ListSymbol.select](item, selected, trigger) {
+    if (selected === item?.[SELECTED]) return;
+    const prev = this.selected;
+    if (item) item[SELECTED] = selected;
+    const changed = !selected ? prev === item : prev !== item;
+    if (changed) {
+      if (prev) prev[SELECTED] = false;
+      this.dispatchEvent(
+        new DOMEvent("change", {
+          detail: {
+            prev,
+            current: this.selected
+          },
+          trigger
+        })
+      );
+    }
+  }
+}
+
+class AudioTrackList extends SelectList {
+}
+
+function round(num, decimalPlaces = 2) {
+  return Number(num.toFixed(decimalPlaces));
+}
+function getNumberOfDecimalPlaces(num) {
+  return String(num).split(".")[1]?.length ?? 0;
+}
+function clampNumber(min, value, max) {
+  return Math.max(min, Math.min(max, value));
+}
+
+function isEventInside(el, event) {
+  const target = event.composedPath()[0];
+  return isDOMNode(target) && el.contains(target);
+}
+const rafJobs = /* @__PURE__ */ new Set();
+if (!IS_SERVER) {
+  let processJobs = function() {
+    for (const job of rafJobs) {
+      try {
+        job();
+      } catch (e) {
+        console.error(`[vidstack] failed job:
+
+${e}`);
+      }
+    }
+    window.requestAnimationFrame(processJobs);
+  };
+  processJobs();
+}
+function scheduleRafJob(job) {
+  rafJobs.add(job);
+  return () => rafJobs.delete(job);
+}
+function setAttributeIfEmpty(target, name, value) {
+  if (!target.hasAttribute(name)) target.setAttribute(name, value);
+}
+function setARIALabel(target, $label) {
+  if (target.hasAttribute("aria-label") || target.hasAttribute("data-no-label")) return;
+  if (!isFunction($label)) {
+    setAttribute(target, "aria-label", $label);
+    return;
+  }
+  function updateAriaDescription() {
+    setAttribute(target, "aria-label", $label());
+  }
+  if (IS_SERVER) updateAriaDescription();
+  else effect(updateAriaDescription);
+}
+function isElementVisible(el) {
+  const style = getComputedStyle(el);
+  return style.display !== "none" && parseInt(style.opacity) > 0;
+}
+function checkVisibility(el) {
+  return !!el && ("checkVisibility" in el ? el.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true }) : isElementVisible(el));
+}
+function observeVisibility(el, callback) {
+  return scheduleRafJob(() => callback(checkVisibility(el)));
+}
+function isElementParent(owner, node, test) {
+  while (node) {
+    if (node === owner) {
+      return true;
+    } else if (test?.(node)) {
+      break;
+    } else {
+      node = node.parentElement;
+    }
+  }
+  return false;
+}
+function onPress(target, handler) {
+  return new EventsController(target).add("pointerup", (event) => {
+    if (event.button === 0 && !event.defaultPrevented) handler(event);
+  }).add("keydown", (event) => {
+    if (isKeyboardClick(event)) handler(event);
+  });
+}
+function isTouchPinchEvent(event) {
+  return isTouchEvent(event) && (event.touches.length > 1 || event.changedTouches.length > 1);
+}
+function requestScopedAnimationFrame(callback) {
+  if (IS_SERVER) return callback();
+  let scope = getScope(), id = window.requestAnimationFrame(() => {
+    scoped(callback, scope);
+    id = -1;
+  });
+  return () => void window.cancelAnimationFrame(id);
+}
+function autoPlacement(el, trigger, placement, {
+  offsetVarName,
+  xOffset,
+  yOffset,
+  ...options
+}) {
+  if (!el) return;
+  const floatingPlacement = placement.replace(" ", "-").replace("-center", "");
+  setStyle(el, "visibility", !trigger ? "hidden" : null);
+  if (!trigger) return;
+  let isTop = placement.includes("top");
+  const negateX = (x) => placement.includes("left") ? `calc(-1 * ${x})` : x, negateY = (y) => isTop ? `calc(-1 * ${y})` : y;
+  return autoUpdate(trigger, el, () => {
+    computePosition(trigger, el, {
+      placement: floatingPlacement,
+      middleware: [
+        ...options.middleware ?? [],
+        flip({ fallbackAxisSideDirection: "start", crossAxis: false }),
+        shift()
+      ],
+      ...options
+    }).then(({ x, y, middlewareData }) => {
+      const hasFlipped = !!middlewareData.flip?.index;
+      isTop = placement.includes(hasFlipped ? "bottom" : "top");
+      el.setAttribute(
+        "data-placement",
+        hasFlipped ? placement.startsWith("top") ? placement.replace("top", "bottom") : placement.replace("bottom", "top") : placement
+      );
+      Object.assign(el.style, {
+        top: `calc(${y + "px"} + ${negateY(
+          yOffset ? yOffset + "px" : `var(--${offsetVarName}-y-offset, 0px)`
+        )})`,
+        left: `calc(${x + "px"} + ${negateX(
+          xOffset ? xOffset + "px" : `var(--${offsetVarName}-x-offset, 0px)`
+        )})`
+      });
+    });
+  });
+}
+function hasAnimation(el) {
+  const styles = getComputedStyle(el);
+  return styles.animationName !== "none";
+}
+function isHTMLElement(el) {
+  return el instanceof HTMLElement;
+}
+
+class NativeTextRenderer {
+  priority = 0;
+  #display = true;
+  #video = null;
+  #track = null;
+  #tracks = /* @__PURE__ */ new Set();
+  canRender(_, video) {
+    return !!video;
+  }
+  attach(video) {
+    this.#video = video;
+    if (video) video.textTracks.onchange = this.#onChange.bind(this);
+  }
+  addTrack(track) {
+    this.#tracks.add(track);
+    this.#attachTrack(track);
+  }
+  removeTrack(track) {
+    track[TextTrackSymbol.native]?.remove?.();
+    track[TextTrackSymbol.native] = null;
+    this.#tracks.delete(track);
+  }
+  changeTrack(track) {
+    const current = track?.[TextTrackSymbol.native];
+    if (current && current.track.mode !== "showing") {
+      current.track.mode = "showing";
+    }
+    this.#track = track;
+  }
+  setDisplay(display) {
+    this.#display = display;
+    this.#onChange();
+  }
+  detach() {
+    if (this.#video) this.#video.textTracks.onchange = null;
+    for (const track of this.#tracks) this.removeTrack(track);
+    this.#tracks.clear();
+    this.#video = null;
+    this.#track = null;
+  }
+  #attachTrack(track) {
+    if (!this.#video) return;
+    const el = track[TextTrackSymbol.native] ??= this.#createTrackElement(track);
+    if (isHTMLElement(el)) {
+      this.#video.append(el);
+      el.track.mode = el.default ? "showing" : "disabled";
+    }
+  }
+  #createTrackElement(track) {
+    const el = document.createElement("track"), isDefault = track.default || track.mode === "showing", isSupported = track.src && track.type === "vtt";
+    el.id = track.id;
+    el.src = isSupported ? track.src : "";
+    el.label = track.label;
+    el.kind = track.kind;
+    el.default = isDefault;
+    track.language && (el.srclang = track.language);
+    if (isDefault && !isSupported) {
+      this.#copyCues(track, el.track);
+    }
+    return el;
+  }
+  #copyCues(track, native) {
+    if (track.src && track.type === "vtt" || native.cues?.length) return;
+    for (const cue of track.cues) native.addCue(cue);
+  }
+  #onChange(event) {
+    for (const track of this.#tracks) {
+      const native = track[TextTrackSymbol.native];
+      if (!native) continue;
+      if (!this.#display) {
+        native.track.mode = native.managed ? "hidden" : "disabled";
+        continue;
+      }
+      const isShowing = native.track.mode === "showing";
+      if (isShowing) this.#copyCues(track, native.track);
+      track.setMode(isShowing ? "showing" : "disabled", event);
+    }
+  }
+}
+
+class TextRenderers {
+  #video = null;
+  #textTracks;
+  #renderers = [];
+  #media;
+  #nativeDisplay = false;
+  #nativeRenderer = null;
+  #customRenderer = null;
+  constructor(media) {
+    this.#media = media;
+    const textTracks = media.textTracks;
+    this.#textTracks = textTracks;
+    effect(this.#watchControls.bind(this));
+    onDispose(this.#detach.bind(this));
+    new EventsController(textTracks).add("add", this.#onAddTrack.bind(this)).add("remove", this.#onRemoveTrack.bind(this)).add("mode-change", this.#update.bind(this));
+  }
+  #watchControls() {
+    const { nativeControls } = this.#media.$state;
+    this.#nativeDisplay = nativeControls();
+    this.#update();
+  }
+  add(renderer) {
+    this.#renderers.push(renderer);
+    untrack(this.#update.bind(this));
+  }
+  remove(renderer) {
+    renderer.detach();
+    this.#renderers.splice(this.#renderers.indexOf(renderer), 1);
+    untrack(this.#update.bind(this));
+  }
+  /** @internal */
+  attachVideo(video) {
+    requestAnimationFrame(() => {
+      this.#video = video;
+      if (video) {
+        this.#nativeRenderer = new NativeTextRenderer();
+        this.#nativeRenderer.attach(video);
+        for (const track of this.#textTracks) this.#addNativeTrack(track);
+      }
+      this.#update();
+    });
+  }
+  #addNativeTrack(track) {
+    if (!isTrackCaptionKind(track)) return;
+    this.#nativeRenderer?.addTrack(track);
+  }
+  #removeNativeTrack(track) {
+    if (!isTrackCaptionKind(track)) return;
+    this.#nativeRenderer?.removeTrack(track);
+  }
+  #onAddTrack(event) {
+    this.#addNativeTrack(event.detail);
+  }
+  #onRemoveTrack(event) {
+    this.#removeNativeTrack(event.detail);
+  }
+  #update() {
+    const currentTrack = this.#textTracks.selected;
+    if (this.#video && (this.#nativeDisplay || currentTrack?.[TextTrackSymbol.nativeHLS])) {
+      this.#customRenderer?.changeTrack(null);
+      this.#nativeRenderer?.setDisplay(true);
+      this.#nativeRenderer?.changeTrack(currentTrack);
+      return;
+    }
+    this.#nativeRenderer?.setDisplay(false);
+    this.#nativeRenderer?.changeTrack(null);
+    if (!currentTrack) {
+      this.#customRenderer?.changeTrack(null);
+      return;
+    }
+    const customRenderer = this.#renderers.sort((a, b) => a.priority - b.priority).find((renderer) => renderer.canRender(currentTrack, this.#video));
+    if (this.#customRenderer !== customRenderer) {
+      this.#customRenderer?.detach();
+      customRenderer?.attach(this.#video);
+      this.#customRenderer = customRenderer ?? null;
+    }
+    customRenderer?.changeTrack(currentTrack);
+  }
+  #detach() {
+    this.#nativeRenderer?.detach();
+    this.#nativeRenderer = null;
+    this.#customRenderer?.detach();
+    this.#customRenderer = null;
+  }
+}
+
+class TextTrackList extends List {
+  #canLoad = false;
+  #defaults = {};
+  #storage = null;
+  #preferredLang = null;
+  /** @internal */
+  [TextTrackSymbol.crossOrigin];
+  constructor() {
+    super();
+  }
+  get selected() {
+    const track = this.items.find((t) => t.mode === "showing" && isTrackCaptionKind(t));
+    return track ?? null;
+  }
+  get selectedIndex() {
+    const selected = this.selected;
+    return selected ? this.indexOf(selected) : -1;
+  }
+  get preferredLang() {
+    return this.#preferredLang;
+  }
+  set preferredLang(lang) {
+    this.#preferredLang = lang;
+    this.#saveLang(lang);
+  }
+  add(init, trigger) {
+    const isTrack = init instanceof TextTrack, track = isTrack ? init : new TextTrack(init), kind = init.kind === "captions" || init.kind === "subtitles" ? "captions" : init.kind;
+    if (this.#defaults[kind] && init.default) delete init.default;
+    track.addEventListener("mode-change", this.#onTrackModeChangeBind);
+    this[ListSymbol.add](track, trigger);
+    track[TextTrackSymbol.crossOrigin] = this[TextTrackSymbol.crossOrigin];
+    if (this.#canLoad) track[TextTrackSymbol.canLoad]();
+    if (init.default) this.#defaults[kind] = track;
+    this.#selectTracks();
+    return this;
+  }
+  remove(track, trigger) {
+    this.#pendingRemoval = track;
+    if (!this.items.includes(track)) return;
+    if (track === this.#defaults[track.kind]) delete this.#defaults[track.kind];
+    track.mode = "disabled";
+    track[TextTrackSymbol.onModeChange] = null;
+    track.removeEventListener("mode-change", this.#onTrackModeChangeBind);
+    this[ListSymbol.remove](track, trigger);
+    this.#pendingRemoval = null;
+    return this;
+  }
+  clear(trigger) {
+    for (const track of [...this.items]) {
+      this.remove(track, trigger);
+    }
+    return this;
+  }
+  getByKind(kind) {
+    const kinds = Array.isArray(kind) ? kind : [kind];
+    return this.items.filter((track) => kinds.includes(track.kind));
+  }
+  /** @internal */
+  [TextTrackSymbol.canLoad]() {
+    if (this.#canLoad) return;
+    for (const track of this.items) track[TextTrackSymbol.canLoad]();
+    this.#canLoad = true;
+    this.#selectTracks();
+  }
+  #selectTracks = functionDebounce(async () => {
+    if (!this.#canLoad) return;
+    if (!this.#preferredLang && this.#storage) {
+      this.#preferredLang = await this.#storage.getLang();
+    }
+    const showCaptions = await this.#storage?.getCaptions(), kinds = [
+      ["captions", "subtitles"],
+      "chapters",
+      "descriptions",
+      "metadata"
+    ];
+    for (const kind of kinds) {
+      const tracks = this.getByKind(kind);
+      if (tracks.find((t) => t.mode === "showing")) continue;
+      const preferredTrack = this.#preferredLang ? tracks.find((track2) => track2.language === this.#preferredLang) : null;
+      const defaultTrack = isArray(kind) ? this.#defaults[kind.find((kind2) => this.#defaults[kind2]) || ""] : this.#defaults[kind];
+      const track = preferredTrack ?? defaultTrack, isCaptionsKind = track && isTrackCaptionKind(track);
+      if (track && (!isCaptionsKind || showCaptions !== false)) {
+        track.mode = "showing";
+        if (isCaptionsKind) this.#saveCaptionsTrack(track);
+      }
+    }
+  }, 300);
+  #pendingRemoval = null;
+  #onTrackModeChangeBind = this.#onTrackModeChange.bind(this);
+  #onTrackModeChange(event) {
+    const track = event.detail;
+    if (this.#storage && isTrackCaptionKind(track) && track !== this.#pendingRemoval) {
+      this.#saveCaptionsTrack(track);
+    }
+    if (track.mode === "showing") {
+      const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
+      for (const t of this.items) {
+        if (t.mode === "showing" && t != track && kinds.includes(t.kind)) {
+          t.mode = "disabled";
+        }
+      }
+    }
+    this.dispatchEvent(
+      new DOMEvent("mode-change", {
+        detail: event.detail,
+        trigger: event
+      })
+    );
+  }
+  #saveCaptionsTrack(track) {
+    if (track.mode !== "disabled") {
+      this.#saveLang(track.language);
+    }
+    this.#storage?.setCaptions?.(track.mode === "showing");
+  }
+  #saveLang(lang) {
+    this.#storage?.setLang?.(this.#preferredLang = lang);
+  }
+  setStorage(storage) {
+    this.#storage = storage;
+  }
+}
+
+const SET_AUTO = Symbol("SET_AUTO_QUALITY" ), ENABLE_AUTO = Symbol("ENABLE_AUTO_QUALITY" );
+const QualitySymbol = {
+  setAuto: SET_AUTO,
+  enableAuto: ENABLE_AUTO
+};
+
+class VideoQualityList extends SelectList {
+  #auto = false;
+  /**
+   * Configures quality switching:
+   *
+   * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
+   * request if any, flush the whole buffer, and fetch fragment matching with current position
+   * and requested quality level.
+   *
+   * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
+   * already buffered next fragment.
+   *
+   * - `load`: Set quality level for next loaded fragment.
+   *
+   * @see {@link https://www.vidstack.io/docs/player/api/video-quality#switch}
+   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
+   */
+  switch = "current";
+  /**
+   * Whether automatic quality selection is enabled.
+   */
+  get auto() {
+    return this.#auto || this.readonly;
+  }
+  /** @internal */
+  [QualitySymbol.enableAuto];
+  /** @internal */
+  [ListSymbol.onUserSelect]() {
+    this[QualitySymbol.setAuto](false);
+  }
+  /** @internal */
+  [ListSymbol.onReset](trigger) {
+    this[QualitySymbol.enableAuto] = void 0;
+    this[QualitySymbol.setAuto](false, trigger);
+  }
+  /**
+   * Request automatic quality selection (if supported). This will be a no-op if the list is
+   * `readonly` as that already implies auto-selection.
+   */
+  autoSelect(trigger) {
+    if (this.readonly || this.#auto || !this[QualitySymbol.enableAuto]) return;
+    this[QualitySymbol.enableAuto]?.(trigger);
+    this[QualitySymbol.setAuto](true, trigger);
+  }
+  getBySrc(src) {
+    return this.items.find((quality) => quality.src === src);
+  }
+  /** @internal */
+  [QualitySymbol.setAuto](auto, trigger) {
+    if (this.#auto === auto) return;
+    this.#auto = auto;
+    this.dispatchEvent(
+      new DOMEvent("auto-change", {
+        detail: auto,
+        trigger
+      })
+    );
+  }
+}
+
+function sortVideoQualities(qualities, desc) {
+  return [...qualities].sort(desc ? compareVideoQualityDesc : compareVideoQualityAsc);
+}
+function compareVideoQualityAsc(a, b) {
+  return a.height === b.height ? (a.bitrate ?? 0) - (b.bitrate ?? 0) : a.height - b.height;
+}
+function compareVideoQualityDesc(a, b) {
+  return b.height === a.height ? (b.bitrate ?? 0) - (a.bitrate ?? 0) : b.height - a.height;
+}
+
+function isAudioProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "AUDIO";
+}
+function isVideoProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "VIDEO";
+}
+function isHLSProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "HLS";
+}
+function isDASHProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "DASH";
+}
+function isYouTubeProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "YOUTUBE";
+}
+function isVimeoProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "VIMEO";
+}
+function isGoogleCastProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "GOOGLE_CAST";
+}
+function isHTMLAudioElement(element) {
+  return !IS_SERVER && element instanceof HTMLAudioElement;
+}
+function isHTMLVideoElement(element) {
+  return !IS_SERVER && element instanceof HTMLVideoElement;
+}
+function isHTMLMediaElement(element) {
+  return isHTMLAudioElement(element) || isHTMLVideoElement(element);
+}
+function isHTMLIFrameElement(element) {
+  return !IS_SERVER && element instanceof HTMLIFrameElement;
+}
+
+class MediaPlayerController extends ViewController {
+}
+
+const MEDIA_KEY_SHORTCUTS = {
+  togglePaused: "k Space",
+  toggleMuted: "m",
+  toggleFullscreen: "f",
+  togglePictureInPicture: "i",
+  toggleCaptions: "c",
+  seekBackward: "j J ArrowLeft",
+  seekForward: "l L ArrowRight",
+  volumeUp: "ArrowUp",
+  volumeDown: "ArrowDown",
+  speedUp: ">",
+  slowDown: "<"
+};
+const MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Ctrl"]), BUTTON_SELECTORS = 'button, [role="button"]', IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"], [role="timer"]';
+class MediaKeyboardController extends MediaPlayerController {
+  #media;
+  constructor(media) {
+    super();
+    this.#media = media;
+  }
+  onConnect() {
+    effect(this.#onTargetChange.bind(this));
+  }
+  #onTargetChange() {
+    const { keyDisabled, keyTarget } = this.$props;
+    if (keyDisabled()) return;
+    const target = keyTarget() === "player" ? this.el : document, $active = signal(false);
+    if (target === this.el) {
+      new EventsController(this.el).add("focusin", () => $active.set(true)).add("focusout", (event) => {
+        if (!this.el.contains(event.target)) $active.set(false);
+      });
+    } else {
+      if (!peek($active)) $active.set(document.querySelector("[data-media-player]") === this.el);
+      listenEvent(document, "focusin", (event) => {
+        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
+        if (activePlayer !== void 0) $active.set(this.el === activePlayer);
+      });
+    }
+    effect(() => {
+      if (!$active()) return;
+      new EventsController(target).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("keydown", this.#onPreventVideoKeys.bind(this), { capture: true });
+    });
+  }
+  #onKeyUp(event) {
+    const focusedEl = document.activeElement;
+    if (!event.key || !this.$state.canSeek() || focusedEl?.matches(IGNORE_SELECTORS)) {
+      return;
+    }
+    let { method, value } = this.#getMatchingMethod(event);
+    if (!isString(value) && !isArray(value)) {
+      value?.onKeyUp?.({
+        event,
+        player: this.#media.player,
+        remote: this.#media.remote
+      });
+      value?.callback?.(event, this.#media.remote);
+      return;
+    }
+    if (method?.startsWith("seek")) {
+      event.preventDefault();
+      event.stopPropagation();
+      if (this.#timeSlider) {
+        this.#forwardTimeKeyboardEvent(event, method === "seekForward");
+        this.#timeSlider = null;
+      } else {
+        this.#media.remote.seek(this.#seekTotal, event);
+        this.#seekTotal = void 0;
+      }
+    }
+    if (method?.startsWith("volume")) {
+      const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
+      volumeSlider?.dispatchEvent(
+        new KeyboardEvent("keyup", {
+          key: method === "volumeUp" ? "Up" : "Down",
+          shiftKey: event.shiftKey,
+          trigger: event
+        })
+      );
+    }
+  }
+  #onKeyDown(event) {
+    if (!event.key || MODIFIER_KEYS.has(event.key)) return;
+    const focusedEl = document.activeElement;
+    if (focusedEl?.matches(IGNORE_SELECTORS) || isKeyboardClick(event) && focusedEl?.matches(BUTTON_SELECTORS)) {
+      return;
+    }
+    let { method, value } = this.#getMatchingMethod(event), isNumberPress = !event.metaKey && /^[0-9]$/.test(event.key);
+    if (!isString(value) && !isArray(value) && !isNumberPress) {
+      value?.onKeyDown?.({
+        event,
+        player: this.#media.player,
+        remote: this.#media.remote
+      });
+      value?.callback?.(event, this.#media.remote);
+      return;
+    }
+    if (!method && isNumberPress) {
+      event.preventDefault();
+      event.stopPropagation();
+      this.#media.remote.seek(this.$state.duration() / 10 * Number(event.key), event);
+      return;
+    }
+    if (!method) return;
+    event.preventDefault();
+    event.stopPropagation();
+    switch (method) {
+      case "seekForward":
+      case "seekBackward":
+        this.#seeking(event, method, method === "seekForward");
+        break;
+      case "volumeUp":
+      case "volumeDown":
+        const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
+        if (volumeSlider) {
+          volumeSlider.dispatchEvent(
+            new KeyboardEvent("keydown", {
+              key: method === "volumeUp" ? "Up" : "Down",
+              shiftKey: event.shiftKey,
+              trigger: event
+            })
+          );
+        } else {
+          const value2 = event.shiftKey ? 0.1 : 0.05;
+          this.#media.remote.changeVolume(
+            this.$state.volume() + (method === "volumeUp" ? +value2 : -value2),
+            event
+          );
+        }
+        break;
+      case "toggleFullscreen":
+        this.#media.remote.toggleFullscreen("prefer-media", event);
+        break;
+      case "speedUp":
+      case "slowDown":
+        const playbackRate = this.$state.playbackRate();
+        this.#media.remote.changePlaybackRate(
+          Math.max(0.25, Math.min(2, playbackRate + (method === "speedUp" ? 0.25 : -0.25))),
+          event
+        );
+        break;
+      default:
+        this.#media.remote[method]?.(event);
+    }
+    this.$state.lastKeyboardAction.set({
+      action: method,
+      event
+    });
+  }
+  #onPreventVideoKeys(event) {
+    if (isHTMLMediaElement(event.target) && this.#getMatchingMethod(event).method) {
+      event.preventDefault();
+    }
+  }
+  #getMatchingMethod(event) {
+    const keyShortcuts = {
+      ...this.$props.keyShortcuts(),
+      ...this.#media.ariaKeys
+    };
+    const method = Object.keys(keyShortcuts).find((method2) => {
+      const value = keyShortcuts[method2], keys = isArray(value) ? value.join(" ") : isString(value) ? value : value?.keys;
+      const combinations = (isArray(keys) ? keys : keys?.split(" "))?.map(
+        (key) => replaceSymbolKeys(key).replace(/Control/g, "Ctrl").split("+")
+      );
+      return combinations?.some((combo) => {
+        const modifierKeys = new Set(combo.filter((key) => MODIFIER_KEYS.has(key)));
+        for (const modKey of MODIFIER_KEYS) {
+          const modKeyProp = modKey.toLowerCase() + "Key";
+          if (!modifierKeys.has(modKey) && event[modKeyProp]) {
+            return false;
+          }
+        }
+        return combo.every((key) => {
+          return MODIFIER_KEYS.has(key) ? event[key.toLowerCase() + "Key"] : event.key === key.replace("Space", " ");
+        });
+      });
+    });
+    return {
+      method,
+      value: method ? keyShortcuts[method] : null
+    };
+  }
+  #seekTotal;
+  #calcSeekAmount(event, type) {
+    const seekBy = event.shiftKey ? 10 : 5;
+    return this.#seekTotal = Math.max(
+      0,
+      Math.min(
+        (this.#seekTotal ?? this.$state.currentTime()) + (type === "seekForward" ? +seekBy : -seekBy),
+        this.$state.duration()
+      )
+    );
+  }
+  #timeSlider = null;
+  #forwardTimeKeyboardEvent(event, forward) {
+    this.#timeSlider?.dispatchEvent(
+      new KeyboardEvent(event.type, {
+        key: !forward ? "Left" : "Right",
+        shiftKey: event.shiftKey,
+        trigger: event
+      })
+    );
+  }
+  #seeking(event, type, forward) {
+    if (!this.$state.canSeek()) return;
+    if (!this.#timeSlider) {
+      this.#timeSlider = this.el.querySelector("[data-media-time-slider]");
+    }
+    if (this.#timeSlider) {
+      this.#forwardTimeKeyboardEvent(event, forward);
+    } else {
+      this.#media.remote.seeking(this.#calcSeekAmount(event, type), event);
+    }
+  }
+}
+const SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
+function replaceSymbolKeys(key) {
+  return key.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
+}
+
+class ARIAKeyShortcuts extends ViewController {
+  #shortcut;
+  constructor(shortcut) {
+    super();
+    this.#shortcut = shortcut;
+  }
+  onAttach(el) {
+    const { $props, ariaKeys } = useMediaContext(), keys = el.getAttribute("aria-keyshortcuts");
+    if (keys) {
+      ariaKeys[this.#shortcut] = keys;
+      if (!IS_SERVER) {
+        onDispose(() => {
+          delete ariaKeys[this.#shortcut];
+        });
+      }
+      return;
+    }
+    const shortcuts = $props.keyShortcuts()[this.#shortcut];
+    if (shortcuts) {
+      const keys2 = isArray(shortcuts) ? shortcuts.join(" ") : isString(shortcuts) ? shortcuts : shortcuts?.keys;
+      el.setAttribute("aria-keyshortcuts", isArray(keys2) ? keys2.join(" ") : keys2);
+    }
+  }
+}
+
+class MediaControls extends MediaPlayerController {
+  #idleTimer = -2;
+  #pausedTracking = false;
+  #hideOnMouseLeave = signal(false);
+  #isMouseOutside = signal(false);
+  #focusedItem = null;
+  #canIdle = signal(true);
+  /**
+   * The default amount of delay in milliseconds while media playback is progressing without user
+   * activity to indicate an idle state (i.e., hide controls).
+   *
+   * @defaultValue 2000
+   */
+  defaultDelay = 2e3;
+  /**
+   * Whether controls can hide after a delay in user interaction. If this is false, controls will
+   * not hide and be user controlled.
+   */
+  get canIdle() {
+    return this.#canIdle();
+  }
+  set canIdle(canIdle) {
+    this.#canIdle.set(canIdle);
+  }
+  /**
+   * Whether controls visibility should be toggled when the mouse enters and leaves the player
+   * container.
+   *
+   * @defaultValue false
+   */
+  get hideOnMouseLeave() {
+    const { hideControlsOnMouseLeave } = this.$props;
+    return this.#hideOnMouseLeave() || hideControlsOnMouseLeave();
+  }
+  set hideOnMouseLeave(hide) {
+    this.#hideOnMouseLeave.set(hide);
+  }
+  /**
+   * Whether media controls are currently visible.
+   */
+  get showing() {
+    return this.$state.controlsVisible();
+  }
+  /**
+   * Show controls.
+   */
+  show(delay = 0, trigger) {
+    this.#clearIdleTimer();
+    if (!this.#pausedTracking) {
+      this.#changeVisibility(true, delay, trigger);
+    }
+  }
+  /**
+   * Hide controls.
+   */
+  hide(delay = this.defaultDelay, trigger) {
+    this.#clearIdleTimer();
+    if (!this.#pausedTracking) {
+      this.#changeVisibility(false, delay, trigger);
+    }
+  }
+  /**
+   * Whether all idle tracking on controls should be paused until resumed again.
+   */
+  pause(trigger) {
+    this.#pausedTracking = true;
+    this.#clearIdleTimer();
+    this.#changeVisibility(true, 0, trigger);
+  }
+  resume(trigger) {
+    this.#pausedTracking = false;
+    if (this.$state.paused()) return;
+    this.#changeVisibility(false, this.defaultDelay, trigger);
+  }
+  onConnect() {
+    effect(this.#init.bind(this));
+  }
+  #init() {
+    const { viewType } = this.$state;
+    if (!this.el || !this.#canIdle()) return;
+    if (viewType() === "audio") {
+      this.show();
+      return;
+    }
+    effect(this.#watchMouse.bind(this));
+    effect(this.#watchPaused.bind(this));
+    const onPlay = this.#onPlay.bind(this), onPause = this.#onPause.bind(this), onEnd = this.#onEnd.bind(this);
+    new EventsController(this.el).add("can-play", (event) => this.show(0, event)).add("play", onPlay).add("pause", onPause).add("end", onEnd).add("auto-play-fail", onPause);
+  }
+  #watchMouse() {
+    if (!this.el) return;
+    const { started, pointer, paused } = this.$state;
+    if (!started() || pointer() !== "fine") return;
+    const events = new EventsController(this.el), shouldHideOnMouseLeave = this.hideOnMouseLeave;
+    if (!shouldHideOnMouseLeave || !this.#isMouseOutside()) {
+      effect(() => {
+        if (!paused()) events.add("pointermove", this.#onStopIdle.bind(this));
+      });
+    }
+    if (shouldHideOnMouseLeave) {
+      events.add("mouseenter", this.#onMouseEnter.bind(this)).add("mouseleave", this.#onMouseLeave.bind(this));
+    }
+  }
+  #watchPaused() {
+    const { paused, started, autoPlayError } = this.$state;
+    if (paused() || autoPlayError() && !started()) return;
+    const onStopIdle = this.#onStopIdle.bind(this);
+    effect(() => {
+      if (!this.el) return;
+      const pointer = this.$state.pointer(), isTouch = pointer === "coarse", events = new EventsController(this.el), eventTypes = [isTouch ? "touchend" : "pointerup", "keydown"];
+      for (const eventType of eventTypes) {
+        events.add(eventType, onStopIdle, { passive: false });
+      }
+    });
+  }
+  #onPlay(event) {
+    if (event.triggers.hasType("ended")) return;
+    this.show(0, event);
+    this.hide(void 0, event);
+  }
+  #onPause(event) {
+    this.show(0, event);
+  }
+  #onEnd(event) {
+    const { loop } = this.$state;
+    if (loop()) this.hide(0, event);
+  }
+  #onMouseEnter(event) {
+    this.#isMouseOutside.set(false);
+    this.show(0, event);
+    this.hide(void 0, event);
+  }
+  #onMouseLeave(event) {
+    this.#isMouseOutside.set(true);
+    this.hide(0, event);
+  }
+  #clearIdleTimer() {
+    window.clearTimeout(this.#idleTimer);
+    this.#idleTimer = -1;
+  }
+  #onStopIdle(event) {
+    if (
+      // @ts-expect-error
+      event.MEDIA_GESTURE || this.#pausedTracking || isTouchPinchEvent(event)
+    ) {
+      return;
+    }
+    if (isKeyboardEvent(event)) {
+      if (event.key === "Escape") {
+        this.el?.focus();
+        this.#focusedItem = null;
+      } else if (this.#focusedItem) {
+        event.preventDefault();
+        requestAnimationFrame(() => {
+          this.#focusedItem?.focus();
+          this.#focusedItem = null;
+        });
+      }
+    }
+    this.show(0, event);
+    this.hide(this.defaultDelay, event);
+  }
+  #changeVisibility(visible, delay, trigger) {
+    if (delay === 0) {
+      this.#onChange(visible, trigger);
+      return;
+    }
+    this.#idleTimer = window.setTimeout(() => {
+      if (!this.scope) return;
+      this.#onChange(visible && !this.#pausedTracking, trigger);
+    }, delay);
+  }
+  #onChange(visible, trigger) {
+    if (this.$state.controlsVisible() === visible) return;
+    this.$state.controlsVisible.set(visible);
+    if (!visible && document.activeElement && this.el?.contains(document.activeElement)) {
+      this.#focusedItem = document.activeElement;
+      requestAnimationFrame(() => {
+        this.el?.focus({ preventScroll: true });
+      });
+    }
+    this.dispatch("controls-change", {
+      detail: visible,
+      trigger
+    });
+  }
+}
+
+const CAN_FULLSCREEN = fscreen.fullscreenEnabled;
+class FullscreenController extends ViewController {
+  /**
+   * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be
+   * listened to globally on the document so we need to know if they relate to the current host
+   * element or not.
+   */
+  #listening = false;
+  #active = false;
+  get active() {
+    return this.#active;
+  }
+  get supported() {
+    return CAN_FULLSCREEN;
+  }
+  onConnect() {
+    new EventsController(fscreen).add("fullscreenchange", this.#onChange.bind(this)).add("fullscreenerror", this.#onError.bind(this));
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  async #onDisconnect() {
+    if (CAN_FULLSCREEN) await this.exit();
+  }
+  #onChange(event) {
+    const active = isFullscreen(this.el);
+    if (active === this.#active) return;
+    if (!active) this.#listening = false;
+    this.#active = active;
+    this.dispatch("fullscreen-change", { detail: active, trigger: event });
+  }
+  #onError(event) {
+    if (!this.#listening) return;
+    this.dispatch("fullscreen-error", { detail: null, trigger: event });
+    this.#listening = false;
+  }
+  async enter() {
+    try {
+      this.#listening = true;
+      if (!this.el || isFullscreen(this.el)) return;
+      assertFullscreenAPI();
+      return fscreen.requestFullscreen(this.el);
+    } catch (error) {
+      this.#listening = false;
+      throw error;
+    }
+  }
+  async exit() {
+    if (!this.el || !isFullscreen(this.el)) return;
+    assertFullscreenAPI();
+    return fscreen.exitFullscreen();
+  }
+}
+function canFullscreen() {
+  return CAN_FULLSCREEN;
+}
+function isFullscreen(host) {
+  if (fscreen.fullscreenElement === host) return true;
+  try {
+    return host.matches(
+      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
+      fscreen.fullscreenPseudoClass
+    );
+  } catch (error) {
+    return false;
+  }
+}
+function assertFullscreenAPI() {
+  if (CAN_FULLSCREEN) return;
+  throw Error(
+    "[vidstack] fullscreen API is not enabled or supported in this environment" 
+  );
+}
+
+class ScreenOrientationController extends ViewController {
+  #type = signal(this.#getScreenOrientation());
+  #locked = signal(false);
+  #currentLock;
+  /**
+   * The current screen orientation type.
+   *
+   * @signal
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
+   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
+   */
+  get type() {
+    return this.#type();
+  }
+  /**
+   * Whether the screen orientation is currently locked.
+   *
+   * @signal
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
+   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
+   */
+  get locked() {
+    return this.#locked();
+  }
+  /**
+   * Whether the viewport is in a portrait orientation.
+   *
+   * @signal
+   */
+  get portrait() {
+    return this.#type().startsWith("portrait");
+  }
+  /**
+   * Whether the viewport is in a landscape orientation.
+   *
+   * @signal
+   */
+  get landscape() {
+    return this.#type().startsWith("landscape");
+  }
+  /**
+   * Whether the native Screen Orientation API is available.
+   */
+  static supported = canOrientScreen();
+  /**
+   * Whether the native Screen Orientation API is available.
+   */
+  get supported() {
+    return ScreenOrientationController.supported;
+  }
+  onConnect() {
+    if (this.supported) {
+      listenEvent(screen.orientation, "change", this.#onOrientationChange.bind(this));
+    } else {
+      const query = window.matchMedia("(orientation: landscape)");
+      query.onchange = this.#onOrientationChange.bind(this);
+      onDispose(() => query.onchange = null);
+    }
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  async #onDisconnect() {
+    if (this.supported && this.#locked()) await this.unlock();
+  }
+  #onOrientationChange(event) {
+    this.#type.set(this.#getScreenOrientation());
+    this.dispatch("orientation-change", {
+      detail: {
+        orientation: peek(this.#type),
+        lock: this.#currentLock
+      },
+      trigger: event
+    });
+  }
+  /**
+   * Locks the orientation of the screen to the desired orientation type using the
+   * Screen Orientation API.
+   *
+   * @param lockType - The screen lock orientation type.
+   * @throws Error - If screen orientation API is unavailable.
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
+   * @see {@link https://w3c.github.io/screen-orientation}
+   */
+  async lock(lockType) {
+    if (peek(this.#locked) || this.#currentLock === lockType) return;
+    this.#assertScreenOrientationAPI();
+    await screen.orientation.lock(lockType);
+    this.#locked.set(true);
+    this.#currentLock = lockType;
+  }
+  /**
+   * Unlocks the orientation of the screen to it's default state using the Screen Orientation
+   * API. This method will throw an error if the API is unavailable.
+   *
+   * @throws Error - If screen orientation API is unavailable.
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
+   * @see {@link https://w3c.github.io/screen-orientation}
+   */
+  async unlock() {
+    if (!peek(this.#locked)) return;
+    this.#assertScreenOrientationAPI();
+    this.#currentLock = void 0;
+    await screen.orientation.unlock();
+    this.#locked.set(false);
+  }
+  #assertScreenOrientationAPI() {
+    if (this.supported) return;
+    throw Error(
+      "[vidstack] screen orientation API is not available" 
+    );
+  }
+  #getScreenOrientation() {
+    if (IS_SERVER) return "portrait-primary";
+    if (this.supported) return window.screen.orientation.type;
+    return window.innerWidth >= window.innerHeight ? "landscape-primary" : "portrait-primary";
+  }
+}
+
+class AudioProviderLoader {
+  name = "audio";
+  target;
+  canPlay(src) {
+    if (!isAudioSrc(src)) return false;
+    return IS_SERVER || !isString(src.src) || src.type === "?" || canPlayAudioType(this.target, src.type);
+  }
+  mediaType() {
+    return "audio";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load audio provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<audio>` element was not found - did you forget to include `<media-provider>`?"
+      );
+    }
+    return new (await import('./vidstack-ffBqvQK6.js')).AudioProvider(this.target, ctx);
+  }
+}
+
+class VideoProviderLoader {
+  name = "video";
+  target;
+  canPlay(src) {
+    if (!isVideoSrc(src)) return false;
+    return IS_SERVER || !isString(src.src) || src.type === "?" || canPlayVideoType(this.target, src.type);
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load video provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<video>` element was not found - did you forget to include media provider?"
+      );
+    }
+    return new (await Promise.resolve().then(function () { return provider$1; })).VideoProvider(this.target, ctx);
+  }
+}
+
+class HLSProviderLoader extends VideoProviderLoader {
+  static supported = isHLSSupported();
+  name = "hls";
+  canPlay(src) {
+    return HLSProviderLoader.supported && isHLSSrc(src);
+  }
+  async load(context) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load hls provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<video>` element was not found - did you forget to include `<media-provider>`?"
+      );
+    }
+    return new (await import('./vidstack-BJ2PnLPJ.js')).HLSProvider(this.target, context);
+  }
+}
+
+let audioContext = null, gainNodes = [], elAudioSources = [];
+function getOrCreateAudioCtx() {
+  return audioContext ??= new AudioContext();
+}
+function createGainNode() {
+  const audioCtx = getOrCreateAudioCtx(), gainNode = audioCtx.createGain();
+  gainNode.connect(audioCtx.destination);
+  gainNodes.push(gainNode);
+  return gainNode;
+}
+function createElementSource(el, gainNode) {
+  const audioCtx = getOrCreateAudioCtx(), src = audioCtx.createMediaElementSource(el);
+  if (gainNode) {
+    src.connect(gainNode);
+  }
+  elAudioSources.push(src);
+  return src;
+}
+function destroyGainNode(node) {
+  const idx = gainNodes.indexOf(node);
+  if (idx !== -1) {
+    gainNodes.splice(idx, 1);
+    node.disconnect();
+    freeAudioCtxWhenAllResourcesFreed();
+  }
+}
+function destroyElementSource(src) {
+  const idx = elAudioSources.indexOf(src);
+  if (idx !== -1) {
+    elAudioSources.splice(idx, 1);
+    src.disconnect();
+    freeAudioCtxWhenAllResourcesFreed();
+  }
+}
+function freeAudioCtxWhenAllResourcesFreed() {
+  if (audioContext && gainNodes.length === 0 && elAudioSources.length === 0) {
+    audioContext.close().then(() => {
+      audioContext = null;
+    });
+  }
+}
+
+class AudioGain {
+  #media;
+  #onChange;
+  #gainNode = null;
+  #srcAudioNode = null;
+  get currentGain() {
+    return this.#gainNode?.gain?.value ?? null;
+  }
+  get supported() {
+    return true;
+  }
+  constructor(media, onChange) {
+    this.#media = media;
+    this.#onChange = onChange;
+  }
+  setGain(gain) {
+    const currGain = this.currentGain;
+    if (gain === this.currentGain) {
+      return;
+    }
+    if (gain === 1 && currGain !== 1) {
+      this.removeGain();
+      return;
+    }
+    if (!this.#gainNode) {
+      this.#gainNode = createGainNode();
+      if (this.#srcAudioNode) {
+        this.#srcAudioNode.connect(this.#gainNode);
+      }
+    }
+    if (!this.#srcAudioNode) {
+      this.#srcAudioNode = createElementSource(this.#media, this.#gainNode);
+    }
+    this.#gainNode.gain.value = gain;
+    this.#onChange(gain);
+  }
+  removeGain() {
+    if (!this.#gainNode) return;
+    if (this.#srcAudioNode) {
+      this.#srcAudioNode.connect(getOrCreateAudioCtx().destination);
+    }
+    this.#destroyGainNode();
+    this.#onChange(null);
+  }
+  destroy() {
+    this.#destroySrcNode();
+    this.#destroyGainNode();
+  }
+  #destroySrcNode() {
+    if (!this.#srcAudioNode) return;
+    try {
+      destroyElementSource(this.#srcAudioNode);
+    } catch (e) {
+    } finally {
+      this.#srcAudioNode = null;
+    }
+  }
+  #destroyGainNode() {
+    if (!this.#gainNode) return;
+    try {
+      destroyGainNode(this.#gainNode);
+    } catch (e) {
+    } finally {
+      this.#gainNode = null;
+    }
+  }
+}
+
+const PAGE_EVENTS = ["focus", "blur", "visibilitychange", "pageshow", "pagehide"];
+class PageVisibility {
+  #state = signal(determinePageState());
+  #visibility = signal(IS_SERVER ? "visible" : document.visibilityState);
+  #safariBeforeUnloadTimeout;
+  connect() {
+    const events = new EventsController(window), handlePageEvent = this.#handlePageEvent.bind(this);
+    for (const eventType of PAGE_EVENTS) {
+      events.add(eventType, handlePageEvent);
+    }
+    if (IS_SAFARI) {
+      events.add("beforeunload", (event) => {
+        this.#safariBeforeUnloadTimeout = setTimeout(() => {
+          if (!(event.defaultPrevented || event.returnValue.length > 0)) {
+            this.#state.set("hidden");
+            this.#visibility.set("hidden");
+          }
+        }, 0);
+      });
+    }
+  }
+  /**
+   * The current page state. Important to note we only account for a subset of page states, as
+   * the rest aren't valuable to the player at the moment.
+   *
+   * - **active:** A page is in the active state if it is visible and has input focus.
+   * - **passive:** A page is in the passive state if it is visible and does not have input focus.
+   * - **hidden:** A page is in the hidden state if it is not visible.
+   *
+   * @see https://developers.google.com/web/updates/2018/07/page-lifecycle-api#states
+   */
+  get pageState() {
+    return this.#state();
+  }
+  /**
+   * The current document visibility state.
+   *
+   * - **visible:** The page content may be at least partially visible. In practice, this means that
+   * the page is the foreground tab of a non-minimized window.
+   * - **hidden:** The page content is not visible to the user. In practice this means that the
+   * document is either a background tab or part of a minimized window, or the OS screen lock is
+   * active.
+   *
+   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState
+   */
+  get visibility() {
+    return this.#visibility();
+  }
+  #handlePageEvent(event) {
+    if (IS_SAFARI) window.clearTimeout(this.#safariBeforeUnloadTimeout);
+    if (event.type !== "blur" || this.#state() === "active") {
+      this.#state.set(determinePageState(event));
+      this.#visibility.set(document.visibilityState == "hidden" ? "hidden" : "visible");
+    }
+  }
+}
+function determinePageState(event) {
+  if (IS_SERVER) return "hidden";
+  if (event?.type === "blur" || document.visibilityState === "hidden") return "hidden";
+  if (document.hasFocus()) return "active";
+  return "passive";
+}
+
+class RAFLoop {
+  #id;
+  #callback;
+  constructor(callback) {
+    this.#callback = callback;
+  }
+  start() {
+    if (!isUndefined(this.#id)) return;
+    this.#loop();
+  }
+  stop() {
+    if (isNumber(this.#id)) window.cancelAnimationFrame(this.#id);
+    this.#id = void 0;
+  }
+  #loop() {
+    this.#id = window.requestAnimationFrame(() => {
+      if (isUndefined(this.#id)) return;
+      this.#callback();
+      this.#loop();
+    });
+  }
+}
+
+class HTMLMediaEvents {
+  #provider;
+  #ctx;
+  #waiting = false;
+  #attachedLoadStart = false;
+  #attachedCanPlay = false;
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #pageVisibility = new PageVisibility();
+  #events;
+  get #media() {
+    return this.#provider.media;
+  }
+  constructor(provider, ctx) {
+    this.#provider = provider;
+    this.#ctx = ctx;
+    this.#events = new EventsController(provider.media);
+    this.#attachInitialListeners();
+    this.#pageVisibility.connect();
+    effect(this.#attachTimeUpdate.bind(this));
+    onDispose(this.#onDispose.bind(this));
+  }
+  #onDispose() {
+    this.#attachedLoadStart = false;
+    this.#attachedCanPlay = false;
+    this.#timeRAF.stop();
+    this.#events.abort();
+    this.#devHandlers?.clear();
+  }
+  /**
+   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
+   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
+   * resolve that by retrieving time updates in a request animation frame loop.
+   */
+  #lastSeenTime = 0;
+  #seekedTo = -1;
+  #onAnimationFrame() {
+    const newTime = this.#media.currentTime;
+    const didStutter = IS_SAFARI && newTime - this.#seekedTo < 0.35;
+    if (!didStutter && this.#lastSeenTime !== newTime) {
+      this.#updateCurrentTime(newTime);
+      this.#lastSeenTime = newTime;
+    }
+  }
+  #attachInitialListeners() {
+    {
+      this.#ctx.logger?.info("attaching initial listeners");
+    }
+    this.#attachEventListener("loadstart", this.#onLoadStart);
+    this.#attachEventListener("abort", this.#onAbort);
+    this.#attachEventListener("emptied", this.#onEmptied);
+    this.#attachEventListener("error", this.#onError);
+    this.#attachEventListener("volumechange", this.#onVolumeChange);
+    this.#ctx.logger?.debug("attached initial media event listeners");
+  }
+  #attachLoadStartListeners() {
+    if (this.#attachedLoadStart) return;
+    {
+      this.#ctx.logger?.info("attaching load start listeners");
+    }
+    this.#attachEventListener("loadeddata", this.#onLoadedData);
+    this.#attachEventListener("loadedmetadata", this.#onLoadedMetadata);
+    this.#attachEventListener("canplay", this.#onCanPlay);
+    this.#attachEventListener("canplaythrough", this.#onCanPlayThrough);
+    this.#attachEventListener("durationchange", this.#onDurationChange);
+    this.#attachEventListener("play", this.#onPlay);
+    this.#attachEventListener("progress", this.#onProgress);
+    this.#attachEventListener("stalled", this.#onStalled);
+    this.#attachEventListener("suspend", this.#onSuspend);
+    this.#attachEventListener("ratechange", this.#onRateChange);
+    this.#attachedLoadStart = true;
+  }
+  #attachCanPlayListeners() {
+    if (this.#attachedCanPlay) return;
+    {
+      this.#ctx.logger?.info("attaching can play listeners");
+    }
+    this.#attachEventListener("pause", this.#onPause);
+    this.#attachEventListener("playing", this.#onPlaying);
+    this.#attachEventListener("seeked", this.#onSeeked);
+    this.#attachEventListener("seeking", this.#onSeeking);
+    this.#attachEventListener("ended", this.#onEnded);
+    this.#attachEventListener("waiting", this.#onWaiting);
+    this.#attachedCanPlay = true;
+  }
+  #devHandlers = /* @__PURE__ */ new Map() ;
+  #handleDevEvent = this.#onDevEvent.bind(this) ;
+  #attachEventListener(eventType, handler) {
+    this.#devHandlers.set(eventType, handler);
+    this.#events.add(eventType, this.#handleDevEvent );
+  }
+  #onDevEvent(event2) {
+    this.#ctx.logger?.debugGroup(`\u{1F4FA} provider fired \`${event2.type}\``).labelledLog("Provider", this.#provider).labelledLog("Event", event2).labelledLog("Media Store", { ...this.#ctx.$state }).dispatch();
+    this.#devHandlers.get(event2.type)?.call(this, event2);
+  }
+  #updateCurrentTime(time, trigger) {
+    const newTime = Math.min(time, this.#ctx.$state.seekableEnd());
+    this.#ctx.notify("time-change", newTime, trigger);
+  }
+  #onLoadStart(event2) {
+    if (this.#media.networkState === 3) {
+      this.#onAbort(event2);
+      return;
+    }
+    this.#attachLoadStartListeners();
+    this.#ctx.notify("load-start", void 0, event2);
+  }
+  #onAbort(event2) {
+    this.#ctx.notify("abort", void 0, event2);
+  }
+  #onEmptied() {
+    this.#ctx.notify("emptied", void 0, event);
+  }
+  #onLoadedData(event2) {
+    this.#ctx.notify("loaded-data", void 0, event2);
+  }
+  #onLoadedMetadata(event2) {
+    this.#lastSeenTime = 0;
+    this.#seekedTo = -1;
+    this.#attachCanPlayListeners();
+    this.#ctx.notify("loaded-metadata", void 0, event2);
+    if (IS_IOS || IS_SAFARI && isHLSSrc(this.#ctx.$state.source())) {
+      this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
+    }
+  }
+  #getCanPlayDetail() {
+    return {
+      provider: peek(this.#ctx.$provider),
+      duration: this.#media.duration,
+      buffered: this.#media.buffered,
+      seekable: this.#media.seekable
+    };
+  }
+  #onPlay(event2) {
+    if (!this.#ctx.$state.canPlay) return;
+    this.#ctx.notify("play", void 0, event2);
+  }
+  #onPause(event2) {
+    if (this.#media.readyState === 1 && !this.#waiting) return;
+    this.#waiting = false;
+    this.#timeRAF.stop();
+    this.#ctx.notify("pause", void 0, event2);
+  }
+  #onCanPlay(event2) {
+    this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
+  }
+  #onCanPlayThrough(event2) {
+    if (this.#ctx.$state.started()) return;
+    this.#ctx.notify("can-play-through", this.#getCanPlayDetail(), event2);
+  }
+  #onPlaying(event2) {
+    if (this.#media.paused) return;
+    this.#waiting = false;
+    this.#ctx.notify("playing", void 0, event2);
+    this.#timeRAF.start();
+  }
+  #onStalled(event2) {
+    this.#ctx.notify("stalled", void 0, event2);
+    if (this.#media.readyState < 3) {
+      this.#waiting = true;
+      this.#ctx.notify("waiting", void 0, event2);
+    }
+  }
+  #onWaiting(event2) {
+    if (this.#media.readyState < 3) {
+      this.#waiting = true;
+      this.#ctx.notify("waiting", void 0, event2);
+    }
+  }
+  #onEnded(event2) {
+    this.#timeRAF.stop();
+    this.#updateCurrentTime(this.#media.duration, event2);
+    this.#ctx.notify("end", void 0, event2);
+    if (this.#ctx.$state.loop()) {
+      const hasCustomControls = isNil(this.#media.controls);
+      if (hasCustomControls) this.#media.controls = false;
+    }
+  }
+  #attachTimeUpdate() {
+    const isPaused = this.#ctx.$state.paused(), isPageHidden = this.#pageVisibility.visibility === "hidden", shouldListenToTimeUpdates = isPaused || isPageHidden;
+    if (shouldListenToTimeUpdates) {
+      listenEvent(this.#media, "timeupdate", this.#onTimeUpdate.bind(this));
+    }
+  }
+  #onTimeUpdate(event2) {
+    this.#updateCurrentTime(this.#media.currentTime, event2);
+  }
+  #onDurationChange(event2) {
+    if (this.#ctx.$state.ended()) {
+      this.#updateCurrentTime(this.#media.duration, event2);
+    }
+    this.#ctx.notify("duration-change", this.#media.duration, event2);
+  }
+  #onVolumeChange(event2) {
+    const detail = {
+      volume: this.#media.volume,
+      muted: this.#media.muted
+    };
+    this.#ctx.notify("volume-change", detail, event2);
+  }
+  #onSeeked(event2) {
+    this.#seekedTo = this.#media.currentTime;
+    this.#updateCurrentTime(this.#media.currentTime, event2);
+    this.#ctx.notify("seeked", this.#media.currentTime, event2);
+    if (Math.trunc(this.#media.currentTime) === Math.trunc(this.#media.duration) && getNumberOfDecimalPlaces(this.#media.duration) > getNumberOfDecimalPlaces(this.#media.currentTime)) {
+      this.#updateCurrentTime(this.#media.duration, event2);
+      if (!this.#media.ended) {
+        this.#ctx.player.dispatch(
+          new DOMEvent("media-play-request", {
+            trigger: event2
+          })
+        );
+      }
+    }
+  }
+  #onSeeking(event2) {
+    this.#ctx.notify("seeking", this.#media.currentTime, event2);
+  }
+  #onProgress(event2) {
+    const detail = {
+      buffered: this.#media.buffered,
+      seekable: this.#media.seekable
+    };
+    this.#ctx.notify("progress", detail, event2);
+  }
+  #onSuspend(event2) {
+    this.#ctx.notify("suspend", void 0, event2);
+  }
+  #onRateChange(event2) {
+    this.#ctx.notify("rate-change", this.#media.playbackRate, event2);
+  }
+  #onError(event2) {
+    const error = this.#media.error;
+    if (!error) return;
+    const detail = {
+      message: error.message,
+      code: error.code,
+      mediaError: error
+    };
+    this.#ctx.notify("error", detail, event2);
+  }
+}
+
+class NativeAudioTracks {
+  #provider;
+  #ctx;
+  get #nativeTracks() {
+    return this.#provider.media.audioTracks;
+  }
+  constructor(provider, ctx) {
+    this.#provider = provider;
+    this.#ctx = ctx;
+    this.#nativeTracks.onaddtrack = this.#onAddNativeTrack.bind(this);
+    this.#nativeTracks.onremovetrack = this.#onRemoveNativeTrack.bind(this);
+    this.#nativeTracks.onchange = this.#onChangeNativeTrack.bind(this);
+    listenEvent(this.#ctx.audioTracks, "change", this.#onChangeTrack.bind(this));
+  }
+  #onAddNativeTrack(event) {
+    const nativeTrack = event.track;
+    if (nativeTrack.label === "") return;
+    const id = nativeTrack.id.toString() || `native-audio-${this.#ctx.audioTracks.length}`, audioTrack = {
+      id,
+      label: nativeTrack.label,
+      language: nativeTrack.language,
+      kind: nativeTrack.kind,
+      selected: false
+    };
+    this.#ctx.audioTracks[ListSymbol.add](audioTrack, event);
+    if (nativeTrack.enabled) audioTrack.selected = true;
+  }
+  #onRemoveNativeTrack(event) {
+    const track = this.#ctx.audioTracks.getById(event.track.id);
+    if (track) this.#ctx.audioTracks[ListSymbol.remove](track, event);
+  }
+  #onChangeNativeTrack(event) {
+    let enabledTrack = this.#getEnabledNativeTrack();
+    if (!enabledTrack) return;
+    const track = this.#ctx.audioTracks.getById(enabledTrack.id);
+    if (track) this.#ctx.audioTracks[ListSymbol.select](track, true, event);
+  }
+  #getEnabledNativeTrack() {
+    return Array.from(this.#nativeTracks).find((track) => track.enabled);
+  }
+  #onChangeTrack(event) {
+    const { current } = event.detail;
+    if (!current) return;
+    const track = this.#nativeTracks.getTrackById(current.id);
+    if (track) {
+      const prev = this.#getEnabledNativeTrack();
+      if (prev) prev.enabled = false;
+      track.enabled = true;
+    }
+  }
+}
+
+class HTMLMediaProvider {
+  constructor(media, ctx) {
+    this.media = media;
+    this.ctx = ctx;
+    this.audioGain = new AudioGain(media, (gain) => {
+      this.ctx.notify("audio-gain-change", gain);
+    });
+  }
+  scope = createScope();
+  currentSrc = null;
+  audioGain;
+  setup() {
+    new HTMLMediaEvents(this, this.ctx);
+    if ("audioTracks" in this.media) new NativeAudioTracks(this, this.ctx);
+    onDispose(() => {
+      this.audioGain.destroy();
+      this.media.srcObject = null;
+      this.media.removeAttribute("src");
+      for (const source of this.media.querySelectorAll("source")) source.remove();
+      this.media.load();
+    });
+  }
+  get type() {
+    return "";
+  }
+  setPlaybackRate(rate) {
+    this.media.playbackRate = rate;
+  }
+  async play() {
+    return this.media.play();
+  }
+  async pause() {
+    return this.media.pause();
+  }
+  setMuted(muted) {
+    this.media.muted = muted;
+  }
+  setVolume(volume) {
+    this.media.volume = volume;
+  }
+  setCurrentTime(time) {
+    this.media.currentTime = time;
+  }
+  setPlaysInline(inline) {
+    setAttribute(this.media, "playsinline", inline);
+  }
+  async loadSource({ src, type }, preload) {
+    this.media.preload = preload || "";
+    if (isMediaStream(src)) {
+      this.removeSource();
+      this.media.srcObject = src;
+    } else {
+      this.media.srcObject = null;
+      if (isString(src)) {
+        if (type !== "?") {
+          this.appendSource({ src, type });
+        } else {
+          this.removeSource();
+          this.media.src = this.#appendMediaFragment(src);
+        }
+      } else {
+        this.removeSource();
+        this.media.src = window.URL.createObjectURL(src);
+      }
+    }
+    this.media.load();
+    this.currentSrc = { src, type };
+  }
+  /**
+   * Append source so it works when requesting AirPlay since hls.js will remove it.
+   */
+  appendSource(src, defaultType) {
+    const prevSource = this.media.querySelector("source[data-vds]"), source = prevSource ?? document.createElement("source");
+    setAttribute(source, "src", this.#appendMediaFragment(src.src));
+    setAttribute(source, "type", src.type !== "?" ? src.type : defaultType);
+    setAttribute(source, "data-vds", "");
+    if (!prevSource) this.media.append(source);
+  }
+  removeSource() {
+    this.media.querySelector("source[data-vds]")?.remove();
+  }
+  #appendMediaFragment(src) {
+    const { clipStartTime, clipEndTime } = this.ctx.$state, startTime = clipStartTime(), endTime = clipEndTime();
+    if (startTime > 0 && endTime > 0) {
+      return `${src}#t=${startTime},${endTime}`;
+    } else if (startTime > 0) {
+      return `${src}#t=${startTime}`;
+    } else if (endTime > 0) {
+      return `${src}#t=0,${endTime}`;
+    }
+    return src;
+  }
+}
+
+class HTMLRemotePlaybackAdapter {
+  #media;
+  #ctx;
+  #state;
+  #supported = signal(false);
+  get supported() {
+    return this.#supported();
+  }
+  constructor(media, ctx) {
+    this.#media = media;
+    this.#ctx = ctx;
+    this.#setup();
+  }
+  #setup() {
+    if (IS_SERVER || !this.#media?.remote || !this.canPrompt) return;
+    this.#media.remote.watchAvailability((available) => {
+      this.#supported.set(available);
+    }).catch(() => {
+      this.#supported.set(false);
+    });
+    effect(this.#watchSupported.bind(this));
+  }
+  #watchSupported() {
+    if (!this.#supported()) return;
+    const events = ["connecting", "connect", "disconnect"], onStateChange = this.#onStateChange.bind(this);
+    onStateChange();
+    listenEvent(this.#media, "playing", onStateChange);
+    const remoteEvents = new EventsController(this.#media.remote);
+    for (const type of events) {
+      remoteEvents.add(type, onStateChange);
+    }
+  }
+  async prompt() {
+    if (!this.supported) throw Error("Not supported on this platform.");
+    if (this.type === "airplay" && this.#media.webkitShowPlaybackTargetPicker) {
+      return this.#media.webkitShowPlaybackTargetPicker();
+    }
+    return this.#media.remote.prompt();
+  }
+  #onStateChange(event) {
+    const state = this.#media.remote.state;
+    if (state === this.#state) return;
+    const detail = { type: this.type, state };
+    this.#ctx.notify("remote-playback-change", detail, event);
+    this.#state = state;
+  }
+}
+class HTMLAirPlayAdapter extends HTMLRemotePlaybackAdapter {
+  type = "airplay";
+  get canPrompt() {
+    return "WebKitPlaybackTargetAvailabilityEvent" in window;
+  }
+}
+
+class NativeHLSTextTracks {
+  #video;
+  #ctx;
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+    video.textTracks.onaddtrack = this.#onAddTrack.bind(this);
+    onDispose(this.#onDispose.bind(this));
+  }
+  #onAddTrack(event) {
+    const nativeTrack = event.track;
+    if (!nativeTrack || findTextTrackElement(this.#video, nativeTrack)) return;
+    const track = new TextTrack({
+      id: nativeTrack.id,
+      kind: nativeTrack.kind,
+      label: nativeTrack.label ?? "",
+      language: nativeTrack.language,
+      type: "vtt"
+    });
+    track[TextTrackSymbol.native] = { track: nativeTrack };
+    track[TextTrackSymbol.readyState] = 2;
+    track[TextTrackSymbol.nativeHLS] = true;
+    let lastIndex = 0;
+    const onCueChange = (event2) => {
+      if (!nativeTrack.cues) return;
+      for (let i = lastIndex; i < nativeTrack.cues.length; i++) {
+        track.addCue(nativeTrack.cues[i], event2);
+        lastIndex++;
+      }
+    };
+    onCueChange(event);
+    nativeTrack.oncuechange = onCueChange;
+    this.#ctx.textTracks.add(track, event);
+    track.setMode(nativeTrack.mode, event);
+  }
+  #onDispose() {
+    this.#video.textTracks.onaddtrack = null;
+    for (const track of this.#ctx.textTracks) {
+      const nativeTrack = track[TextTrackSymbol.native]?.track;
+      if (nativeTrack?.oncuechange) nativeTrack.oncuechange = null;
+    }
+  }
+}
+function findTextTrackElement(video, track) {
+  return Array.from(video.children).find((el) => el.track === track);
+}
+
+class VideoPictureInPicture {
+  #video;
+  #media;
+  constructor(video, media) {
+    this.#video = video;
+    this.#media = media;
+    new EventsController(video).add("enterpictureinpicture", this.#onEnter.bind(this)).add("leavepictureinpicture", this.#onExit.bind(this));
+  }
+  get active() {
+    return document.pictureInPictureElement === this.#video;
+  }
+  get supported() {
+    return canUsePictureInPicture(this.#video);
+  }
+  async enter() {
+    return this.#video.requestPictureInPicture();
+  }
+  exit() {
+    return document.exitPictureInPicture();
+  }
+  #onEnter(event) {
+    this.#onChange(true, event);
+  }
+  #onExit(event) {
+    this.#onChange(false, event);
+  }
+  #onChange = (active, event) => {
+    this.#media.notify("picture-in-picture-change", active, event);
+  };
+}
+
+class VideoPresentation {
+  #video;
+  #media;
+  #mode = "inline";
+  get mode() {
+    return this.#mode;
+  }
+  constructor(video, media) {
+    this.#video = video;
+    this.#media = media;
+    listenEvent(video, "webkitpresentationmodechanged", this.#onModeChange.bind(this));
+  }
+  get supported() {
+    return canUseVideoPresentation(this.#video);
+  }
+  async setPresentationMode(mode) {
+    if (this.#mode === mode) return;
+    this.#video.webkitSetPresentationMode(mode);
+  }
+  #onModeChange(event) {
+    const prevMode = this.#mode;
+    this.#mode = this.#video.webkitPresentationMode;
+    {
+      this.#media.logger?.infoGroup("presentation mode change").labelledLog("Mode", this.#mode).labelledLog("Event", event).dispatch();
+    }
+    this.#media.player?.dispatch(
+      new DOMEvent("video-presentation-change", {
+        detail: this.#mode,
+        trigger: event
+      })
+    );
+    ["fullscreen", "picture-in-picture"].forEach((type) => {
+      if (this.#mode === type || prevMode === type) {
+        this.#media.notify(`${type}-change`, this.#mode === type, event);
+      }
+    });
+  }
+}
+class FullscreenPresentationAdapter {
+  #presentation;
+  get active() {
+    return this.#presentation.mode === "fullscreen";
+  }
+  get supported() {
+    return this.#presentation.supported;
+  }
+  constructor(presentation) {
+    this.#presentation = presentation;
+  }
+  async enter() {
+    this.#presentation.setPresentationMode("fullscreen");
+  }
+  async exit() {
+    this.#presentation.setPresentationMode("inline");
+  }
+}
+class PIPPresentationAdapter {
+  #presentation;
+  get active() {
+    return this.#presentation.mode === "picture-in-picture";
+  }
+  get supported() {
+    return this.#presentation.supported;
+  }
+  constructor(presentation) {
+    this.#presentation = presentation;
+  }
+  async enter() {
+    this.#presentation.setPresentationMode("picture-in-picture");
+  }
+  async exit() {
+    this.#presentation.setPresentationMode("inline");
+  }
+}
+
+class VideoProvider extends HTMLMediaProvider {
+  $$PROVIDER_TYPE = "VIDEO";
+  get type() {
+    return "video";
+  }
+  airPlay;
+  fullscreen;
+  pictureInPicture;
+  constructor(video, ctx) {
+    super(video, ctx);
+    scoped(() => {
+      this.airPlay = new HTMLAirPlayAdapter(video, ctx);
+      if (canUseVideoPresentation(video)) {
+        const presentation = new VideoPresentation(video, ctx);
+        this.fullscreen = new FullscreenPresentationAdapter(presentation);
+        this.pictureInPicture = new PIPPresentationAdapter(presentation);
+      } else if (canUsePictureInPicture(video)) {
+        this.pictureInPicture = new VideoPictureInPicture(video, ctx);
+      }
+    }, this.scope);
+  }
+  setup() {
+    super.setup();
+    if (canPlayHLSNatively(this.video)) {
+      new NativeHLSTextTracks(this.video, this.ctx);
+    }
+    this.ctx.textRenderers.attachVideo(this.video);
+    onDispose(() => {
+      this.ctx.textRenderers.attachVideo(null);
+    });
+    if (this.type === "video") this.ctx.notify("provider-setup", this);
+  }
+  /**
+   * The native HTML `<video>` element.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement}
+   */
+  get video() {
+    return this.media;
+  }
+}
+
+var provider$1 = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  VideoProvider: VideoProvider
+});
+
+function getLangName(langCode) {
+  try {
+    const displayNames = new Intl.DisplayNames(navigator.languages, { type: "language" });
+    const languageName = displayNames.of(langCode);
+    return languageName ?? null;
+  } catch (err) {
+    return null;
+  }
+}
+
+const toDOMEventType = (type) => `dash-${camelToKebabCase(type)}`;
+class DASHController {
+  #video;
+  #ctx;
+  #instance = null;
+  #callbacks = /* @__PURE__ */ new Set();
+  #stopLiveSync = null;
+  config = {};
+  get instance() {
+    return this.#instance;
+  }
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+  }
+  setup(ctor) {
+    this.#instance = ctor().create();
+    const dispatcher = this.#dispatchDASHEvent.bind(this);
+    for (const event of Object.values(ctor.events)) this.#instance.on(event, dispatcher);
+    this.#instance.on(ctor.events.ERROR, this.#onError.bind(this));
+    for (const callback of this.#callbacks) callback(this.#instance);
+    this.#ctx.player.dispatch("dash-instance", {
+      detail: this.#instance
+    });
+    this.#instance.initialize(this.#video, void 0, false);
+    this.#instance.updateSettings({
+      streaming: {
+        text: {
+          // Disabling text rendering by dash.
+          defaultEnabled: false,
+          dispatchForManualRendering: true
+        },
+        buffer: {
+          /// Enables buffer replacement when switching bitrates for faster switching.
+          fastSwitchEnabled: true
+        }
+      },
+      ...this.config
+    });
+    this.#instance.on(ctor.events.FRAGMENT_LOADING_STARTED, this.#onFragmentLoadStart.bind(this));
+    this.#instance.on(
+      ctor.events.FRAGMENT_LOADING_COMPLETED,
+      this.#onFragmentLoadComplete.bind(this)
+    );
+    this.#instance.on(ctor.events.MANIFEST_LOADED, this.#onManifestLoaded.bind(this));
+    this.#instance.on(ctor.events.QUALITY_CHANGE_RENDERED, this.#onQualityChange.bind(this));
+    this.#instance.on(ctor.events.TEXT_TRACKS_ADDED, this.#onTextTracksAdded.bind(this));
+    this.#instance.on(ctor.events.TRACK_CHANGE_RENDERED, this.#onTrackChange.bind(this));
+    this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
+    listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
+    listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
+    this.#stopLiveSync = effect(this.#liveSync.bind(this));
+  }
+  #createDOMEvent(event) {
+    return new DOMEvent(toDOMEventType(event.type), { detail: event });
+  }
+  #liveSync() {
+    if (!this.#ctx.$state.live()) return;
+    const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
+    raf.start();
+    return raf.stop.bind(raf);
+  }
+  #liveSyncPosition() {
+    if (!this.#instance) return;
+    const position = this.#instance.duration() - this.#instance.time();
+    this.#ctx.$state.liveSyncPosition.set(!isNaN(position) ? position : Infinity);
+  }
+  #dispatchDASHEvent(event) {
+    this.#ctx.player?.dispatch(this.#createDOMEvent(event));
+  }
+  #currentTrack = null;
+  #cueTracker = {};
+  #onTextFragmentLoaded(event) {
+    const native = this.#currentTrack?.[TextTrackSymbol.native], cues = (native?.track).cues;
+    if (!native || !cues) return;
+    const id = this.#currentTrack.id, startIndex = this.#cueTracker[id] ?? 0, trigger = this.#createDOMEvent(event);
+    for (let i = startIndex; i < cues.length; i++) {
+      const cue = cues[i];
+      if (!cue.positionAlign) cue.positionAlign = "auto";
+      this.#currentTrack.addCue(cue, trigger);
+    }
+    this.#cueTracker[id] = cues.length;
+  }
+  #onTextTracksAdded(event) {
+    if (!this.#instance) return;
+    const data = event.tracks, nativeTextTracks = [...this.#video.textTracks].filter((track) => "manualMode" in track), trigger = this.#createDOMEvent(event);
+    for (let i = 0; i < nativeTextTracks.length; i++) {
+      const textTrackInfo = data[i], nativeTextTrack = nativeTextTracks[i];
+      const id = `dash-${textTrackInfo.kind}-${i}`, track = new TextTrack({
+        id,
+        label: textTrackInfo?.label ?? textTrackInfo.labels.find((t) => t.text)?.text ?? (textTrackInfo?.lang && getLangName(textTrackInfo.lang)) ?? textTrackInfo?.lang ?? void 0,
+        language: textTrackInfo.lang ?? void 0,
+        kind: textTrackInfo.kind,
+        default: textTrackInfo.defaultTrack
+      });
+      track[TextTrackSymbol.native] = {
+        managed: true,
+        track: nativeTextTrack
+      };
+      track[TextTrackSymbol.readyState] = 2;
+      track[TextTrackSymbol.onModeChange] = () => {
+        if (!this.#instance) return;
+        if (track.mode === "showing") {
+          this.#instance.setTextTrack(i);
+          this.#currentTrack = track;
+        } else {
+          this.#instance.setTextTrack(-1);
+          this.#currentTrack = null;
+        }
+      };
+      this.#ctx.textTracks.add(track, trigger);
+    }
+  }
+  #onTrackChange(event) {
+    const { mediaType, newMediaInfo } = event;
+    if (mediaType === "audio") {
+      const track = this.#ctx.audioTracks.getById(`dash-audio-${newMediaInfo.index}`);
+      if (track) {
+        const trigger = this.#createDOMEvent(event);
+        this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
+      }
+    }
+  }
+  #onQualityChange(event) {
+    if (event.mediaType !== "video") return;
+    const quality = this.#ctx.qualities[event.newQuality];
+    if (quality) {
+      const trigger = this.#createDOMEvent(event);
+      this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+  }
+  #onManifestLoaded(event) {
+    if (this.#ctx.$state.canPlay() || !this.#instance) return;
+    const { type, mediaPresentationDuration } = event.data, trigger = this.#createDOMEvent(event);
+    this.#ctx.notify("stream-type-change", type !== "static" ? "live" : "on-demand", trigger);
+    this.#ctx.notify("duration-change", mediaPresentationDuration, trigger);
+    this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
+    const media = this.#instance.getVideoElement();
+    const videoQualities = this.#instance.getTracksForTypeFromManifest(
+      "video",
+      event.data
+    );
+    const supportedVideoMimeType = [...new Set(videoQualities.map((e) => e.mimeType))].find(
+      (type2) => type2 && canPlayVideoType(media, type2)
+    );
+    const videoQuality = videoQualities.filter(
+      (track) => supportedVideoMimeType === track.mimeType
+    )[0];
+    let audioTracks = this.#instance.getTracksForTypeFromManifest(
+      "audio",
+      event.data
+    );
+    const supportedAudioMimeType = [...new Set(audioTracks.map((e) => e.mimeType))].find(
+      (type2) => type2 && canPlayAudioType(media, type2)
+    );
+    audioTracks = audioTracks.filter((track) => supportedAudioMimeType === track.mimeType);
+    videoQuality.bitrateList.forEach((bitrate, index) => {
+      const quality = {
+        id: bitrate.id?.toString() ?? `dash-bitrate-${index}`,
+        width: bitrate.width ?? 0,
+        height: bitrate.height ?? 0,
+        bitrate: bitrate.bandwidth ?? 0,
+        codec: videoQuality.codec,
+        index
+      };
+      this.#ctx.qualities[ListSymbol.add](quality, trigger);
+    });
+    if (isNumber(videoQuality.index)) {
+      const quality = this.#ctx.qualities[videoQuality.index];
+      if (quality) this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+    audioTracks.forEach((audioTrack, index) => {
+      const matchingLabel = audioTrack.labels.find((label2) => {
+        return navigator.languages.some((language) => {
+          return label2.lang && language.toLowerCase().startsWith(label2.lang.toLowerCase());
+        });
+      });
+      const label = matchingLabel || audioTrack.labels[0];
+      const localTrack = {
+        id: `dash-audio-${audioTrack?.index}`,
+        label: label?.text ?? (audioTrack.lang && getLangName(audioTrack.lang)) ?? audioTrack.lang ?? "",
+        language: audioTrack.lang ?? "",
+        kind: "main",
+        mimeType: audioTrack.mimeType,
+        codec: audioTrack.codec,
+        index
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
+    });
+    media.dispatchEvent(new DOMEvent("canplay", { trigger }));
+  }
+  #onError(event) {
+    const { type: eventType, error: data } = event;
+    {
+      this.#ctx.logger?.errorGroup(`[vidstack] DASH error \`${data.message}\``).labelledLog("Media Element", this.#video).labelledLog("DASH Instance", this.#instance).labelledLog("Event Type", eventType).labelledLog("Data", data).labelledLog("Src", peek(this.#ctx.$state.source)).labelledLog("Media Store", { ...this.#ctx.$state }).dispatch();
+    }
+    switch (data.code) {
+      case 27:
+        this.#onNetworkError(data);
+        break;
+      default:
+        this.#onFatalError(data);
+        break;
+    }
+  }
+  #onFragmentLoadStart() {
+    if (this.#retryLoadingTimer >= 0) this.#clearRetryTimer();
+  }
+  #onFragmentLoadComplete(event) {
+    const mediaType = event.mediaType;
+    if (mediaType === "text") {
+      requestAnimationFrame(this.#onTextFragmentLoaded.bind(this, event));
+    }
+  }
+  #retryLoadingTimer = -1;
+  #onNetworkError(error) {
+    this.#clearRetryTimer();
+    this.#instance?.play();
+    this.#retryLoadingTimer = window.setTimeout(() => {
+      this.#retryLoadingTimer = -1;
+      this.#onFatalError(error);
+    }, 5e3);
+  }
+  #clearRetryTimer() {
+    clearTimeout(this.#retryLoadingTimer);
+    this.#retryLoadingTimer = -1;
+  }
+  #onFatalError(error) {
+    this.#ctx.notify("error", {
+      message: error.message ?? "",
+      code: 1,
+      error
+    });
+  }
+  #enableAutoQuality() {
+    this.#switchAutoBitrate("video", true);
+    const { qualities } = this.#ctx;
+    this.#instance?.setQualityFor("video", qualities.selectedIndex, true);
+  }
+  #switchAutoBitrate(type, auto) {
+    this.#instance?.updateSettings({
+      streaming: { abr: { autoSwitchBitrate: { [type]: auto } } }
+    });
+  }
+  #onUserQualityChange() {
+    const { qualities } = this.#ctx;
+    if (!this.#instance || qualities.auto || !qualities.selected) return;
+    this.#switchAutoBitrate("video", false);
+    this.#instance.setQualityFor("video", qualities.selectedIndex, qualities.switch === "current");
+    if (IS_CHROME) {
+      this.#video.currentTime = this.#video.currentTime;
+    }
+  }
+  #onUserAudioChange() {
+    if (!this.#instance) return;
+    const { audioTracks } = this.#ctx, selectedTrack = this.#instance.getTracksFor("audio").find(
+      (track) => audioTracks.selected && audioTracks.selected.id === `dash-audio-${track.index}`
+    );
+    if (selectedTrack) this.#instance.setCurrentTrack(selectedTrack);
+  }
+  #reset() {
+    this.#clearRetryTimer();
+    this.#currentTrack = null;
+    this.#cueTracker = {};
+  }
+  onInstance(callback) {
+    this.#callbacks.add(callback);
+    return () => this.#callbacks.delete(callback);
+  }
+  loadSource(src) {
+    this.#reset();
+    if (!isString(src.src)) return;
+    this.#instance?.attachSource(src.src);
+  }
+  destroy() {
+    this.#reset();
+    this.#instance?.destroy();
+    this.#instance = null;
+    this.#stopLiveSync?.();
+    this.#stopLiveSync = null;
+    this.#ctx?.logger?.info("\u{1F3D7}\uFE0F Destroyed DASH instance");
+  }
+}
+
+function coerceToError(error) {
+  return error instanceof Error ? error : Error(typeof error === "string" ? error : JSON.stringify(error));
+}
+function assert(condition, message) {
+  if (!condition) {
+    throw Error(message || "Assertion failed.");
+  }
+}
+
+class DASHLibLoader {
+  #lib;
+  #ctx;
+  #callback;
+  constructor(lib, ctx, callback) {
+    this.#lib = lib;
+    this.#ctx = ctx;
+    this.#callback = callback;
+    this.#startLoading();
+  }
+  async #startLoading() {
+    this.#ctx.logger?.info("\u{1F3D7}\uFE0F Loading DASH Library");
+    const callbacks = {
+      onLoadStart: this.#onLoadStart.bind(this),
+      onLoaded: this.#onLoaded.bind(this),
+      onLoadError: this.#onLoadError.bind(this)
+    };
+    let ctor = await loadDASHScript(this.#lib, callbacks);
+    if (isUndefined(ctor) && !isString(this.#lib)) ctor = await importDASH(this.#lib, callbacks);
+    if (!ctor) return null;
+    if (!window.dashjs.supportsMediaSource()) {
+      const message = "[vidstack] `dash.js` is not supported in this environment";
+      this.#ctx.logger?.error(message);
+      this.#ctx.player.dispatch(new DOMEvent("dash-unsupported"));
+      this.#ctx.notify("error", { message, code: 4 });
+      return null;
+    }
+    return ctor;
+  }
+  #onLoadStart() {
+    {
+      this.#ctx.logger?.infoGroup("Starting to load `dash.js`").labelledLog("URL", this.#lib).dispatch();
+    }
+    this.#ctx.player.dispatch(new DOMEvent("dash-lib-load-start"));
+  }
+  #onLoaded(ctor) {
+    {
+      this.#ctx.logger?.infoGroup("Loaded `dash.js`").labelledLog("Library", this.#lib).labelledLog("Constructor", ctor).dispatch();
+    }
+    this.#ctx.player.dispatch(
+      new DOMEvent("dash-lib-loaded", {
+        detail: ctor
+      })
+    );
+    this.#callback(ctor);
+  }
+  #onLoadError(e) {
+    const error = coerceToError(e);
+    {
+      this.#ctx.logger?.errorGroup("[vidstack] Failed to load `dash.js`").labelledLog("Library", this.#lib).labelledLog("Error", e).dispatch();
+    }
+    this.#ctx.player.dispatch(
+      new DOMEvent("dash-lib-load-error", {
+        detail: error
+      })
+    );
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 4,
+      error
+    });
+  }
+}
+async function importDASH(loader, callbacks = {}) {
+  if (isUndefined(loader)) return void 0;
+  callbacks.onLoadStart?.();
+  if (isDASHConstructor(loader)) {
+    callbacks.onLoaded?.(loader);
+    return loader;
+  }
+  if (isDASHNamespace(loader)) {
+    const ctor = loader.MediaPlayer;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  }
+  try {
+    const ctor = (await loader())?.default;
+    if (isDASHNamespace(ctor)) {
+      callbacks.onLoaded?.(ctor.MediaPlayer);
+      return ctor.MediaPlayer;
+    }
+    if (ctor) {
+      callbacks.onLoaded?.(ctor);
+    } else {
+      throw Error(
+        true ? "[vidstack] failed importing `dash.js`. Dynamic import returned invalid object." : ""
+      );
+    }
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+async function loadDASHScript(src, callbacks = {}) {
+  if (!isString(src)) return void 0;
+  callbacks.onLoadStart?.();
+  try {
+    await loadScript(src);
+    if (!isFunction(window.dashjs.MediaPlayer)) {
+      throw Error(
+        true ? "[vidstack] failed loading `dash.js`. Could not find a valid `Dash` constructor on window" : ""
+      );
+    }
+    const ctor = window.dashjs.MediaPlayer;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+function isDASHConstructor(value) {
+  return value && value.prototype && value.prototype !== Function;
+}
+function isDASHNamespace(value) {
+  return value && "MediaPlayer" in value;
+}
+
+const JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
+class DASHProvider extends VideoProvider {
+  $$PROVIDER_TYPE = "DASH";
+  #ctor = null;
+  #controller = new DASHController(this.video, this.ctx);
+  /**
+   * The `dash.js` constructor.
+   */
+  get ctor() {
+    return this.#ctor;
+  }
+  /**
+   * The current `dash.js` instance.
+   */
+  get instance() {
+    return this.#controller.instance;
+  }
+  /**
+   * Whether `dash.js` is supported in this environment.
+   */
+  static supported = isDASHSupported();
+  get type() {
+    return "dash";
+  }
+  get canLiveSync() {
+    return true;
+  }
+  #library = `${JS_DELIVR_CDN}/npm/dashjs@4.7.4/dist/dash${".all.debug.js" }`;
+  /**
+   * The `dash.js` configuration object.
+   *
+   * @see {@link https://cdn.dashjs.org/latest/jsdoc/module-Settings.html}
+   */
+  get config() {
+    return this.#controller.config;
+  }
+  set config(config) {
+    this.#controller.config = config;
+  }
+  /**
+   * The `dash.js` constructor (supports dynamic imports) or a URL of where it can be found.
+   *
+   * @defaultValue `https://cdn.jsdelivr.net/npm/dashjs@4.7.4/dist/dash.all.min.js`
+   */
+  get library() {
+    return this.#library;
+  }
+  set library(library) {
+    this.#library = library;
+  }
+  preconnect() {
+    if (!isString(this.#library)) return;
+    preconnect(this.#library);
+  }
+  setup() {
+    super.setup();
+    new DASHLibLoader(this.#library, this.ctx, (ctor) => {
+      this.#ctor = ctor;
+      this.#controller.setup(ctor);
+      this.ctx.notify("provider-setup", this);
+      const src = peek(this.ctx.$state.source);
+      if (src) this.loadSource(src);
+    });
+  }
+  async loadSource(src, preload) {
+    if (!isString(src.src)) {
+      this.removeSource();
+      return;
+    }
+    this.media.preload = preload || "";
+    this.appendSource(src, "application/x-mpegurl");
+    this.#controller.loadSource(src);
+    this.currentSrc = src;
+  }
+  /**
+   * The given callback is invoked when a new `dash.js` instance is created and right before it's
+   * attached to media.
+   */
+  onInstance(callback) {
+    const instance = this.#controller.instance;
+    if (instance) callback(instance);
+    return this.#controller.onInstance(callback);
+  }
+  destroy() {
+    this.#controller.destroy();
+  }
+}
+
+var provider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  DASHProvider: DASHProvider
+});
+
+class DASHProviderLoader extends VideoProviderLoader {
+  static supported = isDASHSupported();
+  name = "dash";
+  canPlay(src) {
+    return DASHProviderLoader.supported && isDASHSrc(src);
+  }
+  async load(context) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load dash provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<video>` element was not found - did you forget to include `<media-provider>`?"
+      );
+    }
+    return new (await Promise.resolve().then(function () { return provider; })).DASHProvider(this.target, context);
+  }
+}
+
+class VimeoProviderLoader {
+  name = "vimeo";
+  target;
+  preconnect() {
+    const connections = [
+      "https://i.vimeocdn.com",
+      "https://f.vimeocdn.com",
+      "https://fresnel.vimeocdn.com"
+    ];
+    for (const url of connections) {
+      preconnect(url);
+    }
+  }
+  canPlay(src) {
+    return isString(src.src) && src.type === "video/vimeo";
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load vimeo provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<iframe>` element was not found - did you forget to include media provider?"
+      );
+    }
+    return new (await import('./vidstack-Cm3xcWXU.js')).VimeoProvider(this.target, ctx);
+  }
+  async loadPoster(src, ctx, abort) {
+    const { resolveVimeoVideoId, getVimeoVideoInfo } = await import('./vidstack-krOAtKMi.js');
+    if (!isString(src.src)) return null;
+    const { videoId, hash } = resolveVimeoVideoId(src.src);
+    if (videoId) {
+      return getVimeoVideoInfo(videoId, abort, hash).then((info) => info ? info.poster : null);
+    }
+    return null;
+  }
+}
+
+class YouTubeProviderLoader {
+  name = "youtube";
+  target;
+  preconnect() {
+    const connections = [
+      // Botguard script.
+      "https://www.google.com",
+      // Posters.
+      "https://i.ytimg.com",
+      // Ads.
+      "https://googleads.g.doubleclick.net",
+      "https://static.doubleclick.net"
+    ];
+    for (const url of connections) {
+      preconnect(url);
+    }
+  }
+  canPlay(src) {
+    return isString(src.src) && src.type === "video/youtube";
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load youtube provider server-side");
+    }
+    if (!this.target) {
+      throw Error(
+        "[vidstack] `<iframe>` element was not found - did you forget to include media provider?"
+      );
+    }
+    return new (await import('./vidstack-YexL4NVj.js')).YouTubeProvider(this.target, ctx);
+  }
+  async loadPoster(src, ctx, abort) {
+    const { findYouTubePoster, resolveYouTubeVideoId } = await import('./vidstack-Zc3I7oOd.js');
+    const videoId = isString(src.src) && resolveYouTubeVideoId(src.src);
+    if (videoId) return findYouTubePoster(videoId, abort);
+    return null;
+  }
+}
+
+function padNumberWithZeroes(num, expectedLength) {
+  const str = String(num);
+  const actualLength = str.length;
+  const shouldPad = actualLength < expectedLength;
+  if (shouldPad) {
+    const padLength = expectedLength - actualLength;
+    const padding = `0`.repeat(padLength);
+    return `${padding}${num}`;
+  }
+  return str;
+}
+function parseTime(duration) {
+  const hours = Math.trunc(duration / 3600);
+  const minutes = Math.trunc(duration % 3600 / 60);
+  const seconds = Math.trunc(duration % 60);
+  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
+  return {
+    hours,
+    minutes,
+    seconds,
+    fraction
+  };
+}
+function formatTime(duration, { padHrs = null, padMins = null, showHrs = false, showMs = false } = {}) {
+  const { hours, minutes, seconds, fraction } = parseTime(duration), paddedHours = padHrs ? padNumberWithZeroes(hours, 2) : hours, paddedMinutes = padMins || isNull(padMins) && duration >= 3600 ? padNumberWithZeroes(minutes, 2) : minutes, paddedSeconds = padNumberWithZeroes(seconds, 2), paddedMs = showMs && fraction > 0 ? `.${String(fraction).replace(/^0?\./, "")}` : "", time = `${paddedMinutes}:${paddedSeconds}${paddedMs}`;
+  return hours > 0 || showHrs ? `${paddedHours}:${time}` : time;
+}
+function formatSpokenTime(duration) {
+  const spokenParts = [];
+  const { hours, minutes, seconds } = parseTime(duration);
+  if (hours > 0) {
+    spokenParts.push(`${hours} hour`);
+  }
+  if (minutes > 0) {
+    spokenParts.push(`${minutes} min`);
+  }
+  if (seconds > 0 || spokenParts.length === 0) {
+    spokenParts.push(`${seconds} sec`);
+  }
+  return spokenParts.join(" ");
+}
+
+const MEDIA_ATTRIBUTES = Symbol("MEDIA_ATTRIBUTES" );
+const mediaAttributes = [
+  "autoPlay",
+  "canAirPlay",
+  "canFullscreen",
+  "canGoogleCast",
+  "canLoad",
+  "canLoadPoster",
+  "canPictureInPicture",
+  "canPlay",
+  "canSeek",
+  "ended",
+  "fullscreen",
+  "isAirPlayConnected",
+  "isGoogleCastConnected",
+  "live",
+  "liveEdge",
+  "loop",
+  "mediaType",
+  "muted",
+  "paused",
+  "pictureInPicture",
+  "playing",
+  "playsInline",
+  "remotePlaybackState",
+  "remotePlaybackType",
+  "seeking",
+  "started",
+  "streamType",
+  "viewType",
+  "waiting"
+];
+
+const mediaPlayerProps = {
+  artist: "",
+  artwork: null,
+  autoplay: false,
+  autoPlay: false,
+  clipStartTime: 0,
+  clipEndTime: 0,
+  controls: false,
+  currentTime: 0,
+  crossorigin: null,
+  crossOrigin: null,
+  duration: -1,
+  fullscreenOrientation: "landscape",
+  googleCast: {},
+  load: "visible",
+  posterLoad: "visible",
+  logLevel: "warn" ,
+  loop: false,
+  muted: false,
+  paused: true,
+  playsinline: false,
+  playsInline: false,
+  playbackRate: 1,
+  poster: "",
+  preload: "metadata",
+  preferNativeHLS: false,
+  src: "",
+  title: "",
+  controlsDelay: 2e3,
+  hideControlsOnMouseLeave: false,
+  viewType: "unknown",
+  streamType: "unknown",
+  volume: 1,
+  liveEdgeTolerance: 10,
+  minLiveDVRWindow: 60,
+  keyDisabled: false,
+  keyTarget: "player",
+  keyShortcuts: MEDIA_KEY_SHORTCUTS,
+  storage: null
+};
+
+const MEDIA_EVENTS = [
+  "abort",
+  "can-play",
+  "can-play-through",
+  "duration-change",
+  "emptied",
+  "ended",
+  "error",
+  "fullscreen-change",
+  "loaded-data",
+  "loaded-metadata",
+  "load-start",
+  "media-type-change",
+  "pause",
+  "play",
+  "playing",
+  "progress",
+  "seeked",
+  "seeking",
+  "source-change",
+  "sources-change",
+  "stalled",
+  "started",
+  "suspend",
+  "stream-type-change",
+  "replay",
+  // time-change,
+  // 'time-update',
+  "view-type-change",
+  "volume-change",
+  "waiting"
+] ;
+class MediaEventsLogger extends MediaPlayerController {
+  #media;
+  constructor(media) {
+    super();
+    this.#media = media;
+  }
+  onConnect(el) {
+    const events = new EventsController(el), handler = this.#onMediaEvent.bind(this);
+    for (const eventType of MEDIA_EVENTS) {
+      events.add(eventType, handler);
+    }
+  }
+  #onMediaEvent(event) {
+    this.#media.logger?.debugGroup(`\u{1F4E1} dispatching \`${event.type}\``).labelledLog("Media Store", { ...this.$state }).labelledLog("Event", event).dispatch();
+  }
+}
+
+class MediaLoadController extends MediaPlayerController {
+  #type;
+  #callback;
+  constructor(type, callback) {
+    super();
+    this.#type = type;
+    this.#callback = callback;
+  }
+  async onAttach(el) {
+    if (IS_SERVER) return;
+    const load = this.$props[this.#type]();
+    if (load === "eager") {
+      requestAnimationFrame(this.#callback);
+    } else if (load === "idle") {
+      waitIdlePeriod(this.#callback);
+    } else if (load === "visible") {
+      let dispose, observer = new IntersectionObserver((entries) => {
+        if (!this.scope) return;
+        if (entries[0].isIntersecting) {
+          dispose?.();
+          dispose = void 0;
+          this.#callback();
+        }
+      });
+      observer.observe(el);
+      dispose = onDispose(() => observer.disconnect());
+    }
+  }
+}
+
+let seenAutoplayWarning = false;
+class MediaPlayerDelegate {
+  #handle;
+  #media;
+  constructor(handle, media) {
+    this.#handle = handle;
+    this.#media = media;
+  }
+  notify(type, ...init) {
+    if (IS_SERVER) return;
+    this.#handle(
+      new DOMEvent(type, {
+        detail: init?.[0],
+        trigger: init?.[1]
+      })
+    );
+  }
+  async ready(info, trigger) {
+    if (IS_SERVER) return;
+    return untrack(async () => {
+      const { logger } = this.#media, {
+        autoPlay,
+        canPlay,
+        started,
+        duration,
+        seekable,
+        buffered,
+        remotePlaybackInfo,
+        playsInline,
+        savedState,
+        source
+      } = this.#media.$state;
+      if (canPlay()) return;
+      const detail = {
+        duration: info?.duration ?? duration(),
+        seekable: info?.seekable ?? seekable(),
+        buffered: info?.buffered ?? buffered(),
+        provider: this.#media.$provider()
+      };
+      this.notify("can-play", detail, trigger);
+      tick();
+      {
+        logger?.infoGroup("-~-~-~-~-~-~- \u2705 MEDIA READY -~-~-~-~-~-~-").labelledLog("Media", this.#media).labelledLog("Trigger Event", trigger).dispatch();
+      }
+      let provider = this.#media.$provider(), { storage, qualities } = this.#media, { muted, volume, clipStartTime, playbackRate } = this.#media.$props;
+      await storage?.onLoad?.(source());
+      const savedPlaybackTime = savedState()?.currentTime, savedPausedState = savedState()?.paused, storageTime = await storage?.getTime(), startTime = savedPlaybackTime ?? storageTime ?? clipStartTime(), shouldAutoPlay = savedPausedState === false || savedPausedState !== true && !started() && autoPlay();
+      if (provider) {
+        provider.setVolume(await storage?.getVolume() ?? volume());
+        provider.setMuted(muted() || !!await storage?.getMuted());
+        const audioGain = await storage?.getAudioGain() ?? 1;
+        if (audioGain > 1) provider.audioGain?.setGain?.(audioGain);
+        provider.setPlaybackRate?.(await storage?.getPlaybackRate() ?? playbackRate());
+        provider.setPlaysInline?.(playsInline());
+        if (startTime > 0) provider.setCurrentTime(startTime);
+      }
+      const prefQuality = await storage?.getVideoQuality();
+      if (prefQuality && qualities.length) {
+        let currentQuality = null, currentScore = Infinity;
+        for (const quality of qualities) {
+          const score = Math.abs(prefQuality.width - quality.width) + Math.abs(prefQuality.height - quality.height) + (prefQuality.bitrate ? Math.abs(prefQuality.bitrate - (quality.bitrate ?? 0)) : 0);
+          if (score < currentScore) {
+            currentQuality = quality;
+            currentScore = score;
+          }
+        }
+        if (currentQuality) currentQuality.selected = true;
+      }
+      if (canPlay() && shouldAutoPlay) {
+        await this.#attemptAutoplay(trigger);
+      } else if (storageTime && storageTime > 0) {
+        this.notify("started", void 0, trigger);
+      }
+      remotePlaybackInfo.set(null);
+    });
+  }
+  async #attemptAutoplay(trigger) {
+    const {
+      player,
+      $state: { autoPlaying, muted }
+    } = this.#media;
+    autoPlaying.set(true);
+    const attemptEvent = new DOMEvent("auto-play-attempt", { trigger });
+    try {
+      await player.play(attemptEvent);
+    } catch (error) {
+      if (!seenAutoplayWarning) {
+        const muteMsg = !muted() ? " Attempting with volume muted will most likely resolve the issue." : "";
+        this.#media.logger?.errorGroup("[vidstack] auto-play request failed").labelledLog(
+          "Message",
+          `Autoplay was requested but failed most likely due to browser autoplay policies.${muteMsg}`
+        ).labelledLog("Trigger Event", trigger).labelledLog("Error", error).labelledLog("See", "https://developer.chrome.com/blog/autoplay").dispatch();
+        seenAutoplayWarning = true;
+      }
+    }
+  }
+}
+
+class Queue {
+  #queue = /* @__PURE__ */ new Map();
+  /**
+   * Queue the given `item` under the given `key` to be processed at a later time by calling
+   * `serve(key)`.
+   */
+  enqueue(key, item) {
+    this.#queue.set(key, item);
+  }
+  /**
+   * Process item in queue for the given `key`.
+   */
+  serve(key) {
+    const value = this.peek(key);
+    this.#queue.delete(key);
+    return value;
+  }
+  /**
+   * Peek at item in queue for the given `key`.
+   */
+  peek(key) {
+    return this.#queue.get(key);
+  }
+  /**
+   * Removes queued item under the given `key`.
+   */
+  delete(key) {
+    this.#queue.delete(key);
+  }
+  /**
+   * Clear all items in the queue.
+   */
+  clear() {
+    this.#queue.clear();
+  }
+}
+
+class RequestQueue {
+  #serving = false;
+  #pending = deferredPromise();
+  #queue = /* @__PURE__ */ new Map();
+  /**
+   * The number of callbacks that are currently in queue.
+   */
+  get size() {
+    return this.#queue.size;
+  }
+  /**
+   * Whether items in the queue are being served immediately, otherwise they're queued to
+   * be processed later.
+   */
+  get isServing() {
+    return this.#serving;
+  }
+  /**
+   * Waits for the queue to be flushed (ie: start serving).
+   */
+  async waitForFlush() {
+    if (this.#serving) return;
+    await this.#pending.promise;
+  }
+  /**
+   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
+   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
+   * then the callback will be invoked immediately.
+   *
+   * @param key - Uniquely identifies this callback so duplicates are ignored.
+   * @param callback - The function to call when this item in the queue is being served.
+   */
+  enqueue(key, callback) {
+    if (this.#serving) {
+      callback();
+      return;
+    }
+    this.#queue.delete(key);
+    this.#queue.set(key, callback);
+  }
+  /**
+   * Invokes the callback with the given `key` in the queue (if it exists).
+   */
+  serve(key) {
+    this.#queue.get(key)?.();
+    this.#queue.delete(key);
+  }
+  /**
+   * Flush all queued items and start serving future requests immediately until `stop()` is called.
+   */
+  start() {
+    this.#flush();
+    this.#serving = true;
+    if (this.#queue.size > 0) this.#flush();
+  }
+  /**
+   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
+   */
+  stop() {
+    this.#serving = false;
+  }
+  /**
+   * Stop serving requests, empty the request queue, and release any promises waiting for the
+   * queue to flush.
+   */
+  reset() {
+    this.stop();
+    this.#queue.clear();
+    this.#release();
+  }
+  #flush() {
+    for (const key of this.#queue.keys()) this.serve(key);
+    this.#release();
+  }
+  #release() {
+    this.#pending.resolve();
+    this.#pending = deferredPromise();
+  }
+}
+
+class MediaRequestManager extends MediaPlayerController {
+  #stateMgr;
+  #request;
+  #media;
+  controls;
+  #fullscreen;
+  #orientation;
+  #$provider;
+  #providerQueue = new RequestQueue();
+  constructor(stateMgr, request, media) {
+    super();
+    this.#stateMgr = stateMgr;
+    this.#request = request;
+    this.#media = media;
+    this.#$provider = media.$provider;
+    this.controls = new MediaControls();
+    this.#fullscreen = new FullscreenController();
+    this.#orientation = new ScreenOrientationController();
+  }
+  onAttach() {
+    this.listen("fullscreen-change", this.#onFullscreenChange.bind(this));
+  }
+  onConnect(el) {
+    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), events = new EventsController(el), handleRequest = this.#handleRequest.bind(this);
+    for (const name of names) {
+      if (name.startsWith("media-")) {
+        events.add(name, handleRequest);
+      }
+    }
+    this.#attachLoadPlayListener();
+    effect(this.#watchProvider.bind(this));
+    effect(this.#watchControlsDelayChange.bind(this));
+    effect(this.#watchAudioGainSupport.bind(this));
+    effect(this.#watchAirPlaySupport.bind(this));
+    effect(this.#watchGoogleCastSupport.bind(this));
+    effect(this.#watchFullscreenSupport.bind(this));
+    effect(this.#watchPiPSupport.bind(this));
+  }
+  onDestroy() {
+    try {
+      const destroyEvent = this.createEvent("destroy"), { pictureInPicture, fullscreen } = this.$state;
+      if (fullscreen()) this.exitFullscreen("prefer-media", destroyEvent);
+      if (pictureInPicture()) this.exitPictureInPicture(destroyEvent);
+    } catch (e) {
+    }
+    this.#providerQueue.reset();
+  }
+  #attachLoadPlayListener() {
+    const { load } = this.$props, { canLoad } = this.$state;
+    if (load() !== "play" || canLoad()) return;
+    const off = this.listen("media-play-request", (event) => {
+      this.#handleLoadPlayStrategy(event);
+      off();
+    });
+  }
+  #watchProvider() {
+    const provider = this.#$provider(), canPlay = this.$state.canPlay();
+    if (provider && canPlay) {
+      this.#providerQueue.start();
+    }
+    return () => {
+      this.#providerQueue.stop();
+    };
+  }
+  #handleRequest(event) {
+    event.stopPropagation();
+    if (event.defaultPrevented) return;
+    {
+      this.#media.logger?.infoGroup(`\u{1F4EC} received \`${event.type}\``).labelledLog("Request", event).dispatch();
+    }
+    if (!this[event.type]) return;
+    if (peek(this.#$provider)) {
+      this[event.type](event);
+    } else {
+      this.#providerQueue.enqueue(event.type, () => {
+        if (peek(this.#$provider)) this[event.type](event);
+      });
+    }
+  }
+  async play(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, paused, autoPlaying } = this.$state;
+    if (this.#handleLoadPlayStrategy(trigger)) return;
+    if (!peek(paused)) return;
+    if (trigger) this.#request.queue.enqueue("media-play-request", trigger);
+    const isAutoPlaying = peek(autoPlaying);
+    try {
+      const provider = peek(this.#$provider);
+      throwIfNotReadyForPlayback(provider, peek(canPlay));
+      return await provider.play();
+    } catch (error) {
+      this.#logError("play request failed", error, trigger);
+      const errorEvent = this.createEvent("play-fail", {
+        detail: coerceToError(error),
+        trigger
+      });
+      errorEvent.autoPlay = isAutoPlaying;
+      this.#stateMgr.handle(errorEvent);
+      throw error;
+    }
+  }
+  #handleLoadPlayStrategy(trigger) {
+    const { load } = this.$props, { canLoad } = this.$state;
+    if (load() === "play" && !canLoad()) {
+      const event = this.createEvent("media-start-loading", { trigger });
+      this.dispatchEvent(event);
+      this.#providerQueue.enqueue("media-play-request", async () => {
+        try {
+          await this.play(event);
+        } catch (error) {
+        }
+      });
+      return true;
+    }
+    return false;
+  }
+  async pause(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, paused } = this.$state;
+    if (peek(paused)) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-pause-request", trigger);
+    }
+    try {
+      const provider = peek(this.#$provider);
+      throwIfNotReadyForPlayback(provider, peek(canPlay));
+      return await provider.pause();
+    } catch (error) {
+      this.#request.queue.delete("media-pause-request");
+      {
+        this.#logError("pause request failed", error, trigger);
+      }
+      throw error;
+    }
+  }
+  setAudioGain(gain, trigger) {
+    const { audioGain, canSetAudioGain } = this.$state;
+    if (audioGain() === gain) return;
+    const provider = this.#$provider();
+    if (!provider?.audioGain || !canSetAudioGain()) {
+      throw Error("[vidstack] audio gain api not available");
+    }
+    if (trigger) {
+      this.#request.queue.enqueue("media-audio-gain-change-request", trigger);
+    }
+    provider.audioGain.setGain(gain);
+  }
+  seekToLiveEdge(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, live, liveEdge, canSeek, liveSyncPosition, seekableEnd, userBehindLiveEdge } = this.$state;
+    userBehindLiveEdge.set(false);
+    if (peek(() => !live() || liveEdge() || !canSeek())) return;
+    const provider = peek(this.#$provider);
+    throwIfNotReadyForPlayback(provider, peek(canPlay));
+    if (trigger) this.#request.queue.enqueue("media-seek-request", trigger);
+    const end = seekableEnd() - 2;
+    provider.setCurrentTime(Math.min(end, liveSyncPosition() ?? end));
+  }
+  #wasPIPActive = false;
+  async enterFullscreen(target = "prefer-media", trigger) {
+    if (IS_SERVER) return;
+    const adapter = this.#getFullscreenAdapter(target);
+    throwIfFullscreenNotSupported(target, adapter);
+    if (adapter.active) return;
+    if (peek(this.$state.pictureInPicture)) {
+      this.#wasPIPActive = true;
+      await this.exitPictureInPicture(trigger);
+    }
+    if (trigger) {
+      this.#request.queue.enqueue("media-enter-fullscreen-request", trigger);
+    }
+    return adapter.enter();
+  }
+  async exitFullscreen(target = "prefer-media", trigger) {
+    if (IS_SERVER) return;
+    const adapter = this.#getFullscreenAdapter(target);
+    throwIfFullscreenNotSupported(target, adapter);
+    if (!adapter.active) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-exit-fullscreen-request", trigger);
+    }
+    try {
+      const result = await adapter.exit();
+      if (this.#wasPIPActive && peek(this.$state.canPictureInPicture)) {
+        await this.enterPictureInPicture();
+      }
+      return result;
+    } finally {
+      this.#wasPIPActive = false;
+    }
+  }
+  #getFullscreenAdapter(target) {
+    const provider = peek(this.#$provider);
+    return target === "prefer-media" && this.#fullscreen.supported || target === "media" ? this.#fullscreen : provider?.fullscreen;
+  }
+  async enterPictureInPicture(trigger) {
+    if (IS_SERVER) return;
+    this.#throwIfPIPNotSupported();
+    if (this.$state.pictureInPicture()) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-enter-pip-request", trigger);
+    }
+    return await this.#$provider().pictureInPicture.enter();
+  }
+  async exitPictureInPicture(trigger) {
+    if (IS_SERVER) return;
+    this.#throwIfPIPNotSupported();
+    if (!this.$state.pictureInPicture()) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-exit-pip-request", trigger);
+    }
+    return await this.#$provider().pictureInPicture.exit();
+  }
+  #throwIfPIPNotSupported() {
+    if (this.$state.canPictureInPicture()) return;
+    throw Error(
+      `[vidstack] picture-in-picture is not currently available` 
+    );
+  }
+  #watchControlsDelayChange() {
+    this.controls.defaultDelay = this.$props.controlsDelay();
+  }
+  #watchAudioGainSupport() {
+    const { canSetAudioGain } = this.$state, supported = !!this.#$provider()?.audioGain?.supported;
+    canSetAudioGain.set(supported);
+  }
+  #watchAirPlaySupport() {
+    const { canAirPlay } = this.$state, supported = !!this.#$provider()?.airPlay?.supported;
+    canAirPlay.set(supported);
+  }
+  #watchGoogleCastSupport() {
+    const { canGoogleCast, source } = this.$state, supported = IS_CHROME && !IS_IOS && canGoogleCastSrc(source());
+    canGoogleCast.set(supported);
+  }
+  #watchFullscreenSupport() {
+    const { canFullscreen } = this.$state, supported = this.#fullscreen.supported || !!this.#$provider()?.fullscreen?.supported;
+    canFullscreen.set(supported);
+  }
+  #watchPiPSupport() {
+    const { canPictureInPicture } = this.$state, supported = !!this.#$provider()?.pictureInPicture?.supported;
+    canPictureInPicture.set(supported);
+  }
+  async ["media-airplay-request"](event) {
+    try {
+      await this.requestAirPlay(event);
+    } catch (error) {
+    }
+  }
+  async requestAirPlay(trigger) {
+    try {
+      const adapter = this.#$provider()?.airPlay;
+      if (!adapter?.supported) {
+        throw Error(true ? "AirPlay adapter not available on provider." : "No AirPlay adapter.");
+      }
+      if (trigger) {
+        this.#request.queue.enqueue("media-airplay-request", trigger);
+      }
+      return await adapter.prompt();
+    } catch (error) {
+      this.#request.queue.delete("media-airplay-request");
+      {
+        this.#logError("airplay request failed", error, trigger);
+      }
+      throw error;
+    }
+  }
+  async ["media-google-cast-request"](event) {
+    try {
+      await this.requestGoogleCast(event);
+    } catch (error) {
+    }
+  }
+  #googleCastLoader;
+  async requestGoogleCast(trigger) {
+    try {
+      const { canGoogleCast } = this.$state;
+      if (!peek(canGoogleCast)) {
+        const error = Error(
+          true ? "Google Cast not available on this platform." : "Cast not available."
+        );
+        error.code = "CAST_NOT_AVAILABLE";
+        throw error;
+      }
+      preconnect("https://www.gstatic.com");
+      if (!this.#googleCastLoader) {
+        const $module = await import('./vidstack-Cm9GcCaL.js').then(function (n) { return n.loader; });
+        this.#googleCastLoader = new $module.GoogleCastLoader();
+      }
+      await this.#googleCastLoader.prompt(this.#media);
+      if (trigger) {
+        this.#request.queue.enqueue("media-google-cast-request", trigger);
+      }
+      const isConnecting = peek(this.$state.remotePlaybackState) !== "disconnected";
+      if (isConnecting) {
+        this.$state.savedState.set({
+          paused: peek(this.$state.paused),
+          currentTime: peek(this.$state.currentTime)
+        });
+      }
+      this.$state.remotePlaybackLoader.set(isConnecting ? this.#googleCastLoader : null);
+    } catch (error) {
+      this.#request.queue.delete("media-google-cast-request");
+      {
+        this.#logError("google cast request failed", error, trigger);
+      }
+      throw error;
+    }
+  }
+  ["media-clip-start-change-request"](event) {
+    const { clipStartTime } = this.$state;
+    clipStartTime.set(event.detail);
+  }
+  ["media-clip-end-change-request"](event) {
+    const { clipEndTime } = this.$state;
+    clipEndTime.set(event.detail);
+    this.dispatch("duration-change", {
+      detail: event.detail,
+      trigger: event
+    });
+  }
+  ["media-duration-change-request"](event) {
+    const { providedDuration, clipEndTime } = this.$state;
+    providedDuration.set(event.detail);
+    if (clipEndTime() <= 0) {
+      this.dispatch("duration-change", {
+        detail: event.detail,
+        trigger: event
+      });
+    }
+  }
+  ["media-audio-track-change-request"](event) {
+    const { logger, audioTracks } = this.#media;
+    if (audioTracks.readonly) {
+      {
+        logger?.warnGroup(`[vidstack] attempted to change audio track but it is currently read-only`).labelledLog("Request Event", event).dispatch();
+      }
+      return;
+    }
+    const index = event.detail, track = audioTracks[index];
+    if (track) {
+      const key = event.type;
+      this.#request.queue.enqueue(key, event);
+      track.selected = true;
+    } else {
+      logger?.warnGroup("[vidstack] failed audio track change request (invalid index)").labelledLog("Audio Tracks", audioTracks.toArray()).labelledLog("Index", index).labelledLog("Request Event", event).dispatch();
+    }
+  }
+  async ["media-enter-fullscreen-request"](event) {
+    try {
+      await this.enterFullscreen(event.detail, event);
+    } catch (error) {
+      this.#onFullscreenError(error, event);
+    }
+  }
+  async ["media-exit-fullscreen-request"](event) {
+    try {
+      await this.exitFullscreen(event.detail, event);
+    } catch (error) {
+      this.#onFullscreenError(error, event);
+    }
+  }
+  async #onFullscreenChange(event) {
+    const lockType = peek(this.$props.fullscreenOrientation), isFullscreen = event.detail;
+    if (isUndefined(lockType) || lockType === "none" || !this.#orientation.supported) return;
+    if (isFullscreen) {
+      if (this.#orientation.locked) return;
+      this.dispatch("media-orientation-lock-request", {
+        detail: lockType,
+        trigger: event
+      });
+    } else if (this.#orientation.locked) {
+      this.dispatch("media-orientation-unlock-request", {
+        trigger: event
+      });
+    }
+  }
+  #onFullscreenError(error, request) {
+    {
+      this.#logError("fullscreen request failed", error, request);
+    }
+    this.#stateMgr.handle(
+      this.createEvent("fullscreen-error", {
+        detail: coerceToError(error)
+      })
+    );
+  }
+  async ["media-orientation-lock-request"](event) {
+    const key = event.type;
+    try {
+      this.#request.queue.enqueue(key, event);
+      await this.#orientation.lock(event.detail);
+    } catch (error) {
+      this.#request.queue.delete(key);
+      {
+        this.#logError("failed to lock screen orientation", error, event);
+      }
+    }
+  }
+  async ["media-orientation-unlock-request"](event) {
+    const key = event.type;
+    try {
+      this.#request.queue.enqueue(key, event);
+      await this.#orientation.unlock();
+    } catch (error) {
+      this.#request.queue.delete(key);
+      {
+        this.#logError("failed to unlock screen orientation", error, event);
+      }
+    }
+  }
+  async ["media-enter-pip-request"](event) {
+    try {
+      await this.enterPictureInPicture(event);
+    } catch (error) {
+      this.#onPictureInPictureError(error, event);
+    }
+  }
+  async ["media-exit-pip-request"](event) {
+    try {
+      await this.exitPictureInPicture(event);
+    } catch (error) {
+      this.#onPictureInPictureError(error, event);
+    }
+  }
+  #onPictureInPictureError(error, request) {
+    {
+      this.#logError("pip request failed", error, request);
+    }
+    this.#stateMgr.handle(
+      this.createEvent("picture-in-picture-error", {
+        detail: coerceToError(error)
+      })
+    );
+  }
+  ["media-live-edge-request"](event) {
+    const { live, liveEdge, canSeek } = this.$state;
+    if (!live() || liveEdge() || !canSeek()) return;
+    this.#request.queue.enqueue("media-seek-request", event);
+    try {
+      this.seekToLiveEdge();
+    } catch (error) {
+      this.#request.queue.delete("media-seek-request");
+      {
+        this.#logError("seek to live edge fail", error, event);
+      }
+    }
+  }
+  async ["media-loop-request"](event) {
+    try {
+      this.#request.looping = true;
+      this.#request.replaying = true;
+      await this.play(event);
+    } catch (error) {
+      this.#request.looping = false;
+    }
+  }
+  ["media-user-loop-change-request"](event) {
+    this.$state.userPrefersLoop.set(event.detail);
+  }
+  async ["media-pause-request"](event) {
+    if (this.$state.paused()) return;
+    try {
+      await this.pause(event);
+    } catch (error) {
+    }
+  }
+  async ["media-play-request"](event) {
+    if (!this.$state.paused()) return;
+    try {
+      await this.play(event);
+    } catch (e) {
+    }
+  }
+  ["media-rate-change-request"](event) {
+    const { playbackRate, canSetPlaybackRate } = this.$state;
+    if (playbackRate() === event.detail || !canSetPlaybackRate()) return;
+    const provider = this.#$provider();
+    if (!provider?.setPlaybackRate) return;
+    this.#request.queue.enqueue("media-rate-change-request", event);
+    provider.setPlaybackRate(event.detail);
+  }
+  ["media-audio-gain-change-request"](event) {
+    try {
+      this.setAudioGain(event.detail, event);
+    } catch (e) {
+    }
+  }
+  ["media-quality-change-request"](event) {
+    const { qualities, storage, logger } = this.#media;
+    if (qualities.readonly) {
+      {
+        logger?.warnGroup(`[vidstack] attempted to change video quality but it is currently read-only`).labelledLog("Request Event", event).dispatch();
+      }
+      return;
+    }
+    this.#request.queue.enqueue("media-quality-change-request", event);
+    const index = event.detail;
+    if (index < 0) {
+      qualities.autoSelect(event);
+      if (event.isOriginTrusted) storage?.setVideoQuality?.(null);
+    } else {
+      const quality = qualities[index];
+      if (quality) {
+        quality.selected = true;
+        if (event.isOriginTrusted) {
+          storage?.setVideoQuality?.({
+            id: quality.id,
+            width: quality.width,
+            height: quality.height,
+            bitrate: quality.bitrate
+          });
+        }
+      } else {
+        logger?.warnGroup("[vidstack] failed quality change request (invalid index)").labelledLog("Qualities", qualities.toArray()).labelledLog("Index", index).labelledLog("Request Event", event).dispatch();
+      }
+    }
+  }
+  ["media-pause-controls-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.controls.pause(event);
+  }
+  ["media-resume-controls-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.controls.resume(event);
+  }
+  ["media-seek-request"](event) {
+    const { canSeek, ended, live, seekableEnd, userBehindLiveEdge } = this.$state, seekTime = event.detail;
+    if (ended()) this.#request.replaying = true;
+    const key = event.type;
+    this.#request.seeking = false;
+    this.#request.queue.delete(key);
+    const boundedTime = boundTime(seekTime, this.$state);
+    if (!Number.isFinite(boundedTime) || !canSeek()) return;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setCurrentTime(boundedTime);
+    if (live() && event.isOriginTrusted && Math.abs(seekableEnd() - boundedTime) >= 2) {
+      userBehindLiveEdge.set(true);
+    }
+  }
+  ["media-seeking-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.$state.seeking.set(true);
+    this.#request.seeking = true;
+  }
+  ["media-start-loading"](event) {
+    if (this.$state.canLoad()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#stateMgr.handle(this.createEvent("can-load"));
+  }
+  ["media-poster-start-loading"](event) {
+    if (this.$state.canLoadPoster()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#stateMgr.handle(this.createEvent("can-load-poster"));
+  }
+  ["media-text-track-change-request"](event) {
+    const { index, mode } = event.detail, track = this.#media.textTracks[index];
+    if (track) {
+      const key = event.type;
+      this.#request.queue.enqueue(key, event);
+      track.setMode(mode, event);
+    } else {
+      this.#media.logger?.warnGroup("[vidstack] failed text track change request (invalid index)").labelledLog("Text Tracks", this.#media.textTracks.toArray()).labelledLog("Index", index).labelledLog("Request Event", event).dispatch();
+    }
+  }
+  ["media-mute-request"](event) {
+    if (this.$state.muted()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setMuted(true);
+  }
+  ["media-unmute-request"](event) {
+    const { muted, volume } = this.$state;
+    if (!muted()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#media.$provider().setMuted(false);
+    if (volume() === 0) {
+      this.#request.queue.enqueue(key, event);
+      this.#$provider().setVolume(0.25);
+    }
+  }
+  ["media-volume-change-request"](event) {
+    const { muted, volume } = this.$state;
+    const newVolume = event.detail;
+    if (volume() === newVolume) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setVolume(newVolume);
+    if (newVolume > 0 && muted()) {
+      this.#request.queue.enqueue(key, event);
+      this.#$provider().setMuted(false);
+    }
+  }
+  #logError(title, error, request) {
+    this.#media.logger?.errorGroup(`[vidstack] ${title}`).labelledLog("Error", error).labelledLog("Media Context", { ...this.#media }).labelledLog("Trigger Event", request).dispatch();
+  }
+}
+function throwIfNotReadyForPlayback(provider, canPlay) {
+  if (provider && canPlay) return;
+  throw Error(
+    `[vidstack] media is not ready - wait for \`can-play\` event.` 
+  );
+}
+function throwIfFullscreenNotSupported(target, fullscreen) {
+  if (fullscreen?.supported) return;
+  throw Error(
+    `[vidstack] fullscreen is not currently available on target \`${target}\`` 
+  );
+}
+class MediaRequestContext {
+  seeking = false;
+  looping = false;
+  replaying = false;
+  queue = new Queue();
+}
+
+const TRACKED_EVENT = /* @__PURE__ */ new Set([
+  "auto-play",
+  "auto-play-fail",
+  "can-load",
+  "sources-change",
+  "source-change",
+  "load-start",
+  "abort",
+  "error",
+  "loaded-metadata",
+  "loaded-data",
+  "can-play",
+  "play",
+  "play-fail",
+  "pause",
+  "playing",
+  "seeking",
+  "seeked",
+  "waiting"
+]);
+
+class MediaStateManager extends MediaPlayerController {
+  #request;
+  #media;
+  #trackedEvents = /* @__PURE__ */ new Map();
+  #clipEnded = false;
+  #playedIntervals = [];
+  #playedInterval = [-1, -1];
+  #firingWaiting = false;
+  #waitingTrigger;
+  constructor(request, media) {
+    super();
+    this.#request = request;
+    this.#media = media;
+  }
+  onAttach(el) {
+    el.setAttribute("aria-busy", "true");
+    new EventsController(this).add("fullscreen-change", this["fullscreen-change"].bind(this)).add("fullscreen-error", this["fullscreen-error"].bind(this)).add("orientation-change", this["orientation-change"].bind(this));
+  }
+  onConnect(el) {
+    effect(this.#watchCanSetVolume.bind(this));
+    this.#addTextTrackListeners();
+    this.#addQualityListeners();
+    this.#addAudioTrackListeners();
+    this.#resumePlaybackOnConnect();
+    onDispose(this.#pausePlaybackOnDisconnect.bind(this));
+  }
+  onDestroy() {
+    const { audioTracks, qualities, textTracks } = this.#media;
+    audioTracks[ListSymbol.reset]();
+    qualities[ListSymbol.reset]();
+    textTracks[ListSymbol.reset]();
+    this.#stopWatchingQualityResize();
+  }
+  handle(event) {
+    if (!this.scope) return;
+    const type = event.type;
+    untrack(() => this[event.type]?.(event));
+    if (!IS_SERVER) {
+      if (TRACKED_EVENT.has(type)) this.#trackedEvents.set(type, event);
+      this.dispatch(event);
+    }
+  }
+  #isPlayingOnDisconnect = false;
+  #resumePlaybackOnConnect() {
+    if (!this.#isPlayingOnDisconnect) return;
+    requestAnimationFrame(() => {
+      if (!this.scope) return;
+      this.#media.remote.play(new DOMEvent("dom-connect"));
+    });
+    this.#isPlayingOnDisconnect = false;
+  }
+  #pausePlaybackOnDisconnect() {
+    if (this.#isPlayingOnDisconnect) return;
+    this.#isPlayingOnDisconnect = !this.$state.paused();
+    this.#media.$provider()?.pause();
+  }
+  #resetTracking() {
+    this.#stopWaiting();
+    this.#clipEnded = false;
+    this.#request.replaying = false;
+    this.#request.looping = false;
+    this.#firingWaiting = false;
+    this.#waitingTrigger = void 0;
+    this.#trackedEvents.clear();
+  }
+  #satisfyRequest(request, event) {
+    const requestEvent = this.#request.queue.serve(request);
+    if (!requestEvent) return;
+    event.request = requestEvent;
+    event.triggers.add(requestEvent);
+  }
+  #addTextTrackListeners() {
+    this.#onTextTracksChange();
+    this.#onTextTrackModeChange();
+    const textTracks = this.#media.textTracks;
+    new EventsController(textTracks).add("add", this.#onTextTracksChange.bind(this)).add("remove", this.#onTextTracksChange.bind(this)).add("mode-change", this.#onTextTrackModeChange.bind(this));
+  }
+  #addQualityListeners() {
+    const qualities = this.#media.qualities;
+    new EventsController(qualities).add("add", this.#onQualitiesChange.bind(this)).add("remove", this.#onQualitiesChange.bind(this)).add("change", this.#onQualityChange.bind(this)).add("auto-change", this.#onAutoQualityChange.bind(this)).add("readonly-change", this.#onCanSetQualityChange.bind(this));
+  }
+  #addAudioTrackListeners() {
+    const audioTracks = this.#media.audioTracks;
+    new EventsController(audioTracks).add("add", this.#onAudioTracksChange.bind(this)).add("remove", this.#onAudioTracksChange.bind(this)).add("change", this.#onAudioTrackChange.bind(this));
+  }
+  #onTextTracksChange(event) {
+    const { textTracks } = this.$state;
+    textTracks.set(this.#media.textTracks.toArray());
+    this.dispatch("text-tracks-change", {
+      detail: textTracks(),
+      trigger: event
+    });
+  }
+  #onTextTrackModeChange(event) {
+    if (event) this.#satisfyRequest("media-text-track-change-request", event);
+    const current = this.#media.textTracks.selected, { textTrack } = this.$state;
+    if (textTrack() !== current) {
+      textTrack.set(current);
+      this.dispatch("text-track-change", {
+        detail: current,
+        trigger: event
+      });
+    }
+  }
+  #onAudioTracksChange(event) {
+    const { audioTracks } = this.$state;
+    audioTracks.set(this.#media.audioTracks.toArray());
+    this.dispatch("audio-tracks-change", {
+      detail: audioTracks(),
+      trigger: event
+    });
+  }
+  #onAudioTrackChange(event) {
+    const { audioTrack } = this.$state;
+    audioTrack.set(this.#media.audioTracks.selected);
+    if (event) this.#satisfyRequest("media-audio-track-change-request", event);
+    this.dispatch("audio-track-change", {
+      detail: audioTrack(),
+      trigger: event
+    });
+  }
+  #onQualitiesChange(event) {
+    const { qualities } = this.$state;
+    qualities.set(this.#media.qualities.toArray());
+    this.dispatch("qualities-change", {
+      detail: qualities(),
+      trigger: event
+    });
+  }
+  #onQualityChange(event) {
+    const { quality } = this.$state;
+    quality.set(this.#media.qualities.selected);
+    if (event) this.#satisfyRequest("media-quality-change-request", event);
+    this.dispatch("quality-change", {
+      detail: quality(),
+      trigger: event
+    });
+  }
+  #onAutoQualityChange() {
+    const { qualities } = this.#media, isAuto = qualities.auto;
+    this.$state.autoQuality.set(isAuto);
+    if (!isAuto) this.#stopWatchingQualityResize();
+  }
+  #stopQualityResizeEffect = null;
+  #watchQualityResize() {
+    this.#stopWatchingQualityResize();
+    this.#stopQualityResizeEffect = effect(() => {
+      const { qualities } = this.#media, { mediaWidth, mediaHeight } = this.$state, w = mediaWidth(), h = mediaHeight();
+      if (w === 0 || h === 0) return;
+      let selectedQuality = null, minScore = Infinity;
+      for (const quality of qualities) {
+        const score = Math.abs(quality.width - w) + Math.abs(quality.height - h);
+        if (score < minScore) {
+          minScore = score;
+          selectedQuality = quality;
+        }
+      }
+      if (selectedQuality) {
+        qualities[ListSymbol.select](
+          selectedQuality,
+          true,
+          new DOMEvent("resize", { detail: { width: w, height: h } })
+        );
+      }
+    });
+  }
+  #stopWatchingQualityResize() {
+    this.#stopQualityResizeEffect?.();
+    this.#stopQualityResizeEffect = null;
+  }
+  #onCanSetQualityChange() {
+    this.$state.canSetQuality.set(!this.#media.qualities.readonly);
+  }
+  #watchCanSetVolume() {
+    const { canSetVolume, isGoogleCastConnected } = this.$state;
+    if (isGoogleCastConnected()) {
+      canSetVolume.set(false);
+      return;
+    }
+    canChangeVolume().then(canSetVolume.set);
+  }
+  ["provider-change"](event) {
+    const prevProvider = this.#media.$provider(), newProvider = event.detail;
+    if (prevProvider?.type === newProvider?.type) return;
+    prevProvider?.destroy?.();
+    prevProvider?.scope?.dispose();
+    this.#media.$provider.set(event.detail);
+    if (prevProvider && event.detail === null) {
+      this.#resetMediaState(event);
+    }
+  }
+  ["provider-loader-change"](event) {
+    {
+      this.#media.logger?.infoGroup(`Loader change \`${event.detail?.constructor.name}\``).labelledLog("Event", event).dispatch();
+    }
+  }
+  ["auto-play"](event) {
+    this.$state.autoPlayError.set(null);
+  }
+  ["auto-play-fail"](event) {
+    this.$state.autoPlayError.set(event.detail);
+    this.#resetTracking();
+  }
+  ["can-load"](event) {
+    this.$state.canLoad.set(true);
+    this.#trackedEvents.set("can-load", event);
+    this.#media.textTracks[TextTrackSymbol.canLoad]();
+    this.#satisfyRequest("media-start-loading", event);
+  }
+  ["can-load-poster"](event) {
+    this.$state.canLoadPoster.set(true);
+    this.#trackedEvents.set("can-load-poster", event);
+    this.#satisfyRequest("media-poster-start-loading", event);
+  }
+  ["media-type-change"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const viewType = this.$state.viewType();
+    this.$state.mediaType.set(event.detail);
+    const providedViewType = this.$state.providedViewType(), currentViewType = providedViewType === "unknown" ? event.detail : providedViewType;
+    if (viewType !== currentViewType) {
+      if (IS_SERVER) {
+        this.$state.inferredViewType.set(currentViewType);
+      } else {
+        setTimeout(() => {
+          requestAnimationFrame(() => {
+            if (!this.scope) return;
+            this.$state.inferredViewType.set(event.detail);
+            this.dispatch("view-type-change", {
+              detail: currentViewType,
+              trigger: event
+            });
+          });
+        }, 0);
+      }
+    }
+  }
+  ["stream-type-change"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const { streamType, inferredStreamType } = this.$state;
+    inferredStreamType.set(event.detail);
+    event.detail = streamType();
+  }
+  ["rate-change"](event) {
+    const { storage } = this.#media, { canPlay } = this.$state;
+    this.$state.playbackRate.set(event.detail);
+    this.#satisfyRequest("media-rate-change-request", event);
+    if (canPlay()) {
+      storage?.setPlaybackRate?.(event.detail);
+    }
+  }
+  ["remote-playback-change"](event) {
+    const { remotePlaybackState, remotePlaybackType } = this.$state, { type, state } = event.detail, isConnected = state === "connected";
+    remotePlaybackType.set(type);
+    remotePlaybackState.set(state);
+    const key = type === "airplay" ? "media-airplay-request" : "media-google-cast-request";
+    if (isConnected) {
+      this.#satisfyRequest(key, event);
+    } else {
+      const requestEvent = this.#request.queue.peek(key);
+      if (requestEvent) {
+        event.request = requestEvent;
+        event.triggers.add(requestEvent);
+      }
+    }
+  }
+  ["sources-change"](event) {
+    const prevSources = this.$state.sources(), newSources = event.detail;
+    this.$state.sources.set(newSources);
+    this.#onSourceQualitiesChange(prevSources, newSources, event);
+  }
+  #onSourceQualitiesChange(prevSources, newSources, trigger) {
+    let { qualities } = this.#media, added = false, removed = false;
+    for (const prevSrc of prevSources) {
+      if (!isVideoQualitySrc(prevSrc)) continue;
+      const exists = newSources.some((s) => s.src === prevSrc.src);
+      if (!exists) {
+        const quality = qualities.getBySrc(prevSrc.src);
+        if (quality) {
+          qualities[ListSymbol.remove](quality, trigger);
+          removed = true;
+        }
+      }
+    }
+    if (removed && !qualities.length) {
+      this.$state.savedState.set(null);
+      qualities[ListSymbol.reset](trigger);
+    }
+    for (const src of newSources) {
+      if (!isVideoQualitySrc(src) || qualities.getBySrc(src.src)) continue;
+      const quality = {
+        id: src.id ?? src.height + "p",
+        bitrate: null,
+        codec: null,
+        ...src,
+        selected: false
+      };
+      qualities[ListSymbol.add](quality, trigger);
+      added = true;
+    }
+    if (added && !qualities[QualitySymbol.enableAuto]) {
+      this.#watchQualityResize();
+      qualities[QualitySymbol.enableAuto] = this.#watchQualityResize.bind(this);
+      qualities[QualitySymbol.setAuto](true, trigger);
+    }
+  }
+  ["source-change"](event) {
+    event.isQualityChange = event.originEvent?.type === "quality-change";
+    const source = event.detail;
+    this.#resetMediaState(event, event.isQualityChange);
+    this.#trackedEvents.set(event.type, event);
+    this.$state.source.set(source);
+    this.el?.setAttribute("aria-busy", "true");
+    {
+      this.#media.logger?.infoGroup("\u{1F4FC} Media source change").labelledLog("Source", source).dispatch();
+    }
+  }
+  #resetMediaState(event, isSourceQualityChange = false) {
+    const { audioTracks, qualities } = this.#media;
+    if (!isSourceQualityChange) {
+      this.#playedIntervals = [];
+      this.#playedInterval = [-1, -1];
+      audioTracks[ListSymbol.reset](event);
+      qualities[ListSymbol.reset](event);
+      softResetMediaState(this.$state, isSourceQualityChange);
+      this.#resetTracking();
+      return;
+    }
+    softResetMediaState(this.$state, isSourceQualityChange);
+    this.#resetTracking();
+  }
+  ["abort"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const canLoadEvent = this.#trackedEvents.get("can-load");
+    if (canLoadEvent && !event.triggers.hasType("can-load")) {
+      event.triggers.add(canLoadEvent);
+    }
+  }
+  ["load-start"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+  }
+  ["error"](event) {
+    this.$state.error.set(event.detail);
+    const abortEvent = this.#trackedEvents.get("abort");
+    if (abortEvent) event.triggers.add(abortEvent);
+    {
+      this.#media.logger?.errorGroup("Media Error").labelledLog("Error", event.detail).labelledLog("Event", event).labelledLog("Context", this.#media).dispatch();
+    }
+  }
+  ["loaded-metadata"](event) {
+    const loadStartEvent = this.#trackedEvents.get("load-start");
+    if (loadStartEvent) event.triggers.add(loadStartEvent);
+  }
+  ["loaded-data"](event) {
+    const loadStartEvent = this.#trackedEvents.get("load-start");
+    if (loadStartEvent) event.triggers.add(loadStartEvent);
+  }
+  ["can-play"](event) {
+    const loadedMetadata = this.#trackedEvents.get("loaded-metadata");
+    if (loadedMetadata) event.triggers.add(loadedMetadata);
+    this.#onCanPlayDetail(event.detail);
+    this.el?.setAttribute("aria-busy", "false");
+  }
+  ["can-play-through"](event) {
+    this.#onCanPlayDetail(event.detail);
+    const canPlay = this.#trackedEvents.get("can-play");
+    if (canPlay) event.triggers.add(canPlay);
+  }
+  #onCanPlayDetail(detail) {
+    const { seekable, buffered, intrinsicDuration, canPlay } = this.$state;
+    canPlay.set(true);
+    buffered.set(detail.buffered);
+    seekable.set(detail.seekable);
+    const seekableEnd = getTimeRangesEnd(detail.seekable) ?? Infinity;
+    intrinsicDuration.set(seekableEnd);
+  }
+  ["duration-change"](event) {
+    const { live, intrinsicDuration, providedDuration, clipEndTime, ended } = this.$state, time = event.detail;
+    if (!live()) {
+      const duration = !Number.isNaN(time) ? time : 0;
+      intrinsicDuration.set(duration);
+      if (ended()) this.#onEndPrecisionChange(event);
+    }
+    if (providedDuration() > 0 || clipEndTime() > 0) {
+      event.stopImmediatePropagation();
+    }
+  }
+  ["progress"](event) {
+    const { buffered, seekable } = this.$state, { buffered: newBuffered, seekable: newSeekable } = event.detail, newBufferedEnd = getTimeRangesEnd(newBuffered), hasBufferedLengthChanged = newBuffered.length !== buffered().length, hasBufferedEndChanged = newBufferedEnd !== getTimeRangesEnd(buffered()), newSeekableEnd = getTimeRangesEnd(newSeekable), hasSeekableLengthChanged = newSeekable.length !== seekable().length, hasSeekableEndChanged = newSeekableEnd !== getTimeRangesEnd(seekable());
+    if (hasBufferedLengthChanged || hasBufferedEndChanged) {
+      buffered.set(newBuffered);
+    }
+    if (hasSeekableLengthChanged || hasSeekableEndChanged) {
+      seekable.set(newSeekable);
+    }
+  }
+  ["play"](event) {
+    const {
+      paused,
+      autoPlayError,
+      ended,
+      autoPlaying,
+      playsInline,
+      pointer,
+      muted,
+      viewType,
+      live,
+      userBehindLiveEdge
+    } = this.$state;
+    this.#resetPlaybackIfNeeded();
+    if (!paused()) {
+      event.stopImmediatePropagation();
+      return;
+    }
+    event.autoPlay = autoPlaying();
+    const waitingEvent = this.#trackedEvents.get("waiting");
+    if (waitingEvent) event.triggers.add(waitingEvent);
+    this.#satisfyRequest("media-play-request", event);
+    this.#trackedEvents.set("play", event);
+    paused.set(false);
+    autoPlayError.set(null);
+    if (event.autoPlay) {
+      this.handle(
+        this.createEvent("auto-play", {
+          detail: { muted: muted() },
+          trigger: event
+        })
+      );
+      autoPlaying.set(false);
+    }
+    if (ended() || this.#request.replaying) {
+      this.#request.replaying = false;
+      ended.set(false);
+      this.handle(this.createEvent("replay", { trigger: event }));
+    }
+    if (!playsInline() && viewType() === "video" && pointer() === "coarse") {
+      this.#media.remote.enterFullscreen("prefer-media", event);
+    }
+    if (live() && !userBehindLiveEdge()) {
+      this.#media.remote.seekToLiveEdge(event);
+    }
+  }
+  #resetPlaybackIfNeeded(trigger) {
+    const provider = peek(this.#media.$provider);
+    if (!provider) return;
+    const { ended, seekableStart, clipEndTime, currentTime, realCurrentTime, duration } = this.$state;
+    const shouldReset = ended() || realCurrentTime() < seekableStart() || clipEndTime() > 0 && realCurrentTime() >= clipEndTime() || Math.abs(currentTime() - duration()) < 0.1;
+    if (shouldReset) {
+      this.dispatch("media-seek-request", {
+        detail: seekableStart(),
+        trigger
+      });
+    }
+    return shouldReset;
+  }
+  ["play-fail"](event) {
+    const { muted, autoPlaying } = this.$state;
+    const playEvent = this.#trackedEvents.get("play");
+    if (playEvent) event.triggers.add(playEvent);
+    this.#satisfyRequest("media-play-request", event);
+    const { paused, playing } = this.$state;
+    paused.set(true);
+    playing.set(false);
+    this.#resetTracking();
+    this.#trackedEvents.set("play-fail", event);
+    if (event.autoPlay) {
+      this.handle(
+        this.createEvent("auto-play-fail", {
+          detail: {
+            muted: muted(),
+            error: event.detail
+          },
+          trigger: event
+        })
+      );
+      autoPlaying.set(false);
+    }
+  }
+  ["playing"](event) {
+    const playEvent = this.#trackedEvents.get("play"), seekedEvent = this.#trackedEvents.get("seeked");
+    if (playEvent) event.triggers.add(playEvent);
+    else if (seekedEvent) event.triggers.add(seekedEvent);
+    setTimeout(() => this.#resetTracking(), 0);
+    const {
+      paused,
+      playing,
+      live,
+      liveSyncPosition,
+      seekableEnd,
+      started,
+      currentTime,
+      seeking,
+      ended
+    } = this.$state;
+    paused.set(false);
+    playing.set(true);
+    seeking.set(false);
+    ended.set(false);
+    if (this.#request.looping) {
+      this.#request.looping = false;
+      return;
+    }
+    if (live() && !started() && currentTime() === 0) {
+      const end = liveSyncPosition() ?? seekableEnd() - 2;
+      if (Number.isFinite(end)) this.#media.$provider().setCurrentTime(end);
+    }
+    this["started"](event);
+  }
+  ["started"](event) {
+    const { started } = this.$state;
+    if (!started()) {
+      started.set(true);
+      this.handle(this.createEvent("started", { trigger: event }));
+    }
+  }
+  ["pause"](event) {
+    if (!this.el?.isConnected) {
+      this.#isPlayingOnDisconnect = true;
+    }
+    this.#satisfyRequest("media-pause-request", event);
+    const seekedEvent = this.#trackedEvents.get("seeked");
+    if (seekedEvent) event.triggers.add(seekedEvent);
+    const { paused, playing } = this.$state;
+    paused.set(true);
+    playing.set(false);
+    if (this.#clipEnded) {
+      setTimeout(() => {
+        this.handle(this.createEvent("end", { trigger: event }));
+        this.#clipEnded = false;
+      }, 0);
+    }
+    this.#resetTracking();
+  }
+  ["time-change"](event) {
+    if (this.#request.looping) {
+      event.stopImmediatePropagation();
+      return;
+    }
+    let { waiting, played, clipEndTime, realCurrentTime, currentTime } = this.$state, newTime = event.detail, endTime = clipEndTime();
+    realCurrentTime.set(newTime);
+    this.#updatePlayed();
+    waiting.set(false);
+    for (const track of this.#media.textTracks) {
+      track[TextTrackSymbol.updateActiveCues](newTime, event);
+    }
+    if (endTime > 0 && newTime >= endTime) {
+      this.#clipEnded = true;
+      this.dispatch("media-pause-request", { trigger: event });
+    }
+    this.#saveTime();
+    this.dispatch("time-update", {
+      detail: { currentTime: currentTime(), played: played() },
+      trigger: event
+    });
+  }
+  #updatePlayed() {
+    const { currentTime, played, paused } = this.$state;
+    if (paused()) return;
+    this.#playedInterval = updateTimeIntervals(
+      this.#playedIntervals,
+      this.#playedInterval,
+      currentTime()
+    );
+    played.set(new TimeRange(this.#playedIntervals));
+  }
+  // Called to update time again incase duration precision has changed.
+  #onEndPrecisionChange(trigger) {
+    const { clipStartTime, clipEndTime, duration } = this.$state, isClipped = clipStartTime() > 0 || clipEndTime() > 0;
+    if (isClipped) return;
+    this.handle(
+      this.createEvent("time-change", {
+        detail: duration(),
+        trigger
+      })
+    );
+  }
+  #saveTime() {
+    const { storage } = this.#media, { canPlay, realCurrentTime } = this.$state;
+    if (canPlay()) {
+      storage?.setTime?.(realCurrentTime());
+    }
+  }
+  ["audio-gain-change"](event) {
+    const { storage } = this.#media, { canPlay, audioGain } = this.$state;
+    audioGain.set(event.detail);
+    this.#satisfyRequest("media-audio-gain-change-request", event);
+    if (canPlay()) storage?.setAudioGain?.(audioGain());
+  }
+  ["volume-change"](event) {
+    const { storage } = this.#media, { volume, muted, canPlay } = this.$state, detail = event.detail;
+    volume.set(detail.volume);
+    muted.set(detail.muted || detail.volume === 0);
+    this.#satisfyRequest("media-volume-change-request", event);
+    this.#satisfyRequest(detail.muted ? "media-mute-request" : "media-unmute-request", event);
+    if (canPlay()) {
+      storage?.setVolume?.(volume());
+      storage?.setMuted?.(muted());
+    }
+  }
+  ["seeking"] = functionThrottle(
+    (event) => {
+      const { seeking, realCurrentTime, paused } = this.$state;
+      seeking.set(true);
+      realCurrentTime.set(event.detail);
+      this.#satisfyRequest("media-seeking-request", event);
+      if (paused()) {
+        this.#waitingTrigger = event;
+        this.#fireWaiting();
+      }
+      this.#playedInterval = [-1, -1];
+    },
+    150,
+    { leading: true }
+  );
+  ["seeked"](event) {
+    const { seeking, currentTime, realCurrentTime, paused, seekableEnd, ended, live } = this.$state;
+    if (this.#request.seeking) {
+      seeking.set(true);
+      event.stopImmediatePropagation();
+    } else if (seeking()) {
+      const waitingEvent = this.#trackedEvents.get("waiting");
+      if (waitingEvent) event.triggers.add(waitingEvent);
+      const seekingEvent = this.#trackedEvents.get("seeking");
+      if (seekingEvent && !event.triggers.has(seekingEvent)) {
+        event.triggers.add(seekingEvent);
+      }
+      if (paused()) this.#stopWaiting();
+      seeking.set(false);
+      realCurrentTime.set(event.detail);
+      this.#satisfyRequest("media-seek-request", event);
+      const origin = event?.originEvent;
+      if (origin?.isTrusted && !(origin instanceof MessageEvent) && !/seek/.test(origin.type)) {
+        this["started"](event);
+      }
+    }
+    if (!live()) {
+      if (Math.floor(currentTime()) !== Math.floor(seekableEnd())) {
+        ended.set(false);
+      } else {
+        this.end(event);
+      }
+    }
+  }
+  ["waiting"](event) {
+    if (this.#firingWaiting || this.#request.seeking) return;
+    event.stopImmediatePropagation();
+    this.#waitingTrigger = event;
+    this.#fireWaiting();
+  }
+  #fireWaiting = functionDebounce(() => {
+    if (!this.#waitingTrigger) return;
+    this.#firingWaiting = true;
+    const { waiting, playing } = this.$state;
+    waiting.set(true);
+    playing.set(false);
+    const event = this.createEvent("waiting", { trigger: this.#waitingTrigger });
+    this.#trackedEvents.set("waiting", event);
+    this.dispatch(event);
+    this.#waitingTrigger = void 0;
+    this.#firingWaiting = false;
+  }, 300);
+  ["end"](event) {
+    const { loop, ended } = this.$state;
+    if (!loop() && ended()) return;
+    if (loop()) {
+      setTimeout(() => {
+        requestAnimationFrame(() => {
+          this.#resetPlaybackIfNeeded(event);
+          this.dispatch("media-loop-request", { trigger: event });
+        });
+      }, 10);
+      return;
+    }
+    setTimeout(() => this.#onEnded(event), 0);
+  }
+  #onEnded(event) {
+    const { storage } = this.#media, { paused, seeking, ended, duration } = this.$state;
+    this.#onEndPrecisionChange(event);
+    if (!paused()) {
+      this.dispatch("pause", { trigger: event });
+    }
+    if (seeking()) {
+      this.dispatch("seeked", {
+        detail: duration(),
+        trigger: event
+      });
+    }
+    ended.set(true);
+    this.#resetTracking();
+    storage?.setTime?.(duration(), true);
+    this.dispatch("ended", {
+      trigger: event
+    });
+  }
+  #stopWaiting() {
+    this.#fireWaiting.cancel();
+    this.$state.waiting.set(false);
+  }
+  ["fullscreen-change"](event) {
+    const isFullscreen = event.detail;
+    this.$state.fullscreen.set(isFullscreen);
+    this.#satisfyRequest(
+      isFullscreen ? "media-enter-fullscreen-request" : "media-exit-fullscreen-request",
+      event
+    );
+  }
+  ["fullscreen-error"](event) {
+    this.#satisfyRequest("media-enter-fullscreen-request", event);
+    this.#satisfyRequest("media-exit-fullscreen-request", event);
+  }
+  ["orientation-change"](event) {
+    const isLocked = event.detail.lock;
+    this.#satisfyRequest(
+      isLocked ? "media-orientation-lock-request" : "media-orientation-unlock-request",
+      event
+    );
+  }
+  ["picture-in-picture-change"](event) {
+    const isPiP = event.detail;
+    this.$state.pictureInPicture.set(isPiP);
+    this.#satisfyRequest(isPiP ? "media-enter-pip-request" : "media-exit-pip-request", event);
+  }
+  ["picture-in-picture-error"](event) {
+    this.#satisfyRequest("media-enter-pip-request", event);
+    this.#satisfyRequest("media-exit-pip-request", event);
+  }
+  ["title-change"](event) {
+    if (!event.trigger) return;
+    event.stopImmediatePropagation();
+    this.$state.inferredTitle.set(event.detail);
+  }
+  ["poster-change"](event) {
+    if (!event.trigger) return;
+    event.stopImmediatePropagation();
+    this.$state.inferredPoster.set(event.detail);
+  }
+}
+
+class MediaStateSync extends MediaPlayerController {
+  onSetup() {
+    this.#init();
+    if (IS_SERVER) return;
+    effect(this.#watchLogLevel.bind(this));
+    const effects = [
+      this.#watchMetadata,
+      this.#watchAutoplay,
+      this.#watchClipStartTime,
+      this.#watchClipEndTime,
+      this.#watchControls,
+      this.#watchCrossOrigin,
+      this.#watchDuration,
+      this.#watchLive,
+      this.#watchLiveEdge,
+      this.#watchLiveTolerance,
+      this.#watchLoop,
+      this.#watchPlaysInline,
+      this.#watchPoster,
+      this.#watchProvidedTypes,
+      this.#watchTitle
+    ];
+    for (const callback of effects) {
+      effect(callback.bind(this));
+    }
+  }
+  #init() {
+    const providedProps = {
+      duration: "providedDuration",
+      loop: "providedLoop",
+      poster: "providedPoster",
+      streamType: "providedStreamType",
+      title: "providedTitle",
+      viewType: "providedViewType"
+    };
+    const skip = /* @__PURE__ */ new Set([
+      "currentTime",
+      "paused",
+      "playbackRate",
+      "volume"
+    ]);
+    for (const prop of Object.keys(this.$props)) {
+      if (skip.has(prop)) continue;
+      this.$state[providedProps[prop] ?? prop]?.set(this.$props[prop]());
+    }
+    this.$state.muted.set(this.$props.muted() || this.$props.volume() === 0);
+  }
+  // Sync "provided" props with internal state. Provided props are used to differentiate from
+  // provider inferred values.
+  #watchProvidedTypes() {
+    const { viewType, streamType, title, poster, loop } = this.$props, $state = this.$state;
+    $state.providedPoster.set(poster());
+    $state.providedStreamType.set(streamType());
+    $state.providedViewType.set(viewType());
+    $state.providedTitle.set(title());
+    $state.providedLoop.set(loop());
+  }
+  #watchLogLevel() {
+    this.$state.logLevel.set(this.$props.logLevel());
+  }
+  #watchMetadata() {
+    const { artist, artwork } = this.$props;
+    this.$state.artist.set(artist());
+    this.$state.artwork.set(artwork());
+  }
+  #watchTitle() {
+    const { title } = this.$state;
+    this.dispatch("title-change", { detail: title() });
+  }
+  #watchAutoplay() {
+    const autoPlay = this.$props.autoPlay() || this.$props.autoplay();
+    this.$state.autoPlay.set(autoPlay);
+    this.dispatch("auto-play-change", { detail: autoPlay });
+  }
+  #watchLoop() {
+    const loop = this.$state.loop();
+    this.dispatch("loop-change", { detail: loop });
+  }
+  #watchControls() {
+    const controls = this.$props.controls();
+    this.$state.controls.set(controls);
+  }
+  #watchPoster() {
+    const { poster } = this.$state;
+    this.dispatch("poster-change", { detail: poster() });
+  }
+  #watchCrossOrigin() {
+    const crossOrigin = this.$props.crossOrigin() ?? this.$props.crossorigin(), value = crossOrigin === true ? "" : crossOrigin;
+    this.$state.crossOrigin.set(value);
+  }
+  #watchDuration() {
+    const { duration } = this.$props;
+    this.dispatch("media-duration-change-request", {
+      detail: duration()
+    });
+  }
+  #watchPlaysInline() {
+    const inline = this.$props.playsInline() || this.$props.playsinline();
+    this.$state.playsInline.set(inline);
+    this.dispatch("plays-inline-change", { detail: inline });
+  }
+  #watchClipStartTime() {
+    const { clipStartTime } = this.$props;
+    this.dispatch("media-clip-start-change-request", {
+      detail: clipStartTime()
+    });
+  }
+  #watchClipEndTime() {
+    const { clipEndTime } = this.$props;
+    this.dispatch("media-clip-end-change-request", {
+      detail: clipEndTime()
+    });
+  }
+  #watchLive() {
+    this.dispatch("live-change", { detail: this.$state.live() });
+  }
+  #watchLiveTolerance() {
+    this.$state.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());
+    this.$state.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());
+  }
+  #watchLiveEdge() {
+    this.dispatch("live-edge-change", { detail: this.$state.liveEdge() });
+  }
+}
+
+const actions = ["play", "pause", "seekforward", "seekbackward", "seekto"];
+class NavigatorMediaSession extends MediaPlayerController {
+  onConnect() {
+    effect(this.#onMetadataChange.bind(this));
+    effect(this.#onPlaybackStateChange.bind(this));
+    const handleAction = this.#handleAction.bind(this);
+    for (const action of actions) {
+      navigator.mediaSession.setActionHandler(action, handleAction);
+    }
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  #onDisconnect() {
+    for (const action of actions) {
+      navigator.mediaSession.setActionHandler(action, null);
+    }
+  }
+  #onMetadataChange() {
+    const { title, artist, artwork, poster } = this.$state;
+    navigator.mediaSession.metadata = new MediaMetadata({
+      title: title(),
+      artist: artist(),
+      artwork: artwork() ?? [{ src: poster() }]
+    });
+  }
+  #onPlaybackStateChange() {
+    const { canPlay, paused } = this.$state;
+    navigator.mediaSession.playbackState = !canPlay() ? "none" : paused() ? "paused" : "playing";
+  }
+  #handleAction(details) {
+    const trigger = new DOMEvent(`media-session-action`, { detail: details });
+    switch (details.action) {
+      case "play":
+        this.dispatch("media-play-request", { trigger });
+        break;
+      case "pause":
+        this.dispatch("media-pause-request", { trigger });
+        break;
+      case "seekto":
+      case "seekforward":
+      case "seekbackward":
+        this.dispatch("media-seek-request", {
+          detail: isNumber(details.seekTime) ? details.seekTime : this.$state.currentTime() + (details.seekOffset ?? (details.action === "seekforward" ? 10 : -10)),
+          trigger
+        });
+        break;
+    }
+  }
+}
+
+const LOCAL_STORAGE_KEY = "@vidstack/log-colors";
+const savedColors = init();
+function getLogColor(key) {
+  return savedColors.get(key);
+}
+function saveLogColor(key, { color = generateColor(), overwrite = false } = {}) {
+  if (!savedColors.has(key) || overwrite) {
+    savedColors.set(key, color);
+    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Object.entries(savedColors)));
+  }
+}
+function generateColor() {
+  return `hsl(${Math.random() * 360}, 55%, 70%)`;
+}
+function init() {
+  let colors;
+  try {
+    colors = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));
+  } catch {
+  }
+  return new Map(Object.entries(colors ?? {}));
+}
+
+const LogLevelValue = Object.freeze({
+  silent: 0,
+  error: 1,
+  warn: 2,
+  info: 3,
+  debug: 4
+});
+const LogLevelColor = Object.freeze({
+  silent: "white",
+  error: "hsl(6, 58%, 50%)",
+  warn: "hsl(51, 58%, 50%)",
+  info: "hsl(219, 58%, 50%)",
+  debug: "hsl(280, 58%, 50%)"
+});
+
+const s = 1e3;
+const m = s * 60;
+const h = m * 60;
+const d = h * 24;
+function ms(val) {
+  const msAbs = Math.abs(val);
+  if (msAbs >= d) {
+    return Math.round(val / d) + "d";
+  }
+  if (msAbs >= h) {
+    return Math.round(val / h) + "h";
+  }
+  if (msAbs >= m) {
+    return Math.round(val / m) + "m";
+  }
+  if (msAbs >= s) {
+    return Math.round(val / s) + "s";
+  }
+  return round(val, 2) + "ms";
+}
+
+class LogPrinter extends ViewController {
+  #level = "warn" ;
+  #lastLogged;
+  /**
+   * The current log level.
+   */
+  get logLevel() {
+    return this.#level ;
+  }
+  set logLevel(level) {
+    this.#level = level;
+  }
+  onConnect() {
+    this.listen("vds-log", (event) => {
+      event.stopPropagation();
+      const element = event.path?.[0] ?? (event.target instanceof ViewController ? event.target.el : event.target), eventTargetName = element?.$$COMPONENT_NAME?.replace(/^_/, "").replace(/Instance$/, "") ?? element?.tagName.toLowerCase() ?? "unknown";
+      const { level = "warn", data } = event.detail ?? {};
+      if (LogLevelValue[this.#level] < LogLevelValue[level]) {
+        return;
+      }
+      saveLogColor(eventTargetName);
+      const hint = data?.length === 1 && isGroupedLog(data[0]) ? data[0].title : isString(data?.[0]) ? data[0] : "";
+      console.groupCollapsed(
+        `%c${level.toUpperCase()}%c ${eventTargetName}%c ${hint.slice(0, 50)}${hint.length > 50 ? "..." : ""}`,
+        `background: ${LogLevelColor[level]}; color: white; padding: 1.5px 2.2px; border-radius: 2px; font-size: 11px;`,
+        `color: ${getLogColor(eventTargetName)}; padding: 4px 0px; font-size: 11px;`,
+        "color: gray; font-size: 11px; padding-left: 4px;"
+      );
+      if (data?.length === 1 && isGroupedLog(data[0])) {
+        if (element) data[0].logs.unshift({ label: "Element", data: [element] });
+        printGroup(level, data[0]);
+      } else if (data) {
+        print(level, ...data);
+      }
+      this.#printTimeDiff();
+      printStackTrace();
+      console.groupEnd();
+    });
+    onDispose(() => {
+      this.#lastLogged = void 0;
+    });
+  }
+  #printTimeDiff() {
+    labelledPrint("Time since last log", this.#calcLastLogTimeDiff());
+  }
+  #calcLastLogTimeDiff() {
+    const time = performance.now();
+    const diff = time - (this.#lastLogged ?? (this.#lastLogged = performance.now()));
+    this.#lastLogged = time;
+    return ms(diff);
+  }
+}
+function print(level, ...data) {
+  console[level](...data);
+}
+function labelledPrint(label, ...data) {
+  console.log(`%c${label}:`, "color: gray", ...data);
+}
+function printStackTrace() {
+  console.groupCollapsed("%cStack Trace", "color: gray");
+  console.trace();
+  console.groupEnd();
+}
+function printGroup(level, groupedLog) {
+  for (const log of groupedLog.logs) {
+    if (isGroupedLog(log)) {
+      console.groupCollapsed(groupedLog.title);
+      printGroup(level, log);
+      console.groupEnd();
+    } else if ("label" in log && !isUndefined(log.label)) {
+      labelledPrint(log.label, ...log.data);
+    } else {
+      print(level, ...log.data);
+    }
+  }
+}
+
+let $keyboard = signal(false);
+if (!IS_SERVER) {
+  listenEvent(document, "pointerdown", () => {
+    $keyboard.set(false);
+  });
+  listenEvent(document, "keydown", (e) => {
+    if (e.metaKey || e.altKey || e.ctrlKey) return;
+    $keyboard.set(true);
+  });
+}
+class FocusVisibleController extends ViewController {
+  #focused = signal(false);
+  onConnect(el) {
+    effect(() => {
+      const events = new EventsController(el);
+      if (!$keyboard()) {
+        this.#focused.set(false);
+        updateFocusAttr(el, false);
+        events.add("pointerenter", this.#onPointerEnter.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this));
+        return;
+      }
+      const active = document.activeElement === el;
+      this.#focused.set(active);
+      updateFocusAttr(el, active);
+      events.add("focus", this.#onFocus.bind(this)).add("blur", this.#onBlur.bind(this));
+    });
+  }
+  focused() {
+    return this.#focused();
+  }
+  #onFocus() {
+    this.#focused.set(true);
+    updateFocusAttr(this.el, true);
+  }
+  #onBlur() {
+    this.#focused.set(false);
+    updateFocusAttr(this.el, false);
+  }
+  #onPointerEnter() {
+    updateHoverAttr(this.el, true);
+  }
+  #onPointerLeave() {
+    updateHoverAttr(this.el, false);
+  }
+}
+function updateFocusAttr(el, isFocused) {
+  setAttribute(el, "data-focus", isFocused);
+  setAttribute(el, "data-hocus", isFocused);
+}
+function updateHoverAttr(el, isHovering) {
+  setAttribute(el, "data-hocus", isHovering);
+  setAttribute(el, "data-hover", isHovering);
+}
+
+class MediaPlayer extends Component {
+  static props = mediaPlayerProps;
+  static state = mediaState;
+  #media;
+  #stateMgr;
+  #requestMgr;
+  canPlayQueue = new RequestQueue();
+  remoteControl;
+  get #provider() {
+    return this.#media.$provider();
+  }
+  get #props() {
+    return this.$props;
+  }
+  constructor() {
+    super();
+    new MediaStateSync();
+    const context = {
+      player: this,
+      qualities: new VideoQualityList(),
+      audioTracks: new AudioTrackList(),
+      storage: null,
+      $provider: signal(null),
+      $providerSetup: signal(false),
+      $props: this.$props,
+      $state: this.$state
+    };
+    {
+      const logPrinter = new LogPrinter();
+      effect(() => {
+        logPrinter.logLevel = this.$props.logLevel();
+      });
+    }
+    context.logger = new Logger();
+    context.remote = this.remoteControl = new MediaRemoteControl(
+      context.logger 
+    );
+    context.remote.setPlayer(this);
+    context.textTracks = new TextTrackList();
+    context.textTracks[TextTrackSymbol.crossOrigin] = this.$state.crossOrigin;
+    context.textRenderers = new TextRenderers(context);
+    context.ariaKeys = {};
+    this.#media = context;
+    provideContext(mediaContext, context);
+    this.orientation = new ScreenOrientationController();
+    new FocusVisibleController();
+    new MediaKeyboardController(context);
+    new MediaEventsLogger(context);
+    const request = new MediaRequestContext();
+    this.#stateMgr = new MediaStateManager(request, context);
+    this.#requestMgr = new MediaRequestManager(this.#stateMgr, request, context);
+    context.delegate = new MediaPlayerDelegate(this.#stateMgr.handle.bind(this.#stateMgr), context);
+    context.notify = context.delegate.notify.bind(context.delegate);
+    if (typeof navigator !== "undefined" && "mediaSession" in navigator) {
+      new NavigatorMediaSession();
+    }
+    new MediaLoadController("load", this.startLoading.bind(this));
+    new MediaLoadController("posterLoad", this.startLoadingPoster.bind(this));
+  }
+  onSetup() {
+    this.#setupMediaAttributes();
+    effect(this.#watchCanPlay.bind(this));
+    effect(this.#watchMuted.bind(this));
+    effect(this.#watchPaused.bind(this));
+    effect(this.#watchVolume.bind(this));
+    effect(this.#watchCurrentTime.bind(this));
+    effect(this.#watchPlaysInline.bind(this));
+    effect(this.#watchPlaybackRate.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-player", "");
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "region");
+    effect(this.#watchStorage.bind(this));
+    if (IS_SERVER) this.#watchTitle();
+    else effect(this.#watchTitle.bind(this));
+    if (IS_SERVER) this.#watchOrientation();
+    else effect(this.#watchOrientation.bind(this));
+    listenEvent(el, "find-media-player", this.#onFindPlayer.bind(this));
+  }
+  onConnect(el) {
+    if (IS_IPHONE) setAttribute(el, "data-iphone", "");
+    const pointerQuery = window.matchMedia("(pointer: coarse)");
+    this.#onPointerChange(pointerQuery);
+    pointerQuery.onchange = this.#onPointerChange.bind(this);
+    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
+    resize.observe(el);
+    effect(this.#onResize.bind(this));
+    this.dispatch("media-player-connect", {
+      detail: this,
+      bubbles: true,
+      composed: true
+    });
+    this.#media.logger.setTarget(el);
+    onDispose(() => {
+      resize.disconnect();
+      pointerQuery.onchange = null;
+      this.#media.logger.setTarget(null);
+    });
+  }
+  onDestroy() {
+    this.#media.player = null;
+    this.canPlayQueue.reset();
+  }
+  #skipTitleUpdate = false;
+  #watchTitle() {
+    const el = this.$el, { title, live, viewType, providedTitle } = this.$state, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media", currentTitle = title();
+    setAttribute(
+      this.el,
+      "aria-label",
+      `${typeText} Player` + (currentTitle ? ` - ${currentTitle}` : "")
+    );
+    if (!IS_SERVER && el?.hasAttribute("title")) {
+      this.#skipTitleUpdate = true;
+      el?.removeAttribute("title");
+    }
+  }
+  #watchOrientation() {
+    const orientation = this.orientation.landscape ? "landscape" : "portrait";
+    this.$state.orientation.set(orientation);
+    setAttribute(this.el, "data-orientation", orientation);
+    this.#onResize();
+  }
+  #watchCanPlay() {
+    if (this.$state.canPlay() && this.#provider) this.canPlayQueue.start();
+    else this.canPlayQueue.stop();
+  }
+  #setupMediaAttributes() {
+    if (MediaPlayer[MEDIA_ATTRIBUTES]) {
+      this.setAttributes(MediaPlayer[MEDIA_ATTRIBUTES]);
+      return;
+    }
+    const $attrs = {
+      "data-load": function() {
+        return this.$props.load();
+      },
+      "data-captions": function() {
+        const track = this.$state.textTrack();
+        return !!track && isTrackCaptionKind(track);
+      },
+      "data-ios-controls": function() {
+        return this.$state.iOSControls();
+      },
+      "data-controls": function() {
+        return this.controls.showing;
+      },
+      "data-buffering": function() {
+        const { canLoad, canPlay, waiting } = this.$state;
+        return canLoad() && (!canPlay() || waiting());
+      },
+      "data-error": function() {
+        const { error } = this.$state;
+        return !!error();
+      },
+      "data-autoplay-error": function() {
+        const { autoPlayError } = this.$state;
+        return !!autoPlayError();
+      }
+    };
+    const alias = {
+      autoPlay: "autoplay",
+      canAirPlay: "can-airplay",
+      canPictureInPicture: "can-pip",
+      pictureInPicture: "pip",
+      playsInline: "playsinline",
+      remotePlaybackState: "remote-state",
+      remotePlaybackType: "remote-type",
+      isAirPlayConnected: "airplay",
+      isGoogleCastConnected: "google-cast"
+    };
+    for (const prop2 of mediaAttributes) {
+      const attrName = "data-" + (alias[prop2] ?? camelToKebabCase(prop2));
+      $attrs[attrName] = function() {
+        return this.$state[prop2]();
+      };
+    }
+    delete $attrs.title;
+    MediaPlayer[MEDIA_ATTRIBUTES] = $attrs;
+    this.setAttributes($attrs);
+  }
+  #onFindPlayer(event) {
+    event.detail(this);
+  }
+  #onResize() {
+    if (IS_SERVER || !this.el) return;
+    const width = this.el.clientWidth, height = this.el.clientHeight;
+    this.$state.width.set(width);
+    this.$state.height.set(height);
+    setStyle(this.el, "--player-width", width + "px");
+    setStyle(this.el, "--player-height", height + "px");
+  }
+  #onPointerChange(queryList) {
+    if (IS_SERVER) return;
+    const pointer = queryList.matches ? "coarse" : "fine";
+    setAttribute(this.el, "data-pointer", pointer);
+    this.$state.pointer.set(pointer);
+    this.#onResize();
+  }
+  /**
+   * The current media provider.
+   */
+  get provider() {
+    return this.#provider;
+  }
+  /**
+   * Media controls settings.
+   */
+  get controls() {
+    return this.#requestMgr.controls;
+  }
+  set controls(controls) {
+    this.#props.controls.set(controls);
+  }
+  /**
+   * Controls the screen orientation of the current browser window and dispatches orientation
+   * change events on the player.
+   */
+  orientation;
+  /**
+   * The title of the current media.
+   */
+  get title() {
+    return peek(this.$state.title);
+  }
+  set title(newTitle) {
+    if (this.#skipTitleUpdate) {
+      this.#skipTitleUpdate = false;
+      return;
+    }
+    this.#props.title.set(newTitle);
+  }
+  /**
+   * A list of all `VideoQuality` objects representing the set of available video renditions.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/video-quality}
+   */
+  get qualities() {
+    return this.#media.qualities;
+  }
+  /**
+   * A list of all `AudioTrack` objects representing the set of available audio tracks.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/audio-tracks}
+   */
+  get audioTracks() {
+    return this.#media.audioTracks;
+  }
+  /**
+   * A list of all `TextTrack` objects representing the set of available text tracks.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/text-tracks}
+   */
+  get textTracks() {
+    return this.#media.textTracks;
+  }
+  /**
+   * Contains text renderers which are responsible for loading, parsing, and rendering text
+   * tracks.
+   */
+  get textRenderers() {
+    return this.#media.textRenderers;
+  }
+  get duration() {
+    return this.$state.duration();
+  }
+  set duration(duration) {
+    this.#props.duration.set(duration);
+  }
+  get paused() {
+    return peek(this.$state.paused);
+  }
+  set paused(paused) {
+    this.#queuePausedUpdate(paused);
+  }
+  #watchPaused() {
+    this.#queuePausedUpdate(this.$props.paused());
+  }
+  #queuePausedUpdate(paused) {
+    if (paused) {
+      this.canPlayQueue.enqueue("paused", () => this.#requestMgr.pause());
+    } else this.canPlayQueue.enqueue("paused", () => this.#requestMgr.play());
+  }
+  get muted() {
+    return peek(this.$state.muted);
+  }
+  set muted(muted) {
+    this.#queueMutedUpdate(muted);
+  }
+  #watchMuted() {
+    this.#queueMutedUpdate(this.$props.muted());
+  }
+  #queueMutedUpdate(muted) {
+    this.canPlayQueue.enqueue("muted", () => {
+      if (this.#provider) this.#provider.setMuted(muted);
+    });
+  }
+  get currentTime() {
+    return peek(this.$state.currentTime);
+  }
+  set currentTime(time) {
+    this.#queueCurrentTimeUpdate(time);
+  }
+  #watchCurrentTime() {
+    this.#queueCurrentTimeUpdate(this.$props.currentTime());
+  }
+  #queueCurrentTimeUpdate(time) {
+    this.canPlayQueue.enqueue("currentTime", () => {
+      const { currentTime } = this.$state;
+      if (time === peek(currentTime)) return;
+      peek(() => {
+        if (!this.#provider) return;
+        const boundedTime = boundTime(time, this.$state);
+        if (Number.isFinite(boundedTime)) {
+          this.#provider.setCurrentTime(boundedTime);
+        }
+      });
+    });
+  }
+  get volume() {
+    return peek(this.$state.volume);
+  }
+  set volume(volume) {
+    this.#queueVolumeUpdate(volume);
+  }
+  #watchVolume() {
+    this.#queueVolumeUpdate(this.$props.volume());
+  }
+  #queueVolumeUpdate(volume) {
+    const clampedVolume = clampNumber(0, volume, 1);
+    this.canPlayQueue.enqueue("volume", () => {
+      if (this.#provider) this.#provider.setVolume(clampedVolume);
+    });
+  }
+  get playbackRate() {
+    return peek(this.$state.playbackRate);
+  }
+  set playbackRate(rate) {
+    this.#queuePlaybackRateUpdate(rate);
+  }
+  #watchPlaybackRate() {
+    this.#queuePlaybackRateUpdate(this.$props.playbackRate());
+  }
+  #queuePlaybackRateUpdate(rate) {
+    this.canPlayQueue.enqueue("rate", () => {
+      if (this.#provider) this.#provider.setPlaybackRate?.(rate);
+    });
+  }
+  #watchPlaysInline() {
+    this.#queuePlaysInlineUpdate(this.$props.playsInline());
+  }
+  #queuePlaysInlineUpdate(inline) {
+    this.canPlayQueue.enqueue("playsinline", () => {
+      if (this.#provider) this.#provider.setPlaysInline?.(inline);
+    });
+  }
+  #watchStorage() {
+    let storageValue = this.$props.storage(), storage = isString(storageValue) ? new LocalMediaStorage() : storageValue;
+    if (storage?.onChange) {
+      const { source } = this.$state, playerId = isString(storageValue) ? storageValue : this.el?.id, mediaId = computed(this.#computeMediaId.bind(this));
+      effect(() => storage.onChange(source(), mediaId(), playerId || void 0));
+    }
+    this.#media.storage = storage;
+    this.#media.textTracks.setStorage(storage);
+    onDispose(() => {
+      storage?.onDestroy?.();
+      this.#media.storage = null;
+      this.#media.textTracks.setStorage(null);
+    });
+  }
+  #computeMediaId() {
+    const { clipStartTime, clipEndTime } = this.$props, { source } = this.$state, src = source();
+    return src.src ? `${src.src}:${clipStartTime()}:${clipEndTime()}` : null;
+  }
+  /**
+   * Begins/resumes playback of the media. If this method is called programmatically before the
+   * user has interacted with the player, the promise may be rejected subject to the browser's
+   * autoplay policies. This method will throw if called before media is ready for playback.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play}
+   */
+  async play(trigger) {
+    return this.#requestMgr.play(trigger);
+  }
+  /**
+   * Pauses playback of the media. This method will throw if called before media is ready for
+   * playback.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause}
+   */
+  async pause(trigger) {
+    return this.#requestMgr.pause(trigger);
+  }
+  /**
+   * Attempts to display the player in fullscreen. The promise will resolve if successful, and
+   * reject if not. This method will throw if any fullscreen API is _not_ currently available.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/fullscreen}
+   */
+  async enterFullscreen(target, trigger) {
+    return this.#requestMgr.enterFullscreen(target, trigger);
+  }
+  /**
+   * Attempts to display the player inline by exiting fullscreen. This method will throw if any
+   * fullscreen API is _not_ currently available.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/fullscreen}
+   */
+  async exitFullscreen(target, trigger) {
+    return this.#requestMgr.exitFullscreen(target, trigger);
+  }
+  /**
+   * Attempts to display the player in picture-in-picture mode. This method will throw if PIP is
+   * not supported. This method will also return a `PictureInPictureWindow` if the current
+   * provider supports it.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
+   */
+  enterPictureInPicture(trigger) {
+    return this.#requestMgr.enterPictureInPicture(trigger);
+  }
+  /**
+   * Attempts to display the player in inline by exiting picture-in-picture mode. This method
+   * will throw if not supported.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
+   */
+  exitPictureInPicture(trigger) {
+    return this.#requestMgr.exitPictureInPicture(trigger);
+  }
+  /**
+   * Sets the current time to the live edge (i.e., `duration`). This is a no-op for non-live
+   * streams and will throw if called before media is ready for playback.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/live}
+   */
+  seekToLiveEdge(trigger) {
+    this.#requestMgr.seekToLiveEdge(trigger);
+  }
+  /**
+   * Called when media can begin loading. Calling this method will trigger the initial provider
+   * loading process. Calling it more than once has no effect.
+   *
+   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoading(trigger) {
+    this.#media.notify("can-load", void 0, trigger);
+  }
+  /**
+   * Called when the poster image can begin loading. Calling it more than once has no effect.
+   *
+   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoadingPoster(trigger) {
+    this.#media.notify("can-load-poster", void 0, trigger);
+  }
+  /**
+   * Request Apple AirPlay picker to open.
+   */
+  requestAirPlay(trigger) {
+    return this.#requestMgr.requestAirPlay(trigger);
+  }
+  /**
+   * Request Google Cast device picker to open. The Google Cast framework will be loaded if it
+   * hasn't yet.
+   */
+  requestGoogleCast(trigger) {
+    return this.#requestMgr.requestGoogleCast(trigger);
+  }
+  /**
+   * Set the audio gain, amplifying volume and enabling a maximum volume above 100%.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/audio-gain}
+   */
+  setAudioGain(gain, trigger) {
+    return this.#requestMgr.setAudioGain(gain, trigger);
+  }
+  destroy() {
+    super.destroy();
+    this.#media.remote.setPlayer(null);
+    this.dispatch("destroy");
+  }
+}
+const mediaplayer__proto = MediaPlayer.prototype;
+prop(mediaplayer__proto, "canPlayQueue");
+prop(mediaplayer__proto, "remoteControl");
+prop(mediaplayer__proto, "provider");
+prop(mediaplayer__proto, "controls");
+prop(mediaplayer__proto, "orientation");
+prop(mediaplayer__proto, "title");
+prop(mediaplayer__proto, "qualities");
+prop(mediaplayer__proto, "audioTracks");
+prop(mediaplayer__proto, "textTracks");
+prop(mediaplayer__proto, "textRenderers");
+prop(mediaplayer__proto, "duration");
+prop(mediaplayer__proto, "paused");
+prop(mediaplayer__proto, "muted");
+prop(mediaplayer__proto, "currentTime");
+prop(mediaplayer__proto, "volume");
+prop(mediaplayer__proto, "playbackRate");
+method(mediaplayer__proto, "play");
+method(mediaplayer__proto, "pause");
+method(mediaplayer__proto, "enterFullscreen");
+method(mediaplayer__proto, "exitFullscreen");
+method(mediaplayer__proto, "enterPictureInPicture");
+method(mediaplayer__proto, "exitPictureInPicture");
+method(mediaplayer__proto, "seekToLiveEdge");
+method(mediaplayer__proto, "startLoading");
+method(mediaplayer__proto, "startLoadingPoster");
+method(mediaplayer__proto, "requestAirPlay");
+method(mediaplayer__proto, "requestGoogleCast");
+method(mediaplayer__proto, "setAudioGain");
+
+function resolveStreamTypeFromDASHManifest(manifestSrc, requestInit) {
+  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
+    return /type="static"/.test(manifest) ? "on-demand" : "live";
+  });
+}
+function resolveStreamTypeFromHLSManifest(manifestSrc, requestInit) {
+  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
+    const renditionURI = resolveHLSRenditionURI(manifest);
+    if (renditionURI) {
+      return resolveStreamTypeFromHLSManifest(
+        /^https?:/.test(renditionURI) ? renditionURI : new URL(renditionURI, manifestSrc).href,
+        requestInit
+      );
+    }
+    const streamType = /EXT-X-PLAYLIST-TYPE:\s*VOD/.test(manifest) ? "on-demand" : "live";
+    if (streamType === "live" && resolveTargetDuration(manifest) >= 10 && (/#EXT-X-DVR-ENABLED:\s*true/.test(manifest) || manifest.includes("#EXT-X-DISCONTINUITY"))) {
+      return "live:dvr";
+    }
+    return streamType;
+  });
+}
+function resolveHLSRenditionURI(manifest) {
+  const matches = manifest.match(/#EXT-X-STREAM-INF:[^\n]+(\n[^\n]+)*/g);
+  return matches ? matches[0].split("\n")[1].trim() : null;
+}
+function resolveTargetDuration(manifest) {
+  const lines = manifest.split("\n");
+  for (const line of lines) {
+    if (line.startsWith("#EXT-X-TARGETDURATION")) {
+      const duration = parseFloat(line.split(":")[1]);
+      if (!isNaN(duration)) {
+        return duration;
+      }
+    }
+  }
+  return -1;
+}
+
+let warned$1 = /* @__PURE__ */ new Set() ;
+const sourceTypes = /* @__PURE__ */ new Map();
+class SourceSelection {
+  #initialize = false;
+  #loaders;
+  #domSources;
+  #media;
+  #loader;
+  constructor(domSources, media, loader, customLoaders = []) {
+    this.#domSources = domSources;
+    this.#media = media;
+    this.#loader = loader;
+    const DASH_LOADER = new DASHProviderLoader(), HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader(), YOUTUBE_LOADER = new YouTubeProviderLoader(), VIMEO_LOADER = new VimeoProviderLoader(), EMBED_LOADERS = [YOUTUBE_LOADER, VIMEO_LOADER];
+    this.#loaders = computed(() => {
+      const remoteLoader = media.$state.remotePlaybackLoader();
+      const loaders = media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, HLS_LOADER, ...EMBED_LOADERS, ...customLoaders] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, ...EMBED_LOADERS, ...customLoaders];
+      return remoteLoader ? [remoteLoader, ...loaders] : loaders;
+    });
+    const { $state } = media;
+    $state.sources.set(normalizeSrc(media.$props.src()));
+    for (const src of $state.sources()) {
+      const loader2 = this.#loaders().find((loader3) => loader3.canPlay(src));
+      if (!loader2) continue;
+      const mediaType = loader2.mediaType(src);
+      media.$state.source.set(src);
+      media.$state.mediaType.set(mediaType);
+      media.$state.inferredViewType.set(mediaType);
+      this.#loader.set(loader2);
+      this.#initialize = true;
+      break;
+    }
+  }
+  connect() {
+    const loader = this.#loader();
+    if (this.#initialize) {
+      this.#notifySourceChange(this.#media.$state.source(), loader);
+      this.#notifyLoaderChange(loader);
+      this.#initialize = false;
+    }
+    effect(this.#onSourcesChange.bind(this));
+    effect(this.#onSourceChange.bind(this));
+    effect(this.#onSetup.bind(this));
+    effect(this.#onLoadSource.bind(this));
+    effect(this.#onLoadPoster.bind(this));
+  }
+  #onSourcesChange() {
+    this.#media.notify("sources-change", [
+      ...normalizeSrc(this.#media.$props.src()),
+      ...this.#domSources()
+    ]);
+  }
+  #onSourceChange() {
+    const { $state } = this.#media;
+    const sources = $state.sources(), currentSource = peek($state.source), newSource = this.#findNewSource(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;
+    if (noMatch && !warned$1.has(newSource.src) && !peek(this.#loader)) {
+      const source = sources[0];
+      console.warn(
+        `[vidstack] could not find a loader for any of the given media sources, consider providing \`type\`:
+
+--- HTML ---
+
+<media-provider>
+  <source src="${source.src}" type="video/mp4" />
+</media-provider>"
+
+--- React ---
+
+<MediaPlayer src={{ src: "${source.src}", type: "video/mp4" }}>
+
+---
+
+Falling back to fetching source headers...`
+      );
+      warned$1.add(newSource.src);
+    }
+    if (noMatch) {
+      const { crossOrigin } = $state, credentials = getRequestCredentials(crossOrigin()), abort = new AbortController();
+      Promise.all(
+        sources.map(
+          (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
+            method: "HEAD",
+            credentials,
+            signal: abort.signal
+          }).then((res) => {
+            source.type = res.headers.get("content-type") || "??";
+            sourceTypes.set(source.src, source.type);
+            return source;
+          }).catch(() => source) : source
+        )
+      ).then((sources2) => {
+        if (abort.signal.aborted) return;
+        const newSource2 = this.#findNewSource(peek($state.source), sources2);
+        tick();
+        if (!newSource2.src) {
+          this.#media.notify("error", {
+            message: "Failed to load resource.",
+            code: 4
+          });
+        }
+      });
+      return () => abort.abort();
+    }
+    tick();
+  }
+  #findNewSource(currentSource, sources) {
+    let newSource = { src: "", type: "" }, newLoader = null, triggerEvent = new DOMEvent("sources-change", { detail: { sources } }), loaders = this.#loaders(), { started, paused, currentTime, quality, savedState } = this.#media.$state;
+    for (const src of sources) {
+      const loader = loaders.find((loader2) => loader2.canPlay(src));
+      if (loader) {
+        newSource = src;
+        newLoader = loader;
+        break;
+      }
+    }
+    if (isVideoQualitySrc(newSource)) {
+      const currentQuality = quality(), sourceQuality = sources.find((s) => s.src === currentQuality?.src);
+      if (peek(started)) {
+        savedState.set({
+          paused: peek(paused),
+          currentTime: peek(currentTime)
+        });
+      } else {
+        savedState.set(null);
+      }
+      if (sourceQuality) {
+        newSource = sourceQuality;
+        triggerEvent = new DOMEvent("quality-change", {
+          detail: { quality: currentQuality }
+        });
+      }
+    }
+    if (!isSameSrc(currentSource, newSource)) {
+      this.#notifySourceChange(newSource, newLoader, triggerEvent);
+    }
+    if (newLoader !== peek(this.#loader)) {
+      this.#notifyLoaderChange(newLoader, triggerEvent);
+    }
+    return newSource;
+  }
+  #notifySourceChange(src, loader, trigger) {
+    this.#media.notify("source-change", src, trigger);
+    this.#media.notify("media-type-change", loader?.mediaType(src) || "unknown", trigger);
+  }
+  #notifyLoaderChange(loader, trigger) {
+    this.#media.$providerSetup.set(false);
+    this.#media.notify("provider-change", null, trigger);
+    loader && peek(() => loader.preconnect?.(this.#media));
+    this.#loader.set(loader);
+    this.#media.notify("provider-loader-change", loader, trigger);
+  }
+  #onSetup() {
+    const provider = this.#media.$provider();
+    if (!provider || peek(this.#media.$providerSetup)) return;
+    if (this.#media.$state.canLoad()) {
+      scoped(() => provider.setup(), provider.scope);
+      this.#media.$providerSetup.set(true);
+      return;
+    }
+    peek(() => provider.preconnect?.());
+  }
+  #onLoadSource() {
+    if (!this.#media.$providerSetup()) return;
+    const provider = this.#media.$provider(), source = this.#media.$state.source(), crossOrigin = peek(this.#media.$state.crossOrigin), preferNativeHLS = peek(this.#media.$props.preferNativeHLS);
+    if (isSameSrc(provider?.currentSrc, source)) {
+      return;
+    }
+    if (this.#media.$state.canLoad()) {
+      const abort = new AbortController();
+      if (isHLSSrc(source)) {
+        if (preferNativeHLS || !isHLSSupported()) {
+          resolveStreamTypeFromHLSManifest(source.src, {
+            credentials: getRequestCredentials(crossOrigin),
+            signal: abort.signal
+          }).then((streamType) => {
+            this.#media.notify("stream-type-change", streamType);
+          }).catch(noop);
+        }
+      } else if (isDASHSrc(source)) {
+        resolveStreamTypeFromDASHManifest(source.src, {
+          credentials: getRequestCredentials(crossOrigin),
+          signal: abort.signal
+        }).then((streamType) => {
+          this.#media.notify("stream-type-change", streamType);
+        }).catch(noop);
+      } else {
+        this.#media.notify("stream-type-change", "on-demand");
+      }
+      peek(() => {
+        const preload = peek(this.#media.$state.preload);
+        return provider?.loadSource(source, preload).catch((error) => {
+          {
+            this.#media.logger?.errorGroup("[vidstack] failed to load source").labelledLog("Error", error).labelledLog("Source", source).labelledLog("Provider", provider).labelledLog("Media Context", { ...this.#media }).dispatch();
+          }
+        });
+      });
+      return () => abort.abort();
+    }
+    try {
+      isString(source.src) && preconnect(new URL(source.src).origin);
+    } catch (error) {
+      {
+        this.#media.logger?.infoGroup(`Failed to preconnect to source: ${source.src}`).labelledLog("Error", error).dispatch();
+      }
+    }
+  }
+  #onLoadPoster() {
+    const loader = this.#loader(), { providedPoster, source, canLoadPoster } = this.#media.$state;
+    if (!loader || !loader.loadPoster || !source() || !canLoadPoster() || providedPoster()) return;
+    const abort = new AbortController(), trigger = new DOMEvent("source-change", { detail: source });
+    loader.loadPoster(source(), this.#media, abort).then((url) => {
+      this.#media.notify("poster-change", url || "", trigger);
+    }).catch(() => {
+      this.#media.notify("poster-change", "", trigger);
+    });
+    return () => {
+      abort.abort();
+    };
+  }
+}
+function normalizeSrc(src) {
+  return (isArray(src) ? src : [src]).map((src2) => {
+    if (isString(src2)) {
+      return { src: src2, type: inferType(src2) };
+    } else {
+      return { ...src2, type: inferType(src2.src, src2.type) };
+    }
+  });
+}
+function inferType(src, type) {
+  if (isString(type) && type.length) {
+    return type;
+  } else if (isString(src) && sourceTypes.has(src)) {
+    return sourceTypes.get(src);
+  } else if (!type && isHLSSrc({ src, type: "" })) {
+    return "application/x-mpegurl";
+  } else if (!type && isDASHSrc({ src, type: "" })) {
+    return "application/dash+xml";
+  } else if (!isString(src) || src.startsWith("blob:")) {
+    return "video/object";
+  } else if (src.includes("youtube") || src.includes("youtu.be")) {
+    return "video/youtube";
+  } else if (src.includes("vimeo") && !src.includes("progressive_redirect") && !src.includes(".m3u8")) {
+    return "video/vimeo";
+  }
+  return "?";
+}
+function isSameSrc(a, b) {
+  return a?.src === b?.src && a?.type === b?.type;
+}
+
+class Tracks {
+  #domTracks;
+  #media;
+  #prevTracks = [];
+  constructor(domTracks, media) {
+    this.#domTracks = domTracks;
+    this.#media = media;
+    effect(this.#onTracksChange.bind(this));
+  }
+  #onTracksChange() {
+    const newTracks = this.#domTracks();
+    for (const oldTrack of this.#prevTracks) {
+      if (!newTracks.some((t) => t.id === oldTrack.id)) {
+        const track = oldTrack.id && this.#media.textTracks.getById(oldTrack.id);
+        if (track) this.#media.textTracks.remove(track);
+      }
+    }
+    for (const newTrack of newTracks) {
+      const id = newTrack.id || TextTrack.createId(newTrack);
+      if (!this.#media.textTracks.getById(id)) {
+        newTrack.id = id;
+        this.#media.textTracks.add(newTrack);
+      }
+    }
+    this.#prevTracks = newTracks;
+  }
+}
+
+class MediaProvider extends Component {
+  static props = {
+    loaders: []
+  };
+  static state = new State({
+    loader: null
+  });
+  #media;
+  #sources;
+  #domSources = signal([]);
+  #domTracks = signal([]);
+  #loader = null;
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#sources = new SourceSelection(
+      this.#domSources,
+      this.#media,
+      this.$state.loader,
+      this.$props.loaders()
+    );
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-provider", "");
+  }
+  onConnect(el) {
+    this.#sources.connect();
+    new Tracks(this.#domTracks, this.#media);
+    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
+    resize.observe(el);
+    const mutations = new MutationObserver(this.#onMutation.bind(this));
+    mutations.observe(el, { attributes: true, childList: true });
+    this.#onResize();
+    this.#onMutation();
+    onDispose(() => {
+      resize.disconnect();
+      mutations.disconnect();
+    });
+  }
+  #loadRafId = -1;
+  load(target) {
+    target?.setAttribute("aria-hidden", "true");
+    window.cancelAnimationFrame(this.#loadRafId);
+    this.#loadRafId = requestAnimationFrame(() => this.#runLoader(target));
+    onDispose(() => {
+      window.cancelAnimationFrame(this.#loadRafId);
+    });
+  }
+  #runLoader(target) {
+    if (!this.scope) return;
+    const loader = this.$state.loader(), { $provider } = this.#media;
+    if (this.#loader === loader && loader?.target === target && peek($provider)) return;
+    this.#destroyProvider();
+    this.#loader = loader;
+    if (loader) loader.target = target || null;
+    if (!loader || !target) return;
+    loader.load(this.#media).then((provider) => {
+      if (!this.scope) return;
+      if (peek(this.$state.loader) !== loader) return;
+      this.#media.notify("provider-change", provider);
+    });
+  }
+  onDestroy() {
+    this.#loader = null;
+    this.#destroyProvider();
+  }
+  #destroyProvider() {
+    this.#media?.notify("provider-change", null);
+  }
+  #onResize() {
+    if (!this.el) return;
+    const { player, $state } = this.#media, width = this.el.offsetWidth, height = this.el.offsetHeight;
+    if (!player) return;
+    $state.mediaWidth.set(width);
+    $state.mediaHeight.set(height);
+    if (player.el) {
+      setStyle(player.el, "--media-width", width + "px");
+      setStyle(player.el, "--media-height", height + "px");
+    }
+  }
+  #onMutation() {
+    const sources = [], tracks = [], children = this.el.children;
+    for (const el of children) {
+      if (el.hasAttribute("data-vds")) continue;
+      if (el instanceof HTMLSourceElement) {
+        const src = {
+          id: el.id,
+          src: el.src,
+          type: el.type
+        };
+        for (const prop of ["id", "src", "width", "height", "bitrate", "codec"]) {
+          const value = el.getAttribute(`data-${prop}`);
+          if (isString(value)) src[prop] = /id|src|codec/.test(prop) ? value : Number(value);
+        }
+        sources.push(src);
+      } else if (el instanceof HTMLTrackElement) {
+        const track = {
+          src: el.src,
+          kind: el.track.kind,
+          language: el.srclang,
+          label: el.label,
+          default: el.default,
+          type: el.getAttribute("data-type")
+        };
+        tracks.push({
+          id: el.id || TextTrack.createId(track),
+          ...track
+        });
+      }
+    }
+    this.#domSources.set(sources);
+    this.#domTracks.set(tracks);
+    tick();
+  }
+}
+const mediaprovider__proto = MediaProvider.prototype;
+method(mediaprovider__proto, "load");
+
+class MediaAnnouncer extends Component {
+  static props = {
+    translations: null
+  };
+  static state = new State({
+    label: null,
+    busy: false
+  });
+  #media;
+  #initializing = false;
+  onSetup() {
+    this.#media = useMediaContext();
+  }
+  onAttach(el) {
+    el.style.display = "contents";
+  }
+  onConnect(el) {
+    el.setAttribute("data-media-announcer", "");
+    setAttributeIfEmpty(el, "role", "status");
+    setAttributeIfEmpty(el, "aria-live", "polite");
+    const { busy } = this.$state;
+    this.setAttributes({
+      "aria-busy": () => busy() ? "true" : null
+    });
+    this.#initializing = true;
+    effect(this.#watchPaused.bind(this));
+    effect(this.#watchVolume.bind(this));
+    effect(this.#watchCaptions.bind(this));
+    effect(this.#watchFullscreen.bind(this));
+    effect(this.#watchPiP.bind(this));
+    effect(this.#watchSeeking.bind(this));
+    effect(this.#watchLabel.bind(this));
+    tick();
+    this.#initializing = false;
+  }
+  #watchPaused() {
+    const { paused } = this.#media.$state;
+    this.#setLabel(!paused() ? "Play" : "Pause");
+  }
+  #watchFullscreen() {
+    const { fullscreen } = this.#media.$state;
+    this.#setLabel(fullscreen() ? "Enter Fullscreen" : "Exit Fullscreen");
+  }
+  #watchPiP() {
+    const { pictureInPicture } = this.#media.$state;
+    this.#setLabel(pictureInPicture() ? "Enter PiP" : "Exit PiP");
+  }
+  #watchCaptions() {
+    const { textTrack } = this.#media.$state;
+    this.#setLabel(textTrack() ? "Closed-Captions On" : "Closed-Captions Off");
+  }
+  #watchVolume() {
+    const { muted, volume, audioGain } = this.#media.$state;
+    this.#setLabel(
+      muted() || volume() === 0 ? "Mute" : `${Math.round(volume() * (audioGain() ?? 1) * 100)}% ${this.#translate("Volume")}`
+    );
+  }
+  #startedSeekingAt = -1;
+  #seekTimer = -1;
+  #watchSeeking() {
+    const { seeking, currentTime } = this.#media.$state, isSeeking = seeking();
+    if (this.#startedSeekingAt > 0) {
+      window.clearTimeout(this.#seekTimer);
+      this.#seekTimer = window.setTimeout(() => {
+        if (!this.scope) return;
+        const newTime = peek(currentTime), seconds = Math.abs(newTime - this.#startedSeekingAt);
+        if (seconds >= 1) {
+          const isForward = newTime >= this.#startedSeekingAt, spokenTime = formatSpokenTime(seconds);
+          this.#setLabel(
+            `${this.#translate(isForward ? "Seek Forward" : "Seek Backward")} ${spokenTime}`
+          );
+        }
+        this.#startedSeekingAt = -1;
+        this.#seekTimer = -1;
+      }, 300);
+    } else if (isSeeking) {
+      this.#startedSeekingAt = peek(currentTime);
+    }
+  }
+  #translate(word) {
+    const { translations } = this.$props;
+    return translations?.()?.[word || ""] ?? word;
+  }
+  #watchLabel() {
+    const { label, busy } = this.$state, $label = this.#translate(label());
+    if (this.#initializing) return;
+    busy.set(true);
+    const id = window.setTimeout(() => void busy.set(false), 150);
+    this.el && setAttribute(this.el, "aria-label", $label);
+    if (isString($label)) {
+      this.dispatch("change", { detail: $label });
+    }
+    return () => window.clearTimeout(id);
+  }
+  #setLabel(word) {
+    const { label } = this.$state;
+    label.set(word);
+  }
+}
+
+class Controls extends Component {
+  static props = {
+    hideDelay: 2e3,
+    hideOnMouseLeave: false
+  };
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    effect(this.#watchProps.bind(this));
+  }
+  onAttach(el) {
+    const { pictureInPicture, fullscreen } = this.#media.$state;
+    setStyle(el, "pointer-events", "none");
+    setAttributeIfEmpty(el, "role", "group");
+    this.setAttributes({
+      "data-visible": this.#isShowing.bind(this),
+      "data-fullscreen": fullscreen,
+      "data-pip": pictureInPicture
+    });
+    effect(() => {
+      this.dispatch("change", { detail: this.#isShowing() });
+    });
+    effect(this.#hideControls.bind(this));
+    effect(() => {
+      const isFullscreen = fullscreen();
+      for (const side of ["top", "right", "bottom", "left"]) {
+        setStyle(el, `padding-${side}`, isFullscreen && `env(safe-area-inset-${side})`);
+      }
+    });
+  }
+  #hideControls() {
+    if (!this.el) return;
+    const { nativeControls } = this.#media.$state, isHidden = nativeControls();
+    setAttribute(this.el, "aria-hidden", isHidden ? "true" : null);
+    setStyle(this.el, "display", isHidden ? "none" : null);
+  }
+  #watchProps() {
+    const { controls } = this.#media.player, { hideDelay, hideOnMouseLeave } = this.$props;
+    controls.defaultDelay = hideDelay() === 2e3 ? this.#media.$props.controlsDelay() : hideDelay();
+    controls.hideOnMouseLeave = hideOnMouseLeave();
+  }
+  #isShowing() {
+    const { controlsVisible } = this.#media.$state;
+    return controlsVisible();
+  }
+}
+
+class ControlsGroup extends Component {
+  onAttach(el) {
+    if (!el.style.pointerEvents) setStyle(el, "pointer-events", "auto");
+  }
+}
+
+class Popper extends ViewController {
+  #delegate;
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+    effect(this.#watchTrigger.bind(this));
+  }
+  onDestroy() {
+    this.#stopAnimationEndListener?.();
+    this.#stopAnimationEndListener = null;
+  }
+  #watchTrigger() {
+    const trigger = this.#delegate.trigger();
+    if (!trigger) {
+      this.hide();
+      return;
+    }
+    const show = this.show.bind(this), hide = this.hide.bind(this);
+    this.#delegate.listen(trigger, show, hide);
+  }
+  #showTimerId = -1;
+  #hideRafId = -1;
+  #stopAnimationEndListener = null;
+  show(trigger) {
+    this.#cancelShowing();
+    window.cancelAnimationFrame(this.#hideRafId);
+    this.#hideRafId = -1;
+    this.#stopAnimationEndListener?.();
+    this.#stopAnimationEndListener = null;
+    this.#showTimerId = window.setTimeout(() => {
+      this.#showTimerId = -1;
+      const content = this.#delegate.content();
+      if (content) content.style.removeProperty("display");
+      peek(() => this.#delegate.onChange(true, trigger));
+    }, this.#delegate.showDelay?.() ?? 0);
+  }
+  hide(trigger) {
+    this.#cancelShowing();
+    peek(() => this.#delegate.onChange(false, trigger));
+    this.#hideRafId = requestAnimationFrame(() => {
+      this.#cancelShowing();
+      this.#hideRafId = -1;
+      const content = this.#delegate.content();
+      if (content) {
+        const onHide = () => {
+          content.style.display = "none";
+          this.#stopAnimationEndListener = null;
+        };
+        const isAnimated = hasAnimation(content);
+        if (isAnimated) {
+          this.#stopAnimationEndListener?.();
+          const stop = listenEvent(content, "animationend", onHide, { once: true });
+          this.#stopAnimationEndListener = stop;
+        } else {
+          onHide();
+        }
+      }
+    });
+  }
+  #cancelShowing() {
+    window.clearTimeout(this.#showTimerId);
+    this.#showTimerId = -1;
+  }
+}
+
+const tooltipContext = createContext();
+
+let id = 0;
+class Tooltip extends Component {
+  static props = {
+    showDelay: 700
+  };
+  #id = `media-tooltip-${++id}`;
+  #trigger = signal(null);
+  #content = signal(null);
+  #showing = signal(false);
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { showDelay } = this.$props;
+    new Popper({
+      trigger: this.#trigger,
+      content: this.#content,
+      showDelay,
+      listen(trigger, show, hide) {
+        effect(() => {
+          if ($keyboard()) listenEvent(trigger, "focus", show);
+          listenEvent(trigger, "blur", hide);
+        });
+        new EventsController(trigger).add("touchstart", (e) => e.preventDefault(), { passive: false }).add("mouseenter", show).add("mouseleave", hide);
+      },
+      onChange: this.#onShowingChange.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  onSetup() {
+    provideContext(tooltipContext, {
+      trigger: this.#trigger,
+      content: this.#content,
+      showing: this.#showing,
+      attachTrigger: this.#attachTrigger.bind(this),
+      detachTrigger: this.#detachTrigger.bind(this),
+      attachContent: this.#attachContent.bind(this),
+      detachContent: this.#detachContent.bind(this)
+    });
+  }
+  #attachTrigger(el) {
+    this.#trigger.set(el);
+    let tooltipName = el.getAttribute("data-media-tooltip");
+    if (tooltipName) {
+      this.el?.setAttribute(`data-media-${tooltipName}-tooltip`, "");
+    }
+    setAttribute(el, "data-describedby", this.#id);
+  }
+  #detachTrigger(el) {
+    el.removeAttribute("data-describedby");
+    el.removeAttribute("aria-describedby");
+    this.#trigger.set(null);
+  }
+  #attachContent(el) {
+    el.setAttribute("id", this.#id);
+    el.style.display = "none";
+    setAttributeIfEmpty(el, "role", "tooltip");
+    this.#content.set(el);
+  }
+  #detachContent(el) {
+    el.removeAttribute("id");
+    el.removeAttribute("role");
+    this.#content.set(null);
+  }
+  #onShowingChange(isShowing) {
+    const trigger = this.#trigger(), content = this.#content();
+    if (trigger) {
+      setAttribute(trigger, "aria-describedby", isShowing ? this.#id : null);
+    }
+    for (const el of [this.el, trigger, content]) {
+      el && setAttribute(el, "data-visible", isShowing);
+    }
+    this.#showing.set(isShowing);
+  }
+}
+
+class TooltipTrigger extends Component {
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onConnect(el) {
+    onDispose(
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        this.#attach();
+        const tooltip = useContext(tooltipContext);
+        onDispose(() => {
+          const button = this.#getButton();
+          button && tooltip.detachTrigger(button);
+        });
+      })
+    );
+  }
+  #attach() {
+    const button = this.#getButton(), tooltip = useContext(tooltipContext);
+    button && tooltip.attachTrigger(button);
+  }
+  #getButton() {
+    const candidate = this.el.firstElementChild;
+    return candidate?.localName === "button" || candidate?.getAttribute("role") === "button" ? candidate : this.el;
+  }
+}
+
+class TooltipContent extends Component {
+  static props = {
+    placement: "top center",
+    offset: 0,
+    alignOffset: 0
+  };
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { placement } = this.$props;
+    this.setAttributes({
+      "data-placement": placement
+    });
+  }
+  onAttach(el) {
+    this.#attach(el);
+    Object.assign(el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+  }
+  onConnect(el) {
+    this.#attach(el);
+    const tooltip = useContext(tooltipContext);
+    onDispose(() => tooltip.detachContent(el));
+    onDispose(
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        effect(this.#watchPlacement.bind(this));
+      })
+    );
+  }
+  #attach(el) {
+    const tooltip = useContext(tooltipContext);
+    tooltip.attachContent(el);
+  }
+  #watchPlacement() {
+    const { showing } = useContext(tooltipContext);
+    if (!showing()) return;
+    const { placement, offset: mainOffset, alignOffset } = this.$props;
+    return autoPlacement(this.el, this.#getTrigger(), placement(), {
+      offsetVarName: "media-tooltip",
+      xOffset: alignOffset(),
+      yOffset: mainOffset()
+    });
+  }
+  #getTrigger() {
+    return useContext(tooltipContext).trigger();
+  }
+}
+
+class ToggleButtonController extends ViewController {
+  static props = {
+    disabled: false
+  };
+  #delegate;
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+    new FocusVisibleController();
+    if (delegate.keyShortcut) {
+      new ARIAKeyShortcuts(delegate.keyShortcut);
+    }
+  }
+  onSetup() {
+    const { disabled } = this.$props;
+    this.setAttributes({
+      "data-pressed": this.#delegate.isPresssed,
+      "aria-pressed": this.#isARIAPressed.bind(this),
+      "aria-disabled": () => disabled() ? "true" : null
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+  }
+  onConnect(el) {
+    const events = onPress(el, this.#onMaybePress.bind(this));
+    for (const type of ["click", "touchstart"]) {
+      events.add(type, this.#onInteraction.bind(this), {
+        passive: true
+      });
+    }
+  }
+  #isARIAPressed() {
+    return ariaBool$1(this.#delegate.isPresssed());
+  }
+  #onPressed(event) {
+    if (isWriteSignal(this.#delegate.isPresssed)) {
+      this.#delegate.isPresssed.set((p) => !p);
+    }
+  }
+  #onMaybePress(event) {
+    const disabled = this.$props.disabled() || this.el.hasAttribute("data-disabled");
+    if (disabled) {
+      event.preventDefault();
+      event.stopImmediatePropagation();
+      return;
+    }
+    event.preventDefault();
+    (this.#delegate.onPress ?? this.#onPressed).call(this, event);
+  }
+  #onInteraction(event) {
+    if (this.$props.disabled()) {
+      event.preventDefault();
+      event.stopImmediatePropagation();
+    }
+  }
+}
+
+class ToggleButton extends Component {
+  static props = {
+    disabled: false,
+    defaultPressed: false
+  };
+  #pressed = signal(false);
+  /**
+   * Whether the toggle is currently in a `pressed` state.
+   */
+  get pressed() {
+    return this.#pressed();
+  }
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#pressed
+    });
+  }
+}
+const togglebutton__proto = ToggleButton.prototype;
+prop(togglebutton__proto, "pressed");
+
+function ariaBool(value) {
+  return value ? "true" : "false";
+}
+function $ariaBool(signal) {
+  return () => ariaBool(signal());
+}
+
+class AirPlayButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { canAirPlay, isAirPlayConnected } = this.#media.$state;
+    this.setAttributes({
+      "data-active": isAirPlayConnected,
+      "data-supported": canAirPlay,
+      "data-state": this.#getState.bind(this),
+      "aria-hidden": $ariaBool(() => !canAirPlay())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "airplay");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    remote.requestAirPlay(event);
+  }
+  #isPressed() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "airplay" && remotePlaybackState() !== "disconnected";
+  }
+  #getState() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "airplay" && remotePlaybackState();
+  }
+  #getDefaultLabel() {
+    const { remotePlaybackState } = this.#media.$state;
+    return `AirPlay ${remotePlaybackState()}`;
+  }
+}
+
+class GoogleCastButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { canGoogleCast, isGoogleCastConnected } = this.#media.$state;
+    this.setAttributes({
+      "data-active": isGoogleCastConnected,
+      "data-supported": canGoogleCast,
+      "data-state": this.#getState.bind(this),
+      "aria-hidden": $ariaBool(() => !canGoogleCast())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "google-cast");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    remote.requestGoogleCast(event);
+  }
+  #isPressed() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "google-cast" && remotePlaybackState() !== "disconnected";
+  }
+  #getState() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "google-cast" && remotePlaybackState();
+  }
+  #getDefaultLabel() {
+    const { remotePlaybackState } = this.#media.$state;
+    return `Google Cast ${remotePlaybackState()}`;
+  }
+}
+
+class PlayButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "togglePaused",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { paused, ended } = this.#media.$state;
+    this.setAttributes({
+      "data-paused": paused,
+      "data-ended": ended
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "play");
+    setARIALabel(el, "Play");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.pause(event) : remote.play(event);
+  }
+  #isPressed() {
+    const { paused } = this.#media.$state;
+    return !paused();
+  }
+}
+
+class CaptionButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleCaptions",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "data-active": this.#isPressed.bind(this),
+      "data-supported": () => !this.#isHidden(),
+      "aria-hidden": $ariaBool(this.#isHidden.bind(this))
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "caption");
+    setARIALabel(el, "Captions");
+  }
+  #onPress(event) {
+    this.#media.remote.toggleCaptions(event);
+  }
+  #isPressed() {
+    const { textTrack } = this.#media.$state, track = textTrack();
+    return !!track && isTrackCaptionKind(track);
+  }
+  #isHidden() {
+    const { hasCaptions } = this.#media.$state;
+    return !hasCaptions();
+  }
+}
+
+class FullscreenButton extends Component {
+  static props = {
+    ...ToggleButtonController.props,
+    target: "prefer-media"
+  };
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleFullscreen",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { fullscreen } = this.#media.$state, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      "data-active": fullscreen,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "fullscreen");
+    setARIALabel(el, "Fullscreen");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote, target = this.$props.target();
+    this.#isPressed() ? remote.exitFullscreen(target, event) : remote.enterFullscreen(target, event);
+  }
+  #isPressed() {
+    const { fullscreen } = this.#media.$state;
+    return fullscreen();
+  }
+  #isSupported() {
+    const { canFullscreen } = this.#media.$state;
+    return canFullscreen();
+  }
+}
+
+class MuteButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleMuted",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "data-muted": this.#isPressed.bind(this),
+      "data-state": this.#getState.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-mute-button", "");
+    el.setAttribute("data-media-tooltip", "mute");
+    setARIALabel(el, "Mute");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.unmute(event) : remote.mute(event);
+  }
+  #isPressed() {
+    const { muted, volume } = this.#media.$state;
+    return muted() || volume() === 0;
+  }
+  #getState() {
+    const { muted, volume } = this.#media.$state, $volume = volume();
+    if (muted() || $volume === 0) return "muted";
+    else if ($volume >= 0.5) return "high";
+    else if ($volume < 0.5) return "low";
+  }
+}
+
+class PIPButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "togglePictureInPicture",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { pictureInPicture } = this.#media.$state, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      "data-active": pictureInPicture,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "pip");
+    setARIALabel(el, "PiP");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.exitPictureInPicture(event) : remote.enterPictureInPicture(event);
+  }
+  #isPressed() {
+    const { pictureInPicture } = this.#media.$state;
+    return pictureInPicture();
+  }
+  #isSupported() {
+    const { canPictureInPicture } = this.#media.$state;
+    return canPictureInPicture();
+  }
+}
+
+class SeekButton extends Component {
+  static props = {
+    disabled: false,
+    seconds: 30
+  };
+  #media;
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { seeking } = this.#media.$state, { seconds } = this.$props, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      seconds,
+      "data-seeking": seeking,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+    el.setAttribute("data-media-tooltip", "seek");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  onConnect(el) {
+    onPress(el, this.#onPress.bind(this));
+  }
+  #isSupported() {
+    const { canSeek } = this.#media.$state;
+    return canSeek();
+  }
+  #getDefaultLabel() {
+    const { seconds } = this.$props;
+    return `Seek ${seconds() > 0 ? "forward" : "backward"} ${seconds()} seconds`;
+  }
+  #onPress(event) {
+    const { seconds, disabled } = this.$props;
+    if (disabled()) return;
+    const { currentTime } = this.#media.$state, seekTo = currentTime() + seconds();
+    this.#media.remote.seek(seekTo, event);
+  }
+}
+
+class LiveButton extends Component {
+  static props = {
+    disabled: false
+  };
+  #media;
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { disabled } = this.$props, { live, liveEdge } = this.#media.$state, isHidden = () => !live();
+    this.setAttributes({
+      "data-edge": liveEdge,
+      "data-hidden": isHidden,
+      "aria-disabled": $ariaBool(() => disabled() || liveEdge()),
+      "aria-hidden": $ariaBool(isHidden)
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+    el.setAttribute("data-media-tooltip", "live");
+  }
+  onConnect(el) {
+    onPress(el, this.#onPress.bind(this));
+  }
+  #onPress(event) {
+    const { disabled } = this.$props, { liveEdge } = this.#media.$state;
+    if (disabled() || liveEdge()) return;
+    this.#media.remote.seekToLiveEdge(event);
+  }
+}
+
+const sliderState = new State({
+  min: 0,
+  max: 100,
+  value: 0,
+  step: 1,
+  pointerValue: 0,
+  focused: false,
+  dragging: false,
+  pointing: false,
+  hidden: false,
+  get active() {
+    return this.dragging || this.focused || this.pointing;
+  },
+  get fillRate() {
+    return calcRate(this.min, this.max, this.value);
+  },
+  get fillPercent() {
+    return this.fillRate * 100;
+  },
+  get pointerRate() {
+    return calcRate(this.min, this.max, this.pointerValue);
+  },
+  get pointerPercent() {
+    return this.pointerRate * 100;
+  }
+});
+function calcRate(min, max, value) {
+  const range = max - min, offset = value - min;
+  return range > 0 ? offset / range : 0;
+}
+
+class IntersectionObserverController extends ViewController {
+  #init;
+  #observer;
+  constructor(init) {
+    super();
+    this.#init = init;
+  }
+  onConnect(el) {
+    this.#observer = new IntersectionObserver((entries) => {
+      this.#init.callback?.(entries, this.#observer);
+    }, this.#init);
+    this.#observer.observe(el);
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  /**
+   * Disconnect any active intersection observers.
+   */
+  #onDisconnect() {
+    this.#observer?.disconnect();
+    this.#observer = void 0;
+  }
+}
+
+const sliderContext = createContext();
+const sliderObserverContext = createContext();
+
+function getClampedValue(min, max, value, step) {
+  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
+}
+function getValueFromRate(min, max, rate, step) {
+  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * Math.round(stepRatio);
+  return min + steps;
+}
+
+const SliderKeyDirection = {
+  Left: -1,
+  ArrowLeft: -1,
+  Up: 1,
+  ArrowUp: 1,
+  Right: 1,
+  ArrowRight: 1,
+  Down: -1,
+  ArrowDown: -1
+};
+class SliderEventsController extends ViewController {
+  #delegate;
+  #media;
+  #observer;
+  constructor(delegate, media) {
+    super();
+    this.#delegate = delegate;
+    this.#media = media;
+  }
+  onSetup() {
+    if (hasProvidedContext(sliderObserverContext)) {
+      this.#observer = useContext(sliderObserverContext);
+    }
+  }
+  onConnect(el) {
+    effect(this.#attachEventListeners.bind(this, el));
+    effect(this.#attachPointerListeners.bind(this, el));
+    if (this.#delegate.swipeGesture) effect(this.#watchSwipeGesture.bind(this));
+  }
+  #watchSwipeGesture() {
+    const { pointer } = this.#media.$state;
+    if (pointer() !== "coarse" || !this.#delegate.swipeGesture()) {
+      this.#provider = null;
+      return;
+    }
+    this.#provider = this.#media.player.el?.querySelector(
+      "media-provider,[data-media-provider]"
+    );
+    if (!this.#provider) return;
+    new EventsController(this.#provider).add("touchstart", this.#onTouchStart.bind(this), {
+      passive: true
+    }).add("touchmove", this.#onTouchMove.bind(this), { passive: false });
+  }
+  #provider = null;
+  #touch = null;
+  #touchStartValue = null;
+  #onTouchStart(event) {
+    this.#touch = event.touches[0];
+  }
+  #onTouchMove(event) {
+    if (isNull(this.#touch) || isTouchPinchEvent(event)) return;
+    const touch = event.touches[0], xDiff = touch.clientX - this.#touch.clientX, yDiff = touch.clientY - this.#touch.clientY, isDragging = this.$state.dragging();
+    if (!isDragging && Math.abs(yDiff) > 5) {
+      return;
+    }
+    if (isDragging) return;
+    event.preventDefault();
+    if (Math.abs(xDiff) > 20) {
+      this.#touch = touch;
+      this.#touchStartValue = this.$state.value();
+      this.#onStartDragging(this.#touchStartValue, event);
+    }
+  }
+  #attachEventListeners(el) {
+    const { hidden } = this.$props;
+    listenEvent(el, "focus", this.#onFocus.bind(this));
+    if (hidden() || this.#delegate.isDisabled()) return;
+    new EventsController(el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("pointerenter", this.#onPointerEnter.bind(this)).add("pointermove", this.#onPointerMove.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this)).add("pointerdown", this.#onPointerDown.bind(this));
+  }
+  #attachPointerListeners(el) {
+    if (this.#delegate.isDisabled() || !this.$state.dragging()) return;
+    new EventsController(document).add("pointerup", this.#onDocumentPointerUp.bind(this), { capture: true }).add("pointermove", this.#onDocumentPointerMove.bind(this)).add("touchmove", this.#onDocumentTouchMove.bind(this), {
+      passive: false
+    });
+  }
+  #onFocus() {
+    this.#updatePointerValue(this.$state.value());
+  }
+  #updateValue(newValue, trigger) {
+    const { value, min, max, dragging } = this.$state;
+    const clampedValue = Math.max(min(), Math.min(newValue, max()));
+    value.set(clampedValue);
+    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
+    this.dispatch(event);
+    this.#delegate.onValueChange?.(event);
+    if (dragging()) {
+      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
+      this.dispatch(event2);
+      this.#delegate.onDragValueChange?.(event2);
+    }
+  }
+  #updatePointerValue(value, trigger) {
+    const { pointerValue, dragging } = this.$state;
+    pointerValue.set(value);
+    this.dispatch("pointer-value-change", { detail: value, trigger });
+    if (dragging()) {
+      this.#updateValue(value, trigger);
+    }
+  }
+  #getPointerValue(event) {
+    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$state;
+    if (this.$props.orientation() === "vertical") {
+      const { bottom: trackBottom, height: trackHeight } = rect;
+      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
+    } else {
+      if (this.#touch && isNumber(this.#touchStartValue)) {
+        const { width } = this.#provider.getBoundingClientRect(), rate = (event.clientX - this.#touch.clientX) / width, range = max() - min(), diff = range * Math.abs(rate);
+        thumbPositionRate = (rate < 0 ? this.#touchStartValue - diff : this.#touchStartValue + diff) / range;
+      } else {
+        const { left: trackLeft, width: trackWidth } = rect;
+        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
+      }
+    }
+    return Math.max(
+      min(),
+      Math.min(
+        max(),
+        this.#delegate.roundValue(
+          getValueFromRate(min(), max(), thumbPositionRate, this.#delegate.getStep())
+        )
+      )
+    );
+  }
+  #onPointerEnter(event) {
+    this.$state.pointing.set(true);
+  }
+  #onPointerMove(event) {
+    const { dragging } = this.$state;
+    if (dragging()) return;
+    this.#updatePointerValue(this.#getPointerValue(event), event);
+  }
+  #onPointerLeave(event) {
+    this.$state.pointing.set(false);
+  }
+  #onPointerDown(event) {
+    if (event.button !== 0) return;
+    const value = this.#getPointerValue(event);
+    this.#onStartDragging(value, event);
+    this.#updatePointerValue(value, event);
+  }
+  #onStartDragging(value, trigger) {
+    const { dragging } = this.$state;
+    if (dragging()) return;
+    dragging.set(true);
+    this.#media.remote.pauseControls(trigger);
+    const event = this.createEvent("drag-start", { detail: value, trigger });
+    this.dispatch(event);
+    this.#delegate.onDragStart?.(event);
+    this.#observer?.onDragStart?.();
+  }
+  #onStopDragging(value, trigger) {
+    const { dragging } = this.$state;
+    if (!dragging()) return;
+    dragging.set(false);
+    this.#media.remote.resumeControls(trigger);
+    const event = this.createEvent("drag-end", { detail: value, trigger });
+    this.dispatch(event);
+    this.#delegate.onDragEnd?.(event);
+    this.#touch = null;
+    this.#touchStartValue = null;
+    this.#observer?.onDragEnd?.();
+  }
+  // -------------------------------------------------------------------------------------------
+  // Keyboard Events
+  // -------------------------------------------------------------------------------------------
+  #lastDownKey;
+  #repeatedKeys = false;
+  #onKeyDown(event) {
+    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);
+    if (!isValidKey) return;
+    const { key } = event, jumpValue = this.#calcJumpValue(event);
+    if (!isNull(jumpValue)) {
+      this.#updatePointerValue(jumpValue, event);
+      this.#updateValue(jumpValue, event);
+      return;
+    }
+    const newValue = this.#calcNewKeyValue(event);
+    if (!this.#repeatedKeys) {
+      this.#repeatedKeys = key === this.#lastDownKey;
+      if (!this.$state.dragging() && this.#repeatedKeys) {
+        this.#onStartDragging(newValue, event);
+      }
+    }
+    this.#updatePointerValue(newValue, event);
+    this.#lastDownKey = key;
+  }
+  #onKeyUp(event) {
+    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);
+    if (!isValidKey || !isNull(this.#calcJumpValue(event))) return;
+    const newValue = this.#repeatedKeys ? this.$state.pointerValue() : this.#calcNewKeyValue(event);
+    this.#updateValue(newValue, event);
+    this.#onStopDragging(newValue, event);
+    this.#lastDownKey = "";
+    this.#repeatedKeys = false;
+  }
+  #calcJumpValue(event) {
+    let key = event.key, { min, max } = this.$state;
+    if (key === "Home" || key === "PageUp") {
+      return min();
+    } else if (key === "End" || key === "PageDown") {
+      return max();
+    } else if (!event.metaKey && /^[0-9]$/.test(key)) {
+      return (max() - min()) / 10 * Number(key);
+    }
+    return null;
+  }
+  #calcNewKeyValue(event) {
+    const { key, shiftKey } = event;
+    event.preventDefault();
+    event.stopPropagation();
+    const { shiftKeyMultiplier } = this.$props;
+    const { min, max, value, pointerValue } = this.$state, step = this.#delegate.getStep(), keyStep = this.#delegate.getKeyStep();
+    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, currentValue = this.#repeatedKeys ? pointerValue() : this.#delegate.getValue?.() ?? value(), steps = (currentValue + diff) / step;
+    return Math.max(min(), Math.min(max(), Number((step * steps).toFixed(3))));
+  }
+  // -------------------------------------------------------------------------------------------
+  // Document (Pointer Events)
+  // -------------------------------------------------------------------------------------------
+  #onDocumentPointerUp(event) {
+    if (event.button !== 0) return;
+    event.preventDefault();
+    event.stopImmediatePropagation();
+    const value = this.#getPointerValue(event);
+    this.#updatePointerValue(value, event);
+    this.#onStopDragging(value, event);
+  }
+  #onDocumentTouchMove(event) {
+    event.preventDefault();
+  }
+  #onDocumentPointerMove = functionThrottle(
+    (event) => {
+      this.#updatePointerValue(this.#getPointerValue(event), event);
+    },
+    20,
+    { leading: true }
+  );
+}
+
+const sliderValueFormatContext = createContext(() => ({}));
+
+class SliderController extends ViewController {
+  static props = {
+    hidden: false,
+    disabled: false,
+    step: 1,
+    keyStep: 1,
+    orientation: "horizontal",
+    shiftKeyMultiplier: 5
+  };
+  #media;
+  #delegate;
+  #isVisible = signal(true);
+  #isIntersecting = signal(true);
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const focus = new FocusVisibleController();
+    focus.attach(this);
+    this.$state.focused = focus.focused.bind(focus);
+    if (!hasProvidedContext(sliderValueFormatContext)) {
+      provideContext(sliderValueFormatContext, {
+        default: "value"
+      });
+    }
+    provideContext(sliderContext, {
+      orientation: this.$props.orientation,
+      disabled: this.#delegate.isDisabled,
+      preview: signal(null)
+    });
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchStep.bind(this));
+    effect(this.#watchDisabled.bind(this));
+    this.#setupAttrs();
+    new SliderEventsController(this.#delegate, this.#media).attach(this);
+    new IntersectionObserverController({
+      callback: this.#onIntersectionChange.bind(this)
+    }).attach(this);
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "role", "slider");
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "autocomplete", "off");
+    if (IS_SERVER) this.#watchCSSVars();
+    else effect(this.#watchCSSVars.bind(this));
+  }
+  onConnect(el) {
+    onDispose(observeVisibility(el, this.#isVisible.set));
+    effect(this.#watchHidden.bind(this));
+  }
+  #onIntersectionChange(entries) {
+    this.#isIntersecting.set(entries[0].isIntersecting);
+  }
+  // -------------------------------------------------------------------------------------------
+  // Watch
+  // -------------------------------------------------------------------------------------------
+  #watchHidden() {
+    const { hidden } = this.$props;
+    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting.bind(this));
+  }
+  #watchValue() {
+    const { dragging, value, min, max } = this.$state;
+    if (peek(dragging)) return;
+    value.set(getClampedValue(min(), max(), value(), this.#delegate.getStep()));
+  }
+  #watchStep() {
+    this.$state.step.set(this.#delegate.getStep());
+  }
+  #watchDisabled() {
+    if (!this.#delegate.isDisabled()) return;
+    const { dragging, pointing } = this.$state;
+    dragging.set(false);
+    pointing.set(false);
+  }
+  // -------------------------------------------------------------------------------------------
+  // ARIA
+  // -------------------------------------------------------------------------------------------
+  #getARIADisabled() {
+    return ariaBool$1(this.#delegate.isDisabled());
+  }
+  // -------------------------------------------------------------------------------------------
+  // Attributes
+  // -------------------------------------------------------------------------------------------
+  #setupAttrs() {
+    const { orientation } = this.$props, { dragging, active, pointing } = this.$state;
+    this.setAttributes({
+      "data-dragging": dragging,
+      "data-pointing": pointing,
+      "data-active": active,
+      "aria-disabled": this.#getARIADisabled.bind(this),
+      "aria-valuemin": this.#delegate.aria.valueMin ?? this.$state.min,
+      "aria-valuemax": this.#delegate.aria.valueMax ?? this.$state.max,
+      "aria-valuenow": this.#delegate.aria.valueNow,
+      "aria-valuetext": this.#delegate.aria.valueText,
+      "aria-orientation": orientation
+    });
+  }
+  #watchCSSVars() {
+    const { fillPercent, pointerPercent } = this.$state;
+    this.#updateSliderVars(round(fillPercent(), 3), round(pointerPercent(), 3));
+  }
+  #updateSliderVars = animationFrameThrottle((fillPercent, pointerPercent) => {
+    this.el?.style.setProperty("--slider-fill", fillPercent + "%");
+    this.el?.style.setProperty("--slider-pointer", pointerPercent + "%");
+  });
+}
+
+class Slider extends Component {
+  static props = {
+    ...SliderController.props,
+    min: 0,
+    max: 100,
+    value: 0
+  };
+  static state = sliderState;
+  constructor() {
+    super();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.$props.disabled,
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      }
+    });
+  }
+  onSetup() {
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchMinMax.bind(this));
+  }
+  // -------------------------------------------------------------------------------------------
+  // Props
+  // -------------------------------------------------------------------------------------------
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const { value, max } = this.$state;
+    return round(value() / max() * 100, 2) + "%";
+  }
+  // -------------------------------------------------------------------------------------------
+  // Watch
+  // -------------------------------------------------------------------------------------------
+  #watchValue() {
+    const { value } = this.$props;
+    this.$state.value.set(value());
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+}
+
+const cache = /* @__PURE__ */ new Map(), pending = /* @__PURE__ */ new Map(), warned = /* @__PURE__ */ new Set() ;
+class ThumbnailsLoader {
+  #media;
+  #src;
+  #crossOrigin;
+  $images = signal([]);
+  static create(src, crossOrigin) {
+    const media = useMediaContext();
+    return new ThumbnailsLoader(src, crossOrigin, media);
+  }
+  constructor(src, crossOrigin, media) {
+    this.#src = src;
+    this.#crossOrigin = crossOrigin;
+    this.#media = media;
+    effect(this.#onLoadCues.bind(this));
+  }
+  #onLoadCues() {
+    const { canLoad } = this.#media.$state;
+    if (!canLoad()) return;
+    const src = this.#src();
+    if (!src) return;
+    if (isString(src) && cache.has(src)) {
+      const cues = cache.get(src);
+      cache.delete(src);
+      cache.set(src, cues);
+      if (cache.size > 99) {
+        const firstKey = cache.keys().next().value;
+        cache.delete(firstKey);
+      }
+      this.$images.set(cache.get(src));
+    } else if (isString(src)) {
+      const crossOrigin = this.#crossOrigin(), currentKey = src + "::" + crossOrigin;
+      if (!pending.has(currentKey)) {
+        const promise = new Promise(async (resolve, reject) => {
+          try {
+            const response = await fetch(src, {
+              credentials: getRequestCredentials(crossOrigin)
+            }), isJSON = response.headers.get("content-type") === "application/json";
+            if (isJSON) {
+              const json = await response.json();
+              if (isArray(json)) {
+                if (json[0] && "text" in json[0]) {
+                  resolve(this.#processVTTCues(json));
+                } else {
+                  for (let i = 0; i < json.length; i++) {
+                    const image = json[i];
+                    assert(isObject(image), `Item not an object at index ${i}`);
+                    assert(
+                      "url" in image && isString(image.url),
+                      `Invalid or missing \`url\` property at index ${i}`
+                    );
+                    assert(
+                      "startTime" in image && isNumber(image.startTime),
+                      `Invalid or missing \`startTime\` property at index ${i}`
+                    );
+                  }
+                  resolve(json);
+                }
+              } else {
+                resolve(this.#processStoryboard(json));
+              }
+              return;
+            }
+            import('media-captions').then(async ({ parseResponse }) => {
+              try {
+                const { cues } = await parseResponse(response);
+                resolve(this.#processVTTCues(cues));
+              } catch (e) {
+                reject(e);
+              }
+            });
+          } catch (e) {
+            reject(e);
+          }
+        }).then((images) => {
+          cache.set(currentKey, images);
+          return images;
+        }).catch((error) => {
+          this.#onError(src, error);
+        }).finally(() => {
+          if (isString(currentKey)) pending.delete(currentKey);
+        });
+        pending.set(currentKey, promise);
+      }
+      pending.get(currentKey)?.then((images) => {
+        this.$images.set(images || []);
+      });
+    } else if (isArray(src)) {
+      try {
+        this.$images.set(this.#processImages(src));
+      } catch (error) {
+        this.#onError(src, error);
+      }
+    } else {
+      try {
+        this.$images.set(this.#processStoryboard(src));
+      } catch (error) {
+        this.#onError(src, error);
+      }
+    }
+    return () => {
+      this.$images.set([]);
+    };
+  }
+  #processImages(images) {
+    const baseURL = this.#resolveBaseUrl();
+    return images.map((img, i) => {
+      assert(
+        img.url && isString(img.url),
+        `Invalid or missing \`url\` property at index ${i}`
+      );
+      assert(
+        "startTime" in img && isNumber(img.startTime),
+        `Invalid or missing \`startTime\` property at index ${i}`
+      );
+      return {
+        ...img,
+        url: isString(img.url) ? this.#resolveURL(img.url, baseURL) : img.url
+      };
+    });
+  }
+  #processStoryboard(board) {
+    assert(isString(board.url), "Missing `url` in storyboard object");
+    assert(isArray(board.tiles) && board.tiles?.length, `Empty tiles in storyboard`);
+    const url = new URL(board.url), images = [];
+    const tileWidth = "tile_width" in board ? board.tile_width : board.tileWidth, tileHeight = "tile_height" in board ? board.tile_height : board.tileHeight;
+    for (const tile of board.tiles) {
+      images.push({
+        url,
+        startTime: "start" in tile ? tile.start : tile.startTime,
+        width: tileWidth,
+        height: tileHeight,
+        coords: { x: tile.x, y: tile.y }
+      });
+    }
+    return images;
+  }
+  #processVTTCues(cues) {
+    for (let i = 0; i < cues.length; i++) {
+      const cue = cues[i];
+      assert(
+        "startTime" in cue && isNumber(cue.startTime),
+        `Invalid or missing \`startTime\` property at index ${i}`
+      );
+      assert(
+        "text" in cue && isString(cue.text),
+        `Invalid or missing \`text\` property at index ${i}`
+      );
+    }
+    const images = [], baseURL = this.#resolveBaseUrl();
+    for (const cue of cues) {
+      const [url, hash] = cue.text.split("#"), data = this.#resolveData(hash);
+      images.push({
+        url: this.#resolveURL(url, baseURL),
+        startTime: cue.startTime,
+        endTime: cue.endTime,
+        width: data?.w,
+        height: data?.h,
+        coords: data && isNumber(data.x) && isNumber(data.y) ? { x: data.x, y: data.y } : void 0
+      });
+    }
+    return images;
+  }
+  #resolveBaseUrl() {
+    let baseURL = peek(this.#src);
+    if (!isString(baseURL) || !/^https?:/.test(baseURL)) {
+      return location.href;
+    }
+    return baseURL;
+  }
+  #resolveURL(src, baseURL) {
+    return /^https?:/.test(src) ? new URL(src) : new URL(src, baseURL);
+  }
+  #resolveData(hash) {
+    if (!hash) return {};
+    const [hashProps, values] = hash.split("="), hashValues = values?.split(","), data = {};
+    if (!hashProps || !hashValues) {
+      return null;
+    }
+    for (let i = 0; i < hashProps.length; i++) {
+      const value = +hashValues[i];
+      if (!isNaN(value)) data[hashProps[i]] = value;
+    }
+    return data;
+  }
+  #onError(src, error) {
+    if (warned?.has(src)) return;
+    this.#media.logger?.errorGroup("[vidstack] failed to load thumbnails").labelledLog("Src", src).labelledLog("Error", error).dispatch();
+    warned?.add(src);
+  }
+}
+
+class Thumbnail extends Component {
+  static props = {
+    src: null,
+    time: 0,
+    crossOrigin: null
+  };
+  static state = new State({
+    src: "",
+    img: null,
+    thumbnails: [],
+    activeThumbnail: null,
+    crossOrigin: null,
+    loading: false,
+    error: null,
+    hidden: false
+  });
+  media;
+  #loader;
+  #styleResets = [];
+  onSetup() {
+    this.media = useMediaContext();
+    this.#loader = ThumbnailsLoader.create(this.$props.src, this.$state.crossOrigin);
+    this.#watchCrossOrigin();
+    this.setAttributes({
+      "data-loading": this.#isLoading.bind(this),
+      "data-error": this.#hasError.bind(this),
+      "data-hidden": this.$state.hidden,
+      "aria-hidden": $ariaBool(this.$state.hidden)
+    });
+  }
+  onConnect(el) {
+    effect(this.#watchImg.bind(this));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#onLoadStart.bind(this));
+    effect(this.#onFindActiveThumbnail.bind(this));
+    effect(this.#resize.bind(this));
+  }
+  #watchImg() {
+    const img = this.$state.img();
+    if (!img) return;
+    new EventsController(img).add("load", this.#onLoaded.bind(this)).add("error", this.#onError.bind(this));
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
+  }
+  #onLoadStart() {
+    const { src, loading, error } = this.$state;
+    if (src()) {
+      loading.set(true);
+      error.set(null);
+    }
+    return () => {
+      this.#resetStyles();
+      loading.set(false);
+      error.set(null);
+    };
+  }
+  #onLoaded() {
+    const { loading, error } = this.$state;
+    this.#resize();
+    loading.set(false);
+    error.set(null);
+  }
+  #onError(event) {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(event);
+  }
+  #isLoading() {
+    const { loading, hidden } = this.$state;
+    return !hidden() && loading();
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error());
+  }
+  #watchHidden() {
+    const { hidden } = this.$state, { duration } = this.media.$state, images = this.#loader.$images();
+    hidden.set(this.#hasError() || !Number.isFinite(duration()) || images.length === 0);
+  }
+  getTime() {
+    return this.$props.time();
+  }
+  #onFindActiveThumbnail() {
+    let images = this.#loader.$images();
+    if (!images.length) return;
+    let time = this.getTime(), { src, activeThumbnail } = this.$state, activeIndex = -1, activeImage = null;
+    for (let i = images.length - 1; i >= 0; i--) {
+      const image = images[i];
+      if (time >= image.startTime && (!image.endTime || time < image.endTime)) {
+        activeIndex = i;
+        break;
+      }
+    }
+    if (images[activeIndex]) {
+      activeImage = images[activeIndex];
+    }
+    activeThumbnail.set(activeImage);
+    src.set(activeImage?.url.href || "");
+  }
+  #resize() {
+    if (!this.scope || this.$state.hidden()) return;
+    const rootEl = this.el, imgEl = this.$state.img(), thumbnail = this.$state.activeThumbnail();
+    if (!imgEl || !thumbnail || !rootEl) return;
+    let width = thumbnail.width ?? imgEl.naturalWidth, height = thumbnail?.height ?? imgEl.naturalHeight, {
+      maxWidth,
+      maxHeight,
+      minWidth,
+      minHeight,
+      width: elWidth,
+      height: elHeight
+    } = getComputedStyle(this.el);
+    if (minWidth === "100%") minWidth = parseFloat(elWidth) + "";
+    if (minHeight === "100%") minHeight = parseFloat(elHeight) + "";
+    let minRatio = Math.max(parseInt(minWidth) / width, parseInt(minHeight) / height), maxRatio = Math.min(
+      Math.max(parseInt(minWidth), parseInt(maxWidth)) / width,
+      Math.max(parseInt(minHeight), parseInt(maxHeight)) / height
+    ), scale = !isNaN(maxRatio) && maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
+    this.#style(rootEl, "--thumbnail-width", `${width * scale}px`);
+    this.#style(rootEl, "--thumbnail-height", `${height * scale}px`);
+    this.#style(rootEl, "--thumbnail-aspect-ratio", String(round(width / height, 5)));
+    this.#style(imgEl, "width", `${imgEl.naturalWidth * scale}px`);
+    this.#style(imgEl, "height", `${imgEl.naturalHeight * scale}px`);
+    this.#style(
+      imgEl,
+      "transform",
+      thumbnail.coords ? `translate(-${thumbnail.coords.x * scale}px, -${thumbnail.coords.y * scale}px)` : ""
+    );
+    this.#style(imgEl, "max-width", "none");
+  }
+  #style(el, name, value) {
+    el.style.setProperty(name, value);
+    this.#styleResets.push(() => el.style.removeProperty(name));
+  }
+  #resetStyles() {
+    for (const reset of this.#styleResets) reset();
+    this.#styleResets = [];
+  }
+}
+
+class SliderThumbnail extends Thumbnail {
+  #slider;
+  onAttach(el) {
+    this.#slider = useState(Slider.state);
+  }
+  getTime() {
+    const { duration, clipStartTime } = this.media.$state;
+    return clipStartTime() + this.#slider.pointerRate() * duration();
+  }
+}
+
+class SliderVideo extends Component {
+  static props = {
+    src: null,
+    crossOrigin: null
+  };
+  static state = new State({
+    video: null,
+    src: null,
+    crossOrigin: null,
+    canPlay: false,
+    error: null,
+    hidden: false
+  });
+  #media;
+  #slider;
+  get video() {
+    return this.$state.video();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#slider = useState(Slider.state);
+    this.#watchCrossOrigin();
+    this.setAttributes({
+      "data-loading": this.#isLoading.bind(this),
+      "data-hidden": this.$state.hidden,
+      "data-error": this.#hasError.bind(this),
+      "aria-hidden": $ariaBool(this.$state.hidden)
+    });
+  }
+  onAttach(el) {
+    effect(this.#watchVideo.bind(this));
+    effect(this.#watchSrc.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#onSrcChange.bind(this));
+    effect(this.#onUpdateTime.bind(this));
+  }
+  #watchVideo() {
+    const video = this.$state.video();
+    if (!video) return;
+    if (video.readyState >= 2) this.#onCanPlay();
+    new EventsController(video).add("canplay", this.#onCanPlay.bind(this)).add("error", this.#onError.bind(this));
+  }
+  #watchSrc() {
+    const { src } = this.$state, { canLoad } = this.#media.$state;
+    src.set(canLoad() ? this.$props.src() : null);
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
+  }
+  #isLoading() {
+    const { canPlay, hidden } = this.$state;
+    return !canPlay() && !hidden();
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error);
+  }
+  #watchHidden() {
+    const { src, hidden } = this.$state, { canLoad, duration } = this.#media.$state;
+    hidden.set(canLoad() && (!src() || this.#hasError() || !Number.isFinite(duration())));
+  }
+  #onSrcChange() {
+    const { src, canPlay, error } = this.$state;
+    src();
+    canPlay.set(false);
+    error.set(null);
+  }
+  #onCanPlay(event) {
+    const { canPlay, error } = this.$state;
+    canPlay.set(true);
+    error.set(null);
+    this.dispatch("can-play", { trigger: event });
+  }
+  #onError(event) {
+    const { canPlay, error } = this.$state;
+    canPlay.set(false);
+    error.set(event);
+    this.dispatch("error", { trigger: event });
+  }
+  #onUpdateTime() {
+    const { video, canPlay } = this.$state, { duration } = this.#media.$state, { pointerRate } = this.#slider, media = video(), canUpdate = canPlay() && media && Number.isFinite(duration()) && Number.isFinite(pointerRate());
+    if (canUpdate) {
+      media.currentTime = pointerRate() * duration();
+    }
+  }
+}
+const slidervideo__proto = SliderVideo.prototype;
+prop(slidervideo__proto, "video");
+
+class SliderValue extends Component {
+  static props = {
+    type: "pointer",
+    format: null,
+    showHours: false,
+    showMs: false,
+    padHours: null,
+    padMinutes: null,
+    decimalPlaces: 2
+  };
+  #format;
+  #text;
+  #slider;
+  onSetup() {
+    this.#slider = useState(Slider.state);
+    this.#format = useContext(sliderValueFormatContext);
+    this.#text = computed(this.getValueText.bind(this));
+  }
+  /**
+   * Returns the current value formatted as text based on prop settings.
+   */
+  getValueText() {
+    const {
+      type,
+      format: $format,
+      decimalPlaces,
+      padHours,
+      padMinutes,
+      showHours,
+      showMs
+    } = this.$props, { value: sliderValue, pointerValue, min, max } = this.#slider, format = $format?.() ?? this.#format.default;
+    const value = type() === "current" ? sliderValue() : pointerValue();
+    if (format === "percent") {
+      const range = max() - min();
+      const percent = value / range * 100;
+      return (this.#format.percent ?? round)(percent, decimalPlaces()) + "%";
+    } else if (format === "time") {
+      return (this.#format.time ?? formatTime)(value, {
+        padHrs: padHours(),
+        padMins: padMinutes(),
+        showHrs: showHours(),
+        showMs: showMs()
+      });
+    } else {
+      return (this.#format.value?.(value) ?? value.toFixed(2)) + "";
+    }
+  }
+}
+const slidervalue__proto = SliderValue.prototype;
+method(slidervalue__proto, "getValueText");
+
+class SliderPreview extends Component {
+  static props = {
+    offset: 0,
+    noClamp: false
+  };
+  #slider;
+  onSetup() {
+    this.#slider = useContext(sliderContext);
+    const { active } = useState(Slider.state);
+    this.setAttributes({
+      "data-visible": active
+    });
+  }
+  onAttach(el) {
+    Object.assign(el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+  }
+  onConnect(el) {
+    const { preview } = this.#slider;
+    preview.set(el);
+    onDispose(() => preview.set(null));
+    effect(this.#updatePlacement.bind(this));
+    const resize = new ResizeObserver(this.#updatePlacement.bind(this));
+    resize.observe(el);
+    onDispose(() => resize.disconnect());
+  }
+  #updatePlacement = animationFrameThrottle(() => {
+    const { disabled, orientation } = this.#slider;
+    if (disabled()) return;
+    const el = this.el, { offset, noClamp } = this.$props;
+    if (!el) return;
+    updateSliderPreviewPlacement(el, {
+      clamp: !noClamp(),
+      offset: offset(),
+      orientation: orientation()
+    });
+  });
+}
+function updateSliderPreviewPlacement(el, {
+  clamp,
+  offset,
+  orientation
+}) {
+  const computedStyle = getComputedStyle(el), width = parseFloat(computedStyle.width), height = parseFloat(computedStyle.height), styles = {
+    top: null,
+    right: null,
+    bottom: null,
+    left: null
+  };
+  styles[orientation === "horizontal" ? "bottom" : "left"] = `calc(100% + var(--media-slider-preview-offset, ${offset}px))`;
+  if (orientation === "horizontal") {
+    const widthHalf = width / 2;
+    if (!clamp) {
+      styles.left = `calc(var(--slider-pointer) - ${widthHalf}px)`;
+    } else {
+      const leftClamp = `max(0px, calc(var(--slider-pointer) - ${widthHalf}px))`, rightClamp = `calc(100% - ${width}px)`;
+      styles.left = `min(${leftClamp}, ${rightClamp})`;
+    }
+  } else {
+    const heightHalf = height / 2;
+    if (!clamp) {
+      styles.bottom = `calc(var(--slider-pointer) - ${heightHalf}px)`;
+    } else {
+      const topClamp = `max(${heightHalf}px, calc(var(--slider-pointer) - ${heightHalf}px))`, bottomClamp = `calc(100% - ${height}px)`;
+      styles.bottom = `min(${topClamp}, ${bottomClamp})`;
+    }
+  }
+  Object.assign(el.style, styles);
+}
+
+class VolumeSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    keyStep: 5,
+    shiftKeyMultiplier: 2
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    const { audioGain } = this.#media.$state;
+    provideContext(sliderValueFormatContext, {
+      default: "percent",
+      value(value) {
+        return (value * (audioGain() ?? 1)).toFixed(2);
+      },
+      percent(value) {
+        return Math.round(value * (audioGain() ?? 1));
+      }
+    });
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueMax: this.#getARIAValueMax.bind(this),
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchVolume.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-volume-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Volume");
+    const { canSetVolume } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetVolume,
+      "aria-hidden": $ariaBool(() => !canSetVolume())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state, { audioGain } = this.#media.$state;
+    return Math.round(value() * (audioGain() ?? 1));
+  }
+  #getARIAValueText() {
+    const { value, max } = this.$state, { audioGain } = this.#media.$state;
+    return round(value() / max() * (audioGain() ?? 1) * 100, 2) + "%";
+  }
+  #getARIAValueMax() {
+    const { audioGain } = this.#media.$state;
+    return this.$state.max() * (audioGain() ?? 1);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetVolume } = this.#media.$state;
+    return disabled() || !canSetVolume();
+  }
+  #watchVolume() {
+    const { muted, volume } = this.#media.$state;
+    const newValue = muted() ? 0 : volume() * 100;
+    this.$state.value.set(newValue);
+    this.dispatch("value-change", { detail: newValue });
+  }
+  #throttleVolumeChange = functionThrottle(this.#onVolumeChange.bind(this), 25);
+  #onVolumeChange(event) {
+    if (!event.trigger) return;
+    const mediaVolume = round(event.detail / 100, 3);
+    this.#media.remote.changeVolume(mediaVolume, event);
+  }
+  #onValueChange(event) {
+    this.#throttleVolumeChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttleVolumeChange(event);
+  }
+}
+
+class AudioGainSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 25,
+    keyStep: 25,
+    shiftKeyMultiplier: 2,
+    min: 0,
+    max: 300
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(sliderValueFormatContext, {
+      default: "percent",
+      percent: (_, decimalPlaces) => {
+        return round(this.$state.value(), decimalPlaces) + "%";
+      }
+    });
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMinMax.bind(this));
+    effect(this.#watchAudioGain.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-audio-gain-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Audio Boost");
+    const { canSetAudioGain } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetAudioGain,
+      "aria-hidden": $ariaBool(() => !canSetAudioGain())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const { value } = this.$state;
+    return value() + "%";
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+  #watchAudioGain() {
+    const { audioGain } = this.#media.$state, value = ((audioGain() ?? 1) - 1) * 100;
+    this.$state.value.set(value);
+    this.dispatch("value-change", { detail: value });
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetAudioGain } = this.#media.$state;
+    return disabled() || !canSetAudioGain();
+  }
+  #onAudioGainChange(event) {
+    if (!event.trigger) return;
+    const gain = round(1 + event.detail / 100, 2);
+    this.#media.remote.changeAudioGain(gain, event);
+  }
+  #onValueChange(event) {
+    this.#onAudioGainChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#onAudioGainChange(event);
+  }
+}
+
+class SpeedSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 0.25,
+    keyStep: 0.25,
+    shiftKeyMultiplier: 2,
+    min: 0,
+    max: 2
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: this.#roundValue,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMinMax.bind(this));
+    effect(this.#watchPlaybackRate.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-speed-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Speed");
+    const { canSetPlaybackRate } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetPlaybackRate,
+      "aria-hidden": $ariaBool(() => !canSetPlaybackRate())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return value();
+  }
+  #getARIAValueText() {
+    const { value } = this.$state;
+    return value() + "x";
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+  #watchPlaybackRate() {
+    const { playbackRate } = this.#media.$state;
+    const newValue = playbackRate();
+    this.$state.value.set(newValue);
+    this.dispatch("value-change", { detail: newValue });
+  }
+  #roundValue(value) {
+    return round(value, 2);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetPlaybackRate } = this.#media.$state;
+    return disabled() || !canSetPlaybackRate();
+  }
+  #throttledSpeedChange = functionThrottle(this.#onPlaybackRateChange.bind(this), 25);
+  #onPlaybackRateChange(event) {
+    if (!event.trigger) return;
+    const rate = event.detail;
+    this.#media.remote.changePlaybackRate(rate, event);
+  }
+  #onValueChange(event) {
+    this.#throttledSpeedChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttledSpeedChange(event);
+  }
+}
+
+class QualitySlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 1,
+    keyStep: 1,
+    shiftKeyMultiplier: 1
+  };
+  static state = sliderState;
+  #media;
+  #sortedQualities = computed(() => {
+    const { qualities } = this.#media.$state;
+    return sortVideoQualities(qualities());
+  });
+  onSetup() {
+    this.#media = useMediaContext();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMax.bind(this));
+    effect(this.#watchQuality.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-quality-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Video Quality");
+    const { qualities, canSetQuality } = this.#media.$state, $supported = computed(() => canSetQuality() && qualities().length > 0);
+    this.setAttributes({
+      "data-supported": $supported,
+      "aria-hidden": $ariaBool(() => !$supported())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return value();
+  }
+  #getARIAValueText() {
+    const { quality } = this.#media.$state;
+    if (!quality()) return "";
+    const { height, bitrate } = quality(), bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null;
+    return height ? `${height}p${bitrateText ? ` (${bitrateText})` : ""}` : "Auto";
+  }
+  #watchMax() {
+    const $qualities = this.#sortedQualities();
+    this.$state.max.set(Math.max(0, $qualities.length - 1));
+  }
+  #watchQuality() {
+    let { quality } = this.#media.$state, $qualities = this.#sortedQualities(), value = Math.max(0, $qualities.indexOf(quality()));
+    this.$state.value.set(value);
+    this.dispatch("value-change", { detail: value });
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetQuality, qualities } = this.#media.$state;
+    return disabled() || qualities().length <= 1 || !canSetQuality();
+  }
+  #throttledQualityChange = functionThrottle(this.#onQualityChange.bind(this), 25);
+  #onQualityChange(event) {
+    if (!event.trigger) return;
+    const { qualities } = this.#media, quality = peek(this.#sortedQualities)[event.detail];
+    this.#media.remote.changeQuality(qualities.indexOf(quality), event);
+  }
+  #onValueChange(event) {
+    this.#throttledQualityChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttledQualityChange(event);
+  }
+}
+
+class TimeSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 0.1,
+    keyStep: 5,
+    shiftKeyMultiplier: 2,
+    pauseWhileDragging: false,
+    noSwipeGesture: false,
+    seekingRequestThrottle: 100
+  };
+  static state = sliderState;
+  #media;
+  #dispatchSeeking;
+  #chapter = signal(null);
+  constructor() {
+    super();
+    const { noSwipeGesture } = this.$props;
+    new SliderController({
+      swipeGesture: () => !noSwipeGesture(),
+      getValue: this.#getValue.bind(this),
+      getStep: this.#getStep.bind(this),
+      getKeyStep: this.#getKeyStep.bind(this),
+      roundValue: this.#roundValue,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragStart: this.#onDragStart.bind(this),
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onDragEnd: this.#onDragEnd.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(sliderValueFormatContext, {
+      default: "time",
+      value: this.#formatValue.bind(this),
+      time: this.#formatTime.bind(this)
+    });
+    this.setAttributes({
+      "data-chapters": this.#hasChapters.bind(this)
+    });
+    this.setStyles({
+      "--slider-progress": this.#calcBufferedPercent.bind(this)
+    });
+    effect(this.#watchCurrentTime.bind(this));
+    effect(this.#watchSeekingThrottle.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-time-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Seek");
+  }
+  onConnect(el) {
+    effect(this.#watchPreviewing.bind(this));
+    watchActiveTextTrack(this.#media.textTracks, "chapters", this.#chapter.set);
+  }
+  #calcBufferedPercent() {
+    const { bufferedEnd, duration } = this.#media.$state;
+    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + "%";
+  }
+  #hasChapters() {
+    const { duration } = this.#media.$state;
+    return this.#chapter()?.cues.length && Number.isFinite(duration()) && duration() > 0;
+  }
+  #watchSeekingThrottle() {
+    this.#dispatchSeeking = functionThrottle(
+      this.#seeking.bind(this),
+      this.$props.seekingRequestThrottle()
+    );
+  }
+  #watchCurrentTime() {
+    if (this.$state.hidden()) return;
+    const { value, dragging } = this.$state, newValue = this.#getValue();
+    if (!peek(dragging)) {
+      value.set(newValue);
+      this.dispatch("value-change", { detail: newValue });
+    }
+  }
+  #watchPreviewing() {
+    const player = this.#media.player.el, { preview } = useContext(sliderContext);
+    player && preview() && setAttribute(player, "data-preview", this.$state.active());
+  }
+  #seeking(time, event) {
+    this.#media.remote.seeking(time, event);
+  }
+  #seek(time, percent, event) {
+    this.#dispatchSeeking.cancel();
+    const { live } = this.#media.$state;
+    if (live() && percent >= 99) {
+      this.#media.remote.seekToLiveEdge(event);
+      return;
+    }
+    this.#media.remote.seek(time, event);
+  }
+  #playingBeforeDragStart = false;
+  #onDragStart(event) {
+    const { pauseWhileDragging } = this.$props;
+    if (pauseWhileDragging()) {
+      const { paused } = this.#media.$state;
+      this.#playingBeforeDragStart = !paused();
+      this.#media.remote.pause(event);
+    }
+  }
+  #onDragValueChange(event) {
+    this.#dispatchSeeking(this.#percentToTime(event.detail), event);
+  }
+  #onDragEnd(event) {
+    const { seeking } = this.#media.$state;
+    if (!peek(seeking)) this.#seeking(this.#percentToTime(event.detail), event);
+    const percent = event.detail;
+    this.#seek(this.#percentToTime(percent), percent, event);
+    const { pauseWhileDragging } = this.$props;
+    if (pauseWhileDragging() && this.#playingBeforeDragStart) {
+      this.#media.remote.play(event);
+      this.#playingBeforeDragStart = false;
+    }
+  }
+  #onValueChange(event) {
+    const { dragging } = this.$state;
+    if (dragging() || !event.trigger) return;
+    this.#onDragEnd(event);
+  }
+  // -------------------------------------------------------------------------------------------
+  // Props
+  // -------------------------------------------------------------------------------------------
+  #getValue() {
+    const { currentTime } = this.#media.$state;
+    return this.#timeToPercent(currentTime());
+  }
+  #getStep() {
+    const value = this.$props.step() / this.#media.$state.duration() * 100;
+    return Number.isFinite(value) ? value : 1;
+  }
+  #getKeyStep() {
+    const value = this.$props.keyStep() / this.#media.$state.duration() * 100;
+    return Number.isFinite(value) ? value : 1;
+  }
+  #roundValue(value) {
+    return round(value, 3);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSeek } = this.#media.$state;
+    return disabled() || !canSeek();
+  }
+  // -------------------------------------------------------------------------------------------
+  // ARIA
+  // -------------------------------------------------------------------------------------------
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const time = this.#percentToTime(this.$state.value()), { duration } = this.#media.$state;
+    return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : "live";
+  }
+  // -------------------------------------------------------------------------------------------
+  // Format
+  // -------------------------------------------------------------------------------------------
+  #percentToTime(percent) {
+    const { duration } = this.#media.$state;
+    return round(percent / 100 * duration(), 5);
+  }
+  #timeToPercent(time) {
+    const { liveEdge, duration } = this.#media.$state, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));
+    return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
+  }
+  #formatValue(percent) {
+    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state;
+    return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : "LIVE";
+  }
+  #formatTime(percent, options) {
+    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state, value = live() ? time - duration() : time;
+    return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(Math.abs(value), options)}` : "LIVE";
+  }
+}
+
+class SliderChapters extends Component {
+  static props = {
+    disabled: false
+  };
+  #media;
+  #sliderState;
+  #updateScope;
+  #titleRef = null;
+  #refs = [];
+  #$track = signal(null);
+  #$cues = signal([]);
+  #activeIndex = signal(-1);
+  #activePointerIndex = signal(-1);
+  #bufferedIndex = 0;
+  get cues() {
+    return this.#$cues();
+  }
+  get activeCue() {
+    return this.#$cues()[this.#activeIndex()] || null;
+  }
+  get activePointerCue() {
+    return this.#$cues()[this.#activePointerIndex()] || null;
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#sliderState = useState(TimeSlider.state);
+  }
+  onAttach(el) {
+    watchActiveTextTrack(this.#media.textTracks, "chapters", this.#setTrack.bind(this));
+    effect(this.#watchSource.bind(this));
+  }
+  onConnect() {
+    onDispose(() => this.#reset.bind(this));
+  }
+  onDestroy() {
+    this.#setTrack(null);
+  }
+  setRefs(refs) {
+    this.#refs = refs;
+    this.#updateScope?.dispose();
+    if (this.#refs.length === 1) {
+      const el = this.#refs[0];
+      el.style.width = "100%";
+      el.style.setProperty("--chapter-fill", "var(--slider-fill)");
+      el.style.setProperty("--chapter-progress", "var(--slider-progress)");
+    } else if (this.#refs.length > 0) {
+      scoped(() => this.#watch(), this.#updateScope = createScope());
+    }
+  }
+  #setTrack(track) {
+    if (peek(this.#$track) === track) return;
+    this.#reset();
+    this.#$track.set(track);
+  }
+  #reset() {
+    this.#refs = [];
+    this.#$cues.set([]);
+    this.#activeIndex.set(-1);
+    this.#activePointerIndex.set(-1);
+    this.#bufferedIndex = 0;
+    this.#updateScope?.dispose();
+  }
+  #watch() {
+    if (!this.#refs.length) return;
+    effect(this.#watchUpdates.bind(this));
+  }
+  #watchUpdates() {
+    const { hidden } = this.#sliderState;
+    if (hidden()) return;
+    effect(this.#watchContainerWidths.bind(this));
+    effect(this.#watchFillPercent.bind(this));
+    effect(this.#watchPointerPercent.bind(this));
+    effect(this.#watchBufferedPercent.bind(this));
+  }
+  #watchContainerWidths() {
+    const cues = this.#$cues();
+    if (!cues.length) return;
+    let cue, { seekableStart, seekableEnd } = this.#media.$state, startTime = seekableStart(), endTime = seekableEnd() || cues[cues.length - 1].endTime, duration = endTime - startTime, remainingWidth = 100;
+    for (let i = 0; i < cues.length; i++) {
+      cue = cues[i];
+      if (this.#refs[i]) {
+        const width = i === cues.length - 1 ? remainingWidth : round((cue.endTime - Math.max(startTime, cue.startTime)) / duration * 100, 3);
+        this.#refs[i].style.width = width + "%";
+        remainingWidth -= width;
+      }
+    }
+  }
+  #watchFillPercent() {
+    let { liveEdge, seekableStart, seekableEnd } = this.#media.$state, { fillPercent, value } = this.#sliderState, cues = this.#$cues(), isLiveEdge = liveEdge(), prevActiveIndex = peek(this.#activeIndex), currentChapter = cues[prevActiveIndex];
+    let currentActiveIndex = isLiveEdge ? this.#$cues.length - 1 : this.#findActiveChapterIndex(
+      currentChapter ? currentChapter.startTime / seekableEnd() * 100 <= peek(value) ? prevActiveIndex : 0 : 0,
+      fillPercent()
+    );
+    if (isLiveEdge || !currentChapter) {
+      this.#updateFillPercents(0, cues.length, 100);
+    } else if (currentActiveIndex > prevActiveIndex) {
+      this.#updateFillPercents(prevActiveIndex, currentActiveIndex, 100);
+    } else if (currentActiveIndex < prevActiveIndex) {
+      this.#updateFillPercents(currentActiveIndex + 1, prevActiveIndex + 1, 0);
+    }
+    const percent = isLiveEdge ? 100 : this.#calcPercent(
+      cues[currentActiveIndex],
+      fillPercent(),
+      seekableStart(),
+      this.#getEndTime(cues)
+    );
+    this.#updateFillPercent(this.#refs[currentActiveIndex], percent);
+    this.#activeIndex.set(currentActiveIndex);
+  }
+  #watchPointerPercent() {
+    let { pointing, pointerPercent } = this.#sliderState;
+    if (!pointing()) {
+      this.#activePointerIndex.set(-1);
+      return;
+    }
+    const activeIndex = this.#findActiveChapterIndex(0, pointerPercent());
+    this.#activePointerIndex.set(activeIndex);
+  }
+  #updateFillPercents(start, end, percent) {
+    for (let i = start; i < end; i++) this.#updateFillPercent(this.#refs[i], percent);
+  }
+  #updateFillPercent(ref, percent) {
+    if (!ref) return;
+    ref.style.setProperty("--chapter-fill", percent + "%");
+    setAttribute(ref, "data-active", percent > 0 && percent < 100);
+    setAttribute(ref, "data-ended", percent === 100);
+  }
+  #findActiveChapterIndex(startIndex, percent) {
+    let chapterPercent = 0, cues = this.#$cues();
+    if (percent === 0) return 0;
+    else if (percent === 100) return cues.length - 1;
+    let { seekableStart } = this.#media.$state, startTime = seekableStart(), endTime = this.#getEndTime(cues);
+    for (let i = startIndex; i < cues.length; i++) {
+      chapterPercent = this.#calcPercent(cues[i], percent, startTime, endTime);
+      if (chapterPercent >= 0 && chapterPercent < 100) return i;
+    }
+    return 0;
+  }
+  #watchBufferedPercent() {
+    this.#updateBufferedPercent(this.#bufferedPercent());
+  }
+  #updateBufferedPercent = animationFrameThrottle((bufferedPercent) => {
+    let percent, cues = this.#$cues(), { seekableStart } = this.#media.$state, startTime = seekableStart(), endTime = this.#getEndTime(cues);
+    for (let i = this.#bufferedIndex; i < this.#refs.length; i++) {
+      percent = this.#calcPercent(cues[i], bufferedPercent, startTime, endTime);
+      this.#refs[i]?.style.setProperty("--chapter-progress", percent + "%");
+      if (percent < 100) {
+        this.#bufferedIndex = i;
+        break;
+      }
+    }
+  });
+  #bufferedPercent = computed(this.#calcMediaBufferedPercent.bind(this));
+  #calcMediaBufferedPercent() {
+    const { bufferedEnd, duration } = this.#media.$state;
+    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1), 3) * 100;
+  }
+  #getEndTime(cues) {
+    const { seekableEnd } = this.#media.$state, endTime = seekableEnd();
+    return Number.isFinite(endTime) ? endTime : cues[cues.length - 1]?.endTime || 0;
+  }
+  #calcPercent(cue, percent, startTime, endTime) {
+    if (!cue) return 0;
+    const cues = this.#$cues();
+    if (cues.length === 0) return 0;
+    const duration = endTime - startTime, cueStartTime = Math.max(0, cue.startTime - startTime), cueEndTime = Math.min(endTime, cue.endTime) - startTime;
+    const startRatio = cueStartTime / duration, startPercent = startRatio * 100, endPercent = Math.min(1, startRatio + (cueEndTime - cueStartTime) / duration) * 100;
+    return Math.max(
+      0,
+      round(
+        percent >= endPercent ? 100 : (percent - startPercent) / (endPercent - startPercent) * 100,
+        3
+      )
+    );
+  }
+  #fillGaps(cues) {
+    let chapters = [], { seekableStart, seekableEnd, duration } = this.#media.$state, startTime = seekableStart(), endTime = seekableEnd();
+    cues = cues.filter((cue) => cue.startTime <= endTime && cue.endTime >= startTime);
+    const firstCue = cues[0];
+    if (firstCue && firstCue.startTime > startTime) {
+      chapters.push(new window.VTTCue(startTime, firstCue.startTime, ""));
+    }
+    for (let i = 0; i < cues.length - 1; i++) {
+      const currentCue = cues[i], nextCue = cues[i + 1];
+      chapters.push(currentCue);
+      if (nextCue) {
+        const timeDiff = nextCue.startTime - currentCue.endTime;
+        if (timeDiff > 0) {
+          chapters.push(new window.VTTCue(currentCue.endTime, currentCue.endTime + timeDiff, ""));
+        }
+      }
+    }
+    const lastCue = cues[cues.length - 1];
+    if (lastCue) {
+      chapters.push(lastCue);
+      const endTime2 = duration();
+      if (endTime2 >= 0 && endTime2 - lastCue.endTime > 1) {
+        chapters.push(new window.VTTCue(lastCue.endTime, duration(), ""));
+      }
+    }
+    return chapters;
+  }
+  #watchSource() {
+    const { source } = this.#media.$state;
+    source();
+    this.#onTrackChange();
+  }
+  #onTrackChange() {
+    if (!this.scope) return;
+    const { disabled } = this.$props;
+    if (disabled()) {
+      this.#$cues.set([]);
+      this.#activeIndex.set(0);
+      this.#bufferedIndex = 0;
+      return;
+    }
+    const track = this.#$track();
+    if (track) {
+      const onCuesChange = this.#onCuesChange.bind(this);
+      onCuesChange();
+      new EventsController(track).add("add-cue", onCuesChange).add("remove-cue", onCuesChange);
+      effect(this.#watchMediaDuration.bind(this));
+    }
+    this.#titleRef = this.#findChapterTitleRef();
+    if (this.#titleRef) effect(this.#onChapterTitleChange.bind(this));
+    return () => {
+      if (this.#titleRef) {
+        this.#titleRef.textContent = "";
+        this.#titleRef = null;
+      }
+    };
+  }
+  #watchMediaDuration() {
+    this.#media.$state.duration();
+    this.#onCuesChange();
+  }
+  #onCuesChange = functionDebounce(
+    () => {
+      const track = peek(this.#$track);
+      if (!this.scope || !track || !track.cues.length) return;
+      this.#$cues.set(this.#fillGaps(track.cues));
+      this.#activeIndex.set(0);
+      this.#bufferedIndex = 0;
+    },
+    150,
+    true
+  );
+  #onChapterTitleChange() {
+    const cue = this.activePointerCue || this.activeCue;
+    if (this.#titleRef) this.#titleRef.textContent = cue?.text || "";
+  }
+  #findParentSlider() {
+    let node = this.el;
+    while (node && node.getAttribute("role") !== "slider") {
+      node = node.parentElement;
+    }
+    return node;
+  }
+  #findChapterTitleRef() {
+    const slider = this.#findParentSlider();
+    return slider ? slider.querySelector('[data-part="chapter-title"]') : null;
+  }
+}
+const sliderchapters__proto = SliderChapters.prototype;
+prop(sliderchapters__proto, "cues");
+prop(sliderchapters__proto, "activeCue");
+prop(sliderchapters__proto, "activePointerCue");
+method(sliderchapters__proto, "setRefs");
+
+const menuContext = createContext();
+
+function scrollIntoView(el, options) {
+  const scrolls = r(el, options);
+  for (const { el: el2, top, left } of scrolls) {
+    el2.scroll({ top, left, behavior: options.behavior });
+  }
+}
+function scrollIntoCenter(el, options = {}) {
+  scrollIntoView(el, {
+    scrollMode: "if-needed",
+    block: "center",
+    inline: "center",
+    ...options
+  });
+}
+
+const FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
+  "a[href]",
+  "[tabindex]",
+  "input",
+  "select",
+  "button"
+].map((selector) => `${selector}:not([aria-hidden='true'])`).join(",");
+const VALID_KEYS = /* @__PURE__ */ new Set([
+  "Escape",
+  "Tab",
+  "ArrowUp",
+  "ArrowDown",
+  "Home",
+  "PageUp",
+  "End",
+  "PageDown",
+  "Enter",
+  " "
+]);
+class MenuFocusController {
+  #index = -1;
+  #el = null;
+  #elements = [];
+  #delegate;
+  get items() {
+    return this.#elements;
+  }
+  constructor(delegate) {
+    this.#delegate = delegate;
+  }
+  attachMenu(el) {
+    listenEvent(el, "focus", this.#onFocus.bind(this));
+    this.#el = el;
+    onDispose(() => {
+      this.#el = null;
+    });
+  }
+  listen() {
+    if (!this.#el) return;
+    this.update();
+    new EventsController(this.#el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this));
+    onDispose(() => {
+      this.#index = -1;
+      this.#elements = [];
+    });
+  }
+  update() {
+    this.#index = 0;
+    this.#elements = this.#getFocusableElements();
+  }
+  scroll(index = this.#findActiveIndex()) {
+    const element = this.#elements[index];
+    if (element) {
+      requestAnimationFrame(() => {
+        requestAnimationFrame(() => {
+          scrollIntoCenter(element, {
+            behavior: "smooth",
+            boundary: (el) => {
+              return !el.hasAttribute("data-root");
+            }
+          });
+        });
+      });
+    }
+  }
+  focusActive(scroll = true) {
+    const index = this.#findActiveIndex();
+    this.#focusAt(index >= 0 ? index : 0, scroll);
+  }
+  #focusAt(index, scroll = true) {
+    this.#index = index;
+    if (this.#elements[index]) {
+      this.#elements[index].focus({ preventScroll: true });
+      if (scroll) this.scroll(index);
+    } else {
+      this.#el?.focus({ preventScroll: true });
+    }
+  }
+  #findActiveIndex() {
+    return this.#elements.findIndex(
+      (el) => document.activeElement === el || el.getAttribute("role") === "menuitemradio" && el.getAttribute("aria-checked") === "true"
+    );
+  }
+  #onFocus() {
+    if (this.#index >= 0) return;
+    this.update();
+    this.focusActive();
+  }
+  #validateKeyEvent(event) {
+    const el = event.target;
+    if (wasEnterKeyPressed(event) && el instanceof Element) {
+      const role = el.getAttribute("role");
+      return !/a|input|select|button/.test(el.localName) && !role;
+    }
+    return VALID_KEYS.has(event.key);
+  }
+  #onKeyUp(event) {
+    if (!this.#validateKeyEvent(event)) return;
+    event.stopPropagation();
+    event.preventDefault();
+  }
+  #onKeyDown(event) {
+    if (!this.#validateKeyEvent(event)) return;
+    event.stopPropagation();
+    event.preventDefault();
+    switch (event.key) {
+      case "Escape":
+        this.#delegate.closeMenu(event);
+        break;
+      case "Tab":
+        this.#focusAt(this.#nextIndex(event.shiftKey ? -1 : 1));
+        break;
+      case "ArrowUp":
+        this.#focusAt(this.#nextIndex(-1));
+        break;
+      case "ArrowDown":
+        this.#focusAt(this.#nextIndex(1));
+        break;
+      case "Home":
+      case "PageUp":
+        this.#focusAt(0);
+        break;
+      case "End":
+      case "PageDown":
+        this.#focusAt(this.#elements.length - 1);
+        break;
+    }
+  }
+  #nextIndex(delta) {
+    let index = this.#index;
+    do {
+      index = (index + delta + this.#elements.length) % this.#elements.length;
+    } while (this.#elements[index]?.offsetParent === null);
+    return index;
+  }
+  #getFocusableElements() {
+    if (!this.#el) return [];
+    const focusableElements = this.#el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
+    const is = (node) => {
+      return node.getAttribute("role") === "menu";
+    };
+    for (const el of focusableElements) {
+      if (isHTMLElement(el) && el.offsetParent !== null && // does not have display: none
+      isElementParent(this.#el, el, is)) {
+        elements.push(el);
+      }
+    }
+    return elements;
+  }
+}
+
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __decorateClass = (decorators, target, key, kind) => {
+  var result = __getOwnPropDesc(target, key) ;
+  for (var i = decorators.length - 1, decorator; i >= 0; i--)
+    if (decorator = decorators[i])
+      result = (decorator(target, key, result) ) || result;
+  if (result) __defProp(target, key, result);
+  return result;
+};
+let idCount = 0;
+class Menu extends Component {
+  static props = {
+    showDelay: 0
+  };
+  #media;
+  #menuId;
+  #menuButtonId;
+  #expanded = signal(false);
+  #disabled = signal(false);
+  #trigger = signal(null);
+  #content = signal(null);
+  #parentMenu;
+  #submenus = /* @__PURE__ */ new Set();
+  #menuObserver = null;
+  #popper;
+  #focus;
+  #isSliderActive = false;
+  #isTriggerDisabled = signal(false);
+  #transitionCallbacks = /* @__PURE__ */ new Set();
+  get triggerElement() {
+    return this.#trigger();
+  }
+  get contentElement() {
+    return this.#content();
+  }
+  get isSubmenu() {
+    return !!this.#parentMenu;
+  }
+  constructor() {
+    super();
+    const { showDelay } = this.$props;
+    this.#popper = new Popper({
+      trigger: this.#trigger,
+      content: this.#content,
+      showDelay,
+      listen: (trigger, show, hide) => {
+        onPress(trigger, (event) => {
+          if (this.#expanded()) hide(event);
+          else show(event);
+        });
+        const closeTarget = this.#getCloseTarget();
+        if (closeTarget) {
+          onPress(closeTarget, (event) => {
+            event.stopPropagation();
+            hide(event);
+          });
+        }
+      },
+      onChange: this.#onExpandedChange.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const currentIdCount = ++idCount;
+    this.#menuId = `media-menu-${currentIdCount}`;
+    this.#menuButtonId = `media-menu-button-${currentIdCount}`;
+    this.#focus = new MenuFocusController({
+      closeMenu: this.close.bind(this)
+    });
+    if (hasProvidedContext(menuContext)) {
+      this.#parentMenu = useContext(menuContext);
+    }
+    this.#observeSliders();
+    this.setAttributes({
+      "data-open": this.#expanded,
+      "data-root": !this.isSubmenu,
+      "data-submenu": this.isSubmenu,
+      "data-disabled": this.#isDisabled.bind(this)
+    });
+    provideContext(menuContext, {
+      button: this.#trigger,
+      content: this.#content,
+      expanded: this.#expanded,
+      hint: signal(""),
+      submenu: !!this.#parentMenu,
+      disable: this.#disable.bind(this),
+      attachMenuButton: this.#attachMenuButton.bind(this),
+      attachMenuItems: this.#attachMenuItems.bind(this),
+      attachObserver: this.#attachObserver.bind(this),
+      disableMenuButton: this.#disableMenuButton.bind(this),
+      addSubmenu: this.#addSubmenu.bind(this),
+      onTransitionEvent: (callback) => {
+        this.#transitionCallbacks.add(callback);
+        onDispose(() => {
+          this.#transitionCallbacks.delete(callback);
+        });
+      }
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  onConnect(el) {
+    effect(this.#watchExpanded.bind(this));
+    if (this.isSubmenu) {
+      this.#parentMenu?.addSubmenu(this);
+    }
+  }
+  onDestroy() {
+    this.#trigger.set(null);
+    this.#content.set(null);
+    this.#menuObserver = null;
+    this.#transitionCallbacks.clear();
+  }
+  #observeSliders() {
+    let sliderActiveTimer = -1, parentSliderObserver = hasProvidedContext(sliderObserverContext) ? useContext(sliderObserverContext) : null;
+    provideContext(sliderObserverContext, {
+      onDragStart: () => {
+        parentSliderObserver?.onDragStart?.();
+        window.clearTimeout(sliderActiveTimer);
+        sliderActiveTimer = -1;
+        this.#isSliderActive = true;
+      },
+      onDragEnd: () => {
+        parentSliderObserver?.onDragEnd?.();
+        sliderActiveTimer = window.setTimeout(() => {
+          this.#isSliderActive = false;
+          sliderActiveTimer = -1;
+        }, 300);
+      }
+    });
+  }
+  #watchExpanded() {
+    const expanded = this.#isExpanded();
+    if (!this.isSubmenu) this.#onResize();
+    this.#updateMenuItemsHidden(expanded);
+    if (!expanded) return;
+    effect(() => {
+      const { height } = this.#media.$state, content = this.#content();
+      content && setStyle(content, "--player-height", height() + "px");
+    });
+    this.#focus.listen();
+    this.listen("pointerup", this.#onPointerUp.bind(this));
+    listenEvent(window, "pointerup", this.#onWindowPointerUp.bind(this));
+  }
+  #attachMenuButton(button) {
+    const el = button.el, isMenuItem = this.isSubmenu, isARIADisabled = $ariaBool(this.#isDisabled.bind(this));
+    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
+    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
+    setAttribute(el, "id", this.#menuButtonId);
+    setAttribute(el, "aria-haspopup", "menu");
+    setAttribute(el, "aria-expanded", "false");
+    setAttribute(el, "data-root", !this.isSubmenu);
+    setAttribute(el, "data-submenu", this.isSubmenu);
+    const watchAttrs = () => {
+      setAttribute(el, "data-open", this.#expanded());
+      setAttribute(el, "aria-disabled", isARIADisabled());
+    };
+    if (IS_SERVER) watchAttrs();
+    else effect(watchAttrs);
+    this.#trigger.set(el);
+    onDispose(() => {
+      this.#trigger.set(null);
+    });
+  }
+  #attachMenuItems(items) {
+    const el = items.el;
+    el.style.setProperty("display", "none");
+    setAttribute(el, "id", this.#menuId);
+    setAttributeIfEmpty(el, "role", "menu");
+    setAttributeIfEmpty(el, "tabindex", "-1");
+    setAttribute(el, "data-root", !this.isSubmenu);
+    setAttribute(el, "data-submenu", this.isSubmenu);
+    this.#content.set(el);
+    onDispose(() => this.#content.set(null));
+    const watchAttrs = () => setAttribute(el, "data-open", this.#expanded());
+    if (IS_SERVER) watchAttrs();
+    else effect(watchAttrs);
+    this.#focus.attachMenu(el);
+    this.#updateMenuItemsHidden(false);
+    const onTransition = this.#onResizeTransition.bind(this);
+    if (!this.isSubmenu) {
+      items.listen("transitionstart", onTransition);
+      items.listen("transitionend", onTransition);
+      items.listen("animationend", this.#onResize);
+      items.listen("vds-menu-resize", this.#onResize);
+    } else {
+      this.#parentMenu?.onTransitionEvent(onTransition);
+    }
+  }
+  #attachObserver(observer) {
+    this.#menuObserver = observer;
+  }
+  #updateMenuItemsHidden(expanded) {
+    const content = peek(this.#content);
+    if (content) setAttribute(content, "aria-hidden", ariaBool$1(!expanded));
+  }
+  #disableMenuButton(disabled) {
+    this.#isTriggerDisabled.set(disabled);
+  }
+  #wasKeyboardExpand = false;
+  #onExpandedChange(isExpanded, event) {
+    this.#wasKeyboardExpand = isKeyboardEvent(event);
+    event?.stopPropagation();
+    if (this.#expanded() === isExpanded) return;
+    if (this.#isDisabled()) {
+      if (isExpanded) this.#popper.hide(event);
+      return;
+    }
+    this.el?.dispatchEvent(
+      new Event("vds-menu-resize", {
+        bubbles: true,
+        composed: true
+      })
+    );
+    const trigger = this.#trigger(), content = this.#content();
+    if (trigger) {
+      setAttribute(trigger, "aria-controls", isExpanded && this.#menuId);
+      setAttribute(trigger, "aria-expanded", ariaBool$1(isExpanded));
+    }
+    if (content) setAttribute(content, "aria-labelledby", isExpanded && this.#menuButtonId);
+    this.#expanded.set(isExpanded);
+    this.#toggleMediaControls(event);
+    tick();
+    if (this.#wasKeyboardExpand) {
+      if (isExpanded) content?.focus();
+      else trigger?.focus();
+      for (const el of [this.el, content]) {
+        el && el.setAttribute("data-keyboard", "");
+      }
+    } else {
+      for (const el of [this.el, content]) {
+        el && el.removeAttribute("data-keyboard");
+      }
+    }
+    this.dispatch(isExpanded ? "open" : "close", { trigger: event });
+    if (isExpanded) {
+      if (!this.isSubmenu && this.#media.activeMenu !== this) {
+        this.#media.activeMenu?.close(event);
+        this.#media.activeMenu = this;
+      }
+      this.#menuObserver?.onOpen?.(event);
+    } else {
+      if (this.isSubmenu) {
+        for (const el of this.#submenus) el.close(event);
+      } else {
+        this.#media.activeMenu = null;
+      }
+      this.#menuObserver?.onClose?.(event);
+    }
+    if (isExpanded) {
+      requestAnimationFrame(this.#updateFocus.bind(this));
+    }
+  }
+  #updateFocus() {
+    if (this.#isTransitionActive || this.#isSubmenuOpen) return;
+    this.#focus.update();
+    requestAnimationFrame(() => {
+      if (this.#wasKeyboardExpand) {
+        this.#focus.focusActive();
+      } else {
+        this.#focus.scroll();
+      }
+    });
+  }
+  #isExpanded() {
+    return !this.#isDisabled() && this.#expanded();
+  }
+  #isDisabled() {
+    return this.#disabled() || this.#isTriggerDisabled();
+  }
+  #disable(disabled) {
+    this.#disabled.set(disabled);
+  }
+  #onPointerUp(event) {
+    const content = this.#content();
+    if (this.#isSliderActive || content && isEventInside(content, event)) {
+      return;
+    }
+    event.stopPropagation();
+  }
+  #onWindowPointerUp(event) {
+    const content = this.#content();
+    if (this.#isSliderActive || content && isEventInside(content, event)) {
+      return;
+    }
+    this.close(event);
+  }
+  #getCloseTarget() {
+    const target = this.el?.querySelector('[data-part="close-target"]');
+    return this.el && target && isElementParent(this.el, target, (node) => node.getAttribute("role") === "menu") ? target : null;
+  }
+  #toggleMediaControls(trigger) {
+    if (this.isSubmenu) return;
+    if (this.#expanded()) this.#media.remote.pauseControls(trigger);
+    else this.#media.remote.resumeControls(trigger);
+  }
+  #addSubmenu(menu) {
+    this.#submenus.add(menu);
+    new EventsController(menu).add("open", this.#onSubmenuOpenBind).add("close", this.#onSubmenuCloseBind);
+    onDispose(this.#removeSubmenuBind);
+  }
+  #removeSubmenuBind = this.#removeSubmenu.bind(this);
+  #removeSubmenu(menu) {
+    this.#submenus.delete(menu);
+  }
+  #isSubmenuOpen = false;
+  #onSubmenuOpenBind = this.#onSubmenuOpen.bind(this);
+  #onSubmenuOpen(event) {
+    this.#isSubmenuOpen = true;
+    const content = this.#content();
+    if (this.isSubmenu) {
+      this.triggerElement?.setAttribute("aria-hidden", "true");
+    }
+    for (const target of this.#submenus) {
+      if (target !== event.target) {
+        for (const el of [target.el, target.triggerElement]) {
+          el?.setAttribute("aria-hidden", "true");
+        }
+      }
+    }
+    if (content) {
+      const el = event.target.el;
+      for (const child of content.children) {
+        if (child.contains(el)) {
+          child.setAttribute("data-open", "");
+        } else if (child !== el) {
+          child.setAttribute("data-hidden", "");
+        }
+      }
+    }
+  }
+  #onSubmenuCloseBind = this.#onSubmenuClose.bind(this);
+  #onSubmenuClose(event) {
+    this.#isSubmenuOpen = false;
+    const content = this.#content();
+    if (this.isSubmenu) {
+      this.triggerElement?.setAttribute("aria-hidden", "false");
+    }
+    for (const target of this.#submenus) {
+      for (const el of [target.el, target.triggerElement]) {
+        el?.setAttribute("aria-hidden", "false");
+      }
+    }
+    if (content) {
+      for (const child of content.children) {
+        child.removeAttribute("data-open");
+        child.removeAttribute("data-hidden");
+      }
+    }
+  }
+  #onResize = animationFrameThrottle(() => {
+    const content = peek(this.#content);
+    if (!content || IS_SERVER) return;
+    let height = 0, styles = getComputedStyle(content), children = [...content.children];
+    for (const prop2 of ["paddingTop", "paddingBottom", "borderTopWidth", "borderBottomWidth"]) {
+      height += parseFloat(styles[prop2]) || 0;
+    }
+    for (const child of children) {
+      if (isHTMLElement(child) && child.style.display === "contents") {
+        children.push(...child.children);
+      } else if (child.nodeType === 3) {
+        height += parseFloat(getComputedStyle(child).fontSize);
+      } else if (isHTMLElement(child)) {
+        if (!isElementVisible(child)) continue;
+        const style = getComputedStyle(child);
+        height += child.offsetHeight + (parseFloat(style.marginTop) || 0) + (parseFloat(style.marginBottom) || 0);
+      }
+    }
+    setStyle(content, "--menu-height", height + "px");
+  });
+  #isTransitionActive = false;
+  #onResizeTransition(event) {
+    const content = this.#content();
+    if (content && event.propertyName === "height") {
+      this.#isTransitionActive = event.type === "transitionstart";
+      setAttribute(content, "data-transition", this.#isTransitionActive ? "height" : null);
+      if (this.#expanded()) this.#updateFocus();
+    }
+    for (const callback of this.#transitionCallbacks) callback(event);
+  }
+  open(trigger) {
+    if (peek(this.#expanded)) return;
+    this.#popper.show(trigger);
+    tick();
+  }
+  close(trigger) {
+    if (!peek(this.#expanded)) return;
+    this.#popper.hide(trigger);
+    tick();
+  }
+}
+__decorateClass([
+  prop
+], Menu.prototype, "triggerElement");
+__decorateClass([
+  prop
+], Menu.prototype, "contentElement");
+__decorateClass([
+  prop
+], Menu.prototype, "isSubmenu");
+__decorateClass([
+  method
+], Menu.prototype, "open");
+__decorateClass([
+  method
+], Menu.prototype, "close");
+
+class MenuButton extends Component {
+  static props = {
+    disabled: false
+  };
+  #menu;
+  #hintEl = signal(null);
+  get expanded() {
+    return this.#menu?.expanded() ?? false;
+  }
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#menu = useContext(menuContext);
+  }
+  onAttach(el) {
+    this.#menu.attachMenuButton(this);
+    effect(this.#watchDisabled.bind(this));
+    setAttributeIfEmpty(el, "type", "button");
+  }
+  onConnect(el) {
+    effect(this.#watchHintEl.bind(this));
+    this.#onMutation();
+    const mutations = new MutationObserver(this.#onMutation.bind(this));
+    mutations.observe(el, { attributeFilter: ["data-part"], childList: true, subtree: true });
+    onDispose(() => mutations.disconnect());
+    onPress(el, (trigger) => {
+      this.dispatch("select", { trigger });
+    });
+  }
+  #watchDisabled() {
+    this.#menu.disableMenuButton(this.$props.disabled());
+  }
+  #watchHintEl() {
+    const el = this.#hintEl();
+    if (!el) return;
+    effect(() => {
+      const text = this.#menu.hint();
+      if (text) el.textContent = text;
+    });
+  }
+  #onMutation() {
+    const hintEl = this.el?.querySelector('[data-part="hint"]');
+    this.#hintEl.set(hintEl ?? null);
+  }
+}
+const menubutton__proto = MenuButton.prototype;
+prop(menubutton__proto, "expanded");
+
+class MenuItem extends MenuButton {
+}
+
+class MenuPortal extends Component {
+  static props = {
+    container: null,
+    disabled: false
+  };
+  #target = null;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(menuPortalContext, {
+      attach: this.#attachElement.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  // Need this so connect scope is defined.
+  onConnect(el) {
+  }
+  onDestroy() {
+    this.#target?.remove();
+    this.#target = null;
+  }
+  #attachElement(el) {
+    this.#portal(false);
+    this.#target = el;
+    requestScopedAnimationFrame(() => {
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        effect(this.#watchDisabled.bind(this));
+      });
+    });
+  }
+  #watchDisabled() {
+    const { fullscreen } = this.#media.$state, { disabled } = this.$props;
+    this.#portal(disabled() === "fullscreen" ? !fullscreen() : !disabled());
+  }
+  #portal(shouldPortal) {
+    if (!this.#target) return;
+    let container = this.#getContainer(this.$props.container());
+    if (!container) return;
+    const isPortalled = this.#target.parentElement === container;
+    setAttribute(this.#target, "data-portal", shouldPortal);
+    if (shouldPortal) {
+      if (!isPortalled) {
+        this.#target.remove();
+        container.append(this.#target);
+      }
+    } else if (isPortalled && this.#target.parentElement === container) {
+      this.#target.remove();
+      this.el?.append(this.#target);
+    }
+  }
+  #getContainer(selector) {
+    if (isHTMLElement(selector)) return selector;
+    return selector ? document.querySelector(selector) : document.body;
+  }
+}
+const menuPortalContext = createContext();
+
+class MenuItems extends Component {
+  static props = {
+    placement: null,
+    offset: 0,
+    alignOffset: 0
+  };
+  #menu;
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { placement } = this.$props;
+    this.setAttributes({
+      "data-placement": placement
+    });
+  }
+  onAttach(el) {
+    this.#menu = useContext(menuContext);
+    this.#menu.attachMenuItems(this);
+    if (hasProvidedContext(menuPortalContext)) {
+      const portal = useContext(menuPortalContext);
+      if (portal) {
+        provideContext(menuPortalContext, null);
+        portal.attach(el);
+        onDispose(() => portal.attach(null));
+      }
+    }
+  }
+  onConnect(el) {
+    effect(this.#watchPlacement.bind(this));
+  }
+  #watchPlacement() {
+    const { expanded } = this.#menu;
+    if (!this.el || !expanded()) return;
+    const placement = this.$props.placement();
+    if (!placement) return;
+    Object.assign(this.el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+    const { offset: mainOffset, alignOffset } = this.$props;
+    onDispose(
+      autoPlacement(this.el, this.#getButton(), placement, {
+        offsetVarName: "media-menu",
+        xOffset: alignOffset(),
+        yOffset: mainOffset()
+      })
+    );
+    onDispose(this.#hide.bind(this));
+  }
+  #hide() {
+    if (!this.el) return;
+    this.el.removeAttribute("style");
+    this.el.style.display = "none";
+  }
+  #getButton() {
+    return this.#menu.button();
+  }
+}
+
+const radioControllerContext = createContext();
+
+class RadioGroupController extends ViewController {
+  #group = /* @__PURE__ */ new Set();
+  #value = signal("");
+  #controller = null;
+  onValueChange;
+  get values() {
+    return Array.from(this.#group).map((radio) => radio.value());
+  }
+  get value() {
+    return this.#value();
+  }
+  set value(value) {
+    this.#onChange(value);
+  }
+  onSetup() {
+    provideContext(radioControllerContext, {
+      add: this.#addRadio.bind(this),
+      remove: this.#removeRadio.bind(this)
+    });
+  }
+  onAttach(el) {
+    const isMenuItem = hasProvidedContext(menuContext);
+    if (!isMenuItem) setAttributeIfEmpty(el, "role", "radiogroup");
+    this.setAttributes({ value: this.#value });
+  }
+  onDestroy() {
+    this.#group.clear();
+  }
+  #addRadio(radio) {
+    if (this.#group.has(radio)) return;
+    this.#group.add(radio);
+    radio.onCheck = this.#onChangeBind;
+    radio.check(radio.value() === this.#value());
+  }
+  #removeRadio(radio) {
+    radio.onCheck = null;
+    this.#group.delete(radio);
+  }
+  #onChangeBind = this.#onChange.bind(this);
+  #onChange(newValue, trigger) {
+    const currentValue = peek(this.#value);
+    if (!newValue || newValue === currentValue) return;
+    const currentRadio = this.#findRadio(currentValue), newRadio = this.#findRadio(newValue);
+    currentRadio?.check(false, trigger);
+    newRadio?.check(true, trigger);
+    this.#value.set(newValue);
+    this.onValueChange?.(newValue, trigger);
+  }
+  #findRadio(newValue) {
+    for (const radio of this.#group) {
+      if (newValue === peek(radio.value)) return radio;
+    }
+    return null;
+  }
+}
+
+class RadioGroup extends Component {
+  static props = {
+    value: ""
+  };
+  #controller;
+  /**
+   * A list of radio values that belong this group.
+   */
+  get values() {
+    return this.#controller.values;
+  }
+  /**
+   * The radio value that is checked in this group.
+   */
+  get value() {
+    return this.#controller.value;
+  }
+  set value(newValue) {
+    this.#controller.value = newValue;
+  }
+  constructor() {
+    super();
+    this.#controller = new RadioGroupController();
+    this.#controller.onValueChange = this.#onValueChange.bind(this);
+  }
+  onSetup() {
+    if (IS_SERVER) this.#watchValue();
+    else effect(this.#watchValue.bind(this));
+  }
+  #watchValue() {
+    this.#controller.value = this.$props.value();
+  }
+  #onValueChange(value, trigger) {
+    const event = this.createEvent("change", { detail: value, trigger });
+    this.dispatch(event);
+  }
+}
+const radiogroup__proto = RadioGroup.prototype;
+prop(radiogroup__proto, "values");
+prop(radiogroup__proto, "value");
+
+class Radio extends Component {
+  static props = {
+    value: ""
+  };
+  #checked = signal(false);
+  #controller = {
+    value: this.$props.value,
+    check: this.#check.bind(this),
+    onCheck: null
+  };
+  /**
+   * Whether this radio is currently checked.
+   */
+  get checked() {
+    return this.#checked();
+  }
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.setAttributes({
+      value: this.$props.value,
+      "data-checked": this.#checked,
+      "aria-checked": $ariaBool(this.#checked)
+    });
+  }
+  onAttach(el) {
+    const isMenuItem = hasProvidedContext(menuContext);
+    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
+    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitemradio" : "radio");
+    effect(this.#watchValue.bind(this));
+  }
+  onConnect(el) {
+    this.#addToGroup();
+    onPress(el, this.#onPress.bind(this));
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  #onDisconnect() {
+    scoped(() => {
+      const group = useContext(radioControllerContext);
+      group.remove(this.#controller);
+    }, this.connectScope);
+  }
+  #addToGroup() {
+    const group = useContext(radioControllerContext);
+    group.add(this.#controller);
+  }
+  #watchValue() {
+    const { value } = this.$props, newValue = value();
+    if (peek(this.#checked)) {
+      this.#controller.onCheck?.(newValue);
+    }
+  }
+  #onPress(event) {
+    if (peek(this.#checked)) return;
+    this.#onChange(true, event);
+    this.#onSelect(event);
+    this.#controller.onCheck?.(peek(this.$props.value), event);
+  }
+  #check(value, trigger) {
+    if (peek(this.#checked) === value) return;
+    this.#onChange(value, trigger);
+  }
+  #onChange(value, trigger) {
+    this.#checked.set(value);
+    this.dispatch("change", { detail: value, trigger });
+  }
+  #onSelect(trigger) {
+    this.dispatch("select", { trigger });
+  }
+}
+const radio__proto = Radio.prototype;
+prop(radio__proto, "checked");
+
+class Gesture extends Component {
+  static props = {
+    disabled: false,
+    event: void 0,
+    action: void 0
+  };
+  #media;
+  #provider = null;
+  onSetup() {
+    this.#media = useMediaContext();
+    const { event, action } = this.$props;
+    this.setAttributes({
+      event,
+      action
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-gesture", "");
+    el.style.setProperty("pointer-events", "none");
+  }
+  onConnect(el) {
+    this.#provider = this.#media.player.el?.querySelector(
+      "[data-media-provider]"
+    );
+    effect(this.#attachListener.bind(this));
+  }
+  #attachListener() {
+    let eventType = this.$props.event(), disabled = this.$props.disabled();
+    if (!this.#provider || !eventType || disabled) return;
+    if (/^dbl/.test(eventType)) {
+      eventType = eventType.split(/^dbl/)[1];
+    }
+    if (eventType === "pointerup" || eventType === "pointerdown") {
+      const pointer = this.#media.$state.pointer();
+      if (pointer === "coarse") {
+        eventType = eventType === "pointerup" ? "touchend" : "touchstart";
+      }
+    }
+    listenEvent(
+      this.#provider,
+      eventType,
+      this.#acceptEvent.bind(this),
+      { passive: false }
+    );
+  }
+  #presses = 0;
+  #pressTimerId = -1;
+  #acceptEvent(event) {
+    if (this.$props.disabled() || isPointerEvent(event) && (event.button !== 0 || this.#media.activeMenu) || isTouchEvent(event) && this.#media.activeMenu || isTouchPinchEvent(event) || !this.#inBounds(event)) {
+      return;
+    }
+    event.MEDIA_GESTURE = true;
+    event.preventDefault();
+    const eventType = peek(this.$props.event), isDblEvent = eventType?.startsWith("dbl");
+    if (!isDblEvent) {
+      if (this.#presses === 0) {
+        setTimeout(() => {
+          if (this.#presses === 1) this.#handleEvent(event);
+        }, 250);
+      }
+    } else if (this.#presses === 1) {
+      queueMicrotask(() => this.#handleEvent(event));
+      clearTimeout(this.#pressTimerId);
+      this.#presses = 0;
+      return;
+    }
+    if (this.#presses === 0) {
+      this.#pressTimerId = window.setTimeout(() => {
+        this.#presses = 0;
+      }, 275);
+    }
+    this.#presses++;
+  }
+  #handleEvent(event) {
+    this.el.setAttribute("data-triggered", "");
+    requestAnimationFrame(() => {
+      if (this.#isTopLayer()) {
+        this.#performAction(peek(this.$props.action), event);
+      }
+      requestAnimationFrame(() => {
+        this.el.removeAttribute("data-triggered");
+      });
+    });
+  }
+  /** Validate event occurred in gesture bounds. */
+  #inBounds(event) {
+    if (!this.el) return false;
+    if (isPointerEvent(event) || isMouseEvent(event) || isTouchEvent(event)) {
+      const touch = isTouchEvent(event) ? event.changedTouches[0] ?? event.touches[0] : void 0;
+      const clientX = touch?.clientX ?? event.clientX;
+      const clientY = touch?.clientY ?? event.clientY;
+      const rect = this.el.getBoundingClientRect();
+      const inBounds = clientY >= rect.top && clientY <= rect.bottom && clientX >= rect.left && clientX <= rect.right;
+      return event.type.includes("leave") ? !inBounds : inBounds;
+    }
+    return true;
+  }
+  /** Validate gesture has the highest z-index in this triggered group. */
+  #isTopLayer() {
+    const gestures = this.#media.player.el.querySelectorAll(
+      "[data-media-gesture][data-triggered]"
+    );
+    return Array.from(gestures).sort(
+      (a, b) => +getComputedStyle(b).zIndex - +getComputedStyle(a).zIndex
+    )[0] === this.el;
+  }
+  #performAction(action, trigger) {
+    if (!action) return;
+    const willTriggerEvent = new DOMEvent("will-trigger", {
+      detail: action,
+      cancelable: true,
+      trigger
+    });
+    this.dispatchEvent(willTriggerEvent);
+    if (willTriggerEvent.defaultPrevented) return;
+    const [method, value] = action.replace(/:([a-z])/, "-$1").split(":");
+    if (action.includes(":fullscreen")) {
+      this.#media.remote.toggleFullscreen("prefer-media", trigger);
+    } else if (action.includes("seek:")) {
+      this.#media.remote.seek(peek(this.#media.$state.currentTime) + (+value || 0), trigger);
+    } else {
+      this.#media.remote[kebabToCamelCase(method)](trigger);
+    }
+    this.dispatch("trigger", {
+      detail: action,
+      trigger
+    });
+  }
+}
+
+class CaptionsTextRenderer {
+  priority = 10;
+  #track = null;
+  #renderer;
+  #events;
+  constructor(renderer) {
+    this.#renderer = renderer;
+  }
+  attach() {
+  }
+  canRender() {
+    return true;
+  }
+  detach() {
+    this.#events?.abort();
+    this.#events = void 0;
+    this.#renderer.reset();
+    this.#track = null;
+  }
+  changeTrack(track) {
+    if (!track || this.#track === track) return;
+    this.#events?.abort();
+    this.#events = new EventsController(track);
+    if (track.readyState < 2) {
+      this.#renderer.reset();
+      this.#events.add("load", () => this.#changeTrack(track), { once: true });
+    } else {
+      this.#changeTrack(track);
+    }
+    this.#events.add("add-cue", (event) => {
+      this.#renderer.addCue(event.detail);
+    }).add("remove-cue", (event) => {
+      this.#renderer.removeCue(event.detail);
+    });
+    this.#track = track;
+  }
+  #changeTrack(track) {
+    this.#renderer.changeTrack({
+      cues: [...track.cues],
+      regions: [...track.regions]
+    });
+  }
+}
+
+class Captions extends Component {
+  static props = {
+    textDir: "ltr",
+    exampleText: "Captions look like this."
+  };
+  #media;
+  static lib = signal(null);
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "aria-hidden": $ariaBool(this.#isHidden.bind(this))
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("pointer-events", "none");
+  }
+  onConnect(el) {
+    if (!Captions.lib()) {
+      import('media-captions').then((lib) => Captions.lib.set(lib));
+    }
+    effect(this.#watchViewType.bind(this));
+  }
+  #isHidden() {
+    const { textTrack, remotePlaybackState, iOSControls } = this.#media.$state, track = textTrack();
+    return iOSControls() || remotePlaybackState() === "connected" || !track || !isTrackCaptionKind(track);
+  }
+  #watchViewType() {
+    if (!Captions.lib()) return;
+    const { viewType } = this.#media.$state;
+    if (viewType() === "audio") {
+      return this.#setupAudioView();
+    } else {
+      return this.#setupVideoView();
+    }
+  }
+  #setupAudioView() {
+    effect(this.#onTrackChange.bind(this));
+    this.#listenToFontStyleChanges(null);
+    return () => {
+      this.el.textContent = "";
+    };
+  }
+  #onTrackChange() {
+    if (this.#isHidden()) return;
+    this.#onCueChange();
+    const { textTrack } = this.#media.$state;
+    listenEvent(textTrack(), "cue-change", this.#onCueChange.bind(this));
+    effect(this.#onUpdateTimedNodes.bind(this));
+  }
+  #onCueChange() {
+    this.el.textContent = "";
+    if (this.#hideExampleTimer >= 0) {
+      this.#removeExample();
+    }
+    const { realCurrentTime, textTrack } = this.#media.$state, { renderVTTCueString } = Captions.lib(), time = peek(realCurrentTime), activeCues = peek(textTrack).activeCues;
+    for (const cue of activeCues) {
+      const displayEl = this.#createCueDisplayElement(), cueEl = this.#createCueElement();
+      cueEl.innerHTML = renderVTTCueString(cue, time);
+      displayEl.append(cueEl);
+      this.el.append(cueEl);
+    }
+  }
+  #onUpdateTimedNodes() {
+    const { realCurrentTime } = this.#media.$state, { updateTimedVTTCueNodes } = Captions.lib();
+    updateTimedVTTCueNodes(this.el, realCurrentTime());
+  }
+  #setupVideoView() {
+    const { CaptionsRenderer } = Captions.lib(), renderer = new CaptionsRenderer(this.el), textRenderer = new CaptionsTextRenderer(renderer);
+    this.#media.textRenderers.add(textRenderer);
+    effect(this.#watchTextDirection.bind(this, renderer));
+    effect(this.#watchMediaTime.bind(this, renderer));
+    this.#listenToFontStyleChanges(renderer);
+    return () => {
+      this.el.textContent = "";
+      this.#media.textRenderers.remove(textRenderer);
+      renderer.destroy();
+    };
+  }
+  #watchTextDirection(renderer) {
+    renderer.dir = this.$props.textDir();
+  }
+  #watchMediaTime(renderer) {
+    if (this.#isHidden()) return;
+    const { realCurrentTime, textTrack } = this.#media.$state;
+    renderer.currentTime = realCurrentTime();
+    if (this.#hideExampleTimer >= 0 && textTrack()?.activeCues[0]) {
+      this.#removeExample();
+    }
+  }
+  #listenToFontStyleChanges(renderer) {
+    const player = this.#media.player;
+    if (!player) return;
+    const onChange = this.#onFontStyleChange.bind(this, renderer);
+    listenEvent(player, "vds-font-change", onChange);
+  }
+  #onFontStyleChange(renderer) {
+    if (this.#hideExampleTimer >= 0) {
+      this.#hideExample();
+      return;
+    }
+    const { textTrack } = this.#media.$state;
+    if (!textTrack()?.activeCues[0]) {
+      this.#showExample();
+    } else {
+      renderer?.update(true);
+    }
+  }
+  #showExample() {
+    const display = this.#createCueDisplayElement();
+    setAttribute(display, "data-example", "");
+    const cue = this.#createCueElement();
+    setAttribute(cue, "data-example", "");
+    cue.textContent = this.$props.exampleText();
+    display?.append(cue);
+    this.el?.append(display);
+    this.el?.setAttribute("data-example", "");
+    this.#hideExample();
+  }
+  #hideExampleTimer = -1;
+  #hideExample() {
+    window.clearTimeout(this.#hideExampleTimer);
+    this.#hideExampleTimer = window.setTimeout(this.#removeExample.bind(this), 2500);
+  }
+  #removeExample() {
+    this.el?.removeAttribute("data-example");
+    if (this.el?.querySelector("[data-example]")) this.el.textContent = "";
+    this.#hideExampleTimer = -1;
+  }
+  #createCueDisplayElement() {
+    const el = document.createElement("div");
+    setAttribute(el, "data-part", "cue-display");
+    return el;
+  }
+  #createCueElement() {
+    const el = document.createElement("div");
+    setAttribute(el, "data-part", "cue");
+    return el;
+  }
+}
+
+class Poster extends Component {
+  static props = {
+    src: null,
+    alt: null,
+    crossOrigin: null
+  };
+  static state = new State({
+    img: null,
+    src: null,
+    alt: null,
+    crossOrigin: null,
+    loading: true,
+    error: null,
+    hidden: false
+  });
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#watchSrc();
+    this.#watchAlt();
+    this.#watchCrossOrigin();
+    this.#watchHidden();
+  }
+  onAttach(el) {
+    el.style.setProperty("pointer-events", "none");
+    effect(this.#watchImg.bind(this));
+    effect(this.#watchSrc.bind(this));
+    effect(this.#watchAlt.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#watchHidden.bind(this));
+    const { started } = this.#media.$state;
+    this.setAttributes({
+      "data-visible": () => !started() && !this.$state.hidden(),
+      "data-loading": this.#isLoading.bind(this),
+      "data-error": this.#hasError.bind(this),
+      "data-hidden": this.$state.hidden
+    });
+  }
+  onConnect(el) {
+    effect(this.#onPreconnect.bind(this));
+    effect(this.#onLoadStart.bind(this));
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error());
+  }
+  #onPreconnect() {
+    const { canLoadPoster, poster } = this.#media.$state;
+    if (!canLoadPoster() && poster()) preconnect(poster(), "preconnect");
+  }
+  #watchHidden() {
+    const { src } = this.$props, { poster, nativeControls } = this.#media.$state;
+    this.el && setAttribute(this.el, "display", nativeControls() ? "none" : null);
+    this.$state.hidden.set(this.#hasError() || !(src() || poster()) || nativeControls());
+  }
+  #isLoading() {
+    const { loading, hidden } = this.$state;
+    return !hidden() && loading();
+  }
+  #watchImg() {
+    const img = this.$state.img();
+    if (!img) return;
+    new EventsController(img).add("load", this.#onLoad.bind(this)).add("error", this.#onError.bind(this));
+    if (img.complete) this.#onLoad();
+  }
+  #prevSrc = "";
+  #watchSrc() {
+    const { poster: defaultPoster } = this.#media.$props, { canLoadPoster, providedPoster, inferredPoster } = this.#media.$state;
+    const src = this.$props.src() || "", poster = src || defaultPoster() || inferredPoster();
+    if (this.#prevSrc === providedPoster()) {
+      providedPoster.set(src);
+    }
+    this.$state.src.set(canLoadPoster() && poster.length ? poster : null);
+    this.#prevSrc = src;
+  }
+  #watchAlt() {
+    const { src } = this.$props, { alt } = this.$state, { poster } = this.#media.$state;
+    alt.set(src() || poster() ? this.$props.alt() : null);
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin, poster: src } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(
+      /ytimg\.com|vimeo/.test(src() || "") ? null : crossOrigin === true ? "anonymous" : crossOrigin
+    );
+  }
+  #onLoadStart() {
+    const { loading, error } = this.$state, { canLoadPoster, poster } = this.#media.$state;
+    loading.set(canLoadPoster() && !!poster());
+    error.set(null);
+  }
+  #onLoad() {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(null);
+  }
+  #onError(event) {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(event);
+  }
+}
+
+class Time extends Component {
+  static props = {
+    type: "current",
+    showHours: false,
+    padHours: null,
+    padMinutes: null,
+    remainder: false,
+    toggle: false,
+    hidden: false
+  };
+  static state = new State({
+    timeText: "",
+    hidden: false
+  });
+  #media;
+  #invert = signal(null);
+  #isVisible = signal(true);
+  #isIntersecting = signal(true);
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#watchTime();
+    const { type } = this.$props;
+    this.setAttributes({
+      "data-type": type,
+      "data-remainder": this.#shouldInvert.bind(this)
+    });
+    new IntersectionObserverController({
+      callback: this.#onIntersectionChange.bind(this)
+    }).attach(this);
+  }
+  onAttach(el) {
+    if (!el.hasAttribute("role")) effect(this.#watchRole.bind(this));
+    effect(this.#watchTime.bind(this));
+  }
+  onConnect(el) {
+    onDispose(observeVisibility(el, this.#isVisible.set));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#watchToggle.bind(this));
+  }
+  #onIntersectionChange(entries) {
+    this.#isIntersecting.set(entries[0].isIntersecting);
+  }
+  #watchHidden() {
+    const { hidden } = this.$props;
+    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting());
+  }
+  #watchToggle() {
+    if (!this.$props.toggle()) {
+      this.#invert.set(null);
+      return;
+    }
+    if (this.el) {
+      onPress(this.el, this.#onToggle.bind(this));
+    }
+  }
+  #watchTime() {
+    const { hidden, timeText } = this.$state, { duration } = this.#media.$state;
+    if (hidden()) return;
+    const { type, padHours, padMinutes, showHours } = this.$props, seconds = this.#getSeconds(type()), $duration = duration(), shouldInvert = this.#shouldInvert();
+    if (!Number.isFinite(seconds + $duration)) {
+      timeText.set("LIVE");
+      return;
+    }
+    const time = shouldInvert ? Math.max(0, $duration - seconds) : seconds, formattedTime = formatTime(time, {
+      padHrs: padHours(),
+      padMins: padMinutes(),
+      showHrs: showHours()
+    });
+    timeText.set((shouldInvert ? "-" : "") + formattedTime);
+  }
+  #watchRole() {
+    if (!this.el) return;
+    const { toggle } = this.$props;
+    setAttribute(this.el, "role", toggle() ? "timer" : null);
+    setAttribute(this.el, "tabindex", toggle() ? 0 : null);
+  }
+  #getSeconds(type) {
+    const { bufferedEnd, duration, currentTime } = this.#media.$state;
+    switch (type) {
+      case "buffered":
+        return bufferedEnd();
+      case "duration":
+        return duration();
+      default:
+        return currentTime();
+    }
+  }
+  #shouldInvert() {
+    return this.$props.remainder() && this.#invert() !== false;
+  }
+  #onToggle(event) {
+    event.preventDefault();
+    if (this.#invert() === null) {
+      this.#invert.set(!this.$props.remainder());
+      return;
+    }
+    this.#invert.set((v) => !v);
+  }
+}
+
+class MediaPlayerInstance extends MediaPlayer {
+}
+class MediaProviderInstance extends MediaProvider {
+}
+class MediaAnnouncerInstance extends MediaAnnouncer {
+}
+class ControlsInstance extends Controls {
+}
+class ControlsGroupInstance extends ControlsGroup {
+}
+class ToggleButtonInstance extends ToggleButton {
+}
+class CaptionButtonInstance extends CaptionButton {
+}
+class FullscreenButtonInstance extends FullscreenButton {
+}
+class LiveButtonInstance extends LiveButton {
+}
+class MuteButtonInstance extends MuteButton {
+}
+class PIPButtonInstance extends PIPButton {
+}
+class PlayButtonInstance extends PlayButton {
+}
+class AirPlayButtonInstance extends AirPlayButton {
+}
+class GoogleCastButtonInstance extends GoogleCastButton {
+}
+class SeekButtonInstance extends SeekButton {
+}
+class TooltipInstance extends Tooltip {
+}
+class TooltipTriggerInstance extends TooltipTrigger {
+}
+class TooltipContentInstance extends TooltipContent {
+}
+class SliderInstance extends Slider {
+}
+class TimeSliderInstance extends TimeSlider {
+}
+class VolumeSliderInstance extends VolumeSlider {
+}
+class AudioGainSliderInstance extends AudioGainSlider {
+}
+class SpeedSliderInstance extends SpeedSlider {
+}
+class QualitySliderInstance extends QualitySlider {
+}
+class SliderThumbnailInstance extends SliderThumbnail {
+}
+class SliderValueInstance extends SliderValue {
+}
+class SliderVideoInstance extends SliderVideo {
+}
+class SliderPreviewInstance extends SliderPreview {
+}
+class SliderChaptersInstance extends SliderChapters {
+}
+class MenuInstance extends Menu {
+}
+class MenuButtonInstance extends MenuButton {
+}
+class MenuItemsInstance extends MenuItems {
+}
+class MenuItemInstance extends MenuItem {
+}
+class MenuPortalInstance extends MenuPortal {
+}
+class RadioGroupInstance extends RadioGroup {
+}
+class RadioInstance extends Radio {
+}
+class CaptionsInstance extends Captions {
+}
+class GestureInstance extends Gesture {
+}
+class PosterInstance extends Poster {
+}
+class ThumbnailInstance extends Thumbnail {
+}
+class TimeInstance extends Time {
+}
+
+const Slot = React.forwardRef((props, forwardedRef) => {
+  const { children, ...slotProps } = props;
+  const childrenArray = React.Children.toArray(children);
+  const slottable = childrenArray.find(isSlottable);
+  if (slottable) {
+    const newElement = slottable.props.children;
+    const newChildren = childrenArray.map((child) => {
+      if (child === slottable) {
+        if (React.Children.count(newElement) > 1) return React.Children.only(null);
+        return React.isValidElement(newElement) ? newElement.props.children : null;
+      } else {
+        return child;
+      }
+    });
+    return /* @__PURE__ */ React.createElement(SlotClone, { ...slotProps, ref: forwardedRef }, React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null);
+  }
+  return /* @__PURE__ */ React.createElement(SlotClone, { ...slotProps, ref: forwardedRef }, children);
+});
+Slot.displayName = "Slot";
+const SlotClone = React.forwardRef((props, forwardedRef) => {
+  const { children, ...slotProps } = props;
+  if (React.isValidElement(children)) {
+    return React.cloneElement(children, {
+      ...mergeProps(slotProps, children.props),
+      ref: forwardedRef ? composeRefs(forwardedRef, children.ref) : children.ref
+    });
+  }
+  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
+});
+SlotClone.displayName = "SlotClone";
+const Slottable = ({ children }) => {
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
+};
+function isSlottable(child) {
+  return React.isValidElement(child) && child.type === Slottable;
+}
+function mergeProps(slotProps, childProps) {
+  const overrideProps = { ...childProps };
+  for (const propName in childProps) {
+    const slotPropValue = slotProps[propName];
+    const childPropValue = childProps[propName];
+    const isHandler = /^on[A-Z]/.test(propName);
+    if (isHandler) {
+      if (slotPropValue && childPropValue) {
+        overrideProps[propName] = (...args) => {
+          childPropValue(...args);
+          slotPropValue(...args);
+        };
+      } else if (slotPropValue) {
+        overrideProps[propName] = slotPropValue;
+      }
+    } else if (propName === "style") {
+      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
+    } else if (propName === "className") {
+      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
+    }
+  }
+  return { ...slotProps, ...overrideProps };
+}
+
+const NODES = ["button", "div", "span", "img", "video", "audio"];
+const Primitive = NODES.reduce((primitives, node) => {
+  const Node = React.forwardRef((props, forwardedRef) => {
+    const { asChild, ...primitiveProps } = props;
+    const Comp = asChild ? Slot : node;
+    return /* @__PURE__ */ React.createElement(Comp, { ...primitiveProps, ref: forwardedRef });
+  });
+  Node.displayName = `Primitive.${node}`;
+  return { ...primitives, [node]: Node };
+}, {});
+
+function isRemotionProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "REMOTION";
+}
+function isRemotionSrc(src) {
+  return src?.type === "video/remotion";
+}
+
+const sliderStateRecord = SliderInstance.state.record, initialSliderStore = Object.keys(sliderStateRecord).reduce(
+  (store, prop) => ({
+    ...store,
+    [prop]() {
+      return sliderStateRecord[prop];
+    }
+  }),
+  {}
+);
+function useSliderState(prop, ref) {
+  const $state = useStateContext(sliderState);
+  if (!$state && !ref) {
+    console.warn(
+      `[vidstack] \`useSliderState\` requires \`RefObject<SliderInstance>\` argument if called outside of a slider component`
+    );
+  }
+  return useSignal((ref?.current?.$state || $state || initialSliderStore)[prop]);
+}
+function useSliderStore(ref) {
+  const $state = useStateContext(sliderState);
+  if (!$state && !ref) {
+    console.warn(
+      `[vidstack] \`useSliderStore\` requires \`RefObject<SliderInstance>\` argument if called outside of a slider component`
+    );
+  }
+  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialSliderStore);
+}
+
+const mediaStateRecord = MediaPlayerInstance.state.record, initialMediaStore = Object.keys(mediaStateRecord).reduce(
+  (store, prop) => ({
+    ...store,
+    [prop]() {
+      return mediaStateRecord[prop];
+    }
+  }),
+  {}
+);
+function useMediaState(prop, ref) {
+  const $state = useStateContext(mediaState);
+  if (!$state && !ref) {
+    console.warn(
+      `[vidstack] \`useMediaState\` requires \`RefObject<MediaPlayerInstance>\` argument if called outside the \`<MediaPlayer>\` component`
+    );
+  }
+  return useSignal((ref?.current?.$state || $state || initialMediaStore)[prop]);
+}
+function useMediaStore(ref) {
+  const $state = useStateContext(mediaState);
+  if (!$state && !ref) {
+    console.warn(
+      `[vidstack] \`useMediaStore\` requires \`RefObject<MediaPlayerInstance>\` argument if called outside the \`<MediaPlayer>\` component`
+    );
+  }
+  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialMediaStore);
+}
+
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLAirPlayAdapter, HTMLMediaProvider, IS_CHROME, IS_IOS, IS_SERVER, List, ListSymbol, LiveButtonInstance, LocalMediaStorage, Logger, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaPlayerInstance, MediaProviderInstance, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, Primitive, QualitySliderInstance, QualitySymbol, RAFLoop, RadioGroupController, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrack, TextTrackList, TextTrackSymbol, ThumbnailInstance, ThumbnailsLoader, TimeInstance, TimeRange, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProvider, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, appendParamsToURL, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, coerceToError, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHLSSupported, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isRemotionProvider, isRemotionSrc, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, loadScript, mediaContext, mediaState, menuContext, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, preconnect, sliderState, softResetMediaState, sortVideoQualities, updateSliderPreviewPlacement, updateTimeIntervals, useMediaContext, useMediaState, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange };
diff --git a/dev/chunks/vidstack-Dq9VWd7A.js b/dev/chunks/vidstack-Dq9VWd7A.js
new file mode 100644
index 0000000000000000000000000000000000000000..daa9c81b8bcb169c0ff3a15dd7fd0bea8c2ed54c
--- /dev/null
+++ b/dev/chunks/vidstack-Dq9VWd7A.js
@@ -0,0 +1,287 @@
+"use client"
+
+import { createScope, signal, effect, isString, deferredPromise, isObject, isNumber, isBoolean } from './vidstack-CH225ns1.js';
+import { preconnect, TimeRange } from './vidstack-MAWt6ODZ.js';
+import { EmbedProvider } from './vidstack-fXdyeRpg.js';
+import { resolveYouTubeVideoId } from './vidstack-Zc3I7oOd.js';
+import 'react';
+import '@floating-ui/dom';
+
+const YouTubePlayerState = {
+  Unstarted: -1,
+  Ended: 0,
+  Playing: 1,
+  Paused: 2,
+  Buffering: 3,
+  Cued: 5
+};
+
+class YouTubeProvider extends EmbedProvider {
+  $$PROVIDER_TYPE = "YOUTUBE";
+  scope = createScope();
+  #ctx;
+  #videoId = signal("");
+  #state = -1;
+  #currentSrc = null;
+  #seekingTimer = -1;
+  #invalidPlay = false;
+  #promises = /* @__PURE__ */ new Map();
+  constructor(iframe, ctx) {
+    super(iframe);
+    this.#ctx = ctx;
+  }
+  /**
+   * Sets the player's interface language. The parameter value is an ISO 639-1 two-letter
+   * language code or a fully specified locale. For example, fr and fr-ca are both valid values.
+   * Other language input codes, such as IETF language tags (BCP 47) might also be handled properly.
+   *
+   * The interface language is used for tooltips in the player and also affects the default caption
+   * track. Note that YouTube might select a different caption track language for a particular
+   * user based on the user's individual language preferences and the availability of caption tracks.
+   *
+   * @defaultValue 'en'
+   */
+  language = "en";
+  color = "red";
+  /**
+   * Whether cookies should be enabled on the embed. This is turned off by default to be
+   * GDPR-compliant.
+   *
+   * @defaultValue `false`
+   */
+  cookies = false;
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  get type() {
+    return "youtube";
+  }
+  get videoId() {
+    return this.#videoId();
+  }
+  preconnect() {
+    preconnect(this.getOrigin());
+  }
+  setup() {
+    super.setup();
+    effect(this.#watchVideoId.bind(this));
+    this.#ctx.notify("provider-setup", this);
+  }
+  destroy() {
+    this.#reset();
+    const message = "provider destroyed";
+    for (const promises of this.#promises.values()) {
+      for (const { reject } of promises) reject(message);
+    }
+    this.#promises.clear();
+  }
+  async play() {
+    return this.#remote("playVideo");
+  }
+  #playFail(message) {
+    this.#getPromise("playVideo")?.reject(message);
+  }
+  async pause() {
+    return this.#remote("pauseVideo");
+  }
+  #pauseFail(message) {
+    this.#getPromise("pauseVideo")?.reject(message);
+  }
+  setMuted(muted) {
+    if (muted) this.#remote("mute");
+    else this.#remote("unMute");
+  }
+  setCurrentTime(time) {
+    this.#remote("seekTo", time);
+    this.#ctx.notify("seeking", time);
+  }
+  setVolume(volume) {
+    this.#remote("setVolume", volume * 100);
+  }
+  setPlaybackRate(rate) {
+    this.#remote("setPlaybackRate", rate);
+  }
+  async loadSource(src) {
+    if (!isString(src.src)) {
+      this.#currentSrc = null;
+      this.#videoId.set("");
+      return;
+    }
+    const videoId = resolveYouTubeVideoId(src.src);
+    this.#videoId.set(videoId ?? "");
+    this.#currentSrc = src;
+  }
+  getOrigin() {
+    return !this.cookies ? "https://www.youtube-nocookie.com" : "https://www.youtube.com";
+  }
+  #watchVideoId() {
+    this.#reset();
+    const videoId = this.#videoId();
+    if (!videoId) {
+      this.src.set("");
+      return;
+    }
+    this.src.set(`${this.getOrigin()}/embed/${videoId}`);
+    this.#ctx.notify("load-start");
+  }
+  buildParams() {
+    const { keyDisabled } = this.#ctx.$props, { muted, playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
+    return {
+      autoplay: 0,
+      cc_lang_pref: this.language,
+      cc_load_policy: showControls ? 1 : void 0,
+      color: this.color,
+      controls: showControls ? 1 : 0,
+      disablekb: !showControls || keyDisabled() ? 1 : 0,
+      enablejsapi: 1,
+      fs: 1,
+      hl: this.language,
+      iv_load_policy: showControls ? 1 : 3,
+      mute: muted() ? 1 : 0,
+      playsinline: playsInline() ? 1 : 0
+    };
+  }
+  #remote(command, arg) {
+    let promise = deferredPromise(), promises = this.#promises.get(command);
+    if (!promises) this.#promises.set(command, promises = []);
+    promises.push(promise);
+    this.postMessage({
+      event: "command",
+      func: command,
+      args: arg ? [arg] : void 0
+    });
+    return promise.promise;
+  }
+  onLoad() {
+    window.setTimeout(() => this.postMessage({ event: "listening" }), 100);
+  }
+  #onReady(trigger) {
+    this.#ctx.notify("loaded-metadata");
+    this.#ctx.notify("loaded-data");
+    this.#ctx.delegate.ready(void 0, trigger);
+  }
+  #onPause(trigger) {
+    this.#getPromise("pauseVideo")?.resolve();
+    this.#ctx.notify("pause", void 0, trigger);
+  }
+  #onTimeUpdate(time, trigger) {
+    const { duration, realCurrentTime } = this.#ctx.$state, hasEnded = this.#state === YouTubePlayerState.Ended, boundTime = hasEnded ? duration() : time;
+    this.#ctx.notify("time-change", boundTime, trigger);
+    if (!hasEnded && Math.abs(boundTime - realCurrentTime()) > 1) {
+      this.#ctx.notify("seeking", boundTime, trigger);
+    }
+  }
+  #onProgress(buffered, seekable, trigger) {
+    const detail = {
+      buffered: new TimeRange(0, buffered),
+      seekable
+    };
+    this.#ctx.notify("progress", detail, trigger);
+    const { seeking, realCurrentTime } = this.#ctx.$state;
+    if (seeking() && buffered > realCurrentTime()) {
+      this.#onSeeked(trigger);
+    }
+  }
+  #onSeeked(trigger) {
+    const { paused, realCurrentTime } = this.#ctx.$state;
+    window.clearTimeout(this.#seekingTimer);
+    this.#seekingTimer = window.setTimeout(
+      () => {
+        this.#ctx.notify("seeked", realCurrentTime(), trigger);
+        this.#seekingTimer = -1;
+      },
+      paused() ? 100 : 0
+    );
+  }
+  #onEnded(trigger) {
+    const { seeking } = this.#ctx.$state;
+    if (seeking()) this.#onSeeked(trigger);
+    this.#ctx.notify("pause", void 0, trigger);
+    this.#ctx.notify("end", void 0, trigger);
+  }
+  #onStateChange(state, trigger) {
+    const { paused, seeking } = this.#ctx.$state, isPlaying = state === YouTubePlayerState.Playing, isBuffering = state === YouTubePlayerState.Buffering, isPendingPlay = this.#isPending("playVideo"), isPlay = paused() && (isBuffering || isPlaying);
+    if (isBuffering) this.#ctx.notify("waiting", void 0, trigger);
+    if (seeking() && isPlaying) {
+      this.#onSeeked(trigger);
+    }
+    if (this.#invalidPlay && isPlaying) {
+      this.pause();
+      this.#invalidPlay = false;
+      this.setMuted(this.#ctx.$state.muted());
+      return;
+    }
+    if (!isPendingPlay && isPlay) {
+      this.#invalidPlay = true;
+      this.setMuted(true);
+      return;
+    }
+    if (isPlay) {
+      this.#getPromise("playVideo")?.resolve();
+      this.#ctx.notify("play", void 0, trigger);
+    }
+    switch (state) {
+      case YouTubePlayerState.Cued:
+        this.#onReady(trigger);
+        break;
+      case YouTubePlayerState.Playing:
+        this.#ctx.notify("playing", void 0, trigger);
+        break;
+      case YouTubePlayerState.Paused:
+        this.#onPause(trigger);
+        break;
+      case YouTubePlayerState.Ended:
+        this.#onEnded(trigger);
+        break;
+    }
+    this.#state = state;
+  }
+  onMessage({ info }, event) {
+    if (!info) return;
+    const { title, intrinsicDuration, playbackRate } = this.#ctx.$state;
+    if (isObject(info.videoData) && info.videoData.title !== title()) {
+      this.#ctx.notify("title-change", info.videoData.title, event);
+    }
+    if (isNumber(info.duration) && info.duration !== intrinsicDuration()) {
+      if (isNumber(info.videoLoadedFraction)) {
+        const buffered = info.progressState?.loaded ?? info.videoLoadedFraction * info.duration, seekable = new TimeRange(0, info.duration);
+        this.#onProgress(buffered, seekable, event);
+      }
+      this.#ctx.notify("duration-change", info.duration, event);
+    }
+    if (isNumber(info.playbackRate) && info.playbackRate !== playbackRate()) {
+      this.#ctx.notify("rate-change", info.playbackRate, event);
+    }
+    if (info.progressState) {
+      const { current, seekableStart, seekableEnd, loaded, duration } = info.progressState;
+      this.#onTimeUpdate(current, event);
+      this.#onProgress(loaded, new TimeRange(seekableStart, seekableEnd), event);
+      if (duration !== intrinsicDuration()) {
+        this.#ctx.notify("duration-change", duration, event);
+      }
+    }
+    if (isNumber(info.volume) && isBoolean(info.muted) && !this.#invalidPlay) {
+      const detail = {
+        muted: info.muted,
+        volume: info.volume / 100
+      };
+      this.#ctx.notify("volume-change", detail, event);
+    }
+    if (isNumber(info.playerState) && info.playerState !== this.#state) {
+      this.#onStateChange(info.playerState, event);
+    }
+  }
+  #reset() {
+    this.#state = -1;
+    this.#seekingTimer = -1;
+    this.#invalidPlay = false;
+  }
+  #getPromise(command) {
+    return this.#promises.get(command)?.shift();
+  }
+  #isPending(command) {
+    return Boolean(this.#promises.get(command)?.length);
+  }
+}
+
+export { YouTubeProvider };
diff --git a/dev/chunks/vidstack-GkDbnYKN.js b/dev/chunks/vidstack-GkDbnYKN.js
new file mode 100644
index 0000000000000000000000000000000000000000..60ad7ff11ca06c3f39e07412dd0d0761f0234703
--- /dev/null
+++ b/dev/chunks/vidstack-GkDbnYKN.js
@@ -0,0 +1,401 @@
+"use client"
+
+import { peek, listenEvent, effect, DOMEvent, isString, camelToKebabCase, isUndefined, isFunction } from './vidstack-CH225ns1.js';
+import { QualitySymbol, RAFLoop, TextTrack, TextTrackSymbol, ListSymbol, IS_CHROME, coerceToError, loadScript, VideoProvider, isHLSSupported, preconnect } from './vidstack-BdoOxmTD.js';
+import 'react';
+import '@floating-ui/dom';
+
+const toDOMEventType = (type) => camelToKebabCase(type);
+class HLSController {
+  #video;
+  #ctx;
+  #instance = null;
+  #stopLiveSync = null;
+  config = {};
+  #callbacks = /* @__PURE__ */ new Set();
+  get instance() {
+    return this.#instance;
+  }
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+  }
+  setup(ctor) {
+    const { streamType } = this.#ctx.$state;
+    const isLive = peek(streamType).includes("live"), isLiveLowLatency = peek(streamType).includes("ll-");
+    this.#instance = new ctor({
+      lowLatencyMode: isLiveLowLatency,
+      backBufferLength: isLiveLowLatency ? 4 : isLive ? 8 : void 0,
+      renderTextTracksNatively: false,
+      ...this.config
+    });
+    const dispatcher = this.#dispatchHLSEvent.bind(this);
+    for (const event of Object.values(ctor.Events)) this.#instance.on(event, dispatcher);
+    this.#instance.on(ctor.Events.ERROR, this.#onError.bind(this));
+    for (const callback of this.#callbacks) callback(this.#instance);
+    this.#ctx.player.dispatch("hls-instance", {
+      detail: this.#instance
+    });
+    this.#instance.attachMedia(this.#video);
+    this.#instance.on(ctor.Events.AUDIO_TRACK_SWITCHED, this.#onAudioSwitch.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_SWITCHED, this.#onLevelSwitched.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_LOADED, this.#onLevelLoaded.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_UPDATED, this.#onLevelUpdated.bind(this));
+    this.#instance.on(ctor.Events.NON_NATIVE_TEXT_TRACKS_FOUND, this.#onTracksFound.bind(this));
+    this.#instance.on(ctor.Events.CUES_PARSED, this.#onCuesParsed.bind(this));
+    this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
+    listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
+    listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
+    this.#stopLiveSync = effect(this.#liveSync.bind(this));
+  }
+  #createDOMEvent(type, data) {
+    return new DOMEvent(toDOMEventType(type), { detail: data });
+  }
+  #liveSync() {
+    if (!this.#ctx.$state.live()) return;
+    const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
+    raf.start();
+    return raf.stop.bind(raf);
+  }
+  #liveSyncPosition() {
+    this.#ctx.$state.liveSyncPosition.set(this.#instance?.liveSyncPosition ?? Infinity);
+  }
+  #dispatchHLSEvent(type, data) {
+    this.#ctx.player?.dispatch(this.#createDOMEvent(type, data));
+  }
+  #onTracksFound(eventType, data) {
+    const event = this.#createDOMEvent(eventType, data);
+    let currentTrack = -1;
+    for (let i = 0; i < data.tracks.length; i++) {
+      const nonNativeTrack = data.tracks[i], init = nonNativeTrack.subtitleTrack ?? nonNativeTrack.closedCaptions, track = new TextTrack({
+        id: `hls-${nonNativeTrack.kind}-${i}`,
+        src: init?.url,
+        label: nonNativeTrack.label,
+        language: init?.lang,
+        kind: nonNativeTrack.kind,
+        default: nonNativeTrack.default
+      });
+      track[TextTrackSymbol.readyState] = 2;
+      track[TextTrackSymbol.onModeChange] = () => {
+        if (track.mode === "showing") {
+          this.#instance.subtitleTrack = i;
+          currentTrack = i;
+        } else if (currentTrack === i) {
+          this.#instance.subtitleTrack = -1;
+          currentTrack = -1;
+        }
+      };
+      this.#ctx.textTracks.add(track, event);
+    }
+  }
+  #onCuesParsed(eventType, data) {
+    const index = this.#instance?.subtitleTrack, track = this.#ctx.textTracks.getById(`hls-${data.type}-${index}`);
+    if (!track) return;
+    const event = this.#createDOMEvent(eventType, data);
+    for (const cue of data.cues) {
+      cue.positionAlign = "auto";
+      track.addCue(cue, event);
+    }
+  }
+  #onAudioSwitch(eventType, data) {
+    const track = this.#ctx.audioTracks[data.id];
+    if (track) {
+      const trigger = this.#createDOMEvent(eventType, data);
+      this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
+    }
+  }
+  #onLevelSwitched(eventType, data) {
+    const quality = this.#ctx.qualities[data.level];
+    if (quality) {
+      const trigger = this.#createDOMEvent(eventType, data);
+      this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+  }
+  #onLevelUpdated(eventType, data) {
+    if (data.details.totalduration > 0) {
+      this.#ctx.$state.inferredLiveDVRWindow.set(data.details.totalduration);
+    }
+  }
+  #onLevelLoaded(eventType, data) {
+    if (this.#ctx.$state.canPlay()) return;
+    const { type, live, totalduration: duration, targetduration } = data.details, trigger = this.#createDOMEvent(eventType, data);
+    this.#ctx.notify(
+      "stream-type-change",
+      live ? type === "EVENT" && Number.isFinite(duration) && targetduration >= 10 ? "live:dvr" : "live" : "on-demand",
+      trigger
+    );
+    this.#ctx.notify("duration-change", duration, trigger);
+    const media = this.#instance.media;
+    if (this.#instance.currentLevel === -1) {
+      this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
+    }
+    for (const remoteTrack of this.#instance.audioTracks) {
+      const localTrack = {
+        id: remoteTrack.id.toString(),
+        label: remoteTrack.name,
+        language: remoteTrack.lang || "",
+        kind: "main"
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
+    }
+    for (const level of this.#instance.levels) {
+      const videoQuality = {
+        id: level.id?.toString() ?? level.height + "p",
+        width: level.width,
+        height: level.height,
+        codec: level.codecSet,
+        bitrate: level.bitrate
+      };
+      this.#ctx.qualities[ListSymbol.add](videoQuality, trigger);
+    }
+    media.dispatchEvent(new DOMEvent("canplay", { trigger }));
+  }
+  #onError(eventType, data) {
+    {
+      this.#ctx.logger?.errorGroup(`[vidstack] HLS error \`${eventType}\``).labelledLog("Media Element", this.#instance?.media).labelledLog("HLS Instance", this.#instance).labelledLog("Event Type", eventType).labelledLog("Data", data).labelledLog("Src", peek(this.#ctx.$state.source)).labelledLog("Media Store", { ...this.#ctx.$state }).dispatch();
+    }
+    if (data.fatal) {
+      switch (data.type) {
+        case "mediaError":
+          this.#instance?.recoverMediaError();
+          break;
+        default:
+          this.#onFatalError(data.error);
+          break;
+      }
+    }
+  }
+  #onFatalError(error) {
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 1,
+      error
+    });
+  }
+  #enableAutoQuality() {
+    if (this.#instance) this.#instance.currentLevel = -1;
+  }
+  #onUserQualityChange() {
+    const { qualities } = this.#ctx;
+    if (!this.#instance || qualities.auto) return;
+    this.#instance[qualities.switch + "Level"] = qualities.selectedIndex;
+    if (IS_CHROME) {
+      this.#video.currentTime = this.#video.currentTime;
+    }
+  }
+  #onUserAudioChange() {
+    const { audioTracks } = this.#ctx;
+    if (this.#instance && this.#instance.audioTrack !== audioTracks.selectedIndex) {
+      this.#instance.audioTrack = audioTracks.selectedIndex;
+    }
+  }
+  onInstance(callback) {
+    this.#callbacks.add(callback);
+    return () => this.#callbacks.delete(callback);
+  }
+  loadSource(src) {
+    if (!isString(src.src)) return;
+    this.#instance?.loadSource(src.src);
+  }
+  destroy() {
+    this.#instance?.destroy();
+    this.#instance = null;
+    this.#stopLiveSync?.();
+    this.#stopLiveSync = null;
+    this.#ctx?.logger?.info("\u{1F3D7}\uFE0F Destroyed HLS instance");
+  }
+}
+
+class HLSLibLoader {
+  #lib;
+  #ctx;
+  #callback;
+  constructor(lib, ctx, callback) {
+    this.#lib = lib;
+    this.#ctx = ctx;
+    this.#callback = callback;
+    this.#startLoading();
+  }
+  async #startLoading() {
+    this.#ctx.logger?.info("\u{1F3D7}\uFE0F Loading HLS Library");
+    const callbacks = {
+      onLoadStart: this.#onLoadStart.bind(this),
+      onLoaded: this.#onLoaded.bind(this),
+      onLoadError: this.#onLoadError.bind(this)
+    };
+    let ctor = await loadHLSScript(this.#lib, callbacks);
+    if (isUndefined(ctor) && !isString(this.#lib)) ctor = await importHLS(this.#lib, callbacks);
+    if (!ctor) return null;
+    if (!ctor.isSupported()) {
+      const message = "[vidstack] `hls.js` is not supported in this environment";
+      this.#ctx.logger?.error(message);
+      this.#ctx.player.dispatch(new DOMEvent("hls-unsupported"));
+      this.#ctx.notify("error", { message, code: 4 });
+      return null;
+    }
+    return ctor;
+  }
+  #onLoadStart() {
+    {
+      this.#ctx.logger?.infoGroup("Starting to load `hls.js`").labelledLog("URL", this.#lib).dispatch();
+    }
+    this.#ctx.player.dispatch(new DOMEvent("hls-lib-load-start"));
+  }
+  #onLoaded(ctor) {
+    {
+      this.#ctx.logger?.infoGroup("Loaded `hls.js`").labelledLog("Library", this.#lib).labelledLog("Constructor", ctor).dispatch();
+    }
+    this.#ctx.player.dispatch(
+      new DOMEvent("hls-lib-loaded", {
+        detail: ctor
+      })
+    );
+    this.#callback(ctor);
+  }
+  #onLoadError(e) {
+    const error = coerceToError(e);
+    {
+      this.#ctx.logger?.errorGroup("[vidstack] Failed to load `hls.js`").labelledLog("Library", this.#lib).labelledLog("Error", e).dispatch();
+    }
+    this.#ctx.player.dispatch(
+      new DOMEvent("hls-lib-load-error", {
+        detail: error
+      })
+    );
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 4,
+      error
+    });
+  }
+}
+async function importHLS(loader, callbacks = {}) {
+  if (isUndefined(loader)) return void 0;
+  callbacks.onLoadStart?.();
+  if (loader.prototype && loader.prototype !== Function) {
+    callbacks.onLoaded?.(loader);
+    return loader;
+  }
+  try {
+    const ctor = (await loader())?.default;
+    if (ctor && !!ctor.isSupported) {
+      callbacks.onLoaded?.(ctor);
+    } else {
+      throw Error(
+        true ? "[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
+      );
+    }
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+async function loadHLSScript(src, callbacks = {}) {
+  if (!isString(src)) return void 0;
+  callbacks.onLoadStart?.();
+  try {
+    await loadScript(src);
+    if (!isFunction(window.Hls)) {
+      throw Error(
+        true ? "[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window" : ""
+      );
+    }
+    const ctor = window.Hls;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+
+const JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
+class HLSProvider extends VideoProvider {
+  $$PROVIDER_TYPE = "HLS";
+  #ctor = null;
+  #controller = new HLSController(this.video, this.ctx);
+  /**
+   * The `hls.js` constructor.
+   */
+  get ctor() {
+    return this.#ctor;
+  }
+  /**
+   * The current `hls.js` instance.
+   */
+  get instance() {
+    return this.#controller.instance;
+  }
+  /**
+   * Whether `hls.js` is supported in this environment.
+   */
+  static supported = isHLSSupported();
+  get type() {
+    return "hls";
+  }
+  get canLiveSync() {
+    return true;
+  }
+  #library = `${JS_DELIVR_CDN}/npm/hls.js@^1.5.0/dist/hls${".js" }`;
+  /**
+   * The `hls.js` configuration object.
+   *
+   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#fine-tuning}
+   */
+  get config() {
+    return this.#controller.config;
+  }
+  set config(config) {
+    this.#controller.config = config;
+  }
+  /**
+   * The `hls.js` constructor (supports dynamic imports) or a URL of where it can be found.
+   *
+   * @defaultValue `https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.min.js`
+   */
+  get library() {
+    return this.#library;
+  }
+  set library(library) {
+    this.#library = library;
+  }
+  preconnect() {
+    if (!isString(this.#library)) return;
+    preconnect(this.#library);
+  }
+  setup() {
+    super.setup();
+    new HLSLibLoader(this.#library, this.ctx, (ctor) => {
+      this.#ctor = ctor;
+      this.#controller.setup(ctor);
+      this.ctx.notify("provider-setup", this);
+      const src = peek(this.ctx.$state.source);
+      if (src) this.loadSource(src);
+    });
+  }
+  async loadSource(src, preload) {
+    if (!isString(src.src)) {
+      this.removeSource();
+      return;
+    }
+    this.media.preload = preload || "";
+    this.appendSource(src, "application/x-mpegurl");
+    this.#controller.loadSource(src);
+    this.currentSrc = src;
+  }
+  /**
+   * The given callback is invoked when a new `hls.js` instance is created and right before it's
+   * attached to media.
+   */
+  onInstance(callback) {
+    const instance = this.#controller.instance;
+    if (instance) callback(instance);
+    return this.#controller.onInstance(callback);
+  }
+  destroy() {
+    this.#controller.destroy();
+  }
+}
+
+export { HLSProvider };
diff --git a/dev/chunks/vidstack-tCTk_Mpr.js b/dev/chunks/vidstack-MAWt6ODZ.js
similarity index 99%
rename from dev/chunks/vidstack-tCTk_Mpr.js
rename to dev/chunks/vidstack-MAWt6ODZ.js
index 0dbbc6aa6eac15bbb93eaaaccb2399133bb4070c..b4c3c9d01e748b128c70726810f0d66fa77441cd 100644
--- a/dev/chunks/vidstack-tCTk_Mpr.js
+++ b/dev/chunks/vidstack-MAWt6ODZ.js
@@ -1,7 +1,7 @@
 "use client"
 
 import * as React from 'react';
-import { isString, isNumber, isFunction, isUndefined, waitTimeout, isArray, isBoolean, isNull, deferredPromise, listenEvent, scoped, getScope, EventsTarget, DOMEvent, State, fscreen, tick, createContext, useContext, Component, functionThrottle, isTouchEvent, isDOMNode, setAttribute, effect, EventsController, isKeyboardClick, setStyle, onDispose, untrack, functionDebounce, ViewController, signal, peek, isKeyboardEvent, isNil, createScope, camelToKebabCase, waitIdlePeriod, provideContext, animationFrameThrottle, uppercaseFirstChar, computed, prop, method, noop, ariaBool as ariaBool$1, isWriteSignal, hasProvidedContext, isObject, useState, r, wasEnterKeyPressed, isPointerEvent, isMouseEvent, kebabToCamelCase, composeRefs, useStateContext, useSignal, useSignalRecord } from './vidstack-CH225ns1.js';
+import { isString, isNumber, isFunction, isUndefined, waitTimeout, isArray, isBoolean, isNull, deferredPromise, listenEvent, scoped, getScope, EventsTarget, DOMEvent, State, fscreen, tick, createContext, useContext, Component, functionThrottle, setAttribute, effect, isTouchEvent, isDOMNode, EventsController, isKeyboardClick, setStyle, onDispose, untrack, functionDebounce, ViewController, signal, peek, isKeyboardEvent, isNil, createScope, camelToKebabCase, waitIdlePeriod, prop, method, provideContext, animationFrameThrottle, uppercaseFirstChar, computed, noop, ariaBool as ariaBool$1, isWriteSignal, hasProvidedContext, isObject, useState, r, wasEnterKeyPressed, isPointerEvent, isMouseEvent, kebabToCamelCase, composeRefs, useStateContext, useSignal, useSignalRecord } from './vidstack-CH225ns1.js';
 import { autoUpdate, computePosition, flip, shift } from '@floating-ui/dom';
 
 function isVideoQualitySrc(src) {
@@ -507,6 +507,8 @@ class TextTrack extends EventsTarget {
       });
       if (this.type === "json") {
         this.#parseJSON(await (await response).text(), VTTCue, VTTRegion);
+      } else if (this.type === "lrc") {
+        this.#parseLRC(await (await response).text(), VTTCue, VTTRegion);
       } else {
         const { errors, metadata, regions, cues } = await parseResponse(response, {
           type: this.type,
@@ -541,6 +543,20 @@ class TextTrack extends EventsTarget {
     this[TextTrackSymbol.readyState] = 3;
     this.dispatchEvent(new DOMEvent("error", { detail: error }));
   }
+  #parseLRC(lrc, VTTCue, VTTRegion) {
+    try {
+      const { regions, cues } = parseLRCCaptionsFile(lrc, VTTCue, VTTRegion);
+      this.#regions = regions;
+      this.#cues = cues;
+    } catch (error) {
+      {
+        console.error(`[vidstack] failed to parse LRC captions at: \`${this.src}\`
+
+`, error);
+      }
+      this.#error(error);
+    }
+  }
   #parseJSON(json, VTTCue, VTTRegion) {
     try {
       const { regions, cues } = parseJSONCaptionsFile(json, VTTCue, VTTRegion);
@@ -563,6 +579,30 @@ const captionRE = /captions|subtitles/;
 function isTrackCaptionKind(track) {
   return captionRE.test(track.kind);
 }
+function parseLRCCaptionsFile(lrc, Cue, Region) {
+  const cues = [], regions = [];
+  const lines = lrc.split("\n");
+  let lineIndex = 0;
+  while (lineIndex < lines.length) {
+    const line = lines[lineIndex].trim();
+    if (!line) {
+      lineIndex++;
+      continue;
+    }
+    const cue = new Cue(0, 0, ""), parts = line.split("]");
+    if (parts.length < 2) {
+      lineIndex++;
+      continue;
+    }
+    const times = parts[0].split("[")[1].split("-");
+    cue.startTime = parseFloat(times[0]);
+    cue.endTime = parseFloat(times[1]);
+    cue.text = parts.slice(1).join("]");
+    cues.push(cue);
+    lineIndex++;
+  }
+  return { cues, regions };
+}
 function parseJSONCaptionsFile(json, Cue, Region) {
   const content = isString(json) ? JSON.parse(json) : json;
   let regions = [], cues = [];
@@ -2768,7 +2808,7 @@ class AudioProviderLoader {
         "[vidstack] `<audio>` element was not found - did you forget to include `<media-provider>`?"
       );
     }
-    return new (await import('./vidstack-BI_qiU6Y.js')).AudioProvider(this.target, ctx);
+    return new (await import('./vidstack-Bofiwj54.js')).AudioProvider(this.target, ctx);
   }
 }
 
@@ -2810,7 +2850,7 @@ class HLSProviderLoader extends VideoProviderLoader {
         "[vidstack] `<video>` element was not found - did you forget to include `<media-provider>`?"
       );
     }
-    return new (await import('./vidstack-B6cpIZaB.js')).HLSProvider(this.target, context);
+    return new (await import('./vidstack-C2NXX4XZ.js')).HLSProvider(this.target, context);
   }
 }
 
@@ -4214,7 +4254,7 @@ class VimeoProviderLoader {
         "[vidstack] `<iframe>` element was not found - did you forget to include media provider?"
       );
     }
-    return new (await import('./vidstack-LkorjYNN.js')).VimeoProvider(this.target, ctx);
+    return new (await import('./vidstack-BV8aou1h.js')).VimeoProvider(this.target, ctx);
   }
   async loadPoster(src, ctx, abort) {
     const { resolveVimeoVideoId, getVimeoVideoInfo } = await import('./vidstack-krOAtKMi.js');
@@ -4259,7 +4299,7 @@ class YouTubeProviderLoader {
         "[vidstack] `<iframe>` element was not found - did you forget to include media provider?"
       );
     }
-    return new (await import('./vidstack-DeDlc57T.js')).YouTubeProvider(this.target, ctx);
+    return new (await import('./vidstack-Dq9VWd7A.js')).YouTubeProvider(this.target, ctx);
   }
   async loadPoster(src, ctx, abort) {
     const { findYouTubePoster, resolveYouTubeVideoId } = await import('./vidstack-Zc3I7oOd.js');
@@ -4964,7 +5004,7 @@ class MediaRequestManager extends MediaPlayerController {
       }
       preconnect("https://www.gstatic.com");
       if (!this.#googleCastLoader) {
-        const $module = await import('./vidstack-DnVfQIbh.js').then(function (n) { return n.loader; });
+        const $module = await import('./vidstack-Bk4a1y2Y.js').then(function (n) { return n.loader; });
         this.#googleCastLoader = new $module.GoogleCastLoader();
       }
       await this.#googleCastLoader.prompt(this.#media);
@@ -11631,4 +11671,4 @@ function useMediaStore(ref) {
   return useSignalRecord(ref?.current ? ref.current.$state : $state || initialMediaStore);
 }
 
-export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLAirPlayAdapter, HTMLMediaProvider, IS_CHROME, IS_IOS, IS_SERVER, List, ListSymbol, LiveButtonInstance, LocalMediaStorage, Logger, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaPlayerInstance, MediaProviderInstance, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, Primitive, QualitySliderInstance, QualitySymbol, RAFLoop, RadioGroupController, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrack, TextTrackList, TextTrackSymbol, ThumbnailInstance, ThumbnailsLoader, TimeInstance, TimeRange, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProvider, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, appendParamsToURL, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, coerceToError, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHLSSupported, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isRemotionProvider, isRemotionSrc, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, loadScript, mediaContext, mediaState, menuContext, normalizeTimeIntervals, parseJSONCaptionsFile, preconnect, sliderState, softResetMediaState, sortVideoQualities, updateSliderPreviewPlacement, updateTimeIntervals, useMediaContext, useMediaState, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange };
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLAirPlayAdapter, HTMLMediaProvider, IS_CHROME, IS_IOS, IS_SERVER, List, ListSymbol, LiveButtonInstance, LocalMediaStorage, Logger, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaPlayerInstance, MediaProviderInstance, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, Primitive, QualitySliderInstance, QualitySymbol, RAFLoop, RadioGroupController, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrack, TextTrackList, TextTrackSymbol, ThumbnailInstance, ThumbnailsLoader, TimeInstance, TimeRange, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProvider, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, appendParamsToURL, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, coerceToError, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHLSSupported, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isRemotionProvider, isRemotionSrc, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, loadScript, mediaContext, mediaState, menuContext, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, preconnect, sliderState, softResetMediaState, sortVideoQualities, updateSliderPreviewPlacement, updateTimeIntervals, useMediaContext, useMediaState, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange };
diff --git a/dev/chunks/vidstack-DBVMDgDR.js b/dev/chunks/vidstack-OQaRvsDl.js
similarity index 96%
rename from dev/chunks/vidstack-DBVMDgDR.js
rename to dev/chunks/vidstack-OQaRvsDl.js
index b4a7e770a6dd3c892135ada2719ceffe34aa19fa..4574f313cdcd5a01ee6e566a31c1e0de0b4961fe 100644
--- a/dev/chunks/vidstack-DBVMDgDR.js
+++ b/dev/chunks/vidstack-OQaRvsDl.js
@@ -1,6 +1,6 @@
 "use client"
 
-import { appendParamsToURL, IS_SERVER } from './vidstack-tCTk_Mpr.js';
+import { appendParamsToURL, IS_SERVER } from './vidstack-DlEFWAGb.js';
 import { signal, listenEvent, effect, peek, isString } from './vidstack-CH225ns1.js';
 
 class EmbedProvider {
diff --git a/dev/chunks/vidstack-U5d70oGh.js b/dev/chunks/vidstack-U5d70oGh.js
new file mode 100644
index 0000000000000000000000000000000000000000..6684b1373c4c49908c579c06b75d3a4db568333a
--- /dev/null
+++ b/dev/chunks/vidstack-U5d70oGh.js
@@ -0,0 +1,189 @@
+"use client"
+
+import * as React from 'react';
+import { RadioGroupController, useMediaContext, menuContext, MediaRemoteControl, MediaPlayerInstance, sortVideoQualities } from './vidstack-BdoOxmTD.js';
+import { useMediaContext as useMediaContext$1 } from './vidstack-VrioNQ8t.js';
+import { prop, method, Component, hasProvidedContext, useContext, effect, useSignal, isString } from './vidstack-CH225ns1.js';
+
+const DEFAULT_PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
+class SpeedRadioGroup extends Component {
+  static props = {
+    normalLabel: "Normal",
+    rates: DEFAULT_PLAYBACK_RATES
+  };
+  #media;
+  #menu;
+  #controller;
+  get value() {
+    return this.#controller.value;
+  }
+  get disabled() {
+    const { rates } = this.$props, { canSetPlaybackRate } = this.#media.$state;
+    return !canSetPlaybackRate() || rates().length === 0;
+  }
+  constructor() {
+    super();
+    this.#controller = new RadioGroupController();
+    this.#controller.onValueChange = this.#onValueChange.bind(this);
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    if (hasProvidedContext(menuContext)) {
+      this.#menu = useContext(menuContext);
+    }
+  }
+  onConnect(el) {
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchHintText.bind(this));
+    effect(this.#watchControllerDisabled.bind(this));
+  }
+  getOptions() {
+    const { rates, normalLabel } = this.$props;
+    return rates().map((rate) => ({
+      label: rate === 1 ? normalLabel : rate + "\xD7",
+      value: rate.toString()
+    }));
+  }
+  #watchValue() {
+    this.#controller.value = this.#getValue();
+  }
+  #watchHintText() {
+    const { normalLabel } = this.$props, { playbackRate } = this.#media.$state, rate = playbackRate();
+    this.#menu?.hint.set(rate === 1 ? normalLabel() : rate + "\xD7");
+  }
+  #watchControllerDisabled() {
+    this.#menu?.disable(this.disabled);
+  }
+  #getValue() {
+    const { playbackRate } = this.#media.$state;
+    return playbackRate().toString();
+  }
+  #onValueChange(value, trigger) {
+    if (this.disabled) return;
+    const rate = +value;
+    this.#media.remote.changePlaybackRate(rate, trigger);
+    this.dispatch("change", { detail: rate, trigger });
+  }
+}
+const speedradiogroup__proto = SpeedRadioGroup.prototype;
+prop(speedradiogroup__proto, "value");
+prop(speedradiogroup__proto, "disabled");
+method(speedradiogroup__proto, "getOptions");
+
+function useMediaRemote(target) {
+  const media = useMediaContext$1(), remote = React.useRef();
+  if (!remote.current) {
+    remote.current = new MediaRemoteControl();
+  }
+  React.useEffect(() => {
+    const ref = target && "current" in target ? target.current : target, isPlayerRef = ref instanceof MediaPlayerInstance, player = isPlayerRef ? ref : media?.player;
+    remote.current.setPlayer(player ?? null);
+    remote.current.setTarget(ref ?? null);
+  }, [media, target && "current" in target ? target.current : target]);
+  return remote.current;
+}
+
+function useVideoQualityOptions({
+  auto = true,
+  sort = "descending"
+} = {}) {
+  const media = useMediaContext$1(), { qualities, quality, autoQuality, canSetQuality } = media.$state, $qualities = useSignal(qualities);
+  useSignal(quality);
+  useSignal(autoQuality);
+  useSignal(canSetQuality);
+  return React.useMemo(() => {
+    const sortedQualities = sortVideoQualities($qualities, sort === "descending"), options = sortedQualities.map((q) => {
+      return {
+        quality: q,
+        label: q.height + "p",
+        value: getQualityValue(q),
+        bitrateText: q.bitrate && q.bitrate > 0 ? `${(q.bitrate / 1e6).toFixed(2)} Mbps` : null,
+        get selected() {
+          return q === quality();
+        },
+        get autoSelected() {
+          return autoQuality();
+        },
+        select(trigger) {
+          const index = qualities().indexOf(q);
+          if (index >= 0) media.remote.changeQuality(index, trigger);
+        }
+      };
+    });
+    if (auto) {
+      options.unshift({
+        quality: null,
+        label: isString(auto) ? auto : "Auto",
+        value: "auto",
+        bitrateText: null,
+        get selected() {
+          return autoQuality();
+        },
+        get autoSelected() {
+          return autoQuality();
+        },
+        select(trigger) {
+          media.remote.requestAutoQuality(trigger);
+        }
+      });
+    }
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !canSetQuality() || $qualities.length <= 1;
+      }
+    });
+    Object.defineProperty(options, "selectedQuality", {
+      get() {
+        return quality();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const $quality = quality();
+        return !autoQuality() && $quality ? getQualityValue($quality) : "auto";
+      }
+    });
+    return options;
+  }, [$qualities, sort]);
+}
+function getQualityValue(quality) {
+  return quality.height + "_" + quality.bitrate;
+}
+
+function usePlaybackRateOptions({
+  rates = DEFAULT_PLAYBACK_RATES,
+  normalLabel = "Normal"
+} = {}) {
+  const media = useMediaContext$1(), { playbackRate, canSetPlaybackRate } = media.$state;
+  useSignal(playbackRate);
+  useSignal(canSetPlaybackRate);
+  return React.useMemo(() => {
+    const options = rates.map((opt) => {
+      const label = typeof opt === "number" ? opt === 1 && normalLabel ? normalLabel : opt + "x" : opt.label, rate = typeof opt === "number" ? opt : opt.rate;
+      return {
+        label,
+        value: rate.toString(),
+        rate,
+        get selected() {
+          return playbackRate() === rate;
+        },
+        select(trigger) {
+          media.remote.changePlaybackRate(rate, trigger);
+        }
+      };
+    });
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !canSetPlaybackRate() || !options.length;
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        return playbackRate().toString();
+      }
+    });
+    return options;
+  }, [rates]);
+}
+
+export { DEFAULT_PLAYBACK_RATES, useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions };
diff --git a/dev/chunks/vidstack-VrioNQ8t.js b/dev/chunks/vidstack-VrioNQ8t.js
new file mode 100644
index 0000000000000000000000000000000000000000..29ff931f44bf19c0010b3b8e931f509f7673d00a
--- /dev/null
+++ b/dev/chunks/vidstack-VrioNQ8t.js
@@ -0,0 +1,668 @@
+"use client"
+
+import * as React from 'react';
+import { useReactContext, createReactComponent, composeRefs, useSignal, noop, useStateContext, signal, effect, isString } from './vidstack-CH225ns1.js';
+import { mediaContext, Primitive, AirPlayButtonInstance, PlayButtonInstance, CaptionButtonInstance, FullscreenButtonInstance, MuteButtonInstance, PIPButtonInstance, SeekButtonInstance, LiveButtonInstance, SliderValueInstance, useSliderState, SliderInstance, SliderPreviewInstance, VolumeSliderInstance, IS_SERVER, ThumbnailInstance, TimeSliderInstance, SliderChaptersInstance, SliderThumbnailInstance, SliderVideoInstance, mediaState, RadioGroupInstance, RadioInstance, useMediaState, MenuInstance, MenuButtonInstance, MenuItemsInstance, MenuItemInstance, GestureInstance, TimeInstance, isTrackCaptionKind } from './vidstack-BdoOxmTD.js';
+import { createPortal } from 'react-dom';
+
+function useMediaContext() {
+  return useReactContext(mediaContext);
+}
+
+const AirPlayButtonBridge = createReactComponent(AirPlayButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const AirPlayButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(AirPlayButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+AirPlayButton.displayName = "AirPlayButton";
+
+const PlayButtonBridge = createReactComponent(PlayButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const PlayButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PlayButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+PlayButton.displayName = "PlayButton";
+
+const CaptionButtonBridge = createReactComponent(CaptionButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const CaptionButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(CaptionButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+CaptionButton.displayName = "CaptionButton";
+
+const FullscreenButtonBridge = createReactComponent(FullscreenButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const FullscreenButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(FullscreenButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+FullscreenButton.displayName = "FullscreenButton";
+
+const MuteButtonBridge = createReactComponent(MuteButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const MuteButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(MuteButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+MuteButton.displayName = "MuteButton";
+
+const PIPButtonBridge = createReactComponent(PIPButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const PIPButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PIPButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+PIPButton.displayName = "PIPButton";
+
+const SeekButtonBridge = createReactComponent(SeekButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const SeekButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SeekButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+SeekButton.displayName = "SeekButton";
+
+const LiveButtonBridge = createReactComponent(LiveButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const LiveButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(LiveButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+LiveButton.displayName = "LiveButton";
+
+const sliderCallbacks = [
+  "onDragStart",
+  "onDragEnd",
+  "onDragValueChange",
+  "onValueChange",
+  "onPointerValueChange"
+];
+
+const SliderValueBridge = createReactComponent(SliderValueInstance);
+
+const SliderBridge = createReactComponent(SliderInstance, {
+  events: sliderCallbacks
+});
+const Root$5 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(SliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+});
+Root$5.displayName = "Slider";
+const Thumb = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Thumb.displayName = "SliderThumb";
+const Track = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Track.displayName = "SliderTrack";
+const TrackFill = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+TrackFill.displayName = "SliderTrackFill";
+const PreviewBridge = createReactComponent(SliderPreviewInstance);
+const Preview = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PreviewBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Preview.displayName = "SliderPreview";
+const Value = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(SliderValueBridge, { ...props }, (props2, instance) => {
+    const $text = useSignal(() => instance.getValueText(), instance);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props2, ref: forwardRef }, $text, children);
+  });
+});
+Value.displayName = "SliderValue";
+const Steps = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const $min = useSliderState("min"), $max = useSliderState("max"), $step = useSliderState("step"), steps = ($max - $min) / $step;
+  return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, Array.from({ length: Math.floor(steps) + 1 }).map((_, step) => children(step)));
+});
+Steps.displayName = "SliderSteps";
+
+var slider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$5,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value
+});
+
+const VolumeSliderBridge = createReactComponent(VolumeSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$4 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(VolumeSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$4.displayName = "VolumeSlider";
+
+var volumeSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$4,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value
+});
+
+function createVTTCue(startTime = 0, endTime = 0, text = "") {
+  if (IS_SERVER) {
+    return {
+      startTime,
+      endTime,
+      text,
+      addEventListener: noop,
+      removeEventListener: noop,
+      dispatchEvent: noop
+    };
+  }
+  return new window.VTTCue(startTime, endTime, text);
+}
+function appendParamsToURL(baseUrl, params) {
+  const url = new URL(baseUrl);
+  for (const key of Object.keys(params)) {
+    url.searchParams.set(key, params[key] + "");
+  }
+  return url.toString();
+}
+
+const ThumbnailBridge = createReactComponent(ThumbnailInstance);
+const Root$3 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ThumbnailBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Root$3.displayName = "Thumbnail";
+const Img = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const { src, img, crossOrigin } = useStateContext(ThumbnailInstance.state), $src = useSignal(src), $crossOrigin = useSignal(crossOrigin);
+  return /* @__PURE__ */ React.createElement(
+    Primitive.img,
+    {
+      crossOrigin: $crossOrigin,
+      ...props,
+      src: $src || void 0,
+      ref: composeRefs(img.set, forwardRef)
+    },
+    children
+  );
+});
+Img.displayName = "ThumbnailImg";
+
+var thumbnail = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Img: Img,
+  Root: Root$3
+});
+
+const TimeSliderContext = React.createContext({
+  $chapters: signal(null)
+});
+TimeSliderContext.displayName = "TimeSliderContext";
+const TimeSliderBridge = createReactComponent(TimeSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$2 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    const $chapters = React.useMemo(() => signal(null), []);
+    return /* @__PURE__ */ React.createElement(TimeSliderContext.Provider, { value: { $chapters } }, /* @__PURE__ */ React.createElement(TimeSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children)));
+  }
+);
+Root$2.displayName = "TimeSlider";
+const SliderChaptersBridge = createReactComponent(SliderChaptersInstance);
+const Chapters = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SliderChaptersBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      /* @__PURE__ */ React.createElement(ChapterTracks, { instance }, children)
+    ));
+  }
+);
+Chapters.displayName = "SliderChapters";
+function ChapterTracks({ instance, children }) {
+  const $cues = useSignal(() => instance.cues, instance), refs = React.useRef([]), emptyCue = React.useRef(), { $chapters } = React.useContext(TimeSliderContext);
+  if (!emptyCue.current) {
+    emptyCue.current = createVTTCue();
+  }
+  React.useEffect(() => {
+    $chapters.set(instance);
+    return () => void $chapters.set(null);
+  }, [instance]);
+  React.useEffect(() => {
+    instance.setRefs(refs.current);
+  }, [$cues]);
+  return children($cues.length ? $cues : [emptyCue.current], (el) => {
+    if (!el) {
+      refs.current.length = 0;
+      return;
+    }
+    refs.current.push(el);
+  });
+}
+ChapterTracks.displayName = "SliderChapterTracks";
+const ChapterTitle = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    const { $chapters } = React.useContext(TimeSliderContext), [title, setTitle] = React.useState();
+    React.useEffect(() => {
+      return effect(() => {
+        const chapters = $chapters(), cue = chapters?.activePointerCue || chapters?.activeCue;
+        setTitle(cue?.text || "");
+      });
+    }, []);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, title, children);
+  }
+);
+ChapterTitle.displayName = "SliderChapterTitle";
+const Progress = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Progress.displayName = "SliderProgress";
+const SliderThumbnailBridge = createReactComponent(SliderThumbnailInstance);
+const ThumbnailRoot = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SliderThumbnailBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2, ref: composeRefs(props2.ref, forwardRef) }, children));
+  }
+);
+ThumbnailRoot.displayName = "SliderThumbnail";
+const Thumbnail = {
+  Root: ThumbnailRoot,
+  Img: Img
+};
+const VideoBridge = createReactComponent(SliderVideoInstance, {
+  events: ["onCanPlay", "onError"]
+});
+const Video = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(VideoBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+      VideoProvider,
+      {
+        ...props2,
+        instance,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Video.displayName = "SliderVideo";
+const VideoProvider = React.forwardRef(
+  ({ instance, children, ...props }, forwardRef) => {
+    const { canLoad } = useStateContext(mediaState), { src, video, crossOrigin } = instance.$state, $src = useSignal(src), $canLoad = useSignal(canLoad), $crossOrigin = useSignal(crossOrigin);
+    return /* @__PURE__ */ React.createElement(
+      Primitive.video,
+      {
+        style: { maxWidth: "unset" },
+        ...props,
+        src: $src || void 0,
+        muted: true,
+        playsInline: true,
+        preload: $canLoad ? "auto" : "none",
+        crossOrigin: $crossOrigin || void 0,
+        ref: composeRefs(video.set, forwardRef)
+      },
+      children
+    );
+  }
+);
+VideoProvider.displayName = "SliderVideoProvider";
+
+var timeSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  ChapterTitle: ChapterTitle,
+  Chapters: Chapters,
+  Preview: Preview,
+  Progress: Progress,
+  Root: Root$2,
+  Steps: Steps,
+  Thumb: Thumb,
+  Thumbnail: Thumbnail,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value,
+  Video: Video
+});
+
+const RadioGroupBridge = createReactComponent(RadioGroupInstance, {
+  events: ["onChange"]
+});
+const Root$1 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(RadioGroupBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$1.displayName = "RadioGroup";
+const ItemBridge$1 = createReactComponent(RadioInstance, {
+  events: ["onChange", "onSelect"]
+});
+const Item$1 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemBridge$1, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Item$1.displayName = "RadioItem";
+
+var radioGroup = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Item: Item$1,
+  Root: Root$1
+});
+
+const MenuBridge = createReactComponent(MenuInstance, {
+  events: ["onOpen", "onClose"],
+  domEventsRegex: /^onMedia/
+});
+const Root = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(MenuBridge, { ...props, ref: forwardRef }, (props2, instance) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      style: { display: !instance.isSubmenu ? "contents" : void 0, ...props2.style }
+    },
+    children
+  ));
+});
+Root.displayName = "Menu";
+const ButtonBridge = createReactComponent(MenuButtonInstance, {
+  events: ["onSelect"]
+});
+const Button = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(ButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Button.displayName = "MenuButton";
+const Portal = React.forwardRef(
+  ({ container = null, disabled = false, children, ...props }, forwardRef) => {
+    let fullscreen = useMediaState("fullscreen"), shouldPortal = disabled === "fullscreen" ? !fullscreen : !disabled;
+    const target = React.useMemo(() => {
+      if (IS_SERVER) return null;
+      const node = isString(container) ? document.querySelector(container) : container;
+      return node ?? document.body;
+    }, [container]);
+    return !target || !shouldPortal ? children : createPortal(
+      /* @__PURE__ */ React.createElement(
+        Primitive.div,
+        {
+          ...props,
+          style: { display: "contents", ...props.style },
+          ref: forwardRef
+        },
+        children
+      ),
+      target
+    );
+  }
+);
+Portal.displayName = "MenuPortal";
+const ItemsBridge = createReactComponent(MenuItemsInstance);
+const Items = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemsBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Items.displayName = "MenuItems";
+const ItemBridge = createReactComponent(MenuItemInstance);
+const Item = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Item.displayName = "MenuItem";
+
+var menu = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Button: Button,
+  Content: Items,
+  Item: Item,
+  Items: Items,
+  Portal: Portal,
+  Radio: Item$1,
+  RadioGroup: Root$1,
+  Root: Root
+});
+
+const GestureBridge = createReactComponent(GestureInstance, {
+  events: ["onWillTrigger", "onTrigger"]
+});
+const Gesture = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(GestureBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Gesture.displayName = "Gesture";
+
+const TimeBridge = createReactComponent(TimeInstance);
+const Time = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(TimeBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+    TimeText,
+    {
+      ...props2,
+      instance,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Time.displayName = "Time";
+const TimeText = React.forwardRef(
+  ({ instance, children, ...props }, forwardRef) => {
+    const { timeText } = instance.$state, $timeText = useSignal(timeText);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, $timeText, children);
+  }
+);
+TimeText.displayName = "TimeText";
+
+function useMediaPlayer() {
+  const context = useMediaContext();
+  if (!context) {
+    throw Error(
+      "[vidstack] no media context was found - was this called outside of `<MediaPlayer>`?"
+    );
+  }
+  return context?.player || null;
+}
+
+function useAudioOptions() {
+  const media = useMediaContext(), { audioTracks, audioTrack } = media.$state, $audioTracks = useSignal(audioTracks);
+  useSignal(audioTrack);
+  return React.useMemo(() => {
+    const options = $audioTracks.map((track) => ({
+      track,
+      label: track.label,
+      value: getTrackValue$1(track),
+      get selected() {
+        return audioTrack() === track;
+      },
+      select(trigger) {
+        const index = audioTracks().indexOf(track);
+        if (index >= 0) media.remote.changeAudioTrack(index, trigger);
+      }
+    }));
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return options.length <= 1;
+      }
+    });
+    Object.defineProperty(options, "selectedTrack", {
+      get() {
+        return audioTrack();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const track = audioTrack();
+        return track ? getTrackValue$1(track) : void 0;
+      }
+    });
+    return options;
+  }, [$audioTracks]);
+}
+function getTrackValue$1(track) {
+  return track.label.toLowerCase();
+}
+
+function useCaptionOptions({ off = true } = {}) {
+  const media = useMediaContext(), { textTracks, textTrack } = media.$state, $textTracks = useSignal(textTracks);
+  useSignal(textTrack);
+  return React.useMemo(() => {
+    const captionTracks = $textTracks.filter(isTrackCaptionKind), options = captionTracks.map((track) => ({
+      track,
+      label: track.label,
+      value: getTrackValue(track),
+      get selected() {
+        return textTrack() === track;
+      },
+      select(trigger) {
+        const index = textTracks().indexOf(track);
+        if (index >= 0) media.remote.changeTextTrackMode(index, "showing", trigger);
+      }
+    }));
+    if (off) {
+      options.unshift({
+        track: null,
+        label: isString(off) ? off : "Off",
+        value: "off",
+        get selected() {
+          return !textTrack();
+        },
+        select(trigger) {
+          media.remote.toggleCaptions(trigger);
+        }
+      });
+    }
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !captionTracks.length;
+      }
+    });
+    Object.defineProperty(options, "selectedTrack", {
+      get() {
+        return textTrack();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const track = textTrack();
+        return track ? getTrackValue(track) : "off";
+      }
+    });
+    return options;
+  }, [$textTracks]);
+}
+function getTrackValue(track) {
+  return track.id + ":" + track.kind + "-" + track.label.toLowerCase();
+}
+
+export { AirPlayButton, Button, CaptionButton, ChapterTitle, Chapters, FullscreenButton, Gesture, Img, Item$1 as Item, Items, LiveButton, MuteButton, PIPButton, PlayButton, Portal, Preview, Progress, Root$3 as Root, Root$2 as Root$1, Root as Root$2, Root$1 as Root$3, Root$4, Root$5, SeekButton, Steps, Thumb, Thumbnail, Time, Track, TrackFill, Value, appendParamsToURL, menu, radioGroup, slider, sliderCallbacks, thumbnail, timeSlider, useAudioOptions, useCaptionOptions, useMediaContext, useMediaPlayer, volumeSlider };
diff --git a/dev/chunks/vidstack-Yc2A7God.js b/dev/chunks/vidstack-Yc2A7God.js
new file mode 100644
index 0000000000000000000000000000000000000000..6901a6b7d0d70603aa4ef5cd9ab54f13d3c7535c
--- /dev/null
+++ b/dev/chunks/vidstack-Yc2A7God.js
@@ -0,0 +1,643 @@
+"use client"
+
+import * as React from 'react';
+import { createDisposalBin, listenEvent, isNumber, isUndefined, isNull, isNil, createScope, signal, peek, effect, tick, isFunction, useSignal, deferredPromise } from './vidstack-CH225ns1.js';
+import { Composition, Internals } from 'remotion';
+import { RemotionLayoutEngine, REMOTION_PROVIDER_ID, RemotionContextProvider, ErrorBoundary } from '../player/vidstack-remotion.js';
+import { isRemotionSrc, TimeRange } from './vidstack-MAWt6ODZ.js';
+import { NoReactInternals } from 'remotion/no-react';
+import './vidstack-CaBvbWDV.js';
+import '@floating-ui/dom';
+
+class RemotionPlaybackEngine {
+  #src;
+  #onFrameChange;
+  #onEnd;
+  #disposal = createDisposalBin();
+  #frame = 0;
+  #framesAdvanced = 0;
+  #playbackRate = 1;
+  #playing = false;
+  #rafId = -1;
+  #timerId = -1;
+  #startedAt = 0;
+  #isRunningInBackground = false;
+  get frame() {
+    return this.#frame;
+  }
+  set frame(frame) {
+    this.#frame = frame;
+    this.#onFrameChange(frame);
+  }
+  constructor(src, onFrameChange, onEnd) {
+    this.#src = src;
+    this.#onFrameChange = onFrameChange;
+    this.#onEnd = onEnd;
+    this.#frame = src.initialFrame ?? 0;
+    this.#disposal.add(
+      listenEvent(document, "visibilitychange", this.#onVisibilityChange.bind(this))
+    );
+  }
+  play() {
+    this.#framesAdvanced = 0;
+    this.#playing = true;
+    this.#startedAt = performance.now();
+    this.#tick();
+  }
+  stop() {
+    this.#playing = false;
+    if (this.#rafId >= 0) {
+      cancelAnimationFrame(this.#rafId);
+      this.#rafId = -1;
+    }
+    if (this.#timerId >= 0) {
+      clearTimeout(this.#timerId);
+      this.#timerId = -1;
+    }
+  }
+  setPlaybackRate(rate) {
+    this.#playbackRate = rate;
+  }
+  destroy() {
+    this.#disposal.empty();
+    this.stop();
+  }
+  #update() {
+    const { nextFrame, framesToAdvance, ended } = this.#calculateNextFrame();
+    this.#framesAdvanced += framesToAdvance;
+    if (nextFrame !== this.#frame) {
+      this.#onFrameChange(nextFrame);
+      this.#frame = nextFrame;
+    }
+    if (ended) {
+      this.#frame = this.#src.outFrame;
+      this.stop();
+      this.#onEnd();
+    }
+  }
+  #tick = () => {
+    this.#update();
+    if (this.#playing) {
+      this.#queueNextFrame(this.#tick);
+    }
+  };
+  #queueNextFrame(callback) {
+    if (this.#isRunningInBackground) {
+      this.#timerId = window.setTimeout(callback, 1e3 / this.#src.fps);
+    } else {
+      this.#rafId = requestAnimationFrame(callback);
+    }
+  }
+  #calculateNextFrame() {
+    const round = this.#playbackRate < 0 ? Math.ceil : Math.floor, time = performance.now() - this.#startedAt, framesToAdvance = round(time * this.#playbackRate / (1e3 / this.#src.fps)) - this.#framesAdvanced, nextFrame = framesToAdvance + this.#frame, isCurrentFrameOutOfBounds = this.#frame > this.#src.outFrame || this.#frame < this.#src.inFrame, isNextFrameOutOfBounds = nextFrame > this.#src.outFrame || nextFrame < this.#src.inFrame, ended = isNextFrameOutOfBounds && !isCurrentFrameOutOfBounds;
+    if (this.#playbackRate > 0 && !ended) {
+      if (isNextFrameOutOfBounds) {
+        return {
+          nextFrame: this.#src.inFrame,
+          framesToAdvance,
+          ended
+        };
+      }
+      return { nextFrame, framesToAdvance, ended };
+    }
+    if (isNextFrameOutOfBounds) {
+      return {
+        nextFrame: this.#src.outFrame,
+        framesToAdvance,
+        ended
+      };
+    }
+    return { nextFrame, framesToAdvance, ended };
+  }
+  #onVisibilityChange() {
+    this.#isRunningInBackground = document.visibilityState === "hidden";
+    if (this.#playing) {
+      this.stop();
+      this.play();
+    }
+  }
+}
+
+function validateRemotionResource({
+  src,
+  compositionWidth: width,
+  compositionHeight: height,
+  fps,
+  durationInFrames,
+  initialFrame,
+  inFrame,
+  outFrame,
+  numberOfSharedAudioTags
+}) {
+  validateComponent(src);
+  validateInitialFrame(initialFrame, durationInFrames);
+  validateDimension(width, "compositionWidth", "of the remotion source");
+  validateDimension(height, "compositionHeight", "of the remotion source");
+  validateDurationInFrames(durationInFrames, {
+    component: "of the remotion source",
+    allowFloats: false
+  });
+  validateFps(fps, "of the remotion source", false);
+  validateInOutFrames(inFrame, outFrame, durationInFrames);
+  validateSharedNumberOfAudioTags(numberOfSharedAudioTags);
+}
+const validateFps = NoReactInternals.validateFps;
+const validateDimension = NoReactInternals.validateDimension;
+const validateDurationInFrames = NoReactInternals.validateDurationInFrames;
+function validateInitialFrame(initialFrame, frames) {
+  if (!isNumber(frames)) {
+    throw new Error(
+      `[vidstack] \`durationInFrames\` must be a number, but is ${JSON.stringify(frames)}`
+    );
+  }
+  if (isUndefined(initialFrame)) {
+    return;
+  }
+  if (!isNumber(initialFrame)) {
+    throw new Error(
+      `[vidstack] \`initialFrame\` must be a number, but is ${JSON.stringify(initialFrame)}`
+    );
+  }
+  if (Number.isNaN(initialFrame)) {
+    throw new Error(`[vidstack] \`initialFrame\` must be a number, but is NaN`);
+  }
+  if (!Number.isFinite(initialFrame)) {
+    throw new Error(`[vidstack] \`initialFrame\` must be a number, but is Infinity`);
+  }
+  if (initialFrame % 1 !== 0) {
+    throw new Error(
+      `[vidstack] \`initialFrame\` must be an integer, but is ${JSON.stringify(initialFrame)}`
+    );
+  }
+  if (initialFrame > frames - 1) {
+    throw new Error(
+      `[vidstack] \`initialFrame\` must be less or equal than \`durationInFrames - 1\`, but is ${JSON.stringify(
+        initialFrame
+      )}`
+    );
+  }
+}
+function validateSingleFrame(frame, variableName) {
+  if (isNil(frame)) {
+    return frame ?? null;
+  }
+  if (!isNumber(frame)) {
+    throw new TypeError(
+      `[vidstack] \`${variableName}\` must be a number, but is ${JSON.stringify(frame)}`
+    );
+  }
+  if (Number.isNaN(frame)) {
+    throw new TypeError(
+      `[vidstack] \`${variableName}\` must not be NaN, but is ${JSON.stringify(frame)}`
+    );
+  }
+  if (!Number.isFinite(frame)) {
+    throw new TypeError(
+      `[vidstack] \`${variableName}\` must be finite, but is ${JSON.stringify(frame)}`
+    );
+  }
+  if (frame % 1 !== 0) {
+    throw new TypeError(
+      `[vidstack] \`${variableName}\` must be an integer, but is ${JSON.stringify(frame)}`
+    );
+  }
+  return frame;
+}
+function validateInOutFrames(inFrame, outFrame, frames) {
+  const validatedInFrame = validateSingleFrame(inFrame, "inFrame"), validatedOutFrame = validateSingleFrame(outFrame, "outFrame");
+  if (isNull(validatedInFrame) && isNull(validatedOutFrame)) {
+    return;
+  }
+  if (!isNull(validatedInFrame) && validatedInFrame > frames - 1) {
+    throw new Error(
+      `[vidstack] \`inFrame\` must be less than (durationInFrames - 1), but is \`${validatedInFrame}\``
+    );
+  }
+  if (!isNull(validatedOutFrame) && validatedOutFrame > frames) {
+    throw new Error(
+      `[vidstack] \`outFrame\` must be less than (durationInFrames), but is \`${validatedOutFrame}\``
+    );
+  }
+  if (!isNull(validatedInFrame) && validatedInFrame < 0) {
+    throw new Error(
+      `[vidstack] \`inFrame\` must be greater than 0, but is \`${validatedInFrame}\``
+    );
+  }
+  if (!isNull(validatedOutFrame) && validatedOutFrame <= 0) {
+    throw new Error(
+      `[vidstack] \`outFrame\` must be greater than 0, but is \`${validatedOutFrame}\`. If you want to render a single frame, use \`<RemotionThumbnail />\` instead.`
+    );
+  }
+  if (!isNull(validatedOutFrame) && !isNull(validatedInFrame) && validatedOutFrame <= validatedInFrame) {
+    throw new Error(
+      "[vidstack] `outFrame` must be greater than `inFrame`, but is " + validatedOutFrame + " <= " + validatedInFrame
+    );
+  }
+}
+function validateSharedNumberOfAudioTags(tags) {
+  if (isUndefined(tags)) return;
+  if (tags % 1 !== 0 || !Number.isFinite(tags) || Number.isNaN(tags) || tags < 0) {
+    throw new TypeError(
+      `[vidstack] \`numberOfSharedAudioTags\` must be an integer but got \`${tags}\` instead`
+    );
+  }
+}
+function validatePlaybackRate(playbackRate) {
+  if (playbackRate > 4) {
+    throw new Error(
+      `[vidstack] The highest possible playback rate with Remotion is 4. You passed: ${playbackRate}`
+    );
+  }
+  if (playbackRate < -4) {
+    throw new Error(
+      `[vidstack] The lowest possible playback rate with Remotion is -4. You passed: ${playbackRate}`
+    );
+  }
+  if (playbackRate === 0) {
+    throw new Error(`[vidstack] A playback rate of 0 is not supported.`);
+  }
+}
+function validateComponent(src) {
+  if (src.type === Composition) {
+    throw new TypeError(
+      `[vidstack] \`src\` should not be an instance of \`<Composition/>\`. Pass the React component directly, and set the duration, fps and dimensions as source props.`
+    );
+  }
+  if (src === Composition) {
+    throw new TypeError(
+      `[vidstack] \`src\` must not be the \`Composition\` component. Pass your own React component directly, and set the duration, fps and dimensions as source props.`
+    );
+  }
+}
+
+class RemotionProvider {
+  $$PROVIDER_TYPE = "REMOTION";
+  scope = createScope();
+  #src = signal(null);
+  #setup = false;
+  #loadStart = false;
+  #audio = null;
+  #waiting = signal(false);
+  #waitingPromise = null;
+  #mediaTags = signal([]);
+  #mediaElements = signal([]);
+  #bufferingElements = /* @__PURE__ */ new Set();
+  #timeline = null;
+  #frame = signal({ [REMOTION_PROVIDER_ID]: 0 });
+  #layoutEngine = new RemotionLayoutEngine();
+  #playbackEngine = null;
+  #container;
+  #ctx;
+  #setTimeline;
+  #setMediaVolume = {
+    setMediaMuted: this.setMuted.bind(this),
+    setMediaVolume: this.setVolume.bind(this)
+  };
+  get type() {
+    return "remotion";
+  }
+  get currentSrc() {
+    return peek(this.#src);
+  }
+  get frame() {
+    return this.#frame();
+  }
+  constructor(container, ctx) {
+    this.#container = container;
+    this.#ctx = ctx;
+    this.#setTimeline = {
+      setFrame: this.#setFrame.bind(this),
+      setPlaying: this.#setPlaying.bind(this)
+    };
+    this.#layoutEngine.setContainer(container);
+  }
+  setup() {
+    effect(this.#watchWaiting.bind(this));
+    effect(this.#watchMediaTags.bind(this));
+    effect(this.#watchMediaElements.bind(this));
+  }
+  #watchMediaTags() {
+    this.#mediaTags();
+    this.#discoverMediaElements();
+  }
+  #discoverMediaElements() {
+    const elements = [...this.#container.querySelectorAll("audio,video")];
+    this.#mediaElements.set(elements);
+  }
+  #watchMediaElements() {
+    const elements = this.#mediaElements();
+    for (const tag of elements) {
+      const onWait = this.#onWaitFor.bind(this, tag), onStopWaiting = this.#onStopWaitingFor.bind(this, tag);
+      if (tag.currentSrc && tag.readyState < 4) {
+        this.#onWaitFor(tag);
+        listenEvent(tag, "canplay", onStopWaiting);
+      }
+      listenEvent(tag, "waiting", onWait);
+      listenEvent(tag, "playing", onStopWaiting);
+    }
+    for (const el of this.#bufferingElements) {
+      if (!elements.includes(el)) this.#onStopWaitingFor(el);
+    }
+  }
+  #onFrameChange(frame) {
+    const { inFrame, fps } = this.#src(), { seeking } = this.#ctx.$state, time = Math.max(0, frame - inFrame) / fps;
+    this.#frame.set((record) => ({
+      ...record,
+      [REMOTION_PROVIDER_ID]: frame
+    }));
+    this.#ctx.notify("time-change", time);
+    if (seeking()) {
+      tick();
+      this.#ctx.notify("seeked", time);
+    }
+  }
+  #onFrameEnd() {
+    this.pause();
+    this.#ctx.notify("end");
+  }
+  async play() {
+    const { ended } = this.#ctx.$state;
+    if (peek(ended)) {
+      this.#setFrame({ [REMOTION_PROVIDER_ID]: 0 });
+    }
+    try {
+      const mediaElements = peek(this.#mediaElements);
+      if (mediaElements.length) {
+        await Promise.all(mediaElements.map((media) => media.play()));
+      }
+      this.#ctx.notify("play");
+      tick();
+      if (this.#waitingPromise) {
+        this.#ctx.notify("waiting");
+        return this.#waitingPromise.promise;
+      } else {
+        this.#playbackEngine?.play();
+        this.#ctx.notify("playing");
+      }
+    } catch (error) {
+      throw error;
+    }
+  }
+  async pause() {
+    this.#ctx.$state;
+    this.#playbackEngine?.stop();
+    this.#ctx.notify("pause");
+  }
+  setMuted(value) {
+    if (!this.#ctx) return;
+    const { muted, volume } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.setMuted(value(muted()));
+      return;
+    }
+    this.#ctx.notify("volume-change", {
+      volume: peek(volume),
+      muted: value
+    });
+  }
+  setCurrentTime(time) {
+    const { fps } = this.#src(), frame = time * fps;
+    this.#ctx.notify("seeking", time);
+    this.#setFrame({ [REMOTION_PROVIDER_ID]: frame });
+  }
+  setVolume(value) {
+    if (!this.#ctx) return;
+    const { volume, muted } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.setVolume(value(volume()));
+      return;
+    }
+    this.#ctx.notify("volume-change", {
+      volume: value,
+      muted: peek(muted)
+    });
+  }
+  setPlaybackRate(rate) {
+    if (isFunction(rate)) {
+      const { playbackRate } = this.#ctx.$state;
+      this.setPlaybackRate(rate(peek(playbackRate)));
+      return;
+    }
+    validatePlaybackRate(rate);
+    this.#playbackEngine?.setPlaybackRate(rate);
+    this.#ctx.notify("rate-change", rate);
+  }
+  async loadSource(src) {
+    if (!isRemotionSrc(src)) return;
+    const onUserError = src.onError, resolvedSrc = {
+      compositionWidth: 1920,
+      compositionHeight: 1080,
+      fps: 30,
+      initialFrame: 0,
+      inFrame: 0,
+      outFrame: src.durationInFrames,
+      numberOfSharedAudioTags: 5,
+      inputProps: {},
+      ...src,
+      onError: (error) => {
+        {
+          this.#ctx.logger?.errorGroup(`[vidstack] ${error.message}`).labelledLog("Source", peek(this.#src)).labelledLog("Error", error).dispatch();
+        }
+        this.pause();
+        this.#ctx.notify("error", {
+          message: error.message,
+          code: 1
+        });
+        onUserError?.(error);
+      }
+    };
+    this.#src.set(resolvedSrc);
+    for (const prop of Object.keys(resolvedSrc)) {
+      src[prop] = resolvedSrc[prop];
+    }
+    this.changeSrc(resolvedSrc);
+  }
+  destroy() {
+    this.changeSrc(null);
+  }
+  changeSrc(src) {
+    this.#playbackEngine?.destroy();
+    this.#waiting.set(false);
+    this.#waitingPromise?.reject("src changed");
+    this.#waitingPromise = null;
+    this.#audio = null;
+    this.#timeline = null;
+    this.#playbackEngine = null;
+    this.#mediaTags.set([]);
+    this.#bufferingElements.clear();
+    this.#frame.set({ [REMOTION_PROVIDER_ID]: 0 });
+    this.#layoutEngine.setSrc(src);
+    if (src) {
+      this.#timeline = this.#createTimelineContextValue();
+      this.#playbackEngine = new RemotionPlaybackEngine(
+        src,
+        this.#onFrameChange.bind(this),
+        this.#onFrameEnd.bind(this)
+      );
+    }
+  }
+  render = () => {
+    const $src = useSignal(this.#src);
+    if (!$src) {
+      throw Error(
+        "[vidstack] attempting to render remotion provider without src" 
+      );
+    }
+    React.useEffect(() => {
+      if (!isRemotionSrc($src)) return;
+      validateRemotionResource($src);
+      const rafId = requestAnimationFrame(() => {
+        if (!this.#setup) {
+          this.#ctx.notify("provider-setup", this);
+          this.#setup = true;
+        }
+        if (!this.#loadStart) {
+          this.#ctx.notify("load-start");
+          this.#loadStart = true;
+        }
+        this.#discoverMediaElements();
+        tick();
+        if (!this.#waiting()) this.#ready($src);
+      });
+      return () => {
+        cancelAnimationFrame(rafId);
+        this.#loadStart = false;
+      };
+    }, [$src]);
+    const Component = Internals.useLazyComponent({
+      component: $src.src
+    });
+    const { $state } = this.#ctx, $volume = useSignal($state.volume), $isMuted = useSignal($state.muted);
+    const mediaVolume = React.useMemo(() => {
+      const { muted, volume } = this.#ctx.$state;
+      return { mediaMuted: muted(), mediaVolume: volume() };
+    }, [$isMuted, $volume]);
+    return /* @__PURE__ */ React.createElement(
+      RemotionContextProvider,
+      {
+        src: $src,
+        component: Component,
+        timeline: this.#timeline,
+        mediaVolume,
+        setMediaVolume: this.#setMediaVolume
+      },
+      /* @__PURE__ */ React.createElement(Internals.Timeline.SetTimelineContext.Provider, { value: this.#setTimeline }, React.createElement(this.renderVideo, { src: $src }))
+    );
+  };
+  renderVideo = ({ src }) => {
+    const video = Internals.useVideo(), Video = video ? video.component : null, audioContext = React.useContext(Internals.SharedAudioContext);
+    const { $state } = this.#ctx;
+    useSignal(this.#frame);
+    useSignal($state.playing);
+    useSignal($state.playbackRate);
+    React.useEffect(() => {
+      this.#audio = audioContext;
+      return () => {
+        this.#audio = null;
+      };
+    }, [audioContext]);
+    const LoadingContent = React.useMemo(() => src.renderLoading?.(), [src]);
+    const Content = Video ? /* @__PURE__ */ React.createElement(ErrorBoundary, { fallback: src.errorFallback, onError: src.onError }, /* @__PURE__ */ React.createElement(Internals.ClipComposition, null, /* @__PURE__ */ React.createElement(Video, { ...video?.props, ...src.inputProps }))) : null;
+    return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: LoadingContent }, Content);
+  };
+  #ready(src) {
+    if (!src) return;
+    const { outFrame, inFrame, fps } = src, duration = (outFrame - inFrame) / fps;
+    this.#ctx.notify("loaded-metadata");
+    this.#ctx.notify("loaded-data");
+    this.#ctx.delegate.ready({
+      duration,
+      seekable: new TimeRange(0, duration),
+      buffered: new TimeRange(0, duration)
+    });
+    if (src.initialFrame) {
+      this.#setFrame({
+        [REMOTION_PROVIDER_ID]: src.initialFrame
+      });
+    }
+  }
+  #onWaitFor(el) {
+    this.#bufferingElements.add(el);
+    this.#waiting.set(true);
+    if (!this.#waitingPromise) {
+      this.#waitingPromise = deferredPromise();
+    }
+  }
+  #onStopWaitingFor(el) {
+    this.#bufferingElements.delete(el);
+    if (this.#bufferingElements.size) return;
+    this.#waiting.set(false);
+    this.#waitingPromise?.resolve();
+    this.#waitingPromise = null;
+    const { canPlay } = this.#ctx.$state;
+    if (!peek(canPlay)) {
+      this.#ready(peek(this.#src));
+    }
+  }
+  #watchWaiting() {
+    this.#waiting();
+    const { paused } = this.#ctx.$state;
+    if (peek(paused)) return;
+    if (this.#waiting()) {
+      this.#playbackEngine?.stop();
+      this.#ctx.notify("waiting");
+    } else {
+      this.#playbackEngine?.play();
+      this.#ctx.notify("playing");
+    }
+  }
+  #setFrame(value) {
+    if (isFunction(value)) {
+      this.#setFrame(value(this.#frame()));
+      return;
+    }
+    this.#frame.set((record) => ({ ...record, ...value }));
+    const nextFrame = value[REMOTION_PROVIDER_ID];
+    if (this.#playbackEngine && this.#playbackEngine.frame !== nextFrame) {
+      this.#playbackEngine.frame = nextFrame;
+    }
+  }
+  #setPlaying(value) {
+    const { playing } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.#setPlaying(value(playing()));
+      return;
+    }
+    if (value) {
+      this.play();
+    } else if (!value) {
+      this.pause();
+    }
+  }
+  #createTimelineContextValue() {
+    const { playing, playbackRate } = this.#ctx.$state, frame = this.#frame, mediaTags = this.#mediaTags, setPlaybackRate = this.setPlaybackRate.bind(this);
+    return {
+      rootId: REMOTION_PROVIDER_ID,
+      get frame() {
+        return frame();
+      },
+      get playing() {
+        return playing();
+      },
+      get playbackRate() {
+        return playbackRate();
+      },
+      imperativePlaying: {
+        get current() {
+          return playing();
+        }
+      },
+      setPlaybackRate,
+      audioAndVideoTags: {
+        get current() {
+          return mediaTags();
+        },
+        set current(tags) {
+          mediaTags.set(tags);
+        }
+      }
+    };
+  }
+}
+
+export { RemotionProvider };
diff --git a/dev/chunks/vidstack-YexL4NVj.js b/dev/chunks/vidstack-YexL4NVj.js
new file mode 100644
index 0000000000000000000000000000000000000000..d6683f9ea138ca437fffa91ae9c22f04ba50cf5b
--- /dev/null
+++ b/dev/chunks/vidstack-YexL4NVj.js
@@ -0,0 +1,287 @@
+"use client"
+
+import { createScope, signal, effect, isString, deferredPromise, isObject, isNumber, isBoolean } from './vidstack-CH225ns1.js';
+import { preconnect, TimeRange } from './vidstack-DlEFWAGb.js';
+import { EmbedProvider } from './vidstack-OQaRvsDl.js';
+import { resolveYouTubeVideoId } from './vidstack-Zc3I7oOd.js';
+import 'react';
+import '@floating-ui/dom';
+
+const YouTubePlayerState = {
+  Unstarted: -1,
+  Ended: 0,
+  Playing: 1,
+  Paused: 2,
+  Buffering: 3,
+  Cued: 5
+};
+
+class YouTubeProvider extends EmbedProvider {
+  $$PROVIDER_TYPE = "YOUTUBE";
+  scope = createScope();
+  #ctx;
+  #videoId = signal("");
+  #state = -1;
+  #currentSrc = null;
+  #seekingTimer = -1;
+  #invalidPlay = false;
+  #promises = /* @__PURE__ */ new Map();
+  constructor(iframe, ctx) {
+    super(iframe);
+    this.#ctx = ctx;
+  }
+  /**
+   * Sets the player's interface language. The parameter value is an ISO 639-1 two-letter
+   * language code or a fully specified locale. For example, fr and fr-ca are both valid values.
+   * Other language input codes, such as IETF language tags (BCP 47) might also be handled properly.
+   *
+   * The interface language is used for tooltips in the player and also affects the default caption
+   * track. Note that YouTube might select a different caption track language for a particular
+   * user based on the user's individual language preferences and the availability of caption tracks.
+   *
+   * @defaultValue 'en'
+   */
+  language = "en";
+  color = "red";
+  /**
+   * Whether cookies should be enabled on the embed. This is turned off by default to be
+   * GDPR-compliant.
+   *
+   * @defaultValue `false`
+   */
+  cookies = false;
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  get type() {
+    return "youtube";
+  }
+  get videoId() {
+    return this.#videoId();
+  }
+  preconnect() {
+    preconnect(this.getOrigin());
+  }
+  setup() {
+    super.setup();
+    effect(this.#watchVideoId.bind(this));
+    this.#ctx.notify("provider-setup", this);
+  }
+  destroy() {
+    this.#reset();
+    const message = "provider destroyed";
+    for (const promises of this.#promises.values()) {
+      for (const { reject } of promises) reject(message);
+    }
+    this.#promises.clear();
+  }
+  async play() {
+    return this.#remote("playVideo");
+  }
+  #playFail(message) {
+    this.#getPromise("playVideo")?.reject(message);
+  }
+  async pause() {
+    return this.#remote("pauseVideo");
+  }
+  #pauseFail(message) {
+    this.#getPromise("pauseVideo")?.reject(message);
+  }
+  setMuted(muted) {
+    if (muted) this.#remote("mute");
+    else this.#remote("unMute");
+  }
+  setCurrentTime(time) {
+    this.#remote("seekTo", time);
+    this.#ctx.notify("seeking", time);
+  }
+  setVolume(volume) {
+    this.#remote("setVolume", volume * 100);
+  }
+  setPlaybackRate(rate) {
+    this.#remote("setPlaybackRate", rate);
+  }
+  async loadSource(src) {
+    if (!isString(src.src)) {
+      this.#currentSrc = null;
+      this.#videoId.set("");
+      return;
+    }
+    const videoId = resolveYouTubeVideoId(src.src);
+    this.#videoId.set(videoId ?? "");
+    this.#currentSrc = src;
+  }
+  getOrigin() {
+    return !this.cookies ? "https://www.youtube-nocookie.com" : "https://www.youtube.com";
+  }
+  #watchVideoId() {
+    this.#reset();
+    const videoId = this.#videoId();
+    if (!videoId) {
+      this.src.set("");
+      return;
+    }
+    this.src.set(`${this.getOrigin()}/embed/${videoId}`);
+    this.#ctx.notify("load-start");
+  }
+  buildParams() {
+    const { keyDisabled } = this.#ctx.$props, { muted, playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
+    return {
+      autoplay: 0,
+      cc_lang_pref: this.language,
+      cc_load_policy: showControls ? 1 : void 0,
+      color: this.color,
+      controls: showControls ? 1 : 0,
+      disablekb: !showControls || keyDisabled() ? 1 : 0,
+      enablejsapi: 1,
+      fs: 1,
+      hl: this.language,
+      iv_load_policy: showControls ? 1 : 3,
+      mute: muted() ? 1 : 0,
+      playsinline: playsInline() ? 1 : 0
+    };
+  }
+  #remote(command, arg) {
+    let promise = deferredPromise(), promises = this.#promises.get(command);
+    if (!promises) this.#promises.set(command, promises = []);
+    promises.push(promise);
+    this.postMessage({
+      event: "command",
+      func: command,
+      args: arg ? [arg] : void 0
+    });
+    return promise.promise;
+  }
+  onLoad() {
+    window.setTimeout(() => this.postMessage({ event: "listening" }), 100);
+  }
+  #onReady(trigger) {
+    this.#ctx.notify("loaded-metadata");
+    this.#ctx.notify("loaded-data");
+    this.#ctx.delegate.ready(void 0, trigger);
+  }
+  #onPause(trigger) {
+    this.#getPromise("pauseVideo")?.resolve();
+    this.#ctx.notify("pause", void 0, trigger);
+  }
+  #onTimeUpdate(time, trigger) {
+    const { duration, realCurrentTime } = this.#ctx.$state, hasEnded = this.#state === YouTubePlayerState.Ended, boundTime = hasEnded ? duration() : time;
+    this.#ctx.notify("time-change", boundTime, trigger);
+    if (!hasEnded && Math.abs(boundTime - realCurrentTime()) > 1) {
+      this.#ctx.notify("seeking", boundTime, trigger);
+    }
+  }
+  #onProgress(buffered, seekable, trigger) {
+    const detail = {
+      buffered: new TimeRange(0, buffered),
+      seekable
+    };
+    this.#ctx.notify("progress", detail, trigger);
+    const { seeking, realCurrentTime } = this.#ctx.$state;
+    if (seeking() && buffered > realCurrentTime()) {
+      this.#onSeeked(trigger);
+    }
+  }
+  #onSeeked(trigger) {
+    const { paused, realCurrentTime } = this.#ctx.$state;
+    window.clearTimeout(this.#seekingTimer);
+    this.#seekingTimer = window.setTimeout(
+      () => {
+        this.#ctx.notify("seeked", realCurrentTime(), trigger);
+        this.#seekingTimer = -1;
+      },
+      paused() ? 100 : 0
+    );
+  }
+  #onEnded(trigger) {
+    const { seeking } = this.#ctx.$state;
+    if (seeking()) this.#onSeeked(trigger);
+    this.#ctx.notify("pause", void 0, trigger);
+    this.#ctx.notify("end", void 0, trigger);
+  }
+  #onStateChange(state, trigger) {
+    const { paused, seeking } = this.#ctx.$state, isPlaying = state === YouTubePlayerState.Playing, isBuffering = state === YouTubePlayerState.Buffering, isPendingPlay = this.#isPending("playVideo"), isPlay = paused() && (isBuffering || isPlaying);
+    if (isBuffering) this.#ctx.notify("waiting", void 0, trigger);
+    if (seeking() && isPlaying) {
+      this.#onSeeked(trigger);
+    }
+    if (this.#invalidPlay && isPlaying) {
+      this.pause();
+      this.#invalidPlay = false;
+      this.setMuted(this.#ctx.$state.muted());
+      return;
+    }
+    if (!isPendingPlay && isPlay) {
+      this.#invalidPlay = true;
+      this.setMuted(true);
+      return;
+    }
+    if (isPlay) {
+      this.#getPromise("playVideo")?.resolve();
+      this.#ctx.notify("play", void 0, trigger);
+    }
+    switch (state) {
+      case YouTubePlayerState.Cued:
+        this.#onReady(trigger);
+        break;
+      case YouTubePlayerState.Playing:
+        this.#ctx.notify("playing", void 0, trigger);
+        break;
+      case YouTubePlayerState.Paused:
+        this.#onPause(trigger);
+        break;
+      case YouTubePlayerState.Ended:
+        this.#onEnded(trigger);
+        break;
+    }
+    this.#state = state;
+  }
+  onMessage({ info }, event) {
+    if (!info) return;
+    const { title, intrinsicDuration, playbackRate } = this.#ctx.$state;
+    if (isObject(info.videoData) && info.videoData.title !== title()) {
+      this.#ctx.notify("title-change", info.videoData.title, event);
+    }
+    if (isNumber(info.duration) && info.duration !== intrinsicDuration()) {
+      if (isNumber(info.videoLoadedFraction)) {
+        const buffered = info.progressState?.loaded ?? info.videoLoadedFraction * info.duration, seekable = new TimeRange(0, info.duration);
+        this.#onProgress(buffered, seekable, event);
+      }
+      this.#ctx.notify("duration-change", info.duration, event);
+    }
+    if (isNumber(info.playbackRate) && info.playbackRate !== playbackRate()) {
+      this.#ctx.notify("rate-change", info.playbackRate, event);
+    }
+    if (info.progressState) {
+      const { current, seekableStart, seekableEnd, loaded, duration } = info.progressState;
+      this.#onTimeUpdate(current, event);
+      this.#onProgress(loaded, new TimeRange(seekableStart, seekableEnd), event);
+      if (duration !== intrinsicDuration()) {
+        this.#ctx.notify("duration-change", duration, event);
+      }
+    }
+    if (isNumber(info.volume) && isBoolean(info.muted) && !this.#invalidPlay) {
+      const detail = {
+        muted: info.muted,
+        volume: info.volume / 100
+      };
+      this.#ctx.notify("volume-change", detail, event);
+    }
+    if (isNumber(info.playerState) && info.playerState !== this.#state) {
+      this.#onStateChange(info.playerState, event);
+    }
+  }
+  #reset() {
+    this.#state = -1;
+    this.#seekingTimer = -1;
+    this.#invalidPlay = false;
+  }
+  #getPromise(command) {
+    return this.#promises.get(command)?.shift();
+  }
+  #isPending(command) {
+    return Boolean(this.#promises.get(command)?.length);
+  }
+}
+
+export { YouTubeProvider };
diff --git a/dev/chunks/vidstack-eBeE3P2U.js b/dev/chunks/vidstack-eBeE3P2U.js
new file mode 100644
index 0000000000000000000000000000000000000000..922862ea99dda8162ad026ea8ced60314cdb71cb
--- /dev/null
+++ b/dev/chunks/vidstack-eBeE3P2U.js
@@ -0,0 +1,189 @@
+"use client"
+
+import * as React from 'react';
+import { RadioGroupController, useMediaContext, menuContext, MediaRemoteControl, MediaPlayerInstance, sortVideoQualities } from './vidstack-DlEFWAGb.js';
+import { useMediaContext as useMediaContext$1 } from './vidstack-Bn2Qk0ao.js';
+import { prop, method, Component, hasProvidedContext, useContext, effect, useSignal, isString } from './vidstack-CH225ns1.js';
+
+const DEFAULT_PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
+class SpeedRadioGroup extends Component {
+  static props = {
+    normalLabel: "Normal",
+    rates: DEFAULT_PLAYBACK_RATES
+  };
+  #media;
+  #menu;
+  #controller;
+  get value() {
+    return this.#controller.value;
+  }
+  get disabled() {
+    const { rates } = this.$props, { canSetPlaybackRate } = this.#media.$state;
+    return !canSetPlaybackRate() || rates().length === 0;
+  }
+  constructor() {
+    super();
+    this.#controller = new RadioGroupController();
+    this.#controller.onValueChange = this.#onValueChange.bind(this);
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    if (hasProvidedContext(menuContext)) {
+      this.#menu = useContext(menuContext);
+    }
+  }
+  onConnect(el) {
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchHintText.bind(this));
+    effect(this.#watchControllerDisabled.bind(this));
+  }
+  getOptions() {
+    const { rates, normalLabel } = this.$props;
+    return rates().map((rate) => ({
+      label: rate === 1 ? normalLabel : rate + "\xD7",
+      value: rate.toString()
+    }));
+  }
+  #watchValue() {
+    this.#controller.value = this.#getValue();
+  }
+  #watchHintText() {
+    const { normalLabel } = this.$props, { playbackRate } = this.#media.$state, rate = playbackRate();
+    this.#menu?.hint.set(rate === 1 ? normalLabel() : rate + "\xD7");
+  }
+  #watchControllerDisabled() {
+    this.#menu?.disable(this.disabled);
+  }
+  #getValue() {
+    const { playbackRate } = this.#media.$state;
+    return playbackRate().toString();
+  }
+  #onValueChange(value, trigger) {
+    if (this.disabled) return;
+    const rate = +value;
+    this.#media.remote.changePlaybackRate(rate, trigger);
+    this.dispatch("change", { detail: rate, trigger });
+  }
+}
+const speedradiogroup__proto = SpeedRadioGroup.prototype;
+prop(speedradiogroup__proto, "value");
+prop(speedradiogroup__proto, "disabled");
+method(speedradiogroup__proto, "getOptions");
+
+function useMediaRemote(target) {
+  const media = useMediaContext$1(), remote = React.useRef();
+  if (!remote.current) {
+    remote.current = new MediaRemoteControl();
+  }
+  React.useEffect(() => {
+    const ref = target && "current" in target ? target.current : target, isPlayerRef = ref instanceof MediaPlayerInstance, player = isPlayerRef ? ref : media?.player;
+    remote.current.setPlayer(player ?? null);
+    remote.current.setTarget(ref ?? null);
+  }, [media, target && "current" in target ? target.current : target]);
+  return remote.current;
+}
+
+function useVideoQualityOptions({
+  auto = true,
+  sort = "descending"
+} = {}) {
+  const media = useMediaContext$1(), { qualities, quality, autoQuality, canSetQuality } = media.$state, $qualities = useSignal(qualities);
+  useSignal(quality);
+  useSignal(autoQuality);
+  useSignal(canSetQuality);
+  return React.useMemo(() => {
+    const sortedQualities = sortVideoQualities($qualities, sort === "descending"), options = sortedQualities.map((q) => {
+      return {
+        quality: q,
+        label: q.height + "p",
+        value: getQualityValue(q),
+        bitrateText: q.bitrate && q.bitrate > 0 ? `${(q.bitrate / 1e6).toFixed(2)} Mbps` : null,
+        get selected() {
+          return q === quality();
+        },
+        get autoSelected() {
+          return autoQuality();
+        },
+        select(trigger) {
+          const index = qualities().indexOf(q);
+          if (index >= 0) media.remote.changeQuality(index, trigger);
+        }
+      };
+    });
+    if (auto) {
+      options.unshift({
+        quality: null,
+        label: isString(auto) ? auto : "Auto",
+        value: "auto",
+        bitrateText: null,
+        get selected() {
+          return autoQuality();
+        },
+        get autoSelected() {
+          return autoQuality();
+        },
+        select(trigger) {
+          media.remote.requestAutoQuality(trigger);
+        }
+      });
+    }
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !canSetQuality() || $qualities.length <= 1;
+      }
+    });
+    Object.defineProperty(options, "selectedQuality", {
+      get() {
+        return quality();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const $quality = quality();
+        return !autoQuality() && $quality ? getQualityValue($quality) : "auto";
+      }
+    });
+    return options;
+  }, [$qualities, sort]);
+}
+function getQualityValue(quality) {
+  return quality.height + "_" + quality.bitrate;
+}
+
+function usePlaybackRateOptions({
+  rates = DEFAULT_PLAYBACK_RATES,
+  normalLabel = "Normal"
+} = {}) {
+  const media = useMediaContext$1(), { playbackRate, canSetPlaybackRate } = media.$state;
+  useSignal(playbackRate);
+  useSignal(canSetPlaybackRate);
+  return React.useMemo(() => {
+    const options = rates.map((opt) => {
+      const label = typeof opt === "number" ? opt === 1 && normalLabel ? normalLabel : opt + "x" : opt.label, rate = typeof opt === "number" ? opt : opt.rate;
+      return {
+        label,
+        value: rate.toString(),
+        rate,
+        get selected() {
+          return playbackRate() === rate;
+        },
+        select(trigger) {
+          media.remote.changePlaybackRate(rate, trigger);
+        }
+      };
+    });
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !canSetPlaybackRate() || !options.length;
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        return playbackRate().toString();
+      }
+    });
+    return options;
+  }, [rates]);
+}
+
+export { DEFAULT_PLAYBACK_RATES, useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions };
diff --git a/dev/chunks/vidstack-fXdyeRpg.js b/dev/chunks/vidstack-fXdyeRpg.js
new file mode 100644
index 0000000000000000000000000000000000000000..720a9b12567a0fde716490ab3044718ed746f54c
--- /dev/null
+++ b/dev/chunks/vidstack-fXdyeRpg.js
@@ -0,0 +1,61 @@
+"use client"
+
+import { appendParamsToURL, IS_SERVER } from './vidstack-MAWt6ODZ.js';
+import { signal, listenEvent, effect, peek, isString } from './vidstack-CH225ns1.js';
+
+class EmbedProvider {
+  #iframe;
+  src = signal("");
+  /**
+   * Defines which referrer is sent when fetching the resource.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy}
+   */
+  referrerPolicy = null;
+  get iframe() {
+    return this.#iframe;
+  }
+  constructor(iframe) {
+    this.#iframe = iframe;
+    iframe.setAttribute("frameBorder", "0");
+    iframe.setAttribute("aria-hidden", "true");
+    iframe.setAttribute(
+      "allow",
+      "autoplay; fullscreen; encrypted-media; picture-in-picture; accelerometer; gyroscope"
+    );
+    if (this.referrerPolicy !== null) {
+      iframe.setAttribute("referrerpolicy", this.referrerPolicy);
+    }
+  }
+  setup() {
+    listenEvent(window, "message", this.#onWindowMessage.bind(this));
+    listenEvent(this.#iframe, "load", this.onLoad.bind(this));
+    effect(this.#watchSrc.bind(this));
+  }
+  #watchSrc() {
+    const src = this.src();
+    if (!src.length) {
+      this.#iframe.setAttribute("src", "");
+      return;
+    }
+    const params = peek(() => this.buildParams());
+    this.#iframe.setAttribute("src", appendParamsToURL(src, params));
+  }
+  postMessage(message, target) {
+    if (IS_SERVER) return;
+    this.#iframe.contentWindow?.postMessage(JSON.stringify(message), target ?? "*");
+  }
+  #onWindowMessage(event) {
+    const origin = this.getOrigin(), isOriginMatch = (event.source === null || event.source === this.#iframe?.contentWindow) && (!isString(origin) || origin === event.origin);
+    if (!isOriginMatch) return;
+    try {
+      const message = JSON.parse(event.data);
+      if (message) this.onMessage(message, event);
+      return;
+    } catch (e) {
+    }
+    if (event.data) this.onMessage(event.data, event);
+  }
+}
+
+export { EmbedProvider };
diff --git a/dev/chunks/vidstack-ffBqvQK6.js b/dev/chunks/vidstack-ffBqvQK6.js
new file mode 100644
index 0000000000000000000000000000000000000000..2ea7628811a304aa6659b71f0176f5fe445c0652
--- /dev/null
+++ b/dev/chunks/vidstack-ffBqvQK6.js
@@ -0,0 +1,34 @@
+"use client"
+
+import { scoped } from './vidstack-CH225ns1.js';
+import { HTMLMediaProvider, HTMLAirPlayAdapter } from './vidstack-DlEFWAGb.js';
+import 'react';
+import '@floating-ui/dom';
+
+class AudioProvider extends HTMLMediaProvider {
+  $$PROVIDER_TYPE = "AUDIO";
+  get type() {
+    return "audio";
+  }
+  airPlay;
+  constructor(audio, ctx) {
+    super(audio, ctx);
+    scoped(() => {
+      this.airPlay = new HTMLAirPlayAdapter(this.media, ctx);
+    }, this.scope);
+  }
+  setup() {
+    super.setup();
+    if (this.type === "audio") this.ctx.notify("provider-setup", this);
+  }
+  /**
+   * The native HTML `<audio>` element.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement}
+   */
+  get audio() {
+    return this.media;
+  }
+}
+
+export { AudioProvider };
diff --git a/dev/chunks/vidstack-saV39v1d.js b/dev/chunks/vidstack-saV39v1d.js
new file mode 100644
index 0000000000000000000000000000000000000000..e419d90d9f8039498e2290cbe4ff2f0ab4710cfc
--- /dev/null
+++ b/dev/chunks/vidstack-saV39v1d.js
@@ -0,0 +1,61 @@
+"use client"
+
+import { appendParamsToURL, IS_SERVER } from './vidstack-BdoOxmTD.js';
+import { signal, listenEvent, effect, peek, isString } from './vidstack-CH225ns1.js';
+
+class EmbedProvider {
+  #iframe;
+  src = signal("");
+  /**
+   * Defines which referrer is sent when fetching the resource.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy}
+   */
+  referrerPolicy = null;
+  get iframe() {
+    return this.#iframe;
+  }
+  constructor(iframe) {
+    this.#iframe = iframe;
+    iframe.setAttribute("frameBorder", "0");
+    iframe.setAttribute("aria-hidden", "true");
+    iframe.setAttribute(
+      "allow",
+      "autoplay; fullscreen; encrypted-media; picture-in-picture; accelerometer; gyroscope"
+    );
+    if (this.referrerPolicy !== null) {
+      iframe.setAttribute("referrerpolicy", this.referrerPolicy);
+    }
+  }
+  setup() {
+    listenEvent(window, "message", this.#onWindowMessage.bind(this));
+    listenEvent(this.#iframe, "load", this.onLoad.bind(this));
+    effect(this.#watchSrc.bind(this));
+  }
+  #watchSrc() {
+    const src = this.src();
+    if (!src.length) {
+      this.#iframe.setAttribute("src", "");
+      return;
+    }
+    const params = peek(() => this.buildParams());
+    this.#iframe.setAttribute("src", appendParamsToURL(src, params));
+  }
+  postMessage(message, target) {
+    if (IS_SERVER) return;
+    this.#iframe.contentWindow?.postMessage(JSON.stringify(message), target ?? "*");
+  }
+  #onWindowMessage(event) {
+    const origin = this.getOrigin(), isOriginMatch = (event.source === null || event.source === this.#iframe?.contentWindow) && (!isString(origin) || origin === event.origin);
+    if (!isOriginMatch) return;
+    try {
+      const message = JSON.parse(event.data);
+      if (message) this.onMessage(message, event);
+      return;
+    } catch (e) {
+    }
+    if (event.data) this.onMessage(event.data, event);
+  }
+}
+
+export { EmbedProvider };
diff --git a/dev/player/vidstack-default-components.js b/dev/player/vidstack-default-components.js
index c833601774ce1ed470e415dfefb00dc26ddb3f34..f28c4c951b8f73957e8e2be2be60b5e71a29d627 100644
--- a/dev/player/vidstack-default-components.js
+++ b/dev/player/vidstack-default-components.js
@@ -1,14 +1,14 @@
 "use client"
 
-export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions } from '../chunks/vidstack-Bl9rvtRZ.js';
+export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions } from '../chunks/vidstack-CGivFV1p.js';
 export { defaultLayoutIcons } from './vidstack-default-icons.js';
 import 'react';
 import '../chunks/vidstack-CH225ns1.js';
-import '../chunks/vidstack-Dpb_iHia.js';
-import '../chunks/vidstack-tCTk_Mpr.js';
+import '../chunks/vidstack-BwNhcxfT.js';
+import '../chunks/vidstack-BdoOxmTD.js';
 import '@floating-ui/dom';
-import '../chunks/vidstack-DM21n8Pk.js';
+import '../chunks/vidstack-VrioNQ8t.js';
 import 'react-dom';
-import '../chunks/vidstack-CXTsWYwn.js';
+import '../chunks/vidstack-Di-ZivLP.js';
 import '../chunks/vidstack-CaBvbWDV.js';
 import '../chunks/vidstack-CBF7iUqu.js';
diff --git a/dev/player/vidstack-default-layout.js b/dev/player/vidstack-default-layout.js
index 89b63e7d717acef4159f093f775b16f3c0b4155c..f6b4589f311e2ccb5367bb867493d341801ce422 100644
--- a/dev/player/vidstack-default-layout.js
+++ b/dev/player/vidstack-default-layout.js
@@ -1,14 +1,14 @@
 "use client"
 
-export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultLayoutContext, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions, i18n, useDefaultLayoutContext, useDefaultLayoutWord } from '../chunks/vidstack-Bl9rvtRZ.js';
+export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultLayoutContext, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions, i18n, useDefaultLayoutContext, useDefaultLayoutWord } from '../chunks/vidstack-CGivFV1p.js';
 export { defaultLayoutIcons } from './vidstack-default-icons.js';
 import 'react';
 import '../chunks/vidstack-CH225ns1.js';
-import '../chunks/vidstack-Dpb_iHia.js';
-import '../chunks/vidstack-tCTk_Mpr.js';
+import '../chunks/vidstack-BwNhcxfT.js';
+import '../chunks/vidstack-BdoOxmTD.js';
 import '@floating-ui/dom';
-import '../chunks/vidstack-DM21n8Pk.js';
+import '../chunks/vidstack-VrioNQ8t.js';
 import 'react-dom';
-import '../chunks/vidstack-CXTsWYwn.js';
+import '../chunks/vidstack-Di-ZivLP.js';
 import '../chunks/vidstack-CaBvbWDV.js';
 import '../chunks/vidstack-CBF7iUqu.js';
diff --git a/dev/player/vidstack-plyr-layout.js b/dev/player/vidstack-plyr-layout.js
index 825d6eef9618b1e9ad637c9b58b9f8c411696e24..8a83ecd67531028cd7292859066b30829c20a2b1 100644
--- a/dev/player/vidstack-plyr-layout.js
+++ b/dev/player/vidstack-plyr-layout.js
@@ -1,11 +1,11 @@
 "use client"
 
-import { useMediaState, Primitive, IS_SERVER, isRemotionSrc, getDownloadFile } from '../chunks/vidstack-tCTk_Mpr.js';
+import { useMediaState, Primitive, IS_SERVER, isRemotionSrc, getDownloadFile } from '../chunks/vidstack-BdoOxmTD.js';
 import * as React from 'react';
 import { effect, createDisposalBin, uppercaseFirstChar, isUndefined, signal, composeRefs, useSignal, isNumber, listenEvent, isString, isKeyboardEvent, isKeyboardClick } from '../chunks/vidstack-CH225ns1.js';
-import { useMediaContext, PlayButton, Root, Img, Gesture, AirPlayButton, CaptionButton, FullscreenButton, PIPButton, SeekButton, Root$1, Value, Preview, Thumbnail, LiveButton, Time, appendParamsToURL, Root$2, Button, Items, useAudioOptions, Root$3, Item, useCaptionOptions, MuteButton, Root$4 } from '../chunks/vidstack-DM21n8Pk.js';
-import { useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions } from '../chunks/vidstack-DFnQvu5z.js';
-import { useLayoutName, useClassName } from '../chunks/vidstack-CXTsWYwn.js';
+import { useMediaContext, PlayButton, Root, Img, Gesture, AirPlayButton, CaptionButton, FullscreenButton, PIPButton, SeekButton, Root$1, Value, Preview, Thumbnail, LiveButton, Time, appendParamsToURL, Root$2, Button, Items, useAudioOptions, Root$3, Item, useCaptionOptions, MuteButton, Root$4 } from '../chunks/vidstack-VrioNQ8t.js';
+import { useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions } from '../chunks/vidstack-U5d70oGh.js';
+import { useLayoutName, useClassName } from '../chunks/vidstack-Di-ZivLP.js';
 import { RemotionThumbnail, RemotionPoster, RemotionSliderThumbnail } from '../chunks/vidstack-CaBvbWDV.js';
 export { plyrLayoutIcons } from './vidstack-plyr-icons.js';
 import '@floating-ui/dom';
diff --git a/dev/player/vidstack-remotion.js b/dev/player/vidstack-remotion.js
index c4bf5a8ec99253a997ad1a758d129d240fca3a52..6aa1ac42c2a398dfcbaf3d13face14de6ca4d1c3 100644
--- a/dev/player/vidstack-remotion.js
+++ b/dev/player/vidstack-remotion.js
@@ -3,8 +3,8 @@
 import * as React from 'react';
 import { createDisposalBin, animationFrameThrottle, noop } from '../chunks/vidstack-CH225ns1.js';
 import { Internals, random } from 'remotion';
-import { IS_SERVER, useMediaState, isRemotionSrc, Primitive, useSliderState } from '../chunks/vidstack-tCTk_Mpr.js';
-export { isRemotionProvider } from '../chunks/vidstack-tCTk_Mpr.js';
+import { IS_SERVER, useMediaState, isRemotionSrc, Primitive, useSliderState } from '../chunks/vidstack-BdoOxmTD.js';
+export { isRemotionProvider } from '../chunks/vidstack-BdoOxmTD.js';
 import { RemotionThumbnail as RemotionThumbnail$1, RemotionSliderThumbnail as RemotionSliderThumbnail$1, RemotionPoster as RemotionPoster$1 } from '../chunks/vidstack-CaBvbWDV.js';
 import '@floating-ui/dom';
 
@@ -338,7 +338,7 @@ class RemotionProviderLoader {
     return "video";
   }
   async load(ctx) {
-    return new (await import('../chunks/vidstack-hrlhZeuZ.js')).RemotionProvider(this.target, ctx);
+    return new (await import('../chunks/vidstack-BEf59GM5.js')).RemotionProvider(this.target, ctx);
   }
 }
 
diff --git a/dev/vidstack.js b/dev/vidstack.js
index d5accbf7cb86d03aa42077d94508b709e673ea80..1c598d99181bdf8c5201c0c81877cd2ff88a0157 100644
--- a/dev/vidstack.js
+++ b/dev/vidstack.js
@@ -1,16 +1,16 @@
 "use client"
 
-import { TextTrackSymbol, RadioGroupController, useMediaContext, menuContext, Primitive, MediaPlayerInstance, isRemotionProvider, MediaProviderInstance, mediaState, TextTrack, ToggleButtonInstance, PosterInstance, useMediaState, ThumbnailsLoader, updateSliderPreviewPlacement } from './chunks/vidstack-tCTk_Mpr.js';
-export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, List, LiveButtonInstance, LocalMediaStorage, Logger, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, QualitySliderInstance, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrackList, ThumbnailInstance, TimeInstance, TimeRange, TimeSliderInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, mediaContext, normalizeTimeIntervals, parseJSONCaptionsFile, sliderState, softResetMediaState, sortVideoQualities, updateTimeIntervals, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange } from './chunks/vidstack-tCTk_Mpr.js';
+import { TextTrackSymbol, RadioGroupController, useMediaContext, menuContext, Primitive, MediaPlayerInstance, isRemotionProvider, MediaProviderInstance, mediaState, TextTrack, ToggleButtonInstance, PosterInstance, useMediaState, ThumbnailsLoader, updateSliderPreviewPlacement } from './chunks/vidstack-BdoOxmTD.js';
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, List, LiveButtonInstance, LocalMediaStorage, Logger, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, QualitySliderInstance, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrackList, ThumbnailInstance, TimeInstance, TimeRange, TimeSliderInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, mediaContext, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, sliderState, softResetMediaState, sortVideoQualities, updateTimeIntervals, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange } from './chunks/vidstack-BdoOxmTD.js';
 import * as React from 'react';
 import { isString, EventsController, DOMEvent, prop, method, Component, hasProvidedContext, useContext, effect, createReactComponent, useStateContext, useSignal, composeRefs, useSignalRecord, useReactScope, signal } from './chunks/vidstack-CH225ns1.js';
 export { appendTriggerEvent, findTriggerEvent, hasTriggerEvent, isKeyboardClick, isKeyboardEvent, isPointerEvent, walkTriggerEventChain } from './chunks/vidstack-CH225ns1.js';
-import { createSignal, useScoped } from './chunks/vidstack-Dpb_iHia.js';
-export { audioGainSlider as AudioGainSlider, Captions, ChapterTitle, controls as Controls, GoogleCastButton, MediaAnnouncer, qualitySlider as QualitySlider, speedSlider as SpeedSlider, spinner as Spinner, Title, tooltip as Tooltip, useActiveTextCues, useActiveTextTrack, useChapterOptions, useChapterTitle, useTextCues } from './chunks/vidstack-Dpb_iHia.js';
-import { useMediaContext as useMediaContext$1 } from './chunks/vidstack-DM21n8Pk.js';
-export { AirPlayButton, CaptionButton, FullscreenButton, Gesture, LiveButton, menu as Menu, MuteButton, PIPButton, PlayButton, radioGroup as RadioGroup, SeekButton, slider as Slider, thumbnail as Thumbnail, Time, timeSlider as TimeSlider, volumeSlider as VolumeSlider, useAudioOptions, useCaptionOptions, useMediaPlayer } from './chunks/vidstack-DM21n8Pk.js';
+import { createSignal, useScoped } from './chunks/vidstack-BwNhcxfT.js';
+export { audioGainSlider as AudioGainSlider, Captions, ChapterTitle, controls as Controls, GoogleCastButton, MediaAnnouncer, qualitySlider as QualitySlider, speedSlider as SpeedSlider, spinner as Spinner, Title, tooltip as Tooltip, useActiveTextCues, useActiveTextTrack, useChapterOptions, useChapterTitle, useTextCues } from './chunks/vidstack-BwNhcxfT.js';
+import { useMediaContext as useMediaContext$1 } from './chunks/vidstack-VrioNQ8t.js';
+export { AirPlayButton, CaptionButton, FullscreenButton, Gesture, LiveButton, menu as Menu, MuteButton, PIPButton, PlayButton, radioGroup as RadioGroup, SeekButton, slider as Slider, thumbnail as Thumbnail, Time, timeSlider as TimeSlider, volumeSlider as VolumeSlider, useAudioOptions, useCaptionOptions, useMediaPlayer } from './chunks/vidstack-VrioNQ8t.js';
 import { Icon } from './chunks/vidstack-CBF7iUqu.js';
-export { DEFAULT_PLAYBACK_RATES, useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions } from './chunks/vidstack-DFnQvu5z.js';
+export { DEFAULT_PLAYBACK_RATES, useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions } from './chunks/vidstack-U5d70oGh.js';
 import '@floating-ui/dom';
 import 'react-dom';
 
diff --git a/index.d.ts b/index.d.ts
index 396fc957304aad8876da7526fa02720792a14f21..68a37c0d527b9b6aa71b8bce4efee97113b683db 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -1,7 +1,7 @@
 /// <reference path="./dom.d.ts" />
 /// <reference path="./google-cast.d.ts" />
 
-export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonEvents, AnyMediaProvider, AudioGainSliderEvents, AudioGainSliderState, AudioMimeType, AudioProvider, AudioProviderLoader, AudioSrc, AudioSrcMeta, AudioTrack, AudioTrackAddEvent, AudioTrackChangeEvent, AudioTrackList, AudioTrackListEvent, AudioTrackListEvents, AudioTrackRemoveEvent, CaptionButtonEvents, ChangeAudioTrackEventDetail, ControlsChangeEvent, ControlsEvents, DASHAdaptationSetRemovedNoCapabilitiesEvent, DASHAllTextTracksAddedEvent, DASHAstInFutureEvent, DASHBaseUrlsUpdatedEvent, DASHBufferLevelUpdatedEvent, DASHBufferLoadedEvent, DASHBufferStalledEvent, DASHBufferStateChangedEvent, DASHCanPlayEvent, DASHCanPlayThroughEvent, DASHCaptionContainerResizeEvent, DASHCaptionRenderedEvent, DASHConformanceViolationEvent, DASHConstructor, DASHConstructorLoader, DASHContentSteeringRequestCompletedEvent, DASHCueEnterEvent, DASHCueExitEvent, DASHDvbFontDownloadAddedEvent, DASHDvbFontDownloadCompleteEvent, DASHDvbFontDownloadFailedEvent, DASHDynamicToStaticEvent, DASHErrorEvent, DASHEventModeOnReceiveEvent, DASHEventModeOnStartEvent, DASHFragmentLoadingAbandonedEvent, DASHFragmentLoadingCompletedEvent, DASHFragmentLoadingProgressEvent, DASHFragmentLoadingStartedEvent, DASHInbandPrftEvent, DASHInstanceCallback, DASHInstanceEvent, DASHLibLoadErrorEvent, DASHLibLoadStartEvent, DASHLibLoadedEvent, DASHLibrary, DASHLogEvent, DASHManagedMediaSourceEndStreamingEvent, DASHManagedMediaSourceStartStreamingEvent, DASHManifestLoadedEvent, DASHManifestLoadingFinishedEvent, DASHManifestLoadingStartedEvent, DASHManifestValidityChangedEvent, DASHMediaEvent, DASHMetricAddedEvent, DASHMetricChangedEvent, DASHMetricUpdatedEvent, DASHMetricsChangedEvent, DASHMimeType, DASHNamespace, DASHNamespaceLoader, DASHPeriodSwitchCompletedEvent, DASHPeriodSwitchStartedEvent, DASHPlaybackEndedEvent, DASHPlaybackErrorEvent, DASHPlaybackLoadedDataEvent, DASHPlaybackMetaDataLoadedEvent, DASHPlaybackNotAllowedEvent, DASHPlaybackPausedEvent, DASHPlaybackPlayingEvent, DASHPlaybackProgressEvent, DASHPlaybackRateChangedEvent, DASHPlaybackSeekedEvent, DASHPlaybackSeekingEvent, DASHPlaybackStalledEvent, DASHPlaybackStartedEvent, DASHPlaybackTimeUpdatedEvent, DASHPlaybackVolumeChangedEvent, DASHPlaybackWaitingEvent, DASHProvider, DASHProviderEvents, DASHProviderLoader, DASHQualityChangeRenderedEvent, DASHQualityChangeRequestedEvent, DASHRepresentationSwitchEvent, DASHSrc, DASHStreamActivatedEvent, DASHStreamDeactivatedEvent, DASHStreamInitializedEvent, DASHStreamInitializingEvent, DASHStreamTeardownCompleteEvent, DASHStreamUpdatedEvent, DASHTextTrackAddedEvent, DASHThroughputMeasurementStoredEvent, DASHTrackChangeRenderedEvent, DASHTtmlParsedEvent, DASHTtmlToParseEvent, DASHUnsupportedEvent, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, DEFAULT_AUDIO_GAINS, DEFAULT_PLAYBACK_RATES, FileDownloadInfo, FindMediaPlayerEvent, FindMediaPlayerEventDetail, FullscreenAdapter, FullscreenButtonEvents, FullscreenChangeEvent, FullscreenController, FullscreenErrorEvent, FullscreenEvents, GestureAction, GestureEvent, GestureEventType, GestureEvents, GestureTriggerEvent, GestureWillTriggerEvent, GoogleCastButtonEvents, GoogleCastEvent, GoogleCastEvents, GoogleCastLoadStartEvent, GoogleCastLoadedEvent, GoogleCastLoader, GoogleCastPromptError, GoogleCastPromptErrorCode, GoogleCastPromptErrorEvent, GoogleCastPromptEvent, GoogleCastProvider, HLSAudioTrackLoadedEvent, HLSAudioTrackLoadingEvent, HLSAudioTrackSwitchedEvent, HLSAudioTrackSwitchingEvent, HLSAudioTracksUpdatedEvent, HLSBackBufferReachedEvent, HLSBufferAppendedEvent, HLSBufferAppendingEvent, HLSBufferCodecsEvent, HLSBufferCreatedEvent, HLSBufferEosEvent, HLSBufferFlushedEvent, HLSBufferFlushingEvent, HLSBufferResetEvent, HLSConstructor, HLSConstructorLoader, HLSCuesParsedEvent, HLSDestroyingEvent, HLSErrorEvent, HLSFpsDropEvent, HLSFpsDropLevelCappingEvent, HLSFragBufferedDataEvent, HLSFragChangedEvent, HLSFragDecryptedEvent, HLSFragLoadEmergencyAbortedEvent, HLSFragLoadedEvent, HLSFragLoadingEvent, HLSFragParsedEvent, HLSFragParsingInitSegmentEvent, HLSFragParsingMetadataEvent, HLSFragParsingUserdataEvent, HLSInitPtsFoundEvent, HLSInstanceCallback, HLSInstanceEvent, HLSKeyLoadedEvent, HLSKeyLoadingEvent, HLSLevelLoadedEvent, HLSLevelLoadingEvent, HLSLevelPtsUpdatedEvent, HLSLevelSwitchedEvent, HLSLevelSwitchingEvent, HLSLevelUpdatedEvent, HLSLevelsUpdatedEvent, HLSLibLoadErrorEvent, HLSLibLoadStartEvent, HLSLibLoadedEvent, HLSLibrary, HLSManifestLoadedEvent, HLSManifestLoadingEvent, HLSManifestParsedEvent, HLSMediaAttachedEvent, HLSMediaAttachingEvent, HLSMediaDetachedEvent, HLSMediaDetachingEvent, HLSMediaEvent, HLSMimeType, HLSNonNativeTextTracksFoundEvent, HLSProvider, HLSProviderEvents, HLSProviderLoader, HLSSrc, HLSSubtitleFragProcessedEvent, HLSSubtitleTrackLoadedEvent, HLSSubtitleTrackLoadingEvent, HLSSubtitleTrackSwitchEvent, HLSSubtitleTracksClearedEvent, HLSSubtitleTracksUpdatedEvent, HLSUnsupportedEvent, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLMediaSrc, LibASSConfig, LibASSConstructor, LibASSErrorEvent, LibASSInstance, LibASSInstanceEvents, LibASSModuleLoader, LibASSReadyEvent, LibASSTextRenderer, List, ListAddEvent, ListEvents, ListItem, ListReadonlyChangeEvent, ListRemoveEvent, LocalMediaStorage, LogEvent, LogEventDetail, Logger, LoggerEvents, MEDIA_KEY_SHORTCUTS, MediaAbortEvent, MediaAirPlayRequestEvent, MediaAnnouncerEvents, MediaAnnouncerState, MediaAnnouncerTranslations, MediaAnnouncerWord, MediaAudioGainChangeEvent, MediaAudioGainChangeRequestEvent, MediaAudioTrackChangeEvent, MediaAudioTrackChangeRequestEvent, MediaAudioTracksChangeEvent, MediaAutoPlayChangeEvent, MediaAutoPlayEvent, MediaAutoPlayEventDetail, MediaAutoPlayFailEvent, MediaAutoPlayFailEventDetail, MediaCanLoadEvent, MediaCanLoadPosterEvent, MediaCanPlayDetail, MediaCanPlayEvent, MediaCanPlayThroughEvent, MediaClipEndChangeRequestEvent, MediaClipStartChangeRequestEvent, MediaContext, MediaControls, MediaControlsChangeEvent, MediaCrossOrigin, MediaDestroyEvent, MediaDurationChangeEvent, MediaDurationChangeRequestEvent, MediaEmptiedEvent, MediaEndEvent, MediaEndedEvent, MediaEnterFullscreenRequestEvent, MediaEnterPIPRequestEvent, MediaErrorCode, MediaErrorDetail, MediaErrorEvent, MediaEvent, MediaEvents, MediaExitFullscreenRequestEvent, MediaExitPIPRequestEvent, MediaFullscreenAdapter, MediaFullscreenChangeEvent, MediaFullscreenErrorEvent, MediaFullscreenRequestTarget, MediaGoogleCastRequestEvent, MediaHidePosterRequestEvent, MediaKeyShortcut, MediaKeyShortcuts, MediaKeyTarget, MediaKeysCallback, MediaLiveChangeEvent, MediaLiveEdgeChangeEvent, MediaLiveEdgeRequestEvent, MediaLoadStartEvent, MediaLoadedDataEvent, MediaLoadedMetadataEvent, MediaLoadingStrategy, MediaLoopChangeEvent, MediaLoopRequestEvent, MediaMuteRequestEvent, MediaOrientationChangeEvent, MediaOrientationLockRequestEvent, MediaOrientationUnlockRequestEvent, MediaPIPChangeEvent, MediaPIPErrorEvent, MediaPauseControlsRequestEvent, MediaPauseEvent, MediaPauseRequestEvent, MediaPlayEvent, MediaPlayFailEvent, MediaPlayRequestEvent, MediaPlayerConnectEvent, MediaPlayerEvents, MediaPlayerQuery, MediaPlayerState, MediaPlayingEvent, MediaPlaysInlineChangeEvent, MediaPosterChangeEvent, MediaPosterLoadingStrategy, MediaPosterStartLoadingRequestEvent, MediaProgressEvent, MediaProgressEventDetail, MediaProviderAdapter, MediaProviderChangeEvent, MediaProviderLoader, MediaProviderLoaderChangeEvent, MediaProviderSetupEvent, MediaProviderState, MediaQualitiesChangeEvent, MediaQualityChangeEvent, MediaQualityChangeRequestEvent, MediaRateChangeEvent, MediaRateChangeRequestEvent, MediaRemoteControl, MediaRemotePlaybackChangeEvent, MediaRemotePlaybackChangeEventDetail, MediaReplayEvent, MediaRequestEvents, MediaResumeControlsRequestEvent, MediaSeekRequestEvent, MediaSeekedEvent, MediaSeekingEvent, MediaSeekingRequestEvent, MediaShowPosterRequestEvent, MediaSourceChangeEvent, MediaSourcesChangeEvent, MediaSrc, MediaSrcObject, MediaStalledEvent, MediaStartLoadingRequestEvent, MediaStartedEvent, MediaState, MediaStateAccessors, MediaStorage, MediaStore, MediaStreamType, MediaStreamTypeChangeEvent, MediaSuspendEvent, MediaTextTrackChangeEvent, MediaTextTrackChangeRequestEvent, MediaTextTracksChangeEvent, MediaTimeChangeEvent, MediaTimeUpdateEvent, MediaTimeUpdateEventDetail, MediaTitleChangeEvent, MediaType, MediaTypeChangeEvent, MediaUnmuteRequestEvent, MediaUserEvents, MediaUserLoopChangeRequestEvent, MediaViewType, MediaViewTypeChangeEvent, MediaVolumeChange, MediaVolumeChangeEvent, MediaVolumeChangeRequestEvent, MediaWaitingEvent, MenuPlacement, MenuPlacementAlign, MenuPlacementSide, MuteButtonEvents, PIPButtonEvents, PlayButtonEvents, PlayerStore, PosterState, QualitySliderEvents, QualitySliderState, RadioChangeEvent, RadioSelectEvent, RemotePlaybackInfo, RemotePlaybackType, ScreenOrientationChangeEvent, ScreenOrientationChangeEventDetail, ScreenOrientationController, ScreenOrientationEvents, ScreenOrientationLockType, ScreenOrientationType, SeekButtonEvents, SerializedVideoQuality, SliderCSSVars, SliderDragEndEvent, SliderDragStartEvent, SliderDragValueChangeEvent, SliderEvent, SliderEvents, SliderOrientation, SliderPointerValueChangeEvent, SliderState, SliderValueChangeEvent, SliderVideoCanPlayEvent, SliderVideoErrorEvent, SliderVideoEvents, SliderVideoState, SpeedSliderEvents, SpeedSliderState, Src, TextRenderer, TextRenderers, TextTrack, TextTrackAddCueEvent, TextTrackAddEvent, TextTrackCueChangeEvent, TextTrackErrorEvent, TextTrackEvent, TextTrackEvents, TextTrackInit, TextTrackList, TextTrackListEvent, TextTrackListEvents, TextTrackListModeChangeEvent, TextTrackLoadEvent, TextTrackLoadStartEvent, TextTrackModeChangeEvent, TextTrackReadyState, TextTrackRemoveCueEvent, TextTrackRemoveEvent, ThumbnailState, TimeInterval, TimeRange, TimeSliderEvents, TimeSliderState, TimeState, TooltipPlacement, TooltipPlacementAlign, TooltipPlacementSide, VIDEO_EXTENSIONS, VIDEO_TYPES, VTTContent, VTTCueInit, VTTRegionInit, VideoMimeType, VideoPresentationChangeEvent, VideoPresentationEvents, VideoProvider, VideoProviderLoader, VideoQuality, VideoQualityAddEvent, VideoQualityAutoChangeEvent, VideoQualityChangeEvent, VideoQualityChangeEventDetail, VideoQualityList, VideoQualityListEvent, VideoQualityListEvents, VideoQualityRemoveEvent, VideoSrc, VideoSrcMeta, VimeoProvider, VimeoProviderLoader, VimeoSrc, VolumeSliderEvents, VolumeSliderState, YouTubeProvider, YouTubeProviderLoader, YouTubeSrc, appendTriggerEvent, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, findTriggerEvent, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, hasTriggerEvent, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isKeyboardClick, isKeyboardEvent, isMediaStream, isPointerEvent, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, mediaContext, mediaState, normalizeTimeIntervals, parseJSONCaptionsFile, sliderState, softResetMediaState, sortVideoQualities, updateTimeIntervals, walkTriggerEventChain, watchActiveTextTrack, watchCueTextChange } from './types/vidstack.js';
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonEvents, AnyMediaProvider, AudioGainSliderEvents, AudioGainSliderState, AudioMimeType, AudioProvider, AudioProviderLoader, AudioSrc, AudioSrcMeta, AudioTrack, AudioTrackAddEvent, AudioTrackChangeEvent, AudioTrackList, AudioTrackListEvent, AudioTrackListEvents, AudioTrackRemoveEvent, CaptionButtonEvents, ChangeAudioTrackEventDetail, ControlsChangeEvent, ControlsEvents, DASHAdaptationSetRemovedNoCapabilitiesEvent, DASHAllTextTracksAddedEvent, DASHAstInFutureEvent, DASHBaseUrlsUpdatedEvent, DASHBufferLevelUpdatedEvent, DASHBufferLoadedEvent, DASHBufferStalledEvent, DASHBufferStateChangedEvent, DASHCanPlayEvent, DASHCanPlayThroughEvent, DASHCaptionContainerResizeEvent, DASHCaptionRenderedEvent, DASHConformanceViolationEvent, DASHConstructor, DASHConstructorLoader, DASHContentSteeringRequestCompletedEvent, DASHCueEnterEvent, DASHCueExitEvent, DASHDvbFontDownloadAddedEvent, DASHDvbFontDownloadCompleteEvent, DASHDvbFontDownloadFailedEvent, DASHDynamicToStaticEvent, DASHErrorEvent, DASHEventModeOnReceiveEvent, DASHEventModeOnStartEvent, DASHFragmentLoadingAbandonedEvent, DASHFragmentLoadingCompletedEvent, DASHFragmentLoadingProgressEvent, DASHFragmentLoadingStartedEvent, DASHInbandPrftEvent, DASHInstanceCallback, DASHInstanceEvent, DASHLibLoadErrorEvent, DASHLibLoadStartEvent, DASHLibLoadedEvent, DASHLibrary, DASHLogEvent, DASHManagedMediaSourceEndStreamingEvent, DASHManagedMediaSourceStartStreamingEvent, DASHManifestLoadedEvent, DASHManifestLoadingFinishedEvent, DASHManifestLoadingStartedEvent, DASHManifestValidityChangedEvent, DASHMediaEvent, DASHMetricAddedEvent, DASHMetricChangedEvent, DASHMetricUpdatedEvent, DASHMetricsChangedEvent, DASHMimeType, DASHNamespace, DASHNamespaceLoader, DASHPeriodSwitchCompletedEvent, DASHPeriodSwitchStartedEvent, DASHPlaybackEndedEvent, DASHPlaybackErrorEvent, DASHPlaybackLoadedDataEvent, DASHPlaybackMetaDataLoadedEvent, DASHPlaybackNotAllowedEvent, DASHPlaybackPausedEvent, DASHPlaybackPlayingEvent, DASHPlaybackProgressEvent, DASHPlaybackRateChangedEvent, DASHPlaybackSeekedEvent, DASHPlaybackSeekingEvent, DASHPlaybackStalledEvent, DASHPlaybackStartedEvent, DASHPlaybackTimeUpdatedEvent, DASHPlaybackVolumeChangedEvent, DASHPlaybackWaitingEvent, DASHProvider, DASHProviderEvents, DASHProviderLoader, DASHQualityChangeRenderedEvent, DASHQualityChangeRequestedEvent, DASHRepresentationSwitchEvent, DASHSrc, DASHStreamActivatedEvent, DASHStreamDeactivatedEvent, DASHStreamInitializedEvent, DASHStreamInitializingEvent, DASHStreamTeardownCompleteEvent, DASHStreamUpdatedEvent, DASHTextTrackAddedEvent, DASHThroughputMeasurementStoredEvent, DASHTrackChangeRenderedEvent, DASHTtmlParsedEvent, DASHTtmlToParseEvent, DASHUnsupportedEvent, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, DEFAULT_AUDIO_GAINS, DEFAULT_PLAYBACK_RATES, FileDownloadInfo, FindMediaPlayerEvent, FindMediaPlayerEventDetail, FullscreenAdapter, FullscreenButtonEvents, FullscreenChangeEvent, FullscreenController, FullscreenErrorEvent, FullscreenEvents, GestureAction, GestureEvent, GestureEventType, GestureEvents, GestureTriggerEvent, GestureWillTriggerEvent, GoogleCastButtonEvents, GoogleCastEvent, GoogleCastEvents, GoogleCastLoadStartEvent, GoogleCastLoadedEvent, GoogleCastLoader, GoogleCastPromptError, GoogleCastPromptErrorCode, GoogleCastPromptErrorEvent, GoogleCastPromptEvent, GoogleCastProvider, HLSAudioTrackLoadedEvent, HLSAudioTrackLoadingEvent, HLSAudioTrackSwitchedEvent, HLSAudioTrackSwitchingEvent, HLSAudioTracksUpdatedEvent, HLSBackBufferReachedEvent, HLSBufferAppendedEvent, HLSBufferAppendingEvent, HLSBufferCodecsEvent, HLSBufferCreatedEvent, HLSBufferEosEvent, HLSBufferFlushedEvent, HLSBufferFlushingEvent, HLSBufferResetEvent, HLSConstructor, HLSConstructorLoader, HLSCuesParsedEvent, HLSDestroyingEvent, HLSErrorEvent, HLSFpsDropEvent, HLSFpsDropLevelCappingEvent, HLSFragBufferedDataEvent, HLSFragChangedEvent, HLSFragDecryptedEvent, HLSFragLoadEmergencyAbortedEvent, HLSFragLoadedEvent, HLSFragLoadingEvent, HLSFragParsedEvent, HLSFragParsingInitSegmentEvent, HLSFragParsingMetadataEvent, HLSFragParsingUserdataEvent, HLSInitPtsFoundEvent, HLSInstanceCallback, HLSInstanceEvent, HLSKeyLoadedEvent, HLSKeyLoadingEvent, HLSLevelLoadedEvent, HLSLevelLoadingEvent, HLSLevelPtsUpdatedEvent, HLSLevelSwitchedEvent, HLSLevelSwitchingEvent, HLSLevelUpdatedEvent, HLSLevelsUpdatedEvent, HLSLibLoadErrorEvent, HLSLibLoadStartEvent, HLSLibLoadedEvent, HLSLibrary, HLSManifestLoadedEvent, HLSManifestLoadingEvent, HLSManifestParsedEvent, HLSMediaAttachedEvent, HLSMediaAttachingEvent, HLSMediaDetachedEvent, HLSMediaDetachingEvent, HLSMediaEvent, HLSMimeType, HLSNonNativeTextTracksFoundEvent, HLSProvider, HLSProviderEvents, HLSProviderLoader, HLSSrc, HLSSubtitleFragProcessedEvent, HLSSubtitleTrackLoadedEvent, HLSSubtitleTrackLoadingEvent, HLSSubtitleTrackSwitchEvent, HLSSubtitleTracksClearedEvent, HLSSubtitleTracksUpdatedEvent, HLSUnsupportedEvent, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLMediaSrc, LibASSConfig, LibASSConstructor, LibASSErrorEvent, LibASSInstance, LibASSInstanceEvents, LibASSModuleLoader, LibASSReadyEvent, LibASSTextRenderer, List, ListAddEvent, ListEvents, ListItem, ListReadonlyChangeEvent, ListRemoveEvent, LocalMediaStorage, LogEvent, LogEventDetail, Logger, LoggerEvents, MEDIA_KEY_SHORTCUTS, MediaAbortEvent, MediaAirPlayRequestEvent, MediaAnnouncerEvents, MediaAnnouncerState, MediaAnnouncerTranslations, MediaAnnouncerWord, MediaAudioGainChangeEvent, MediaAudioGainChangeRequestEvent, MediaAudioTrackChangeEvent, MediaAudioTrackChangeRequestEvent, MediaAudioTracksChangeEvent, MediaAutoPlayChangeEvent, MediaAutoPlayEvent, MediaAutoPlayEventDetail, MediaAutoPlayFailEvent, MediaAutoPlayFailEventDetail, MediaCanLoadEvent, MediaCanLoadPosterEvent, MediaCanPlayDetail, MediaCanPlayEvent, MediaCanPlayThroughEvent, MediaClipEndChangeRequestEvent, MediaClipStartChangeRequestEvent, MediaContext, MediaControls, MediaControlsChangeEvent, MediaCrossOrigin, MediaDestroyEvent, MediaDurationChangeEvent, MediaDurationChangeRequestEvent, MediaEmptiedEvent, MediaEndEvent, MediaEndedEvent, MediaEnterFullscreenRequestEvent, MediaEnterPIPRequestEvent, MediaErrorCode, MediaErrorDetail, MediaErrorEvent, MediaEvent, MediaEvents, MediaExitFullscreenRequestEvent, MediaExitPIPRequestEvent, MediaFullscreenAdapter, MediaFullscreenChangeEvent, MediaFullscreenErrorEvent, MediaFullscreenRequestTarget, MediaGoogleCastRequestEvent, MediaHidePosterRequestEvent, MediaKeyShortcut, MediaKeyShortcuts, MediaKeyTarget, MediaKeysCallback, MediaLiveChangeEvent, MediaLiveEdgeChangeEvent, MediaLiveEdgeRequestEvent, MediaLoadStartEvent, MediaLoadedDataEvent, MediaLoadedMetadataEvent, MediaLoadingStrategy, MediaLoopChangeEvent, MediaLoopRequestEvent, MediaMuteRequestEvent, MediaOrientationChangeEvent, MediaOrientationLockRequestEvent, MediaOrientationUnlockRequestEvent, MediaPIPChangeEvent, MediaPIPErrorEvent, MediaPauseControlsRequestEvent, MediaPauseEvent, MediaPauseRequestEvent, MediaPlayEvent, MediaPlayFailEvent, MediaPlayRequestEvent, MediaPlayerConnectEvent, MediaPlayerEvents, MediaPlayerQuery, MediaPlayerState, MediaPlayingEvent, MediaPlaysInlineChangeEvent, MediaPosterChangeEvent, MediaPosterLoadingStrategy, MediaPosterStartLoadingRequestEvent, MediaProgressEvent, MediaProgressEventDetail, MediaProviderAdapter, MediaProviderChangeEvent, MediaProviderLoader, MediaProviderLoaderChangeEvent, MediaProviderSetupEvent, MediaProviderState, MediaQualitiesChangeEvent, MediaQualityChangeEvent, MediaQualityChangeRequestEvent, MediaRateChangeEvent, MediaRateChangeRequestEvent, MediaRemoteControl, MediaRemotePlaybackChangeEvent, MediaRemotePlaybackChangeEventDetail, MediaReplayEvent, MediaRequestEvents, MediaResumeControlsRequestEvent, MediaSeekRequestEvent, MediaSeekedEvent, MediaSeekingEvent, MediaSeekingRequestEvent, MediaShowPosterRequestEvent, MediaSourceChangeEvent, MediaSourcesChangeEvent, MediaSrc, MediaSrcObject, MediaStalledEvent, MediaStartLoadingRequestEvent, MediaStartedEvent, MediaState, MediaStateAccessors, MediaStorage, MediaStore, MediaStreamType, MediaStreamTypeChangeEvent, MediaSuspendEvent, MediaTextTrackChangeEvent, MediaTextTrackChangeRequestEvent, MediaTextTracksChangeEvent, MediaTimeChangeEvent, MediaTimeUpdateEvent, MediaTimeUpdateEventDetail, MediaTitleChangeEvent, MediaType, MediaTypeChangeEvent, MediaUnmuteRequestEvent, MediaUserEvents, MediaUserLoopChangeRequestEvent, MediaViewType, MediaViewTypeChangeEvent, MediaVolumeChange, MediaVolumeChangeEvent, MediaVolumeChangeRequestEvent, MediaWaitingEvent, MenuPlacement, MenuPlacementAlign, MenuPlacementSide, MuteButtonEvents, PIPButtonEvents, PlayButtonEvents, PlayerStore, PosterState, QualitySliderEvents, QualitySliderState, RadioChangeEvent, RadioSelectEvent, RemotePlaybackInfo, RemotePlaybackType, ScreenOrientationChangeEvent, ScreenOrientationChangeEventDetail, ScreenOrientationController, ScreenOrientationEvents, ScreenOrientationLockType, ScreenOrientationType, SeekButtonEvents, SerializedVideoQuality, SliderCSSVars, SliderDragEndEvent, SliderDragStartEvent, SliderDragValueChangeEvent, SliderEvent, SliderEvents, SliderOrientation, SliderPointerValueChangeEvent, SliderState, SliderValueChangeEvent, SliderVideoCanPlayEvent, SliderVideoErrorEvent, SliderVideoEvents, SliderVideoState, SpeedSliderEvents, SpeedSliderState, Src, TextRenderer, TextRenderers, TextTrack, TextTrackAddCueEvent, TextTrackAddEvent, TextTrackCueChangeEvent, TextTrackErrorEvent, TextTrackEvent, TextTrackEvents, TextTrackInit, TextTrackList, TextTrackListEvent, TextTrackListEvents, TextTrackListModeChangeEvent, TextTrackLoadEvent, TextTrackLoadStartEvent, TextTrackModeChangeEvent, TextTrackReadyState, TextTrackRemoveCueEvent, TextTrackRemoveEvent, ThumbnailState, TimeInterval, TimeRange, TimeSliderEvents, TimeSliderState, TimeState, TooltipPlacement, TooltipPlacementAlign, TooltipPlacementSide, VIDEO_EXTENSIONS, VIDEO_TYPES, VTTContent, VTTCueInit, VTTRegionInit, VideoMimeType, VideoPresentationChangeEvent, VideoPresentationEvents, VideoProvider, VideoProviderLoader, VideoQuality, VideoQualityAddEvent, VideoQualityAutoChangeEvent, VideoQualityChangeEvent, VideoQualityChangeEventDetail, VideoQualityList, VideoQualityListEvent, VideoQualityListEvents, VideoQualityRemoveEvent, VideoSrc, VideoSrcMeta, VimeoProvider, VimeoProviderLoader, VimeoSrc, VolumeSliderEvents, VolumeSliderState, YouTubeProvider, YouTubeProviderLoader, YouTubeSrc, appendTriggerEvent, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, findTriggerEvent, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, hasTriggerEvent, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isKeyboardClick, isKeyboardEvent, isMediaStream, isPointerEvent, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, mediaContext, mediaState, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, sliderState, softResetMediaState, sortVideoQualities, updateTimeIntervals, walkTriggerEventChain, watchActiveTextTrack, watchCueTextChange } from './types/vidstack.js';
 export { AirPlayButtonInstance, AudioGainSliderInstance, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, FullscreenButtonInstance, GestureInstance, GoogleCastButtonInstance, LiveButtonInstance, MediaAnnouncerInstance, MediaPlayerInstance, MediaProviderInstance, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, QualitySliderInstance, RadioGroupInstance, RadioInstance, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, ThumbnailInstance, TimeInstance, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VolumeSliderInstance } from './types/vidstack-instances.js';
 export { AirPlayButton, AirPlayButtonProps, AudioGainOption, AudioGainOptions, audioGainSlider_d as AudioGainSlider, RootProps$4 as AudioGainSliderProps, AudioOption, AudioOptions, caption_d as Caption, CaptionButton, CaptionButtonProps, CaptionOption, CaptionOptions, RootProps$10 as CaptionProps, TextProps as CaptionTextProps, Captions, CaptionsProps, ChapterOption, ChapterOptions, ChapterTitle, ChapterTitleProps$1 as ChapterTitleProps, controls_d as Controls, GroupProps as ControlsGroupProps, RootProps as ControlsProps, DefaultLayoutProps, FullscreenButton, FullscreenButtonProps, Gesture, GestureProps, GoogleCastButton, GoogleCastButtonProps, Icon, IconComponent, IconProps, LiveButton, LiveButtonProps, MediaAnnouncer, MediaAnnouncerProps, MediaPlayer, MediaPlayerProps, MediaProvider, MediaProviderProps, menu_d as Menu, ButtonProps as MenuButtonProps, ItemsProps as MenuContentProps, ItemProps$1 as MenuItemProps, ItemsProps as MenuItemsProps, PortalProps as MenuPortalProps, RootProps$9 as MenuProps, RootProps$8 as MenuRadioGroupProps, ItemProps as MenuRadioProps, MuteButton, MuteButtonProps, PIPButton, PIPButtonProps, PlayButton, PlayButtonProps, PlaybackRateOption, PlaybackRateOptions, PlayerSrc, PlyrLayoutProps, Poster, PosterProps, qualitySlider_d as QualitySlider, RootProps$6 as QualitySliderProps, radioGroup_d as RadioGroup, RootProps$8 as RadioGroupProps, ItemProps as RadioProps, SeekButton, SeekButtonProps, slider_d as Slider, ChaptersProps as SliderChapterProps, ChapterTitleProps as SliderChapterTitleProps, PreviewProps as SliderPreviewProps, RootProps$2 as SliderProps, StepsProps as SliderStepsProps, ThumbnailImgProps as SliderThumbnailImgProps, ThumbnailProps as SliderThumbnailProps, ValueProps as SliderValueProps, VideoProps as SliderVideoProps, speedSlider_d as SpeedSlider, RootProps$5 as SpeedSliderProps, spinner_d as Spinner, RootProps$12 as SpinnerProps, TrackFillProps as SpinnerTrackFillProps, TrackProps$1 as SpinnerTrackProps, thumbnail_d as Thumbnail, ImgProps as ThumbnailImgProps, RootProps$11 as ThumbnailProps, Time, TimeProps, timeSlider_d as TimeSlider, RootProps$7 as TimeSliderProps, Title, TitleProps, ToggleButton, ToggleButtonProps, tooltip_d as Tooltip, ContentProps as TooltipContentProps, RootProps$1 as TooltipProps, TriggerProps as TooltipTriggerProps, Track, TrackProps, UseAudioGainOptions, UseCaptionOptions, UsePlaybackRateOptions, UseSliderPreview, UseVideoQualityOptions, VideoQualityOption, VideoQualityOptions, volumeSlider_d as VolumeSlider, RootProps$3 as VolumeSliderProps, createTextTrack, useActiveTextCues, useActiveTextTrack, useActiveThumbnail, useAudioGainOptions, useAudioOptions, useCaptionOptions, useChapterOptions, useChapterTitle, useMediaContext, useMediaPlayer, useMediaProvider, useMediaRemote, useMediaState, useMediaStore, usePlaybackRateOptions, useSliderPreview, useSliderState, useSliderStore, useState, useStore, useTextCues, useThumbnails, useVideoQualityOptions } from './types/vidstack-react.js';
 import 'media-captions';
diff --git a/prod/chunks/vidstack-3ABKqYU9.js b/prod/chunks/vidstack-3ABKqYU9.js
new file mode 100644
index 0000000000000000000000000000000000000000..2feb93b20a7208acadfc660f7f1a34fd4934755f
--- /dev/null
+++ b/prod/chunks/vidstack-3ABKqYU9.js
@@ -0,0 +1,11179 @@
+"use client"
+
+import * as React from 'react';
+import { isString, isNumber, isFunction, isUndefined, waitTimeout, isArray, isBoolean, isNull, deferredPromise, listenEvent, scoped, getScope, EventsTarget, DOMEvent, State, fscreen, tick, createContext, useContext, Component, functionThrottle, setAttribute, effect, isTouchEvent, isDOMNode, EventsController, isKeyboardClick, setStyle, onDispose, untrack, functionDebounce, ViewController, signal, peek, isKeyboardEvent, isNil, createScope, camelToKebabCase, waitIdlePeriod, prop, method, provideContext, animationFrameThrottle, uppercaseFirstChar, computed, noop, ariaBool as ariaBool$1, isWriteSignal, hasProvidedContext, isObject, useState, r, wasEnterKeyPressed, isPointerEvent, isMouseEvent, kebabToCamelCase, composeRefs, useStateContext, useSignal, useSignalRecord } from './vidstack-CNjv_Zem.js';
+import { autoUpdate, computePosition, flip, shift } from '@floating-ui/dom';
+
+function isVideoQualitySrc(src) {
+  return !isString(src) && "width" in src && "height" in src && isNumber(src.width) && isNumber(src.height);
+}
+
+const IS_SERVER = typeof document === "undefined";
+
+const UA = IS_SERVER ? "" : navigator?.userAgent.toLowerCase() || "";
+const IS_IOS = !IS_SERVER && /iphone|ipad|ipod|ios|crios|fxios/i.test(UA);
+const IS_IPHONE = !IS_SERVER && /(iphone|ipod)/gi.test(navigator?.platform || "");
+const IS_CHROME = !IS_SERVER && !!window.chrome;
+const IS_SAFARI = !IS_SERVER && (!!window.safari || IS_IOS);
+function canOrientScreen() {
+  return canRotateScreen() && isFunction(screen.orientation.unlock);
+}
+function canRotateScreen() {
+  return !IS_SERVER && !isUndefined(window.screen.orientation) && !isUndefined(window.screen.orientation.lock);
+}
+function canPlayAudioType(audio, type) {
+  if (IS_SERVER) return false;
+  if (!audio) audio = document.createElement("audio");
+  return audio.canPlayType(type).length > 0;
+}
+function canPlayVideoType(video, type) {
+  if (IS_SERVER) return false;
+  if (!video) video = document.createElement("video");
+  return video.canPlayType(type).length > 0;
+}
+function canPlayHLSNatively(video) {
+  if (IS_SERVER) return false;
+  if (!video) video = document.createElement("video");
+  return video.canPlayType("application/vnd.apple.mpegurl").length > 0;
+}
+function canUsePictureInPicture(video) {
+  if (IS_SERVER) return false;
+  return !!document.pictureInPictureEnabled && !video?.disablePictureInPicture;
+}
+function canUseVideoPresentation(video) {
+  if (IS_SERVER) return false;
+  return isFunction(video?.webkitSupportsPresentationMode) && isFunction(video?.webkitSetPresentationMode);
+}
+async function canChangeVolume() {
+  const video = document.createElement("video");
+  video.volume = 0.5;
+  await waitTimeout(0);
+  return video.volume === 0.5;
+}
+function getMediaSource() {
+  return IS_SERVER ? void 0 : window?.ManagedMediaSource ?? window?.MediaSource ?? window?.WebKitMediaSource;
+}
+function getSourceBuffer() {
+  return IS_SERVER ? void 0 : window?.SourceBuffer ?? window?.WebKitSourceBuffer;
+}
+function isHLSSupported() {
+  if (IS_SERVER) return false;
+  const MediaSource = getMediaSource();
+  if (isUndefined(MediaSource)) return false;
+  const isTypeSupported = MediaSource && isFunction(MediaSource.isTypeSupported) && MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
+  const SourceBuffer = getSourceBuffer();
+  const isSourceBufferValid = isUndefined(SourceBuffer) || !isUndefined(SourceBuffer.prototype) && isFunction(SourceBuffer.prototype.appendBuffer) && isFunction(SourceBuffer.prototype.remove);
+  return !!isTypeSupported && !!isSourceBufferValid;
+}
+function isDASHSupported() {
+  return isHLSSupported();
+}
+
+class TimeRange {
+  #ranges;
+  get length() {
+    return this.#ranges.length;
+  }
+  constructor(start, end) {
+    if (isArray(start)) {
+      this.#ranges = start;
+    } else if (!isUndefined(start) && !isUndefined(end)) {
+      this.#ranges = [[start, end]];
+    } else {
+      this.#ranges = [];
+    }
+  }
+  start(index) {
+    return this.#ranges[index][0] ?? Infinity;
+  }
+  end(index) {
+    return this.#ranges[index][1] ?? Infinity;
+  }
+}
+function getTimeRangesStart(range) {
+  if (!range.length) return null;
+  let min = range.start(0);
+  for (let i = 1; i < range.length; i++) {
+    const value = range.start(i);
+    if (value < min) min = value;
+  }
+  return min;
+}
+function getTimeRangesEnd(range) {
+  if (!range.length) return null;
+  let max = range.end(0);
+  for (let i = 1; i < range.length; i++) {
+    const value = range.end(i);
+    if (value > max) max = value;
+  }
+  return max;
+}
+function normalizeTimeIntervals(intervals) {
+  if (intervals.length <= 1) {
+    return intervals;
+  }
+  intervals.sort((a, b) => a[0] - b[0]);
+  let normalized = [], current = intervals[0];
+  for (let i = 1; i < intervals.length; i++) {
+    const next = intervals[i];
+    if (current[1] >= next[0] - 1) {
+      current = [current[0], Math.max(current[1], next[1])];
+    } else {
+      normalized.push(current);
+      current = next;
+    }
+  }
+  normalized.push(current);
+  return normalized;
+}
+function updateTimeIntervals(intervals, interval, value) {
+  let start = interval[0], end = interval[1];
+  if (value < start) {
+    return [value, -1];
+  } else if (value === start) {
+    return interval;
+  } else if (start === -1) {
+    interval[0] = value;
+    return interval;
+  } else if (value > start) {
+    interval[1] = value;
+    if (end === -1) intervals.push(interval);
+  }
+  normalizeTimeIntervals(intervals);
+  return interval;
+}
+
+const AUDIO_EXTENSIONS = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx|flac)($|\?)/i;
+const AUDIO_TYPES = /* @__PURE__ */ new Set([
+  "audio/mpeg",
+  "audio/ogg",
+  "audio/3gp",
+  "audio/mp3",
+  "audio/webm",
+  "audio/flac",
+  "audio/m4a",
+  "audio/m4b",
+  "audio/mp4a",
+  "audio/mp4"
+]);
+const VIDEO_EXTENSIONS = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i;
+const VIDEO_TYPES = /* @__PURE__ */ new Set([
+  "video/mp4",
+  "video/webm",
+  "video/3gp",
+  "video/ogg",
+  "video/avi",
+  "video/mpeg"
+]);
+const HLS_VIDEO_EXTENSIONS = /\.(m3u8)($|\?)/i;
+const DASH_VIDEO_EXTENSIONS = /\.(mpd)($|\?)/i;
+const HLS_VIDEO_TYPES = /* @__PURE__ */ new Set([
+  // Apple sanctioned
+  "application/vnd.apple.mpegurl",
+  // Apple sanctioned for backwards compatibility
+  "audio/mpegurl",
+  // Very common
+  "audio/x-mpegurl",
+  // Very common
+  "application/x-mpegurl",
+  // Included for completeness
+  "video/x-mpegurl",
+  "video/mpegurl",
+  "application/mpegurl"
+]);
+const DASH_VIDEO_TYPES = /* @__PURE__ */ new Set(["application/dash+xml"]);
+function isAudioSrc({ src, type }) {
+  return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
+}
+function isVideoSrc(src) {
+  return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && (IS_SERVER || canPlayHLSNatively()) : src.type === "video/object";
+}
+function isHLSSrc({ src, type }) {
+  return isString(src) && HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type);
+}
+function isDASHSrc({ src, type }) {
+  return isString(src) && DASH_VIDEO_EXTENSIONS.test(src) || DASH_VIDEO_TYPES.has(type);
+}
+function canGoogleCastSrc(src) {
+  return isString(src.src) && (isAudioSrc(src) || isVideoSrc(src) || isHLSSrc(src));
+}
+function isMediaStream(src) {
+  return !IS_SERVER && typeof window.MediaStream !== "undefined" && src instanceof window.MediaStream;
+}
+
+function appendParamsToURL(baseUrl, params) {
+  const url = new URL(baseUrl);
+  for (const key of Object.keys(params)) {
+    url.searchParams.set(key, params[key] + "");
+  }
+  return url.toString();
+}
+function preconnect(url, rel = "preconnect") {
+  if (IS_SERVER) return false;
+  const exists = document.querySelector(`link[href="${url}"]`);
+  if (!isNull(exists)) return true;
+  const link = document.createElement("link");
+  link.rel = rel;
+  link.href = url;
+  link.crossOrigin = "true";
+  document.head.append(link);
+  return true;
+}
+const pendingRequests = {};
+function loadScript(src) {
+  if (pendingRequests[src]) return pendingRequests[src].promise;
+  const promise = deferredPromise(), exists = document.querySelector(`script[src="${src}"]`);
+  if (!isNull(exists)) {
+    promise.resolve();
+    return promise.promise;
+  }
+  pendingRequests[src] = promise;
+  const script = document.createElement("script");
+  script.src = src;
+  script.onload = () => {
+    promise.resolve();
+    delete pendingRequests[src];
+  };
+  script.onerror = () => {
+    promise.reject();
+    delete pendingRequests[src];
+  };
+  setTimeout(() => document.head.append(script), 0);
+  return promise.promise;
+}
+function getRequestCredentials(crossOrigin) {
+  return crossOrigin === "use-credentials" ? "include" : isString(crossOrigin) ? "same-origin" : void 0;
+}
+function getDownloadFile({
+  title,
+  src,
+  download
+}) {
+  const url = isBoolean(download) || download === "" ? src.src : isString(download) ? download : download?.url;
+  if (!isValidFileDownload({ url, src, download })) return null;
+  return {
+    url,
+    name: !isBoolean(download) && !isString(download) && download?.filename || title.toLowerCase() || "media"
+  };
+}
+function isValidFileDownload({
+  url,
+  src,
+  download
+}) {
+  return isString(url) && (download && download !== true || isAudioSrc(src) || isVideoSrc(src));
+}
+
+const CROSS_ORIGIN = Symbol(0), READY_STATE = Symbol(0), UPDATE_ACTIVE_CUES = Symbol(0), CAN_LOAD = Symbol(0), ON_MODE_CHANGE = Symbol(0), NATIVE = Symbol(0), NATIVE_HLS = Symbol(0);
+const TextTrackSymbol = {
+  crossOrigin: CROSS_ORIGIN,
+  readyState: READY_STATE,
+  updateActiveCues: UPDATE_ACTIVE_CUES,
+  canLoad: CAN_LOAD,
+  onModeChange: ON_MODE_CHANGE,
+  native: NATIVE,
+  nativeHLS: NATIVE_HLS
+};
+
+function findActiveCue(cues, time) {
+  for (let i = 0, len = cues.length; i < len; i++) {
+    if (isCueActive(cues[i], time)) return cues[i];
+  }
+  return null;
+}
+function isCueActive(cue, time) {
+  return time >= cue.startTime && time < cue.endTime;
+}
+function watchActiveTextTrack(tracks, kind, onChange) {
+  let currentTrack = null, scope = getScope();
+  function onModeChange() {
+    const kinds = isString(kind) ? [kind] : kind, track = tracks.toArray().find((track2) => kinds.includes(track2.kind) && track2.mode === "showing");
+    if (track === currentTrack) return;
+    if (!track) {
+      onChange(null);
+      currentTrack = null;
+      return;
+    }
+    if (track.readyState == 2) {
+      onChange(track);
+    } else {
+      onChange(null);
+      scoped(() => {
+        const off = listenEvent(
+          track,
+          "load",
+          () => {
+            onChange(track);
+            off();
+          },
+          { once: true }
+        );
+      }, scope);
+    }
+    currentTrack = track;
+  }
+  onModeChange();
+  return listenEvent(tracks, "mode-change", onModeChange);
+}
+function watchCueTextChange(tracks, kind, callback) {
+  watchActiveTextTrack(tracks, kind, (track) => {
+    if (!track) {
+      callback("");
+      return;
+    }
+    const onCueChange = () => {
+      const activeCue = track?.activeCues[0];
+      callback(activeCue?.text || "");
+    };
+    onCueChange();
+    listenEvent(track, "cue-change", onCueChange);
+  });
+}
+
+class TextTrack extends EventsTarget {
+  static createId(track) {
+    return `vds-${track.type}-${track.kind}-${track.src ?? track.label ?? "?"}`;
+  }
+  src;
+  content;
+  type;
+  encoding;
+  id = "";
+  label = "";
+  language = "";
+  kind;
+  default = false;
+  #canLoad = false;
+  #currentTime = 0;
+  #mode = "disabled";
+  #metadata = {};
+  #regions = [];
+  #cues = [];
+  #activeCues = [];
+  /** @internal */
+  [TextTrackSymbol.readyState] = 0;
+  /** @internal */
+  [TextTrackSymbol.crossOrigin];
+  /** @internal */
+  [TextTrackSymbol.onModeChange] = null;
+  /** @internal */
+  [TextTrackSymbol.native] = null;
+  get metadata() {
+    return this.#metadata;
+  }
+  get regions() {
+    return this.#regions;
+  }
+  get cues() {
+    return this.#cues;
+  }
+  get activeCues() {
+    return this.#activeCues;
+  }
+  /**
+   * - 0: Not Loading
+   * - 1: Loading
+   * - 2: Ready
+   * - 3: Error
+   */
+  get readyState() {
+    return this[TextTrackSymbol.readyState];
+  }
+  get mode() {
+    return this.#mode;
+  }
+  set mode(mode) {
+    this.setMode(mode);
+  }
+  constructor(init) {
+    super();
+    for (const prop of Object.keys(init)) this[prop] = init[prop];
+    if (!this.type) this.type = "vtt";
+    if (!IS_SERVER && init.content) {
+      this.#parseContent(init);
+    } else if (!init.src) {
+      this[TextTrackSymbol.readyState] = 2;
+    }
+  }
+  addCue(cue, trigger) {
+    let i = 0, length = this.#cues.length;
+    for (i = 0; i < length; i++) if (cue.endTime <= this.#cues[i].startTime) break;
+    if (i === length) this.#cues.push(cue);
+    else this.#cues.splice(i, 0, cue);
+    if (!(cue instanceof TextTrackCue)) {
+      this[TextTrackSymbol.native]?.track.addCue(cue);
+    }
+    this.dispatchEvent(new DOMEvent("add-cue", { detail: cue, trigger }));
+    if (isCueActive(cue, this.#currentTime)) {
+      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+    }
+  }
+  removeCue(cue, trigger) {
+    const index = this.#cues.indexOf(cue);
+    if (index >= 0) {
+      const isActive = this.#activeCues.includes(cue);
+      this.#cues.splice(index, 1);
+      this[TextTrackSymbol.native]?.track.removeCue(cue);
+      this.dispatchEvent(new DOMEvent("remove-cue", { detail: cue, trigger }));
+      if (isActive) {
+        this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+      }
+    }
+  }
+  setMode(mode, trigger) {
+    if (this.#mode === mode) return;
+    this.#mode = mode;
+    if (mode === "disabled") {
+      this.#activeCues = [];
+      this.#activeCuesChanged();
+    } else if (this.readyState === 2) {
+      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+    } else {
+      this.#load();
+    }
+    this.dispatchEvent(new DOMEvent("mode-change", { detail: this, trigger }));
+    this[TextTrackSymbol.onModeChange]?.();
+  }
+  /** @internal */
+  [TextTrackSymbol.updateActiveCues](currentTime, trigger) {
+    this.#currentTime = currentTime;
+    if (this.mode === "disabled" || !this.#cues.length) return;
+    const activeCues = [];
+    for (let i = 0, length = this.#cues.length; i < length; i++) {
+      const cue = this.#cues[i];
+      if (isCueActive(cue, currentTime)) activeCues.push(cue);
+    }
+    let changed = activeCues.length !== this.#activeCues.length;
+    if (!changed) {
+      for (let i = 0; i < activeCues.length; i++) {
+        if (!this.#activeCues.includes(activeCues[i])) {
+          changed = true;
+          break;
+        }
+      }
+    }
+    this.#activeCues = activeCues;
+    if (changed) this.#activeCuesChanged(trigger);
+  }
+  /** @internal */
+  [TextTrackSymbol.canLoad]() {
+    this.#canLoad = true;
+    if (this.#mode !== "disabled") this.#load();
+  }
+  #parseContent(init) {
+    import('media-captions').then(({ parseText, VTTCue, VTTRegion }) => {
+      if (!isString(init.content) || init.type === "json") {
+        this.#parseJSON(init.content, VTTCue, VTTRegion);
+        if (this.readyState !== 3) this.#ready();
+      } else {
+        parseText(init.content, { type: init.type }).then(({ cues, regions }) => {
+          this.#cues = cues;
+          this.#regions = regions;
+          this.#ready();
+        });
+      }
+    });
+  }
+  async #load() {
+    if (!this.#canLoad || this[TextTrackSymbol.readyState] > 0) return;
+    this[TextTrackSymbol.readyState] = 1;
+    this.dispatchEvent(new DOMEvent("load-start"));
+    if (!this.src) {
+      this.#ready();
+      return;
+    }
+    try {
+      const { parseResponse, VTTCue, VTTRegion } = await import('media-captions'), crossOrigin = this[TextTrackSymbol.crossOrigin]?.();
+      const response = fetch(this.src, {
+        headers: this.type === "json" ? { "Content-Type": "application/json" } : void 0,
+        credentials: getRequestCredentials(crossOrigin)
+      });
+      if (this.type === "json") {
+        this.#parseJSON(await (await response).text(), VTTCue, VTTRegion);
+      } else if (this.type === "lrc") {
+        this.#parseLRC(await (await response).text(), VTTCue);
+      } else {
+        const { errors, metadata, regions, cues } = await parseResponse(response, {
+          type: this.type,
+          encoding: this.encoding
+        });
+        if (errors[0]?.code === 0) {
+          throw errors[0];
+        } else {
+          this.#metadata = metadata;
+          this.#regions = regions;
+          this.#cues = cues;
+        }
+      }
+      this.#ready();
+    } catch (error) {
+      this.#error(error);
+    }
+  }
+  #ready() {
+    this[TextTrackSymbol.readyState] = 2;
+    if (!this.src || this.type !== "vtt") {
+      const native = this[TextTrackSymbol.native];
+      if (native && !native.managed) {
+        for (const cue of this.#cues) native.track.addCue(cue);
+      }
+    }
+    const loadEvent = new DOMEvent("load");
+    this[TextTrackSymbol.updateActiveCues](this.#currentTime, loadEvent);
+    this.dispatchEvent(loadEvent);
+  }
+  #error(error) {
+    this[TextTrackSymbol.readyState] = 3;
+    this.dispatchEvent(new DOMEvent("error", { detail: error }));
+  }
+  #parseLRC(lrc, VTTCue) {
+    try {
+      const { cues } = parseLRCCaptionsFile(lrc, VTTCue);
+      this.#cues = cues;
+    } catch (error) {
+      this.#error(error);
+    }
+  }
+  #parseJSON(json, VTTCue, VTTRegion) {
+    try {
+      const { regions, cues } = parseJSONCaptionsFile(json, VTTCue, VTTRegion);
+      this.#regions = regions;
+      this.#cues = cues;
+    } catch (error) {
+      this.#error(error);
+    }
+  }
+  #activeCuesChanged(trigger) {
+    this.dispatchEvent(new DOMEvent("cue-change", { trigger }));
+  }
+}
+const captionRE = /captions|subtitles/;
+function isTrackCaptionKind(track) {
+  return captionRE.test(track.kind);
+}
+function parseLRCCaptionsFile(content, Cue) {
+  const lines = content.trim().split("\n");
+  const cues = [];
+  const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
+  const computedTime = (times) => +(parseInt(times[0]) * 60) + parseInt(times[1]) + parseInt(times[2].padEnd(3, "0")) / 1e3;
+  for (let i = 0; i < lines.length; i++) {
+    const line = lines[i];
+    const match = timeRegex.exec(line);
+    if (match) {
+      const [fullMatch, minutes, seconds, milliseconds] = match;
+      const text = line.slice(fullMatch.length).trim();
+      const startTime = computedTime([minutes, seconds, milliseconds]);
+      let endTime = startTime + 5;
+      for (let j = i + 1; j < lines.length; j++) {
+        const nextMatch = timeRegex.exec(lines[j]);
+        if (nextMatch) {
+          endTime = computedTime([nextMatch[1], nextMatch[2], nextMatch[3]]);
+          break;
+        }
+      }
+      const cue = new Cue(startTime, endTime, text);
+      cues.push(cue);
+    }
+  }
+  return { cues };
+}
+function parseJSONCaptionsFile(json, Cue, Region) {
+  const content = isString(json) ? JSON.parse(json) : json;
+  let regions = [], cues = [];
+  if (content.regions && Region) {
+    regions = content.regions.map((region) => Object.assign(new Region(), region));
+  }
+  if (content.cues || isArray(content)) {
+    cues = (isArray(content) ? content : content.cues).filter((content2) => isNumber(content2.startTime) && isNumber(content2.endTime)).map((cue) => Object.assign(new Cue(0, 0, ""), cue));
+  }
+  return { regions, cues };
+}
+
+const mediaState = new State({
+  artist: "",
+  artwork: null,
+  audioTrack: null,
+  audioTracks: [],
+  autoPlay: false,
+  autoPlayError: null,
+  audioGain: null,
+  buffered: new TimeRange(),
+  canLoad: false,
+  canLoadPoster: false,
+  canFullscreen: false,
+  canOrientScreen: canOrientScreen(),
+  canPictureInPicture: false,
+  canPlay: false,
+  clipStartTime: 0,
+  clipEndTime: 0,
+  controls: false,
+  get iOSControls() {
+    return IS_IPHONE && this.mediaType === "video" && (!this.playsInline || !fscreen.fullscreenEnabled && this.fullscreen);
+  },
+  get nativeControls() {
+    return this.controls || this.iOSControls;
+  },
+  controlsVisible: false,
+  get controlsHidden() {
+    return !this.controlsVisible;
+  },
+  crossOrigin: null,
+  ended: false,
+  error: null,
+  fullscreen: false,
+  get loop() {
+    return this.providedLoop || this.userPrefersLoop;
+  },
+  logLevel: "silent",
+  mediaType: "unknown",
+  muted: false,
+  paused: true,
+  played: new TimeRange(),
+  playing: false,
+  playsInline: false,
+  pictureInPicture: false,
+  preload: "metadata",
+  playbackRate: 1,
+  qualities: [],
+  quality: null,
+  autoQuality: false,
+  canSetQuality: true,
+  canSetPlaybackRate: true,
+  canSetVolume: false,
+  canSetAudioGain: false,
+  seekable: new TimeRange(),
+  seeking: false,
+  source: { src: "", type: "" },
+  sources: [],
+  started: false,
+  textTracks: [],
+  textTrack: null,
+  get hasCaptions() {
+    return this.textTracks.filter(isTrackCaptionKind).length > 0;
+  },
+  volume: 1,
+  waiting: false,
+  realCurrentTime: 0,
+  get currentTime() {
+    return this.ended ? this.duration : this.clipStartTime > 0 ? Math.max(0, Math.min(this.realCurrentTime - this.clipStartTime, this.duration)) : this.realCurrentTime;
+  },
+  providedDuration: -1,
+  intrinsicDuration: 0,
+  get duration() {
+    return this.seekableWindow;
+  },
+  get title() {
+    return this.providedTitle || this.inferredTitle;
+  },
+  get poster() {
+    return this.providedPoster || this.inferredPoster;
+  },
+  get viewType() {
+    return this.providedViewType !== "unknown" ? this.providedViewType : this.inferredViewType;
+  },
+  get streamType() {
+    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
+  },
+  get currentSrc() {
+    return this.source;
+  },
+  get bufferedStart() {
+    const start = getTimeRangesStart(this.buffered) ?? 0;
+    return Math.max(start, this.clipStartTime);
+  },
+  get bufferedEnd() {
+    const end = getTimeRangesEnd(this.buffered) ?? 0;
+    return Math.min(this.seekableEnd, Math.max(0, end - this.clipStartTime));
+  },
+  get bufferedWindow() {
+    return Math.max(0, this.bufferedEnd - this.bufferedStart);
+  },
+  get seekableStart() {
+    if (this.isLiveDVR && this.liveDVRWindow > 0) {
+      return Math.max(0, this.seekableEnd - this.liveDVRWindow);
+    }
+    const start = getTimeRangesStart(this.seekable) ?? 0;
+    return Math.max(start, this.clipStartTime);
+  },
+  get seekableEnd() {
+    if (this.providedDuration > 0) return this.providedDuration;
+    const end = this.liveSyncPosition > 0 ? this.liveSyncPosition : this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
+    return this.clipEndTime > 0 ? Math.min(this.clipEndTime, end) : end;
+  },
+  get seekableWindow() {
+    const window = this.seekableEnd - this.seekableStart;
+    return !isNaN(window) ? Math.max(0, window) : Infinity;
+  },
+  // ~~ remote playback ~~
+  canAirPlay: false,
+  canGoogleCast: false,
+  remotePlaybackState: "disconnected",
+  remotePlaybackType: "none",
+  remotePlaybackLoader: null,
+  remotePlaybackInfo: null,
+  get isAirPlayConnected() {
+    return this.remotePlaybackType === "airplay" && this.remotePlaybackState === "connected";
+  },
+  get isGoogleCastConnected() {
+    return this.remotePlaybackType === "google-cast" && this.remotePlaybackState === "connected";
+  },
+  // ~~ responsive design ~~
+  pointer: "fine",
+  orientation: "landscape",
+  width: 0,
+  height: 0,
+  mediaWidth: 0,
+  mediaHeight: 0,
+  lastKeyboardAction: null,
+  // ~~ user props ~~
+  userBehindLiveEdge: false,
+  // ~~ live props ~~
+  liveEdgeTolerance: 10,
+  minLiveDVRWindow: 60,
+  get canSeek() {
+    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.duration) && (!this.isLiveDVR || this.duration >= this.liveDVRWindow);
+  },
+  get live() {
+    return this.streamType.includes("live") || !Number.isFinite(this.duration);
+  },
+  get liveEdgeStart() {
+    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, this.seekableEnd - this.liveEdgeTolerance) : 0;
+  },
+  get liveEdge() {
+    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
+  },
+  get liveEdgeWindow() {
+    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
+  },
+  get isLiveDVR() {
+    return /:dvr/.test(this.streamType);
+  },
+  get liveDVRWindow() {
+    return Math.max(this.inferredLiveDVRWindow, this.minLiveDVRWindow);
+  },
+  // ~~ internal props ~~
+  autoPlaying: false,
+  providedTitle: "",
+  inferredTitle: "",
+  providedLoop: false,
+  userPrefersLoop: false,
+  providedPoster: "",
+  inferredPoster: "",
+  inferredViewType: "unknown",
+  providedViewType: "unknown",
+  providedStreamType: "unknown",
+  inferredStreamType: "unknown",
+  liveSyncPosition: null,
+  inferredLiveDVRWindow: 0,
+  savedState: null
+});
+const RESET_ON_SRC_QUALITY_CHANGE = /* @__PURE__ */ new Set([
+  "autoPlayError",
+  "autoPlaying",
+  "buffered",
+  "canPlay",
+  "error",
+  "paused",
+  "played",
+  "playing",
+  "seekable",
+  "seeking",
+  "waiting"
+]);
+const RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
+  ...RESET_ON_SRC_QUALITY_CHANGE,
+  "ended",
+  "inferredPoster",
+  "inferredStreamType",
+  "inferredTitle",
+  "intrinsicDuration",
+  "inferredLiveDVRWindow",
+  "liveSyncPosition",
+  "realCurrentTime",
+  "savedState",
+  "started",
+  "userBehindLiveEdge"
+]);
+function softResetMediaState($media, isSourceQualityChange = false) {
+  const filter = isSourceQualityChange ? RESET_ON_SRC_QUALITY_CHANGE : RESET_ON_SRC_CHANGE;
+  mediaState.reset($media, (prop) => filter.has(prop));
+  tick();
+}
+function boundTime(time, store) {
+  const clippedTime = time + store.clipStartTime(), isStart = Math.floor(time) === Math.floor(store.seekableStart()), isEnd = Math.floor(clippedTime) === Math.floor(store.seekableEnd());
+  if (isStart) {
+    return store.seekableStart();
+  }
+  if (isEnd) {
+    return store.seekableEnd();
+  }
+  if (store.isLiveDVR() && store.liveDVRWindow() > 0 && clippedTime < store.seekableEnd() - store.liveDVRWindow()) {
+    return store.bufferedStart();
+  }
+  return Math.min(Math.max(store.seekableStart() + 0.1, clippedTime), store.seekableEnd() - 0.1);
+}
+
+const mediaContext = createContext();
+function useMediaContext() {
+  return useContext(mediaContext);
+}
+
+class MediaRemoteControl {
+  #target = null;
+  #player = null;
+  #prevTrackIndex = -1;
+  #logger;
+  constructor(logger = void 0) {
+    this.#logger = logger;
+  }
+  /**
+   * Set the target from which to dispatch media requests events from. The events should bubble
+   * up from this target to the player element.
+   *
+   * @example
+   * ```ts
+   * const button = document.querySelector('button');
+   * remote.setTarget(button);
+   * ```
+   */
+  setTarget(target) {
+    this.#target = target;
+  }
+  /**
+   * Returns the current player element. This method will attempt to find the player by
+   * searching up from either the given `target` or default target set via `remote.setTarget`.
+   *
+   * @example
+   * ```ts
+   * const player = remote.getPlayer();
+   * ```
+   */
+  getPlayer(target) {
+    if (this.#player) return this.#player;
+    (target ?? this.#target)?.dispatchEvent(
+      new DOMEvent("find-media-player", {
+        detail: (player) => void (this.#player = player),
+        bubbles: true,
+        composed: true
+      })
+    );
+    return this.#player;
+  }
+  /**
+   * Set the current player element so the remote can support toggle methods such as
+   * `togglePaused` as they rely on the current media state.
+   */
+  setPlayer(player) {
+    this.#player = player;
+  }
+  /**
+   * Dispatch a request to start the media loading process. This will only work if the media
+   * player has been initialized with a custom loading strategy `load="custom">`.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoading(trigger) {
+    this.#dispatchRequest("media-start-loading", trigger);
+  }
+  /**
+   * Dispatch a request to start the poster loading process. This will only work if the media
+   * player has been initialized with a custom poster loading strategy `posterLoad="custom">`.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoadingPoster(trigger) {
+    this.#dispatchRequest("media-poster-start-loading", trigger);
+  }
+  /**
+   * Dispatch a request to connect to AirPlay.
+   *
+   * @see {@link https://www.apple.com/au/airplay}
+   */
+  requestAirPlay(trigger) {
+    this.#dispatchRequest("media-airplay-request", trigger);
+  }
+  /**
+   * Dispatch a request to connect to Google Cast.
+   *
+   * @see {@link https://developers.google.com/cast/docs/overview}
+   */
+  requestGoogleCast(trigger) {
+    this.#dispatchRequest("media-google-cast-request", trigger);
+  }
+  /**
+   * Dispatch a request to begin/resume media playback.
+   */
+  play(trigger) {
+    this.#dispatchRequest("media-play-request", trigger);
+  }
+  /**
+   * Dispatch a request to pause media playback.
+   */
+  pause(trigger) {
+    this.#dispatchRequest("media-pause-request", trigger);
+  }
+  /**
+   * Dispatch a request to set the media volume to mute (0).
+   */
+  mute(trigger) {
+    this.#dispatchRequest("media-mute-request", trigger);
+  }
+  /**
+   * Dispatch a request to unmute the media volume and set it back to it's previous state.
+   */
+  unmute(trigger) {
+    this.#dispatchRequest("media-unmute-request", trigger);
+  }
+  /**
+   * Dispatch a request to enter fullscreen.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  enterFullscreen(target, trigger) {
+    this.#dispatchRequest("media-enter-fullscreen-request", trigger, target);
+  }
+  /**
+   * Dispatch a request to exit fullscreen.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  exitFullscreen(target, trigger) {
+    this.#dispatchRequest("media-exit-fullscreen-request", trigger, target);
+  }
+  /**
+   * Dispatch a request to lock the screen orientation.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/screen-orientation#remote-control}
+   */
+  lockScreenOrientation(lockType, trigger) {
+    this.#dispatchRequest("media-orientation-lock-request", trigger, lockType);
+  }
+  /**
+   * Dispatch a request to unlock the screen orientation.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/screen-orientation#remote-control}
+   */
+  unlockScreenOrientation(trigger) {
+    this.#dispatchRequest("media-orientation-unlock-request", trigger);
+  }
+  /**
+   * Dispatch a request to enter picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  enterPictureInPicture(trigger) {
+    this.#dispatchRequest("media-enter-pip-request", trigger);
+  }
+  /**
+   * Dispatch a request to exit picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  exitPictureInPicture(trigger) {
+    this.#dispatchRequest("media-exit-pip-request", trigger);
+  }
+  /**
+   * Notify the media player that a seeking process is happening and to seek to the given `time`.
+   */
+  seeking(time, trigger) {
+    this.#dispatchRequest("media-seeking-request", trigger, time);
+  }
+  /**
+   * Notify the media player that a seeking operation has completed and to seek to the given `time`.
+   * This is generally called after a series of `remote.seeking()` calls.
+   */
+  seek(time, trigger) {
+    this.#dispatchRequest("media-seek-request", trigger, time);
+  }
+  seekToLiveEdge(trigger) {
+    this.#dispatchRequest("media-live-edge-request", trigger);
+  }
+  /**
+   * Dispatch a request to update the length of the media in seconds.
+   *
+   * @example
+   * ```ts
+   * remote.changeDuration(100); // 100 seconds
+   * ```
+   */
+  changeDuration(duration, trigger) {
+    this.#dispatchRequest("media-duration-change-request", trigger, duration);
+  }
+  /**
+   * Dispatch a request to update the clip start time. This is the time at which media playback
+   * should start at.
+   *
+   * @example
+   * ```ts
+   * remote.changeClipStart(100); // start at 100 seconds
+   * ```
+   */
+  changeClipStart(startTime, trigger) {
+    this.#dispatchRequest("media-clip-start-change-request", trigger, startTime);
+  }
+  /**
+   * Dispatch a request to update the clip end time. This is the time at which media playback
+   * should end at.
+   *
+   * @example
+   * ```ts
+   * remote.changeClipEnd(100); // end at 100 seconds
+   * ```
+   */
+  changeClipEnd(endTime, trigger) {
+    this.#dispatchRequest("media-clip-end-change-request", trigger, endTime);
+  }
+  /**
+   * Dispatch a request to update the media volume to the given `volume` level which is a value
+   * between 0 and 1.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/audio-gain#remote-control}
+   * @example
+   * ```ts
+   * remote.changeVolume(0); // 0%
+   * remote.changeVolume(0.05); // 5%
+   * remote.changeVolume(0.5); // 50%
+   * remote.changeVolume(0.75); // 70%
+   * remote.changeVolume(1); // 100%
+   * ```
+   */
+  changeVolume(volume, trigger) {
+    this.#dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
+  }
+  /**
+   * Dispatch a request to change the current audio track.
+   *
+   * @example
+   * ```ts
+   * remote.changeAudioTrack(1); // track at index 1
+   * ```
+   */
+  changeAudioTrack(index, trigger) {
+    this.#dispatchRequest("media-audio-track-change-request", trigger, index);
+  }
+  /**
+   * Dispatch a request to change the video quality. The special value `-1` represents auto quality
+   * selection.
+   *
+   * @example
+   * ```ts
+   * remote.changeQuality(-1); // auto
+   * remote.changeQuality(1); // quality at index 1
+   * ```
+   */
+  changeQuality(index, trigger) {
+    this.#dispatchRequest("media-quality-change-request", trigger, index);
+  }
+  /**
+   * Request auto quality selection.
+   */
+  requestAutoQuality(trigger) {
+    this.changeQuality(-1, trigger);
+  }
+  /**
+   * Dispatch a request to change the mode of the text track at the given index.
+   *
+   * @example
+   * ```ts
+   * remote.changeTextTrackMode(1, 'showing'); // track at index 1
+   * ```
+   */
+  changeTextTrackMode(index, mode, trigger) {
+    this.#dispatchRequest("media-text-track-change-request", trigger, {
+      index,
+      mode
+    });
+  }
+  /**
+   * Dispatch a request to change the media playback rate.
+   *
+   * @example
+   * ```ts
+   * remote.changePlaybackRate(0.5); // Half the normal speed
+   * remote.changePlaybackRate(1); // Normal speed
+   * remote.changePlaybackRate(1.5); // 50% faster than normal
+   * remote.changePlaybackRate(2); // Double the normal speed
+   * ```
+   */
+  changePlaybackRate(rate, trigger) {
+    this.#dispatchRequest("media-rate-change-request", trigger, rate);
+  }
+  /**
+   * Dispatch a request to change the media audio gain.
+   *
+   * @example
+   * ```ts
+   * remote.changeAudioGain(1); // Disable audio gain
+   * remote.changeAudioGain(1.5); // 50% louder
+   * remote.changeAudioGain(2); // 100% louder
+   * ```
+   */
+  changeAudioGain(gain, trigger) {
+    this.#dispatchRequest("media-audio-gain-change-request", trigger, gain);
+  }
+  /**
+   * Dispatch a request to resume idle tracking on controls.
+   */
+  resumeControls(trigger) {
+    this.#dispatchRequest("media-resume-controls-request", trigger);
+  }
+  /**
+   * Dispatch a request to pause controls idle tracking. Pausing tracking will result in the
+   * controls being visible until `remote.resumeControls()` is called. This method
+   * is generally used when building custom controls and you'd like to prevent the UI from
+   * disappearing.
+   *
+   * @example
+   * ```ts
+   * // Prevent controls hiding while menu is being interacted with.
+   * function onSettingsOpen() {
+   *   remote.pauseControls();
+   * }
+   *
+   * function onSettingsClose() {
+   *   remote.resumeControls();
+   * }
+   * ```
+   */
+  pauseControls(trigger) {
+    this.#dispatchRequest("media-pause-controls-request", trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media playback state.
+   */
+  togglePaused(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.paused) this.play(trigger);
+    else this.pause(trigger);
+  }
+  /**
+   * Dispatch a request to toggle the controls visibility.
+   */
+  toggleControls(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (!player.controls.showing) {
+      player.controls.show(0, trigger);
+    } else {
+      player.controls.hide(0, trigger);
+    }
+  }
+  /**
+   * Dispatch a request to toggle the media muted state.
+   */
+  toggleMuted(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.muted) this.unmute(trigger);
+    else this.mute(trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media fullscreen state.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  toggleFullscreen(target, trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.fullscreen) this.exitFullscreen(target, trigger);
+    else this.enterFullscreen(target, trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  togglePictureInPicture(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.pictureInPicture) this.exitPictureInPicture(trigger);
+    else this.enterPictureInPicture(trigger);
+  }
+  /**
+   * Show captions.
+   */
+  showCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    let tracks = player.state.textTracks, index = this.#prevTrackIndex;
+    if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
+      index = -1;
+    }
+    if (index === -1) {
+      index = tracks.findIndex((track) => isTrackCaptionKind(track) && track.default);
+    }
+    if (index === -1) {
+      index = tracks.findIndex((track) => isTrackCaptionKind(track));
+    }
+    if (index >= 0) this.changeTextTrackMode(index, "showing", trigger);
+    this.#prevTrackIndex = -1;
+  }
+  /**
+   * Turn captions off.
+   */
+  disableCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    const tracks = player.state.textTracks, track = player.state.textTrack;
+    if (track) {
+      const index = tracks.indexOf(track);
+      this.changeTextTrackMode(index, "disabled", trigger);
+      this.#prevTrackIndex = index;
+    }
+  }
+  /**
+   * Dispatch a request to toggle the current captions mode.
+   */
+  toggleCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.textTrack) {
+      this.disableCaptions();
+    } else {
+      this.showCaptions();
+    }
+  }
+  userPrefersLoopChange(prefersLoop, trigger) {
+    this.#dispatchRequest("media-user-loop-change-request", trigger, prefersLoop);
+  }
+  #dispatchRequest(type, trigger, detail) {
+    const request = new DOMEvent(type, {
+      bubbles: true,
+      composed: true,
+      cancelable: true,
+      detail,
+      trigger
+    });
+    let target = trigger?.target || null;
+    if (target && target instanceof Component) target = target.el;
+    const shouldUsePlayer = !target || target === document || target === window || target === document.body || this.#player?.el && target instanceof Node && !this.#player.el.contains(target);
+    target = shouldUsePlayer ? this.#target ?? this.getPlayer()?.el : target ?? this.#target;
+    if (this.#player) {
+      if (type === "media-play-request" && !this.#player.state.canLoad) {
+        target?.dispatchEvent(request);
+      } else {
+        this.#player.canPlayQueue.enqueue(type, () => target?.dispatchEvent(request));
+      }
+    } else {
+      target?.dispatchEvent(request);
+    }
+  }
+  #noPlayerWarning(method) {
+  }
+}
+
+class LocalMediaStorage {
+  playerId = "vds-player";
+  mediaId = null;
+  #data = {
+    volume: null,
+    muted: null,
+    audioGain: null,
+    time: null,
+    lang: null,
+    captions: null,
+    rate: null,
+    quality: null
+  };
+  async getVolume() {
+    return this.#data.volume;
+  }
+  async setVolume(volume) {
+    this.#data.volume = volume;
+    this.save();
+  }
+  async getMuted() {
+    return this.#data.muted;
+  }
+  async setMuted(muted) {
+    this.#data.muted = muted;
+    this.save();
+  }
+  async getTime() {
+    return this.#data.time;
+  }
+  async setTime(time, ended) {
+    const shouldClear = time < 0;
+    this.#data.time = !shouldClear ? time : null;
+    if (shouldClear || ended) this.saveTime();
+    else this.saveTimeThrottled();
+  }
+  async getLang() {
+    return this.#data.lang;
+  }
+  async setLang(lang) {
+    this.#data.lang = lang;
+    this.save();
+  }
+  async getCaptions() {
+    return this.#data.captions;
+  }
+  async setCaptions(enabled) {
+    this.#data.captions = enabled;
+    this.save();
+  }
+  async getPlaybackRate() {
+    return this.#data.rate;
+  }
+  async setPlaybackRate(rate) {
+    this.#data.rate = rate;
+    this.save();
+  }
+  async getAudioGain() {
+    return this.#data.audioGain;
+  }
+  async setAudioGain(gain) {
+    this.#data.audioGain = gain;
+    this.save();
+  }
+  async getVideoQuality() {
+    return this.#data.quality;
+  }
+  async setVideoQuality(quality) {
+    this.#data.quality = quality;
+    this.save();
+  }
+  onChange(src, mediaId, playerId = "vds-player") {
+    const savedData = playerId ? localStorage.getItem(playerId) : null, savedTime = mediaId ? localStorage.getItem(mediaId) : null;
+    this.playerId = playerId;
+    this.mediaId = mediaId;
+    this.#data = {
+      volume: null,
+      muted: null,
+      audioGain: null,
+      lang: null,
+      captions: null,
+      rate: null,
+      quality: null,
+      ...savedData ? JSON.parse(savedData) : {},
+      time: savedTime ? +savedTime : null
+    };
+  }
+  save() {
+    if (IS_SERVER || !this.playerId) return;
+    const data = JSON.stringify({ ...this.#data, time: void 0 });
+    localStorage.setItem(this.playerId, data);
+  }
+  saveTimeThrottled = functionThrottle(this.saveTime.bind(this), 1e3);
+  saveTime() {
+    if (IS_SERVER || !this.mediaId) return;
+    const data = (this.#data.time ?? 0).toString();
+    localStorage.setItem(this.mediaId, data);
+  }
+}
+
+const ADD = Symbol(0), REMOVE = Symbol(0), RESET = Symbol(0), SELECT = Symbol(0), READONLY = Symbol(0), SET_READONLY = Symbol(0), ON_RESET = Symbol(0), ON_REMOVE = Symbol(0), ON_USER_SELECT = Symbol(0);
+const ListSymbol = {
+  add: ADD,
+  remove: REMOVE,
+  reset: RESET,
+  select: SELECT,
+  readonly: READONLY,
+  setReadonly: SET_READONLY,
+  onReset: ON_RESET,
+  onRemove: ON_REMOVE,
+  onUserSelect: ON_USER_SELECT
+};
+
+class List extends EventsTarget {
+  items = [];
+  /** @internal */
+  [ListSymbol.readonly] = false;
+  get length() {
+    return this.items.length;
+  }
+  get readonly() {
+    return this[ListSymbol.readonly];
+  }
+  /**
+   * Returns the index of the first occurrence of the given item, or -1 if it is not present.
+   */
+  indexOf(item) {
+    return this.items.indexOf(item);
+  }
+  /**
+   * Returns an item matching the given `id`, or `null` if not present.
+   */
+  getById(id) {
+    if (id === "") return null;
+    return this.items.find((item) => item.id === id) ?? null;
+  }
+  /**
+   * Transform list to an array.
+   */
+  toArray() {
+    return [...this.items];
+  }
+  [Symbol.iterator]() {
+    return this.items.values();
+  }
+  /** @internal */
+  [ListSymbol.add](item, trigger) {
+    const index = this.items.length;
+    if (!("" + index in this)) {
+      Object.defineProperty(this, index, {
+        get() {
+          return this.items[index];
+        }
+      });
+    }
+    if (this.items.includes(item)) return;
+    this.items.push(item);
+    this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
+  }
+  /** @internal */
+  [ListSymbol.remove](item, trigger) {
+    const index = this.items.indexOf(item);
+    if (index >= 0) {
+      this[ListSymbol.onRemove]?.(item, trigger);
+      this.items.splice(index, 1);
+      this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
+    }
+  }
+  /** @internal */
+  [ListSymbol.reset](trigger) {
+    for (const item of [...this.items]) this[ListSymbol.remove](item, trigger);
+    this.items = [];
+    this[ListSymbol.setReadonly](false, trigger);
+    this[ListSymbol.onReset]?.();
+  }
+  /** @internal */
+  [ListSymbol.setReadonly](readonly, trigger) {
+    if (this[ListSymbol.readonly] === readonly) return;
+    this[ListSymbol.readonly] = readonly;
+    this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
+  }
+}
+
+const SELECTED = Symbol(0);
+class SelectList extends List {
+  get selected() {
+    return this.items.find((item) => item.selected) ?? null;
+  }
+  get selectedIndex() {
+    return this.items.findIndex((item) => item.selected);
+  }
+  /** @internal */
+  [ListSymbol.onRemove](item, trigger) {
+    this[ListSymbol.select](item, false, trigger);
+  }
+  /** @internal */
+  [ListSymbol.add](item, trigger) {
+    item[SELECTED] = false;
+    Object.defineProperty(item, "selected", {
+      get() {
+        return this[SELECTED];
+      },
+      set: (selected) => {
+        if (this.readonly) return;
+        this[ListSymbol.onUserSelect]?.();
+        this[ListSymbol.select](item, selected);
+      }
+    });
+    super[ListSymbol.add](item, trigger);
+  }
+  /** @internal */
+  [ListSymbol.select](item, selected, trigger) {
+    if (selected === item?.[SELECTED]) return;
+    const prev = this.selected;
+    if (item) item[SELECTED] = selected;
+    const changed = !selected ? prev === item : prev !== item;
+    if (changed) {
+      if (prev) prev[SELECTED] = false;
+      this.dispatchEvent(
+        new DOMEvent("change", {
+          detail: {
+            prev,
+            current: this.selected
+          },
+          trigger
+        })
+      );
+    }
+  }
+}
+
+class AudioTrackList extends SelectList {
+}
+
+function round(num, decimalPlaces = 2) {
+  return Number(num.toFixed(decimalPlaces));
+}
+function getNumberOfDecimalPlaces(num) {
+  return String(num).split(".")[1]?.length ?? 0;
+}
+function clampNumber(min, value, max) {
+  return Math.max(min, Math.min(max, value));
+}
+
+function isEventInside(el, event) {
+  const target = event.composedPath()[0];
+  return isDOMNode(target) && el.contains(target);
+}
+const rafJobs = /* @__PURE__ */ new Set();
+if (!IS_SERVER) {
+  let processJobs = function() {
+    for (const job of rafJobs) {
+      try {
+        job();
+      } catch (e) {
+      }
+    }
+    window.requestAnimationFrame(processJobs);
+  };
+  processJobs();
+}
+function scheduleRafJob(job) {
+  rafJobs.add(job);
+  return () => rafJobs.delete(job);
+}
+function setAttributeIfEmpty(target, name, value) {
+  if (!target.hasAttribute(name)) target.setAttribute(name, value);
+}
+function setARIALabel(target, $label) {
+  if (target.hasAttribute("aria-label") || target.hasAttribute("data-no-label")) return;
+  if (!isFunction($label)) {
+    setAttribute(target, "aria-label", $label);
+    return;
+  }
+  function updateAriaDescription() {
+    setAttribute(target, "aria-label", $label());
+  }
+  if (IS_SERVER) updateAriaDescription();
+  else effect(updateAriaDescription);
+}
+function isElementVisible(el) {
+  const style = getComputedStyle(el);
+  return style.display !== "none" && parseInt(style.opacity) > 0;
+}
+function checkVisibility(el) {
+  return !!el && ("checkVisibility" in el ? el.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true }) : isElementVisible(el));
+}
+function observeVisibility(el, callback) {
+  return scheduleRafJob(() => callback(checkVisibility(el)));
+}
+function isElementParent(owner, node, test) {
+  while (node) {
+    if (node === owner) {
+      return true;
+    } else if (test?.(node)) {
+      break;
+    } else {
+      node = node.parentElement;
+    }
+  }
+  return false;
+}
+function onPress(target, handler) {
+  return new EventsController(target).add("pointerup", (event) => {
+    if (event.button === 0 && !event.defaultPrevented) handler(event);
+  }).add("keydown", (event) => {
+    if (isKeyboardClick(event)) handler(event);
+  });
+}
+function isTouchPinchEvent(event) {
+  return isTouchEvent(event) && (event.touches.length > 1 || event.changedTouches.length > 1);
+}
+function requestScopedAnimationFrame(callback) {
+  if (IS_SERVER) return callback();
+  let scope = getScope(), id = window.requestAnimationFrame(() => {
+    scoped(callback, scope);
+    id = -1;
+  });
+  return () => void window.cancelAnimationFrame(id);
+}
+function autoPlacement(el, trigger, placement, {
+  offsetVarName,
+  xOffset,
+  yOffset,
+  ...options
+}) {
+  if (!el) return;
+  const floatingPlacement = placement.replace(" ", "-").replace("-center", "");
+  setStyle(el, "visibility", !trigger ? "hidden" : null);
+  if (!trigger) return;
+  let isTop = placement.includes("top");
+  const negateX = (x) => placement.includes("left") ? `calc(-1 * ${x})` : x, negateY = (y) => isTop ? `calc(-1 * ${y})` : y;
+  return autoUpdate(trigger, el, () => {
+    computePosition(trigger, el, {
+      placement: floatingPlacement,
+      middleware: [
+        ...options.middleware ?? [],
+        flip({ fallbackAxisSideDirection: "start", crossAxis: false }),
+        shift()
+      ],
+      ...options
+    }).then(({ x, y, middlewareData }) => {
+      const hasFlipped = !!middlewareData.flip?.index;
+      isTop = placement.includes(hasFlipped ? "bottom" : "top");
+      el.setAttribute(
+        "data-placement",
+        hasFlipped ? placement.startsWith("top") ? placement.replace("top", "bottom") : placement.replace("bottom", "top") : placement
+      );
+      Object.assign(el.style, {
+        top: `calc(${y + "px"} + ${negateY(
+          yOffset ? yOffset + "px" : `var(--${offsetVarName}-y-offset, 0px)`
+        )})`,
+        left: `calc(${x + "px"} + ${negateX(
+          xOffset ? xOffset + "px" : `var(--${offsetVarName}-x-offset, 0px)`
+        )})`
+      });
+    });
+  });
+}
+function hasAnimation(el) {
+  const styles = getComputedStyle(el);
+  return styles.animationName !== "none";
+}
+function isHTMLElement(el) {
+  return el instanceof HTMLElement;
+}
+
+class NativeTextRenderer {
+  priority = 0;
+  #display = true;
+  #video = null;
+  #track = null;
+  #tracks = /* @__PURE__ */ new Set();
+  canRender(_, video) {
+    return !!video;
+  }
+  attach(video) {
+    this.#video = video;
+    if (video) video.textTracks.onchange = this.#onChange.bind(this);
+  }
+  addTrack(track) {
+    this.#tracks.add(track);
+    this.#attachTrack(track);
+  }
+  removeTrack(track) {
+    track[TextTrackSymbol.native]?.remove?.();
+    track[TextTrackSymbol.native] = null;
+    this.#tracks.delete(track);
+  }
+  changeTrack(track) {
+    const current = track?.[TextTrackSymbol.native];
+    if (current && current.track.mode !== "showing") {
+      current.track.mode = "showing";
+    }
+    this.#track = track;
+  }
+  setDisplay(display) {
+    this.#display = display;
+    this.#onChange();
+  }
+  detach() {
+    if (this.#video) this.#video.textTracks.onchange = null;
+    for (const track of this.#tracks) this.removeTrack(track);
+    this.#tracks.clear();
+    this.#video = null;
+    this.#track = null;
+  }
+  #attachTrack(track) {
+    if (!this.#video) return;
+    const el = track[TextTrackSymbol.native] ??= this.#createTrackElement(track);
+    if (isHTMLElement(el)) {
+      this.#video.append(el);
+      el.track.mode = el.default ? "showing" : "disabled";
+    }
+  }
+  #createTrackElement(track) {
+    const el = document.createElement("track"), isDefault = track.default || track.mode === "showing", isSupported = track.src && track.type === "vtt";
+    el.id = track.id;
+    el.src = isSupported ? track.src : "";
+    el.label = track.label;
+    el.kind = track.kind;
+    el.default = isDefault;
+    track.language && (el.srclang = track.language);
+    if (isDefault && !isSupported) {
+      this.#copyCues(track, el.track);
+    }
+    return el;
+  }
+  #copyCues(track, native) {
+    if (track.src && track.type === "vtt" || native.cues?.length) return;
+    for (const cue of track.cues) native.addCue(cue);
+  }
+  #onChange(event) {
+    for (const track of this.#tracks) {
+      const native = track[TextTrackSymbol.native];
+      if (!native) continue;
+      if (!this.#display) {
+        native.track.mode = native.managed ? "hidden" : "disabled";
+        continue;
+      }
+      const isShowing = native.track.mode === "showing";
+      if (isShowing) this.#copyCues(track, native.track);
+      track.setMode(isShowing ? "showing" : "disabled", event);
+    }
+  }
+}
+
+class TextRenderers {
+  #video = null;
+  #textTracks;
+  #renderers = [];
+  #media;
+  #nativeDisplay = false;
+  #nativeRenderer = null;
+  #customRenderer = null;
+  constructor(media) {
+    this.#media = media;
+    const textTracks = media.textTracks;
+    this.#textTracks = textTracks;
+    effect(this.#watchControls.bind(this));
+    onDispose(this.#detach.bind(this));
+    new EventsController(textTracks).add("add", this.#onAddTrack.bind(this)).add("remove", this.#onRemoveTrack.bind(this)).add("mode-change", this.#update.bind(this));
+  }
+  #watchControls() {
+    const { nativeControls } = this.#media.$state;
+    this.#nativeDisplay = nativeControls();
+    this.#update();
+  }
+  add(renderer) {
+    this.#renderers.push(renderer);
+    untrack(this.#update.bind(this));
+  }
+  remove(renderer) {
+    renderer.detach();
+    this.#renderers.splice(this.#renderers.indexOf(renderer), 1);
+    untrack(this.#update.bind(this));
+  }
+  /** @internal */
+  attachVideo(video) {
+    requestAnimationFrame(() => {
+      this.#video = video;
+      if (video) {
+        this.#nativeRenderer = new NativeTextRenderer();
+        this.#nativeRenderer.attach(video);
+        for (const track of this.#textTracks) this.#addNativeTrack(track);
+      }
+      this.#update();
+    });
+  }
+  #addNativeTrack(track) {
+    if (!isTrackCaptionKind(track)) return;
+    this.#nativeRenderer?.addTrack(track);
+  }
+  #removeNativeTrack(track) {
+    if (!isTrackCaptionKind(track)) return;
+    this.#nativeRenderer?.removeTrack(track);
+  }
+  #onAddTrack(event) {
+    this.#addNativeTrack(event.detail);
+  }
+  #onRemoveTrack(event) {
+    this.#removeNativeTrack(event.detail);
+  }
+  #update() {
+    const currentTrack = this.#textTracks.selected;
+    if (this.#video && (this.#nativeDisplay || currentTrack?.[TextTrackSymbol.nativeHLS])) {
+      this.#customRenderer?.changeTrack(null);
+      this.#nativeRenderer?.setDisplay(true);
+      this.#nativeRenderer?.changeTrack(currentTrack);
+      return;
+    }
+    this.#nativeRenderer?.setDisplay(false);
+    this.#nativeRenderer?.changeTrack(null);
+    if (!currentTrack) {
+      this.#customRenderer?.changeTrack(null);
+      return;
+    }
+    const customRenderer = this.#renderers.sort((a, b) => a.priority - b.priority).find((renderer) => renderer.canRender(currentTrack, this.#video));
+    if (this.#customRenderer !== customRenderer) {
+      this.#customRenderer?.detach();
+      customRenderer?.attach(this.#video);
+      this.#customRenderer = customRenderer ?? null;
+    }
+    customRenderer?.changeTrack(currentTrack);
+  }
+  #detach() {
+    this.#nativeRenderer?.detach();
+    this.#nativeRenderer = null;
+    this.#customRenderer?.detach();
+    this.#customRenderer = null;
+  }
+}
+
+class TextTrackList extends List {
+  #canLoad = false;
+  #defaults = {};
+  #storage = null;
+  #preferredLang = null;
+  /** @internal */
+  [TextTrackSymbol.crossOrigin];
+  constructor() {
+    super();
+  }
+  get selected() {
+    const track = this.items.find((t) => t.mode === "showing" && isTrackCaptionKind(t));
+    return track ?? null;
+  }
+  get selectedIndex() {
+    const selected = this.selected;
+    return selected ? this.indexOf(selected) : -1;
+  }
+  get preferredLang() {
+    return this.#preferredLang;
+  }
+  set preferredLang(lang) {
+    this.#preferredLang = lang;
+    this.#saveLang(lang);
+  }
+  add(init, trigger) {
+    const isTrack = init instanceof TextTrack, track = isTrack ? init : new TextTrack(init), kind = init.kind === "captions" || init.kind === "subtitles" ? "captions" : init.kind;
+    if (this.#defaults[kind] && init.default) delete init.default;
+    track.addEventListener("mode-change", this.#onTrackModeChangeBind);
+    this[ListSymbol.add](track, trigger);
+    track[TextTrackSymbol.crossOrigin] = this[TextTrackSymbol.crossOrigin];
+    if (this.#canLoad) track[TextTrackSymbol.canLoad]();
+    if (init.default) this.#defaults[kind] = track;
+    this.#selectTracks();
+    return this;
+  }
+  remove(track, trigger) {
+    this.#pendingRemoval = track;
+    if (!this.items.includes(track)) return;
+    if (track === this.#defaults[track.kind]) delete this.#defaults[track.kind];
+    track.mode = "disabled";
+    track[TextTrackSymbol.onModeChange] = null;
+    track.removeEventListener("mode-change", this.#onTrackModeChangeBind);
+    this[ListSymbol.remove](track, trigger);
+    this.#pendingRemoval = null;
+    return this;
+  }
+  clear(trigger) {
+    for (const track of [...this.items]) {
+      this.remove(track, trigger);
+    }
+    return this;
+  }
+  getByKind(kind) {
+    const kinds = Array.isArray(kind) ? kind : [kind];
+    return this.items.filter((track) => kinds.includes(track.kind));
+  }
+  /** @internal */
+  [TextTrackSymbol.canLoad]() {
+    if (this.#canLoad) return;
+    for (const track of this.items) track[TextTrackSymbol.canLoad]();
+    this.#canLoad = true;
+    this.#selectTracks();
+  }
+  #selectTracks = functionDebounce(async () => {
+    if (!this.#canLoad) return;
+    if (!this.#preferredLang && this.#storage) {
+      this.#preferredLang = await this.#storage.getLang();
+    }
+    const showCaptions = await this.#storage?.getCaptions(), kinds = [
+      ["captions", "subtitles"],
+      "chapters",
+      "descriptions",
+      "metadata"
+    ];
+    for (const kind of kinds) {
+      const tracks = this.getByKind(kind);
+      if (tracks.find((t) => t.mode === "showing")) continue;
+      const preferredTrack = this.#preferredLang ? tracks.find((track2) => track2.language === this.#preferredLang) : null;
+      const defaultTrack = isArray(kind) ? this.#defaults[kind.find((kind2) => this.#defaults[kind2]) || ""] : this.#defaults[kind];
+      const track = preferredTrack ?? defaultTrack, isCaptionsKind = track && isTrackCaptionKind(track);
+      if (track && (!isCaptionsKind || showCaptions !== false)) {
+        track.mode = "showing";
+        if (isCaptionsKind) this.#saveCaptionsTrack(track);
+      }
+    }
+  }, 300);
+  #pendingRemoval = null;
+  #onTrackModeChangeBind = this.#onTrackModeChange.bind(this);
+  #onTrackModeChange(event) {
+    const track = event.detail;
+    if (this.#storage && isTrackCaptionKind(track) && track !== this.#pendingRemoval) {
+      this.#saveCaptionsTrack(track);
+    }
+    if (track.mode === "showing") {
+      const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
+      for (const t of this.items) {
+        if (t.mode === "showing" && t != track && kinds.includes(t.kind)) {
+          t.mode = "disabled";
+        }
+      }
+    }
+    this.dispatchEvent(
+      new DOMEvent("mode-change", {
+        detail: event.detail,
+        trigger: event
+      })
+    );
+  }
+  #saveCaptionsTrack(track) {
+    if (track.mode !== "disabled") {
+      this.#saveLang(track.language);
+    }
+    this.#storage?.setCaptions?.(track.mode === "showing");
+  }
+  #saveLang(lang) {
+    this.#storage?.setLang?.(this.#preferredLang = lang);
+  }
+  setStorage(storage) {
+    this.#storage = storage;
+  }
+}
+
+const SET_AUTO = Symbol(0), ENABLE_AUTO = Symbol(0);
+const QualitySymbol = {
+  setAuto: SET_AUTO,
+  enableAuto: ENABLE_AUTO
+};
+
+class VideoQualityList extends SelectList {
+  #auto = false;
+  /**
+   * Configures quality switching:
+   *
+   * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
+   * request if any, flush the whole buffer, and fetch fragment matching with current position
+   * and requested quality level.
+   *
+   * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
+   * already buffered next fragment.
+   *
+   * - `load`: Set quality level for next loaded fragment.
+   *
+   * @see {@link https://www.vidstack.io/docs/player/api/video-quality#switch}
+   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
+   */
+  switch = "current";
+  /**
+   * Whether automatic quality selection is enabled.
+   */
+  get auto() {
+    return this.#auto || this.readonly;
+  }
+  /** @internal */
+  [QualitySymbol.enableAuto];
+  /** @internal */
+  [ListSymbol.onUserSelect]() {
+    this[QualitySymbol.setAuto](false);
+  }
+  /** @internal */
+  [ListSymbol.onReset](trigger) {
+    this[QualitySymbol.enableAuto] = void 0;
+    this[QualitySymbol.setAuto](false, trigger);
+  }
+  /**
+   * Request automatic quality selection (if supported). This will be a no-op if the list is
+   * `readonly` as that already implies auto-selection.
+   */
+  autoSelect(trigger) {
+    if (this.readonly || this.#auto || !this[QualitySymbol.enableAuto]) return;
+    this[QualitySymbol.enableAuto]?.(trigger);
+    this[QualitySymbol.setAuto](true, trigger);
+  }
+  getBySrc(src) {
+    return this.items.find((quality) => quality.src === src);
+  }
+  /** @internal */
+  [QualitySymbol.setAuto](auto, trigger) {
+    if (this.#auto === auto) return;
+    this.#auto = auto;
+    this.dispatchEvent(
+      new DOMEvent("auto-change", {
+        detail: auto,
+        trigger
+      })
+    );
+  }
+}
+
+function sortVideoQualities(qualities, desc) {
+  return [...qualities].sort(desc ? compareVideoQualityDesc : compareVideoQualityAsc);
+}
+function compareVideoQualityAsc(a, b) {
+  return a.height === b.height ? (a.bitrate ?? 0) - (b.bitrate ?? 0) : a.height - b.height;
+}
+function compareVideoQualityDesc(a, b) {
+  return b.height === a.height ? (b.bitrate ?? 0) - (a.bitrate ?? 0) : b.height - a.height;
+}
+
+function isAudioProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "AUDIO";
+}
+function isVideoProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "VIDEO";
+}
+function isHLSProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "HLS";
+}
+function isDASHProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "DASH";
+}
+function isYouTubeProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "YOUTUBE";
+}
+function isVimeoProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "VIMEO";
+}
+function isGoogleCastProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "GOOGLE_CAST";
+}
+function isHTMLAudioElement(element) {
+  return !IS_SERVER && element instanceof HTMLAudioElement;
+}
+function isHTMLVideoElement(element) {
+  return !IS_SERVER && element instanceof HTMLVideoElement;
+}
+function isHTMLMediaElement(element) {
+  return isHTMLAudioElement(element) || isHTMLVideoElement(element);
+}
+function isHTMLIFrameElement(element) {
+  return !IS_SERVER && element instanceof HTMLIFrameElement;
+}
+
+class MediaPlayerController extends ViewController {
+}
+
+const MEDIA_KEY_SHORTCUTS = {
+  togglePaused: "k Space",
+  toggleMuted: "m",
+  toggleFullscreen: "f",
+  togglePictureInPicture: "i",
+  toggleCaptions: "c",
+  seekBackward: "j J ArrowLeft",
+  seekForward: "l L ArrowRight",
+  volumeUp: "ArrowUp",
+  volumeDown: "ArrowDown",
+  speedUp: ">",
+  slowDown: "<"
+};
+const MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Ctrl"]), BUTTON_SELECTORS = 'button, [role="button"]', IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"], [role="timer"]';
+class MediaKeyboardController extends MediaPlayerController {
+  #media;
+  constructor(media) {
+    super();
+    this.#media = media;
+  }
+  onConnect() {
+    effect(this.#onTargetChange.bind(this));
+  }
+  #onTargetChange() {
+    const { keyDisabled, keyTarget } = this.$props;
+    if (keyDisabled()) return;
+    const target = keyTarget() === "player" ? this.el : document, $active = signal(false);
+    if (target === this.el) {
+      new EventsController(this.el).add("focusin", () => $active.set(true)).add("focusout", (event) => {
+        if (!this.el.contains(event.target)) $active.set(false);
+      });
+    } else {
+      if (!peek($active)) $active.set(document.querySelector("[data-media-player]") === this.el);
+      listenEvent(document, "focusin", (event) => {
+        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
+        if (activePlayer !== void 0) $active.set(this.el === activePlayer);
+      });
+    }
+    effect(() => {
+      if (!$active()) return;
+      new EventsController(target).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("keydown", this.#onPreventVideoKeys.bind(this), { capture: true });
+    });
+  }
+  #onKeyUp(event) {
+    const focusedEl = document.activeElement;
+    if (!event.key || !this.$state.canSeek() || focusedEl?.matches(IGNORE_SELECTORS)) {
+      return;
+    }
+    let { method, value } = this.#getMatchingMethod(event);
+    if (!isString(value) && !isArray(value)) {
+      value?.onKeyUp?.({
+        event,
+        player: this.#media.player,
+        remote: this.#media.remote
+      });
+      value?.callback?.(event, this.#media.remote);
+      return;
+    }
+    if (method?.startsWith("seek")) {
+      event.preventDefault();
+      event.stopPropagation();
+      if (this.#timeSlider) {
+        this.#forwardTimeKeyboardEvent(event, method === "seekForward");
+        this.#timeSlider = null;
+      } else {
+        this.#media.remote.seek(this.#seekTotal, event);
+        this.#seekTotal = void 0;
+      }
+    }
+    if (method?.startsWith("volume")) {
+      const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
+      volumeSlider?.dispatchEvent(
+        new KeyboardEvent("keyup", {
+          key: method === "volumeUp" ? "Up" : "Down",
+          shiftKey: event.shiftKey,
+          trigger: event
+        })
+      );
+    }
+  }
+  #onKeyDown(event) {
+    if (!event.key || MODIFIER_KEYS.has(event.key)) return;
+    const focusedEl = document.activeElement;
+    if (focusedEl?.matches(IGNORE_SELECTORS) || isKeyboardClick(event) && focusedEl?.matches(BUTTON_SELECTORS)) {
+      return;
+    }
+    let { method, value } = this.#getMatchingMethod(event), isNumberPress = !event.metaKey && /^[0-9]$/.test(event.key);
+    if (!isString(value) && !isArray(value) && !isNumberPress) {
+      value?.onKeyDown?.({
+        event,
+        player: this.#media.player,
+        remote: this.#media.remote
+      });
+      value?.callback?.(event, this.#media.remote);
+      return;
+    }
+    if (!method && isNumberPress) {
+      event.preventDefault();
+      event.stopPropagation();
+      this.#media.remote.seek(this.$state.duration() / 10 * Number(event.key), event);
+      return;
+    }
+    if (!method) return;
+    event.preventDefault();
+    event.stopPropagation();
+    switch (method) {
+      case "seekForward":
+      case "seekBackward":
+        this.#seeking(event, method, method === "seekForward");
+        break;
+      case "volumeUp":
+      case "volumeDown":
+        const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
+        if (volumeSlider) {
+          volumeSlider.dispatchEvent(
+            new KeyboardEvent("keydown", {
+              key: method === "volumeUp" ? "Up" : "Down",
+              shiftKey: event.shiftKey,
+              trigger: event
+            })
+          );
+        } else {
+          const value2 = event.shiftKey ? 0.1 : 0.05;
+          this.#media.remote.changeVolume(
+            this.$state.volume() + (method === "volumeUp" ? +value2 : -value2),
+            event
+          );
+        }
+        break;
+      case "toggleFullscreen":
+        this.#media.remote.toggleFullscreen("prefer-media", event);
+        break;
+      case "speedUp":
+      case "slowDown":
+        const playbackRate = this.$state.playbackRate();
+        this.#media.remote.changePlaybackRate(
+          Math.max(0.25, Math.min(2, playbackRate + (method === "speedUp" ? 0.25 : -0.25))),
+          event
+        );
+        break;
+      default:
+        this.#media.remote[method]?.(event);
+    }
+    this.$state.lastKeyboardAction.set({
+      action: method,
+      event
+    });
+  }
+  #onPreventVideoKeys(event) {
+    if (isHTMLMediaElement(event.target) && this.#getMatchingMethod(event).method) {
+      event.preventDefault();
+    }
+  }
+  #getMatchingMethod(event) {
+    const keyShortcuts = {
+      ...this.$props.keyShortcuts(),
+      ...this.#media.ariaKeys
+    };
+    const method = Object.keys(keyShortcuts).find((method2) => {
+      const value = keyShortcuts[method2], keys = isArray(value) ? value.join(" ") : isString(value) ? value : value?.keys;
+      const combinations = (isArray(keys) ? keys : keys?.split(" "))?.map(
+        (key) => replaceSymbolKeys(key).replace(/Control/g, "Ctrl").split("+")
+      );
+      return combinations?.some((combo) => {
+        const modifierKeys = new Set(combo.filter((key) => MODIFIER_KEYS.has(key)));
+        for (const modKey of MODIFIER_KEYS) {
+          const modKeyProp = modKey.toLowerCase() + "Key";
+          if (!modifierKeys.has(modKey) && event[modKeyProp]) {
+            return false;
+          }
+        }
+        return combo.every((key) => {
+          return MODIFIER_KEYS.has(key) ? event[key.toLowerCase() + "Key"] : event.key === key.replace("Space", " ");
+        });
+      });
+    });
+    return {
+      method,
+      value: method ? keyShortcuts[method] : null
+    };
+  }
+  #seekTotal;
+  #calcSeekAmount(event, type) {
+    const seekBy = event.shiftKey ? 10 : 5;
+    return this.#seekTotal = Math.max(
+      0,
+      Math.min(
+        (this.#seekTotal ?? this.$state.currentTime()) + (type === "seekForward" ? +seekBy : -seekBy),
+        this.$state.duration()
+      )
+    );
+  }
+  #timeSlider = null;
+  #forwardTimeKeyboardEvent(event, forward) {
+    this.#timeSlider?.dispatchEvent(
+      new KeyboardEvent(event.type, {
+        key: !forward ? "Left" : "Right",
+        shiftKey: event.shiftKey,
+        trigger: event
+      })
+    );
+  }
+  #seeking(event, type, forward) {
+    if (!this.$state.canSeek()) return;
+    if (!this.#timeSlider) {
+      this.#timeSlider = this.el.querySelector("[data-media-time-slider]");
+    }
+    if (this.#timeSlider) {
+      this.#forwardTimeKeyboardEvent(event, forward);
+    } else {
+      this.#media.remote.seeking(this.#calcSeekAmount(event, type), event);
+    }
+  }
+}
+const SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
+function replaceSymbolKeys(key) {
+  return key.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
+}
+
+class ARIAKeyShortcuts extends ViewController {
+  #shortcut;
+  constructor(shortcut) {
+    super();
+    this.#shortcut = shortcut;
+  }
+  onAttach(el) {
+    const { $props, ariaKeys } = useMediaContext(), keys = el.getAttribute("aria-keyshortcuts");
+    if (keys) {
+      ariaKeys[this.#shortcut] = keys;
+      if (!IS_SERVER) {
+        onDispose(() => {
+          delete ariaKeys[this.#shortcut];
+        });
+      }
+      return;
+    }
+    const shortcuts = $props.keyShortcuts()[this.#shortcut];
+    if (shortcuts) {
+      const keys2 = isArray(shortcuts) ? shortcuts.join(" ") : isString(shortcuts) ? shortcuts : shortcuts?.keys;
+      el.setAttribute("aria-keyshortcuts", isArray(keys2) ? keys2.join(" ") : keys2);
+    }
+  }
+}
+
+class MediaControls extends MediaPlayerController {
+  #idleTimer = -2;
+  #pausedTracking = false;
+  #hideOnMouseLeave = signal(false);
+  #isMouseOutside = signal(false);
+  #focusedItem = null;
+  #canIdle = signal(true);
+  /**
+   * The default amount of delay in milliseconds while media playback is progressing without user
+   * activity to indicate an idle state (i.e., hide controls).
+   *
+   * @defaultValue 2000
+   */
+  defaultDelay = 2e3;
+  /**
+   * Whether controls can hide after a delay in user interaction. If this is false, controls will
+   * not hide and be user controlled.
+   */
+  get canIdle() {
+    return this.#canIdle();
+  }
+  set canIdle(canIdle) {
+    this.#canIdle.set(canIdle);
+  }
+  /**
+   * Whether controls visibility should be toggled when the mouse enters and leaves the player
+   * container.
+   *
+   * @defaultValue false
+   */
+  get hideOnMouseLeave() {
+    const { hideControlsOnMouseLeave } = this.$props;
+    return this.#hideOnMouseLeave() || hideControlsOnMouseLeave();
+  }
+  set hideOnMouseLeave(hide) {
+    this.#hideOnMouseLeave.set(hide);
+  }
+  /**
+   * Whether media controls are currently visible.
+   */
+  get showing() {
+    return this.$state.controlsVisible();
+  }
+  /**
+   * Show controls.
+   */
+  show(delay = 0, trigger) {
+    this.#clearIdleTimer();
+    if (!this.#pausedTracking) {
+      this.#changeVisibility(true, delay, trigger);
+    }
+  }
+  /**
+   * Hide controls.
+   */
+  hide(delay = this.defaultDelay, trigger) {
+    this.#clearIdleTimer();
+    if (!this.#pausedTracking) {
+      this.#changeVisibility(false, delay, trigger);
+    }
+  }
+  /**
+   * Whether all idle tracking on controls should be paused until resumed again.
+   */
+  pause(trigger) {
+    this.#pausedTracking = true;
+    this.#clearIdleTimer();
+    this.#changeVisibility(true, 0, trigger);
+  }
+  resume(trigger) {
+    this.#pausedTracking = false;
+    if (this.$state.paused()) return;
+    this.#changeVisibility(false, this.defaultDelay, trigger);
+  }
+  onConnect() {
+    effect(this.#init.bind(this));
+  }
+  #init() {
+    const { viewType } = this.$state;
+    if (!this.el || !this.#canIdle()) return;
+    if (viewType() === "audio") {
+      this.show();
+      return;
+    }
+    effect(this.#watchMouse.bind(this));
+    effect(this.#watchPaused.bind(this));
+    const onPlay = this.#onPlay.bind(this), onPause = this.#onPause.bind(this), onEnd = this.#onEnd.bind(this);
+    new EventsController(this.el).add("can-play", (event) => this.show(0, event)).add("play", onPlay).add("pause", onPause).add("end", onEnd).add("auto-play-fail", onPause);
+  }
+  #watchMouse() {
+    if (!this.el) return;
+    const { started, pointer, paused } = this.$state;
+    if (!started() || pointer() !== "fine") return;
+    const events = new EventsController(this.el), shouldHideOnMouseLeave = this.hideOnMouseLeave;
+    if (!shouldHideOnMouseLeave || !this.#isMouseOutside()) {
+      effect(() => {
+        if (!paused()) events.add("pointermove", this.#onStopIdle.bind(this));
+      });
+    }
+    if (shouldHideOnMouseLeave) {
+      events.add("mouseenter", this.#onMouseEnter.bind(this)).add("mouseleave", this.#onMouseLeave.bind(this));
+    }
+  }
+  #watchPaused() {
+    const { paused, started, autoPlayError } = this.$state;
+    if (paused() || autoPlayError() && !started()) return;
+    const onStopIdle = this.#onStopIdle.bind(this);
+    effect(() => {
+      if (!this.el) return;
+      const pointer = this.$state.pointer(), isTouch = pointer === "coarse", events = new EventsController(this.el), eventTypes = [isTouch ? "touchend" : "pointerup", "keydown"];
+      for (const eventType of eventTypes) {
+        events.add(eventType, onStopIdle, { passive: false });
+      }
+    });
+  }
+  #onPlay(event) {
+    if (event.triggers.hasType("ended")) return;
+    this.show(0, event);
+    this.hide(void 0, event);
+  }
+  #onPause(event) {
+    this.show(0, event);
+  }
+  #onEnd(event) {
+    const { loop } = this.$state;
+    if (loop()) this.hide(0, event);
+  }
+  #onMouseEnter(event) {
+    this.#isMouseOutside.set(false);
+    this.show(0, event);
+    this.hide(void 0, event);
+  }
+  #onMouseLeave(event) {
+    this.#isMouseOutside.set(true);
+    this.hide(0, event);
+  }
+  #clearIdleTimer() {
+    window.clearTimeout(this.#idleTimer);
+    this.#idleTimer = -1;
+  }
+  #onStopIdle(event) {
+    if (
+      // @ts-expect-error
+      event.MEDIA_GESTURE || this.#pausedTracking || isTouchPinchEvent(event)
+    ) {
+      return;
+    }
+    if (isKeyboardEvent(event)) {
+      if (event.key === "Escape") {
+        this.el?.focus();
+        this.#focusedItem = null;
+      } else if (this.#focusedItem) {
+        event.preventDefault();
+        requestAnimationFrame(() => {
+          this.#focusedItem?.focus();
+          this.#focusedItem = null;
+        });
+      }
+    }
+    this.show(0, event);
+    this.hide(this.defaultDelay, event);
+  }
+  #changeVisibility(visible, delay, trigger) {
+    if (delay === 0) {
+      this.#onChange(visible, trigger);
+      return;
+    }
+    this.#idleTimer = window.setTimeout(() => {
+      if (!this.scope) return;
+      this.#onChange(visible && !this.#pausedTracking, trigger);
+    }, delay);
+  }
+  #onChange(visible, trigger) {
+    if (this.$state.controlsVisible() === visible) return;
+    this.$state.controlsVisible.set(visible);
+    if (!visible && document.activeElement && this.el?.contains(document.activeElement)) {
+      this.#focusedItem = document.activeElement;
+      requestAnimationFrame(() => {
+        this.el?.focus({ preventScroll: true });
+      });
+    }
+    this.dispatch("controls-change", {
+      detail: visible,
+      trigger
+    });
+  }
+}
+
+const CAN_FULLSCREEN = fscreen.fullscreenEnabled;
+class FullscreenController extends ViewController {
+  /**
+   * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be
+   * listened to globally on the document so we need to know if they relate to the current host
+   * element or not.
+   */
+  #listening = false;
+  #active = false;
+  get active() {
+    return this.#active;
+  }
+  get supported() {
+    return CAN_FULLSCREEN;
+  }
+  onConnect() {
+    new EventsController(fscreen).add("fullscreenchange", this.#onChange.bind(this)).add("fullscreenerror", this.#onError.bind(this));
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  async #onDisconnect() {
+    if (CAN_FULLSCREEN) await this.exit();
+  }
+  #onChange(event) {
+    const active = isFullscreen(this.el);
+    if (active === this.#active) return;
+    if (!active) this.#listening = false;
+    this.#active = active;
+    this.dispatch("fullscreen-change", { detail: active, trigger: event });
+  }
+  #onError(event) {
+    if (!this.#listening) return;
+    this.dispatch("fullscreen-error", { detail: null, trigger: event });
+    this.#listening = false;
+  }
+  async enter() {
+    try {
+      this.#listening = true;
+      if (!this.el || isFullscreen(this.el)) return;
+      assertFullscreenAPI();
+      return fscreen.requestFullscreen(this.el);
+    } catch (error) {
+      this.#listening = false;
+      throw error;
+    }
+  }
+  async exit() {
+    if (!this.el || !isFullscreen(this.el)) return;
+    assertFullscreenAPI();
+    return fscreen.exitFullscreen();
+  }
+}
+function canFullscreen() {
+  return CAN_FULLSCREEN;
+}
+function isFullscreen(host) {
+  if (fscreen.fullscreenElement === host) return true;
+  try {
+    return host.matches(
+      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
+      fscreen.fullscreenPseudoClass
+    );
+  } catch (error) {
+    return false;
+  }
+}
+function assertFullscreenAPI() {
+  if (CAN_FULLSCREEN) return;
+  throw Error(
+    "[vidstack] no fullscreen API"
+  );
+}
+
+class ScreenOrientationController extends ViewController {
+  #type = signal(this.#getScreenOrientation());
+  #locked = signal(false);
+  #currentLock;
+  /**
+   * The current screen orientation type.
+   *
+   * @signal
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
+   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
+   */
+  get type() {
+    return this.#type();
+  }
+  /**
+   * Whether the screen orientation is currently locked.
+   *
+   * @signal
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
+   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
+   */
+  get locked() {
+    return this.#locked();
+  }
+  /**
+   * Whether the viewport is in a portrait orientation.
+   *
+   * @signal
+   */
+  get portrait() {
+    return this.#type().startsWith("portrait");
+  }
+  /**
+   * Whether the viewport is in a landscape orientation.
+   *
+   * @signal
+   */
+  get landscape() {
+    return this.#type().startsWith("landscape");
+  }
+  /**
+   * Whether the native Screen Orientation API is available.
+   */
+  static supported = canOrientScreen();
+  /**
+   * Whether the native Screen Orientation API is available.
+   */
+  get supported() {
+    return ScreenOrientationController.supported;
+  }
+  onConnect() {
+    if (this.supported) {
+      listenEvent(screen.orientation, "change", this.#onOrientationChange.bind(this));
+    } else {
+      const query = window.matchMedia("(orientation: landscape)");
+      query.onchange = this.#onOrientationChange.bind(this);
+      onDispose(() => query.onchange = null);
+    }
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  async #onDisconnect() {
+    if (this.supported && this.#locked()) await this.unlock();
+  }
+  #onOrientationChange(event) {
+    this.#type.set(this.#getScreenOrientation());
+    this.dispatch("orientation-change", {
+      detail: {
+        orientation: peek(this.#type),
+        lock: this.#currentLock
+      },
+      trigger: event
+    });
+  }
+  /**
+   * Locks the orientation of the screen to the desired orientation type using the
+   * Screen Orientation API.
+   *
+   * @param lockType - The screen lock orientation type.
+   * @throws Error - If screen orientation API is unavailable.
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
+   * @see {@link https://w3c.github.io/screen-orientation}
+   */
+  async lock(lockType) {
+    if (peek(this.#locked) || this.#currentLock === lockType) return;
+    this.#assertScreenOrientationAPI();
+    await screen.orientation.lock(lockType);
+    this.#locked.set(true);
+    this.#currentLock = lockType;
+  }
+  /**
+   * Unlocks the orientation of the screen to it's default state using the Screen Orientation
+   * API. This method will throw an error if the API is unavailable.
+   *
+   * @throws Error - If screen orientation API is unavailable.
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
+   * @see {@link https://w3c.github.io/screen-orientation}
+   */
+  async unlock() {
+    if (!peek(this.#locked)) return;
+    this.#assertScreenOrientationAPI();
+    this.#currentLock = void 0;
+    await screen.orientation.unlock();
+    this.#locked.set(false);
+  }
+  #assertScreenOrientationAPI() {
+    if (this.supported) return;
+    throw Error(
+      "[vidstack] no orientation API"
+    );
+  }
+  #getScreenOrientation() {
+    if (IS_SERVER) return "portrait-primary";
+    if (this.supported) return window.screen.orientation.type;
+    return window.innerWidth >= window.innerHeight ? "landscape-primary" : "portrait-primary";
+  }
+}
+
+class AudioProviderLoader {
+  name = "audio";
+  target;
+  canPlay(src) {
+    if (!isAudioSrc(src)) return false;
+    return IS_SERVER || !isString(src.src) || src.type === "?" || canPlayAudioType(this.target, src.type);
+  }
+  mediaType() {
+    return "audio";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load audio provider server-side");
+    }
+    return new (await import('./vidstack-Bg-Oi9JY.js')).AudioProvider(this.target, ctx);
+  }
+}
+
+class VideoProviderLoader {
+  name = "video";
+  target;
+  canPlay(src) {
+    if (!isVideoSrc(src)) return false;
+    return IS_SERVER || !isString(src.src) || src.type === "?" || canPlayVideoType(this.target, src.type);
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load video provider server-side");
+    }
+    return new (await Promise.resolve().then(function () { return provider$1; })).VideoProvider(this.target, ctx);
+  }
+}
+
+class HLSProviderLoader extends VideoProviderLoader {
+  static supported = isHLSSupported();
+  name = "hls";
+  canPlay(src) {
+    return HLSProviderLoader.supported && isHLSSrc(src);
+  }
+  async load(context) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load hls provider server-side");
+    }
+    return new (await import('./vidstack-CBvGixcr.js')).HLSProvider(this.target, context);
+  }
+}
+
+let audioContext = null, gainNodes = [], elAudioSources = [];
+function getOrCreateAudioCtx() {
+  return audioContext ??= new AudioContext();
+}
+function createGainNode() {
+  const audioCtx = getOrCreateAudioCtx(), gainNode = audioCtx.createGain();
+  gainNode.connect(audioCtx.destination);
+  gainNodes.push(gainNode);
+  return gainNode;
+}
+function createElementSource(el, gainNode) {
+  const audioCtx = getOrCreateAudioCtx(), src = audioCtx.createMediaElementSource(el);
+  if (gainNode) {
+    src.connect(gainNode);
+  }
+  elAudioSources.push(src);
+  return src;
+}
+function destroyGainNode(node) {
+  const idx = gainNodes.indexOf(node);
+  if (idx !== -1) {
+    gainNodes.splice(idx, 1);
+    node.disconnect();
+    freeAudioCtxWhenAllResourcesFreed();
+  }
+}
+function destroyElementSource(src) {
+  const idx = elAudioSources.indexOf(src);
+  if (idx !== -1) {
+    elAudioSources.splice(idx, 1);
+    src.disconnect();
+    freeAudioCtxWhenAllResourcesFreed();
+  }
+}
+function freeAudioCtxWhenAllResourcesFreed() {
+  if (audioContext && gainNodes.length === 0 && elAudioSources.length === 0) {
+    audioContext.close().then(() => {
+      audioContext = null;
+    });
+  }
+}
+
+class AudioGain {
+  #media;
+  #onChange;
+  #gainNode = null;
+  #srcAudioNode = null;
+  get currentGain() {
+    return this.#gainNode?.gain?.value ?? null;
+  }
+  get supported() {
+    return true;
+  }
+  constructor(media, onChange) {
+    this.#media = media;
+    this.#onChange = onChange;
+  }
+  setGain(gain) {
+    const currGain = this.currentGain;
+    if (gain === this.currentGain) {
+      return;
+    }
+    if (gain === 1 && currGain !== 1) {
+      this.removeGain();
+      return;
+    }
+    if (!this.#gainNode) {
+      this.#gainNode = createGainNode();
+      if (this.#srcAudioNode) {
+        this.#srcAudioNode.connect(this.#gainNode);
+      }
+    }
+    if (!this.#srcAudioNode) {
+      this.#srcAudioNode = createElementSource(this.#media, this.#gainNode);
+    }
+    this.#gainNode.gain.value = gain;
+    this.#onChange(gain);
+  }
+  removeGain() {
+    if (!this.#gainNode) return;
+    if (this.#srcAudioNode) {
+      this.#srcAudioNode.connect(getOrCreateAudioCtx().destination);
+    }
+    this.#destroyGainNode();
+    this.#onChange(null);
+  }
+  destroy() {
+    this.#destroySrcNode();
+    this.#destroyGainNode();
+  }
+  #destroySrcNode() {
+    if (!this.#srcAudioNode) return;
+    try {
+      destroyElementSource(this.#srcAudioNode);
+    } catch (e) {
+    } finally {
+      this.#srcAudioNode = null;
+    }
+  }
+  #destroyGainNode() {
+    if (!this.#gainNode) return;
+    try {
+      destroyGainNode(this.#gainNode);
+    } catch (e) {
+    } finally {
+      this.#gainNode = null;
+    }
+  }
+}
+
+const PAGE_EVENTS = ["focus", "blur", "visibilitychange", "pageshow", "pagehide"];
+class PageVisibility {
+  #state = signal(determinePageState());
+  #visibility = signal(IS_SERVER ? "visible" : document.visibilityState);
+  #safariBeforeUnloadTimeout;
+  connect() {
+    const events = new EventsController(window), handlePageEvent = this.#handlePageEvent.bind(this);
+    for (const eventType of PAGE_EVENTS) {
+      events.add(eventType, handlePageEvent);
+    }
+    if (IS_SAFARI) {
+      events.add("beforeunload", (event) => {
+        this.#safariBeforeUnloadTimeout = setTimeout(() => {
+          if (!(event.defaultPrevented || event.returnValue.length > 0)) {
+            this.#state.set("hidden");
+            this.#visibility.set("hidden");
+          }
+        }, 0);
+      });
+    }
+  }
+  /**
+   * The current page state. Important to note we only account for a subset of page states, as
+   * the rest aren't valuable to the player at the moment.
+   *
+   * - **active:** A page is in the active state if it is visible and has input focus.
+   * - **passive:** A page is in the passive state if it is visible and does not have input focus.
+   * - **hidden:** A page is in the hidden state if it is not visible.
+   *
+   * @see https://developers.google.com/web/updates/2018/07/page-lifecycle-api#states
+   */
+  get pageState() {
+    return this.#state();
+  }
+  /**
+   * The current document visibility state.
+   *
+   * - **visible:** The page content may be at least partially visible. In practice, this means that
+   * the page is the foreground tab of a non-minimized window.
+   * - **hidden:** The page content is not visible to the user. In practice this means that the
+   * document is either a background tab or part of a minimized window, or the OS screen lock is
+   * active.
+   *
+   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState
+   */
+  get visibility() {
+    return this.#visibility();
+  }
+  #handlePageEvent(event) {
+    if (IS_SAFARI) window.clearTimeout(this.#safariBeforeUnloadTimeout);
+    if (event.type !== "blur" || this.#state() === "active") {
+      this.#state.set(determinePageState(event));
+      this.#visibility.set(document.visibilityState == "hidden" ? "hidden" : "visible");
+    }
+  }
+}
+function determinePageState(event) {
+  if (IS_SERVER) return "hidden";
+  if (event?.type === "blur" || document.visibilityState === "hidden") return "hidden";
+  if (document.hasFocus()) return "active";
+  return "passive";
+}
+
+class RAFLoop {
+  #id;
+  #callback;
+  constructor(callback) {
+    this.#callback = callback;
+  }
+  start() {
+    if (!isUndefined(this.#id)) return;
+    this.#loop();
+  }
+  stop() {
+    if (isNumber(this.#id)) window.cancelAnimationFrame(this.#id);
+    this.#id = void 0;
+  }
+  #loop() {
+    this.#id = window.requestAnimationFrame(() => {
+      if (isUndefined(this.#id)) return;
+      this.#callback();
+      this.#loop();
+    });
+  }
+}
+
+class HTMLMediaEvents {
+  #provider;
+  #ctx;
+  #waiting = false;
+  #attachedLoadStart = false;
+  #attachedCanPlay = false;
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #pageVisibility = new PageVisibility();
+  #events;
+  get #media() {
+    return this.#provider.media;
+  }
+  constructor(provider, ctx) {
+    this.#provider = provider;
+    this.#ctx = ctx;
+    this.#events = new EventsController(provider.media);
+    this.#attachInitialListeners();
+    this.#pageVisibility.connect();
+    effect(this.#attachTimeUpdate.bind(this));
+    onDispose(this.#onDispose.bind(this));
+  }
+  #onDispose() {
+    this.#attachedLoadStart = false;
+    this.#attachedCanPlay = false;
+    this.#timeRAF.stop();
+    this.#events.abort();
+    this.#devHandlers?.clear();
+  }
+  /**
+   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
+   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
+   * resolve that by retrieving time updates in a request animation frame loop.
+   */
+  #lastSeenTime = 0;
+  #seekedTo = -1;
+  #onAnimationFrame() {
+    const newTime = this.#media.currentTime;
+    const didStutter = IS_SAFARI && newTime - this.#seekedTo < 0.35;
+    if (!didStutter && this.#lastSeenTime !== newTime) {
+      this.#updateCurrentTime(newTime);
+      this.#lastSeenTime = newTime;
+    }
+  }
+  #attachInitialListeners() {
+    this.#attachEventListener("loadstart", this.#onLoadStart);
+    this.#attachEventListener("abort", this.#onAbort);
+    this.#attachEventListener("emptied", this.#onEmptied);
+    this.#attachEventListener("error", this.#onError);
+    this.#attachEventListener("volumechange", this.#onVolumeChange);
+  }
+  #attachLoadStartListeners() {
+    if (this.#attachedLoadStart) return;
+    this.#attachEventListener("loadeddata", this.#onLoadedData);
+    this.#attachEventListener("loadedmetadata", this.#onLoadedMetadata);
+    this.#attachEventListener("canplay", this.#onCanPlay);
+    this.#attachEventListener("canplaythrough", this.#onCanPlayThrough);
+    this.#attachEventListener("durationchange", this.#onDurationChange);
+    this.#attachEventListener("play", this.#onPlay);
+    this.#attachEventListener("progress", this.#onProgress);
+    this.#attachEventListener("stalled", this.#onStalled);
+    this.#attachEventListener("suspend", this.#onSuspend);
+    this.#attachEventListener("ratechange", this.#onRateChange);
+    this.#attachedLoadStart = true;
+  }
+  #attachCanPlayListeners() {
+    if (this.#attachedCanPlay) return;
+    this.#attachEventListener("pause", this.#onPause);
+    this.#attachEventListener("playing", this.#onPlaying);
+    this.#attachEventListener("seeked", this.#onSeeked);
+    this.#attachEventListener("seeking", this.#onSeeking);
+    this.#attachEventListener("ended", this.#onEnded);
+    this.#attachEventListener("waiting", this.#onWaiting);
+    this.#attachedCanPlay = true;
+  }
+  #devHandlers = void 0;
+  #handleDevEvent = void 0;
+  #attachEventListener(eventType, handler) {
+    this.#events.add(eventType, handler.bind(this));
+  }
+  #onDevEvent(event2) {
+    return;
+  }
+  #updateCurrentTime(time, trigger) {
+    const newTime = Math.min(time, this.#ctx.$state.seekableEnd());
+    this.#ctx.notify("time-change", newTime, trigger);
+  }
+  #onLoadStart(event2) {
+    if (this.#media.networkState === 3) {
+      this.#onAbort(event2);
+      return;
+    }
+    this.#attachLoadStartListeners();
+    this.#ctx.notify("load-start", void 0, event2);
+  }
+  #onAbort(event2) {
+    this.#ctx.notify("abort", void 0, event2);
+  }
+  #onEmptied() {
+    this.#ctx.notify("emptied", void 0, event);
+  }
+  #onLoadedData(event2) {
+    this.#ctx.notify("loaded-data", void 0, event2);
+  }
+  #onLoadedMetadata(event2) {
+    this.#lastSeenTime = 0;
+    this.#seekedTo = -1;
+    this.#attachCanPlayListeners();
+    this.#ctx.notify("loaded-metadata", void 0, event2);
+    if (IS_IOS || IS_SAFARI && isHLSSrc(this.#ctx.$state.source())) {
+      this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
+    }
+  }
+  #getCanPlayDetail() {
+    return {
+      provider: peek(this.#ctx.$provider),
+      duration: this.#media.duration,
+      buffered: this.#media.buffered,
+      seekable: this.#media.seekable
+    };
+  }
+  #onPlay(event2) {
+    if (!this.#ctx.$state.canPlay) return;
+    this.#ctx.notify("play", void 0, event2);
+  }
+  #onPause(event2) {
+    if (this.#media.readyState === 1 && !this.#waiting) return;
+    this.#waiting = false;
+    this.#timeRAF.stop();
+    this.#ctx.notify("pause", void 0, event2);
+  }
+  #onCanPlay(event2) {
+    this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
+  }
+  #onCanPlayThrough(event2) {
+    if (this.#ctx.$state.started()) return;
+    this.#ctx.notify("can-play-through", this.#getCanPlayDetail(), event2);
+  }
+  #onPlaying(event2) {
+    if (this.#media.paused) return;
+    this.#waiting = false;
+    this.#ctx.notify("playing", void 0, event2);
+    this.#timeRAF.start();
+  }
+  #onStalled(event2) {
+    this.#ctx.notify("stalled", void 0, event2);
+    if (this.#media.readyState < 3) {
+      this.#waiting = true;
+      this.#ctx.notify("waiting", void 0, event2);
+    }
+  }
+  #onWaiting(event2) {
+    if (this.#media.readyState < 3) {
+      this.#waiting = true;
+      this.#ctx.notify("waiting", void 0, event2);
+    }
+  }
+  #onEnded(event2) {
+    this.#timeRAF.stop();
+    this.#updateCurrentTime(this.#media.duration, event2);
+    this.#ctx.notify("end", void 0, event2);
+    if (this.#ctx.$state.loop()) {
+      const hasCustomControls = isNil(this.#media.controls);
+      if (hasCustomControls) this.#media.controls = false;
+    }
+  }
+  #attachTimeUpdate() {
+    const isPaused = this.#ctx.$state.paused(), isPageHidden = this.#pageVisibility.visibility === "hidden", shouldListenToTimeUpdates = isPaused || isPageHidden;
+    if (shouldListenToTimeUpdates) {
+      listenEvent(this.#media, "timeupdate", this.#onTimeUpdate.bind(this));
+    }
+  }
+  #onTimeUpdate(event2) {
+    this.#updateCurrentTime(this.#media.currentTime, event2);
+  }
+  #onDurationChange(event2) {
+    if (this.#ctx.$state.ended()) {
+      this.#updateCurrentTime(this.#media.duration, event2);
+    }
+    this.#ctx.notify("duration-change", this.#media.duration, event2);
+  }
+  #onVolumeChange(event2) {
+    const detail = {
+      volume: this.#media.volume,
+      muted: this.#media.muted
+    };
+    this.#ctx.notify("volume-change", detail, event2);
+  }
+  #onSeeked(event2) {
+    this.#seekedTo = this.#media.currentTime;
+    this.#updateCurrentTime(this.#media.currentTime, event2);
+    this.#ctx.notify("seeked", this.#media.currentTime, event2);
+    if (Math.trunc(this.#media.currentTime) === Math.trunc(this.#media.duration) && getNumberOfDecimalPlaces(this.#media.duration) > getNumberOfDecimalPlaces(this.#media.currentTime)) {
+      this.#updateCurrentTime(this.#media.duration, event2);
+      if (!this.#media.ended) {
+        this.#ctx.player.dispatch(
+          new DOMEvent("media-play-request", {
+            trigger: event2
+          })
+        );
+      }
+    }
+  }
+  #onSeeking(event2) {
+    this.#ctx.notify("seeking", this.#media.currentTime, event2);
+  }
+  #onProgress(event2) {
+    const detail = {
+      buffered: this.#media.buffered,
+      seekable: this.#media.seekable
+    };
+    this.#ctx.notify("progress", detail, event2);
+  }
+  #onSuspend(event2) {
+    this.#ctx.notify("suspend", void 0, event2);
+  }
+  #onRateChange(event2) {
+    this.#ctx.notify("rate-change", this.#media.playbackRate, event2);
+  }
+  #onError(event2) {
+    const error = this.#media.error;
+    if (!error) return;
+    const detail = {
+      message: error.message,
+      code: error.code,
+      mediaError: error
+    };
+    this.#ctx.notify("error", detail, event2);
+  }
+}
+
+class NativeAudioTracks {
+  #provider;
+  #ctx;
+  get #nativeTracks() {
+    return this.#provider.media.audioTracks;
+  }
+  constructor(provider, ctx) {
+    this.#provider = provider;
+    this.#ctx = ctx;
+    this.#nativeTracks.onaddtrack = this.#onAddNativeTrack.bind(this);
+    this.#nativeTracks.onremovetrack = this.#onRemoveNativeTrack.bind(this);
+    this.#nativeTracks.onchange = this.#onChangeNativeTrack.bind(this);
+    listenEvent(this.#ctx.audioTracks, "change", this.#onChangeTrack.bind(this));
+  }
+  #onAddNativeTrack(event) {
+    const nativeTrack = event.track;
+    if (nativeTrack.label === "") return;
+    const id = nativeTrack.id.toString() || `native-audio-${this.#ctx.audioTracks.length}`, audioTrack = {
+      id,
+      label: nativeTrack.label,
+      language: nativeTrack.language,
+      kind: nativeTrack.kind,
+      selected: false
+    };
+    this.#ctx.audioTracks[ListSymbol.add](audioTrack, event);
+    if (nativeTrack.enabled) audioTrack.selected = true;
+  }
+  #onRemoveNativeTrack(event) {
+    const track = this.#ctx.audioTracks.getById(event.track.id);
+    if (track) this.#ctx.audioTracks[ListSymbol.remove](track, event);
+  }
+  #onChangeNativeTrack(event) {
+    let enabledTrack = this.#getEnabledNativeTrack();
+    if (!enabledTrack) return;
+    const track = this.#ctx.audioTracks.getById(enabledTrack.id);
+    if (track) this.#ctx.audioTracks[ListSymbol.select](track, true, event);
+  }
+  #getEnabledNativeTrack() {
+    return Array.from(this.#nativeTracks).find((track) => track.enabled);
+  }
+  #onChangeTrack(event) {
+    const { current } = event.detail;
+    if (!current) return;
+    const track = this.#nativeTracks.getTrackById(current.id);
+    if (track) {
+      const prev = this.#getEnabledNativeTrack();
+      if (prev) prev.enabled = false;
+      track.enabled = true;
+    }
+  }
+}
+
+class HTMLMediaProvider {
+  constructor(media, ctx) {
+    this.media = media;
+    this.ctx = ctx;
+    this.audioGain = new AudioGain(media, (gain) => {
+      this.ctx.notify("audio-gain-change", gain);
+    });
+  }
+  scope = createScope();
+  currentSrc = null;
+  audioGain;
+  setup() {
+    new HTMLMediaEvents(this, this.ctx);
+    if ("audioTracks" in this.media) new NativeAudioTracks(this, this.ctx);
+    onDispose(() => {
+      this.audioGain.destroy();
+      this.media.srcObject = null;
+      this.media.removeAttribute("src");
+      for (const source of this.media.querySelectorAll("source")) source.remove();
+      this.media.load();
+    });
+  }
+  get type() {
+    return "";
+  }
+  setPlaybackRate(rate) {
+    this.media.playbackRate = rate;
+  }
+  async play() {
+    return this.media.play();
+  }
+  async pause() {
+    return this.media.pause();
+  }
+  setMuted(muted) {
+    this.media.muted = muted;
+  }
+  setVolume(volume) {
+    this.media.volume = volume;
+  }
+  setCurrentTime(time) {
+    this.media.currentTime = time;
+  }
+  setPlaysInline(inline) {
+    setAttribute(this.media, "playsinline", inline);
+  }
+  async loadSource({ src, type }, preload) {
+    this.media.preload = preload || "";
+    if (isMediaStream(src)) {
+      this.removeSource();
+      this.media.srcObject = src;
+    } else {
+      this.media.srcObject = null;
+      if (isString(src)) {
+        if (type !== "?") {
+          this.appendSource({ src, type });
+        } else {
+          this.removeSource();
+          this.media.src = this.#appendMediaFragment(src);
+        }
+      } else {
+        this.removeSource();
+        this.media.src = window.URL.createObjectURL(src);
+      }
+    }
+    this.media.load();
+    this.currentSrc = { src, type };
+  }
+  /**
+   * Append source so it works when requesting AirPlay since hls.js will remove it.
+   */
+  appendSource(src, defaultType) {
+    const prevSource = this.media.querySelector("source[data-vds]"), source = prevSource ?? document.createElement("source");
+    setAttribute(source, "src", this.#appendMediaFragment(src.src));
+    setAttribute(source, "type", src.type !== "?" ? src.type : defaultType);
+    setAttribute(source, "data-vds", "");
+    if (!prevSource) this.media.append(source);
+  }
+  removeSource() {
+    this.media.querySelector("source[data-vds]")?.remove();
+  }
+  #appendMediaFragment(src) {
+    const { clipStartTime, clipEndTime } = this.ctx.$state, startTime = clipStartTime(), endTime = clipEndTime();
+    if (startTime > 0 && endTime > 0) {
+      return `${src}#t=${startTime},${endTime}`;
+    } else if (startTime > 0) {
+      return `${src}#t=${startTime}`;
+    } else if (endTime > 0) {
+      return `${src}#t=0,${endTime}`;
+    }
+    return src;
+  }
+}
+
+class HTMLRemotePlaybackAdapter {
+  #media;
+  #ctx;
+  #state;
+  #supported = signal(false);
+  get supported() {
+    return this.#supported();
+  }
+  constructor(media, ctx) {
+    this.#media = media;
+    this.#ctx = ctx;
+    this.#setup();
+  }
+  #setup() {
+    if (IS_SERVER || !this.#media?.remote || !this.canPrompt) return;
+    this.#media.remote.watchAvailability((available) => {
+      this.#supported.set(available);
+    }).catch(() => {
+      this.#supported.set(false);
+    });
+    effect(this.#watchSupported.bind(this));
+  }
+  #watchSupported() {
+    if (!this.#supported()) return;
+    const events = ["connecting", "connect", "disconnect"], onStateChange = this.#onStateChange.bind(this);
+    onStateChange();
+    listenEvent(this.#media, "playing", onStateChange);
+    const remoteEvents = new EventsController(this.#media.remote);
+    for (const type of events) {
+      remoteEvents.add(type, onStateChange);
+    }
+  }
+  async prompt() {
+    if (!this.supported) throw Error("Not supported on this platform.");
+    if (this.type === "airplay" && this.#media.webkitShowPlaybackTargetPicker) {
+      return this.#media.webkitShowPlaybackTargetPicker();
+    }
+    return this.#media.remote.prompt();
+  }
+  #onStateChange(event) {
+    const state = this.#media.remote.state;
+    if (state === this.#state) return;
+    const detail = { type: this.type, state };
+    this.#ctx.notify("remote-playback-change", detail, event);
+    this.#state = state;
+  }
+}
+class HTMLAirPlayAdapter extends HTMLRemotePlaybackAdapter {
+  type = "airplay";
+  get canPrompt() {
+    return "WebKitPlaybackTargetAvailabilityEvent" in window;
+  }
+}
+
+class NativeHLSTextTracks {
+  #video;
+  #ctx;
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+    video.textTracks.onaddtrack = this.#onAddTrack.bind(this);
+    onDispose(this.#onDispose.bind(this));
+  }
+  #onAddTrack(event) {
+    const nativeTrack = event.track;
+    if (!nativeTrack || findTextTrackElement(this.#video, nativeTrack)) return;
+    const track = new TextTrack({
+      id: nativeTrack.id,
+      kind: nativeTrack.kind,
+      label: nativeTrack.label ?? "",
+      language: nativeTrack.language,
+      type: "vtt"
+    });
+    track[TextTrackSymbol.native] = { track: nativeTrack };
+    track[TextTrackSymbol.readyState] = 2;
+    track[TextTrackSymbol.nativeHLS] = true;
+    let lastIndex = 0;
+    const onCueChange = (event2) => {
+      if (!nativeTrack.cues) return;
+      for (let i = lastIndex; i < nativeTrack.cues.length; i++) {
+        track.addCue(nativeTrack.cues[i], event2);
+        lastIndex++;
+      }
+    };
+    onCueChange(event);
+    nativeTrack.oncuechange = onCueChange;
+    this.#ctx.textTracks.add(track, event);
+    track.setMode(nativeTrack.mode, event);
+  }
+  #onDispose() {
+    this.#video.textTracks.onaddtrack = null;
+    for (const track of this.#ctx.textTracks) {
+      const nativeTrack = track[TextTrackSymbol.native]?.track;
+      if (nativeTrack?.oncuechange) nativeTrack.oncuechange = null;
+    }
+  }
+}
+function findTextTrackElement(video, track) {
+  return Array.from(video.children).find((el) => el.track === track);
+}
+
+class VideoPictureInPicture {
+  #video;
+  #media;
+  constructor(video, media) {
+    this.#video = video;
+    this.#media = media;
+    new EventsController(video).add("enterpictureinpicture", this.#onEnter.bind(this)).add("leavepictureinpicture", this.#onExit.bind(this));
+  }
+  get active() {
+    return document.pictureInPictureElement === this.#video;
+  }
+  get supported() {
+    return canUsePictureInPicture(this.#video);
+  }
+  async enter() {
+    return this.#video.requestPictureInPicture();
+  }
+  exit() {
+    return document.exitPictureInPicture();
+  }
+  #onEnter(event) {
+    this.#onChange(true, event);
+  }
+  #onExit(event) {
+    this.#onChange(false, event);
+  }
+  #onChange = (active, event) => {
+    this.#media.notify("picture-in-picture-change", active, event);
+  };
+}
+
+class VideoPresentation {
+  #video;
+  #media;
+  #mode = "inline";
+  get mode() {
+    return this.#mode;
+  }
+  constructor(video, media) {
+    this.#video = video;
+    this.#media = media;
+    listenEvent(video, "webkitpresentationmodechanged", this.#onModeChange.bind(this));
+  }
+  get supported() {
+    return canUseVideoPresentation(this.#video);
+  }
+  async setPresentationMode(mode) {
+    if (this.#mode === mode) return;
+    this.#video.webkitSetPresentationMode(mode);
+  }
+  #onModeChange(event) {
+    const prevMode = this.#mode;
+    this.#mode = this.#video.webkitPresentationMode;
+    this.#media.player?.dispatch(
+      new DOMEvent("video-presentation-change", {
+        detail: this.#mode,
+        trigger: event
+      })
+    );
+    ["fullscreen", "picture-in-picture"].forEach((type) => {
+      if (this.#mode === type || prevMode === type) {
+        this.#media.notify(`${type}-change`, this.#mode === type, event);
+      }
+    });
+  }
+}
+class FullscreenPresentationAdapter {
+  #presentation;
+  get active() {
+    return this.#presentation.mode === "fullscreen";
+  }
+  get supported() {
+    return this.#presentation.supported;
+  }
+  constructor(presentation) {
+    this.#presentation = presentation;
+  }
+  async enter() {
+    this.#presentation.setPresentationMode("fullscreen");
+  }
+  async exit() {
+    this.#presentation.setPresentationMode("inline");
+  }
+}
+class PIPPresentationAdapter {
+  #presentation;
+  get active() {
+    return this.#presentation.mode === "picture-in-picture";
+  }
+  get supported() {
+    return this.#presentation.supported;
+  }
+  constructor(presentation) {
+    this.#presentation = presentation;
+  }
+  async enter() {
+    this.#presentation.setPresentationMode("picture-in-picture");
+  }
+  async exit() {
+    this.#presentation.setPresentationMode("inline");
+  }
+}
+
+class VideoProvider extends HTMLMediaProvider {
+  $$PROVIDER_TYPE = "VIDEO";
+  get type() {
+    return "video";
+  }
+  airPlay;
+  fullscreen;
+  pictureInPicture;
+  constructor(video, ctx) {
+    super(video, ctx);
+    scoped(() => {
+      this.airPlay = new HTMLAirPlayAdapter(video, ctx);
+      if (canUseVideoPresentation(video)) {
+        const presentation = new VideoPresentation(video, ctx);
+        this.fullscreen = new FullscreenPresentationAdapter(presentation);
+        this.pictureInPicture = new PIPPresentationAdapter(presentation);
+      } else if (canUsePictureInPicture(video)) {
+        this.pictureInPicture = new VideoPictureInPicture(video, ctx);
+      }
+    }, this.scope);
+  }
+  setup() {
+    super.setup();
+    if (canPlayHLSNatively(this.video)) {
+      new NativeHLSTextTracks(this.video, this.ctx);
+    }
+    this.ctx.textRenderers.attachVideo(this.video);
+    onDispose(() => {
+      this.ctx.textRenderers.attachVideo(null);
+    });
+    if (this.type === "video") this.ctx.notify("provider-setup", this);
+  }
+  /**
+   * The native HTML `<video>` element.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement}
+   */
+  get video() {
+    return this.media;
+  }
+}
+
+var provider$1 = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  VideoProvider: VideoProvider
+});
+
+function getLangName(langCode) {
+  try {
+    const displayNames = new Intl.DisplayNames(navigator.languages, { type: "language" });
+    const languageName = displayNames.of(langCode);
+    return languageName ?? null;
+  } catch (err) {
+    return null;
+  }
+}
+
+const toDOMEventType = (type) => `dash-${camelToKebabCase(type)}`;
+class DASHController {
+  #video;
+  #ctx;
+  #instance = null;
+  #callbacks = /* @__PURE__ */ new Set();
+  #stopLiveSync = null;
+  config = {};
+  get instance() {
+    return this.#instance;
+  }
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+  }
+  setup(ctor) {
+    this.#instance = ctor().create();
+    const dispatcher = this.#dispatchDASHEvent.bind(this);
+    for (const event of Object.values(ctor.events)) this.#instance.on(event, dispatcher);
+    this.#instance.on(ctor.events.ERROR, this.#onError.bind(this));
+    for (const callback of this.#callbacks) callback(this.#instance);
+    this.#ctx.player.dispatch("dash-instance", {
+      detail: this.#instance
+    });
+    this.#instance.initialize(this.#video, void 0, false);
+    this.#instance.updateSettings({
+      streaming: {
+        text: {
+          // Disabling text rendering by dash.
+          defaultEnabled: false,
+          dispatchForManualRendering: true
+        },
+        buffer: {
+          /// Enables buffer replacement when switching bitrates for faster switching.
+          fastSwitchEnabled: true
+        }
+      },
+      ...this.config
+    });
+    this.#instance.on(ctor.events.FRAGMENT_LOADING_STARTED, this.#onFragmentLoadStart.bind(this));
+    this.#instance.on(
+      ctor.events.FRAGMENT_LOADING_COMPLETED,
+      this.#onFragmentLoadComplete.bind(this)
+    );
+    this.#instance.on(ctor.events.MANIFEST_LOADED, this.#onManifestLoaded.bind(this));
+    this.#instance.on(ctor.events.QUALITY_CHANGE_RENDERED, this.#onQualityChange.bind(this));
+    this.#instance.on(ctor.events.TEXT_TRACKS_ADDED, this.#onTextTracksAdded.bind(this));
+    this.#instance.on(ctor.events.TRACK_CHANGE_RENDERED, this.#onTrackChange.bind(this));
+    this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
+    listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
+    listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
+    this.#stopLiveSync = effect(this.#liveSync.bind(this));
+  }
+  #createDOMEvent(event) {
+    return new DOMEvent(toDOMEventType(event.type), { detail: event });
+  }
+  #liveSync() {
+    if (!this.#ctx.$state.live()) return;
+    const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
+    raf.start();
+    return raf.stop.bind(raf);
+  }
+  #liveSyncPosition() {
+    if (!this.#instance) return;
+    const position = this.#instance.duration() - this.#instance.time();
+    this.#ctx.$state.liveSyncPosition.set(!isNaN(position) ? position : Infinity);
+  }
+  #dispatchDASHEvent(event) {
+    this.#ctx.player?.dispatch(this.#createDOMEvent(event));
+  }
+  #currentTrack = null;
+  #cueTracker = {};
+  #onTextFragmentLoaded(event) {
+    const native = this.#currentTrack?.[TextTrackSymbol.native], cues = (native?.track).cues;
+    if (!native || !cues) return;
+    const id = this.#currentTrack.id, startIndex = this.#cueTracker[id] ?? 0, trigger = this.#createDOMEvent(event);
+    for (let i = startIndex; i < cues.length; i++) {
+      const cue = cues[i];
+      if (!cue.positionAlign) cue.positionAlign = "auto";
+      this.#currentTrack.addCue(cue, trigger);
+    }
+    this.#cueTracker[id] = cues.length;
+  }
+  #onTextTracksAdded(event) {
+    if (!this.#instance) return;
+    const data = event.tracks, nativeTextTracks = [...this.#video.textTracks].filter((track) => "manualMode" in track), trigger = this.#createDOMEvent(event);
+    for (let i = 0; i < nativeTextTracks.length; i++) {
+      const textTrackInfo = data[i], nativeTextTrack = nativeTextTracks[i];
+      const id = `dash-${textTrackInfo.kind}-${i}`, track = new TextTrack({
+        id,
+        label: textTrackInfo?.label ?? textTrackInfo.labels.find((t) => t.text)?.text ?? (textTrackInfo?.lang && getLangName(textTrackInfo.lang)) ?? textTrackInfo?.lang ?? void 0,
+        language: textTrackInfo.lang ?? void 0,
+        kind: textTrackInfo.kind,
+        default: textTrackInfo.defaultTrack
+      });
+      track[TextTrackSymbol.native] = {
+        managed: true,
+        track: nativeTextTrack
+      };
+      track[TextTrackSymbol.readyState] = 2;
+      track[TextTrackSymbol.onModeChange] = () => {
+        if (!this.#instance) return;
+        if (track.mode === "showing") {
+          this.#instance.setTextTrack(i);
+          this.#currentTrack = track;
+        } else {
+          this.#instance.setTextTrack(-1);
+          this.#currentTrack = null;
+        }
+      };
+      this.#ctx.textTracks.add(track, trigger);
+    }
+  }
+  #onTrackChange(event) {
+    const { mediaType, newMediaInfo } = event;
+    if (mediaType === "audio") {
+      const track = this.#ctx.audioTracks.getById(`dash-audio-${newMediaInfo.index}`);
+      if (track) {
+        const trigger = this.#createDOMEvent(event);
+        this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
+      }
+    }
+  }
+  #onQualityChange(event) {
+    if (event.mediaType !== "video") return;
+    const quality = this.#ctx.qualities[event.newQuality];
+    if (quality) {
+      const trigger = this.#createDOMEvent(event);
+      this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+  }
+  #onManifestLoaded(event) {
+    if (this.#ctx.$state.canPlay() || !this.#instance) return;
+    const { type, mediaPresentationDuration } = event.data, trigger = this.#createDOMEvent(event);
+    this.#ctx.notify("stream-type-change", type !== "static" ? "live" : "on-demand", trigger);
+    this.#ctx.notify("duration-change", mediaPresentationDuration, trigger);
+    this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
+    const media = this.#instance.getVideoElement();
+    const videoQualities = this.#instance.getTracksForTypeFromManifest(
+      "video",
+      event.data
+    );
+    const supportedVideoMimeType = [...new Set(videoQualities.map((e) => e.mimeType))].find(
+      (type2) => type2 && canPlayVideoType(media, type2)
+    );
+    const videoQuality = videoQualities.filter(
+      (track) => supportedVideoMimeType === track.mimeType
+    )[0];
+    let audioTracks = this.#instance.getTracksForTypeFromManifest(
+      "audio",
+      event.data
+    );
+    const supportedAudioMimeType = [...new Set(audioTracks.map((e) => e.mimeType))].find(
+      (type2) => type2 && canPlayAudioType(media, type2)
+    );
+    audioTracks = audioTracks.filter((track) => supportedAudioMimeType === track.mimeType);
+    videoQuality.bitrateList.forEach((bitrate, index) => {
+      const quality = {
+        id: bitrate.id?.toString() ?? `dash-bitrate-${index}`,
+        width: bitrate.width ?? 0,
+        height: bitrate.height ?? 0,
+        bitrate: bitrate.bandwidth ?? 0,
+        codec: videoQuality.codec,
+        index
+      };
+      this.#ctx.qualities[ListSymbol.add](quality, trigger);
+    });
+    if (isNumber(videoQuality.index)) {
+      const quality = this.#ctx.qualities[videoQuality.index];
+      if (quality) this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+    audioTracks.forEach((audioTrack, index) => {
+      const matchingLabel = audioTrack.labels.find((label2) => {
+        return navigator.languages.some((language) => {
+          return label2.lang && language.toLowerCase().startsWith(label2.lang.toLowerCase());
+        });
+      });
+      const label = matchingLabel || audioTrack.labels[0];
+      const localTrack = {
+        id: `dash-audio-${audioTrack?.index}`,
+        label: label?.text ?? (audioTrack.lang && getLangName(audioTrack.lang)) ?? audioTrack.lang ?? "",
+        language: audioTrack.lang ?? "",
+        kind: "main",
+        mimeType: audioTrack.mimeType,
+        codec: audioTrack.codec,
+        index
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
+    });
+    media.dispatchEvent(new DOMEvent("canplay", { trigger }));
+  }
+  #onError(event) {
+    const { type: eventType, error: data } = event;
+    switch (data.code) {
+      case 27:
+        this.#onNetworkError(data);
+        break;
+      default:
+        this.#onFatalError(data);
+        break;
+    }
+  }
+  #onFragmentLoadStart() {
+    if (this.#retryLoadingTimer >= 0) this.#clearRetryTimer();
+  }
+  #onFragmentLoadComplete(event) {
+    const mediaType = event.mediaType;
+    if (mediaType === "text") {
+      requestAnimationFrame(this.#onTextFragmentLoaded.bind(this, event));
+    }
+  }
+  #retryLoadingTimer = -1;
+  #onNetworkError(error) {
+    this.#clearRetryTimer();
+    this.#instance?.play();
+    this.#retryLoadingTimer = window.setTimeout(() => {
+      this.#retryLoadingTimer = -1;
+      this.#onFatalError(error);
+    }, 5e3);
+  }
+  #clearRetryTimer() {
+    clearTimeout(this.#retryLoadingTimer);
+    this.#retryLoadingTimer = -1;
+  }
+  #onFatalError(error) {
+    this.#ctx.notify("error", {
+      message: error.message ?? "",
+      code: 1,
+      error
+    });
+  }
+  #enableAutoQuality() {
+    this.#switchAutoBitrate("video", true);
+    const { qualities } = this.#ctx;
+    this.#instance?.setQualityFor("video", qualities.selectedIndex, true);
+  }
+  #switchAutoBitrate(type, auto) {
+    this.#instance?.updateSettings({
+      streaming: { abr: { autoSwitchBitrate: { [type]: auto } } }
+    });
+  }
+  #onUserQualityChange() {
+    const { qualities } = this.#ctx;
+    if (!this.#instance || qualities.auto || !qualities.selected) return;
+    this.#switchAutoBitrate("video", false);
+    this.#instance.setQualityFor("video", qualities.selectedIndex, qualities.switch === "current");
+    if (IS_CHROME) {
+      this.#video.currentTime = this.#video.currentTime;
+    }
+  }
+  #onUserAudioChange() {
+    if (!this.#instance) return;
+    const { audioTracks } = this.#ctx, selectedTrack = this.#instance.getTracksFor("audio").find(
+      (track) => audioTracks.selected && audioTracks.selected.id === `dash-audio-${track.index}`
+    );
+    if (selectedTrack) this.#instance.setCurrentTrack(selectedTrack);
+  }
+  #reset() {
+    this.#clearRetryTimer();
+    this.#currentTrack = null;
+    this.#cueTracker = {};
+  }
+  onInstance(callback) {
+    this.#callbacks.add(callback);
+    return () => this.#callbacks.delete(callback);
+  }
+  loadSource(src) {
+    this.#reset();
+    if (!isString(src.src)) return;
+    this.#instance?.attachSource(src.src);
+  }
+  destroy() {
+    this.#reset();
+    this.#instance?.destroy();
+    this.#instance = null;
+    this.#stopLiveSync?.();
+    this.#stopLiveSync = null;
+  }
+}
+
+function coerceToError(error) {
+  return error instanceof Error ? error : Error(typeof error === "string" ? error : JSON.stringify(error));
+}
+function assert(condition, message) {
+  if (!condition) {
+    throw Error("Assertion failed.");
+  }
+}
+
+class DASHLibLoader {
+  #lib;
+  #ctx;
+  #callback;
+  constructor(lib, ctx, callback) {
+    this.#lib = lib;
+    this.#ctx = ctx;
+    this.#callback = callback;
+    this.#startLoading();
+  }
+  async #startLoading() {
+    const callbacks = {
+      onLoadStart: this.#onLoadStart.bind(this),
+      onLoaded: this.#onLoaded.bind(this),
+      onLoadError: this.#onLoadError.bind(this)
+    };
+    let ctor = await loadDASHScript(this.#lib, callbacks);
+    if (isUndefined(ctor) && !isString(this.#lib)) ctor = await importDASH(this.#lib, callbacks);
+    if (!ctor) return null;
+    if (!window.dashjs.supportsMediaSource()) {
+      const message = "[vidstack] `dash.js` is not supported in this environment";
+      this.#ctx.player.dispatch(new DOMEvent("dash-unsupported"));
+      this.#ctx.notify("error", { message, code: 4 });
+      return null;
+    }
+    return ctor;
+  }
+  #onLoadStart() {
+    this.#ctx.player.dispatch(new DOMEvent("dash-lib-load-start"));
+  }
+  #onLoaded(ctor) {
+    this.#ctx.player.dispatch(
+      new DOMEvent("dash-lib-loaded", {
+        detail: ctor
+      })
+    );
+    this.#callback(ctor);
+  }
+  #onLoadError(e) {
+    const error = coerceToError(e);
+    this.#ctx.player.dispatch(
+      new DOMEvent("dash-lib-load-error", {
+        detail: error
+      })
+    );
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 4,
+      error
+    });
+  }
+}
+async function importDASH(loader, callbacks = {}) {
+  if (isUndefined(loader)) return void 0;
+  callbacks.onLoadStart?.();
+  if (isDASHConstructor(loader)) {
+    callbacks.onLoaded?.(loader);
+    return loader;
+  }
+  if (isDASHNamespace(loader)) {
+    const ctor = loader.MediaPlayer;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  }
+  try {
+    const ctor = (await loader())?.default;
+    if (isDASHNamespace(ctor)) {
+      callbacks.onLoaded?.(ctor.MediaPlayer);
+      return ctor.MediaPlayer;
+    }
+    if (ctor) {
+      callbacks.onLoaded?.(ctor);
+    } else {
+      throw Error(
+        false ? "[vidstack] failed importing `dash.js`. Dynamic import returned invalid object." : ""
+      );
+    }
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+async function loadDASHScript(src, callbacks = {}) {
+  if (!isString(src)) return void 0;
+  callbacks.onLoadStart?.();
+  try {
+    await loadScript(src);
+    if (!isFunction(window.dashjs.MediaPlayer)) {
+      throw Error(
+        false ? "[vidstack] failed loading `dash.js`. Could not find a valid `Dash` constructor on window" : ""
+      );
+    }
+    const ctor = window.dashjs.MediaPlayer;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+function isDASHConstructor(value) {
+  return value && value.prototype && value.prototype !== Function;
+}
+function isDASHNamespace(value) {
+  return value && "MediaPlayer" in value;
+}
+
+const JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
+class DASHProvider extends VideoProvider {
+  $$PROVIDER_TYPE = "DASH";
+  #ctor = null;
+  #controller = new DASHController(this.video, this.ctx);
+  /**
+   * The `dash.js` constructor.
+   */
+  get ctor() {
+    return this.#ctor;
+  }
+  /**
+   * The current `dash.js` instance.
+   */
+  get instance() {
+    return this.#controller.instance;
+  }
+  /**
+   * Whether `dash.js` is supported in this environment.
+   */
+  static supported = isDASHSupported();
+  get type() {
+    return "dash";
+  }
+  get canLiveSync() {
+    return true;
+  }
+  #library = `${JS_DELIVR_CDN}/npm/dashjs@4.7.4/dist/dash${".all.min.js"}`;
+  /**
+   * The `dash.js` configuration object.
+   *
+   * @see {@link https://cdn.dashjs.org/latest/jsdoc/module-Settings.html}
+   */
+  get config() {
+    return this.#controller.config;
+  }
+  set config(config) {
+    this.#controller.config = config;
+  }
+  /**
+   * The `dash.js` constructor (supports dynamic imports) or a URL of where it can be found.
+   *
+   * @defaultValue `https://cdn.jsdelivr.net/npm/dashjs@4.7.4/dist/dash.all.min.js`
+   */
+  get library() {
+    return this.#library;
+  }
+  set library(library) {
+    this.#library = library;
+  }
+  preconnect() {
+    if (!isString(this.#library)) return;
+    preconnect(this.#library);
+  }
+  setup() {
+    super.setup();
+    new DASHLibLoader(this.#library, this.ctx, (ctor) => {
+      this.#ctor = ctor;
+      this.#controller.setup(ctor);
+      this.ctx.notify("provider-setup", this);
+      const src = peek(this.ctx.$state.source);
+      if (src) this.loadSource(src);
+    });
+  }
+  async loadSource(src, preload) {
+    if (!isString(src.src)) {
+      this.removeSource();
+      return;
+    }
+    this.media.preload = preload || "";
+    this.appendSource(src, "application/x-mpegurl");
+    this.#controller.loadSource(src);
+    this.currentSrc = src;
+  }
+  /**
+   * The given callback is invoked when a new `dash.js` instance is created and right before it's
+   * attached to media.
+   */
+  onInstance(callback) {
+    const instance = this.#controller.instance;
+    if (instance) callback(instance);
+    return this.#controller.onInstance(callback);
+  }
+  destroy() {
+    this.#controller.destroy();
+  }
+}
+
+var provider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  DASHProvider: DASHProvider
+});
+
+class DASHProviderLoader extends VideoProviderLoader {
+  static supported = isDASHSupported();
+  name = "dash";
+  canPlay(src) {
+    return DASHProviderLoader.supported && isDASHSrc(src);
+  }
+  async load(context) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load dash provider server-side");
+    }
+    return new (await Promise.resolve().then(function () { return provider; })).DASHProvider(this.target, context);
+  }
+}
+
+class VimeoProviderLoader {
+  name = "vimeo";
+  target;
+  preconnect() {
+    const connections = [
+      "https://i.vimeocdn.com",
+      "https://f.vimeocdn.com",
+      "https://fresnel.vimeocdn.com"
+    ];
+    for (const url of connections) {
+      preconnect(url);
+    }
+  }
+  canPlay(src) {
+    return isString(src.src) && src.type === "video/vimeo";
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load vimeo provider server-side");
+    }
+    return new (await import('./vidstack-DLZw-z2Z.js')).VimeoProvider(this.target, ctx);
+  }
+  async loadPoster(src, ctx, abort) {
+    const { resolveVimeoVideoId, getVimeoVideoInfo } = await import('./vidstack-krOAtKMi.js');
+    if (!isString(src.src)) return null;
+    const { videoId, hash } = resolveVimeoVideoId(src.src);
+    if (videoId) {
+      return getVimeoVideoInfo(videoId, abort, hash).then((info) => info ? info.poster : null);
+    }
+    return null;
+  }
+}
+
+class YouTubeProviderLoader {
+  name = "youtube";
+  target;
+  preconnect() {
+    const connections = [
+      // Botguard script.
+      "https://www.google.com",
+      // Posters.
+      "https://i.ytimg.com",
+      // Ads.
+      "https://googleads.g.doubleclick.net",
+      "https://static.doubleclick.net"
+    ];
+    for (const url of connections) {
+      preconnect(url);
+    }
+  }
+  canPlay(src) {
+    return isString(src.src) && src.type === "video/youtube";
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load youtube provider server-side");
+    }
+    return new (await import('./vidstack-B4GpH7JE.js')).YouTubeProvider(this.target, ctx);
+  }
+  async loadPoster(src, ctx, abort) {
+    const { findYouTubePoster, resolveYouTubeVideoId } = await import('./vidstack-Zc3I7oOd.js');
+    const videoId = isString(src.src) && resolveYouTubeVideoId(src.src);
+    if (videoId) return findYouTubePoster(videoId, abort);
+    return null;
+  }
+}
+
+function padNumberWithZeroes(num, expectedLength) {
+  const str = String(num);
+  const actualLength = str.length;
+  const shouldPad = actualLength < expectedLength;
+  if (shouldPad) {
+    const padLength = expectedLength - actualLength;
+    const padding = `0`.repeat(padLength);
+    return `${padding}${num}`;
+  }
+  return str;
+}
+function parseTime(duration) {
+  const hours = Math.trunc(duration / 3600);
+  const minutes = Math.trunc(duration % 3600 / 60);
+  const seconds = Math.trunc(duration % 60);
+  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
+  return {
+    hours,
+    minutes,
+    seconds,
+    fraction
+  };
+}
+function formatTime(duration, { padHrs = null, padMins = null, showHrs = false, showMs = false } = {}) {
+  const { hours, minutes, seconds, fraction } = parseTime(duration), paddedHours = padHrs ? padNumberWithZeroes(hours, 2) : hours, paddedMinutes = padMins || isNull(padMins) && duration >= 3600 ? padNumberWithZeroes(minutes, 2) : minutes, paddedSeconds = padNumberWithZeroes(seconds, 2), paddedMs = showMs && fraction > 0 ? `.${String(fraction).replace(/^0?\./, "")}` : "", time = `${paddedMinutes}:${paddedSeconds}${paddedMs}`;
+  return hours > 0 || showHrs ? `${paddedHours}:${time}` : time;
+}
+function formatSpokenTime(duration) {
+  const spokenParts = [];
+  const { hours, minutes, seconds } = parseTime(duration);
+  if (hours > 0) {
+    spokenParts.push(`${hours} hour`);
+  }
+  if (minutes > 0) {
+    spokenParts.push(`${minutes} min`);
+  }
+  if (seconds > 0 || spokenParts.length === 0) {
+    spokenParts.push(`${seconds} sec`);
+  }
+  return spokenParts.join(" ");
+}
+
+const MEDIA_ATTRIBUTES = Symbol(0);
+const mediaAttributes = [
+  "autoPlay",
+  "canAirPlay",
+  "canFullscreen",
+  "canGoogleCast",
+  "canLoad",
+  "canLoadPoster",
+  "canPictureInPicture",
+  "canPlay",
+  "canSeek",
+  "ended",
+  "fullscreen",
+  "isAirPlayConnected",
+  "isGoogleCastConnected",
+  "live",
+  "liveEdge",
+  "loop",
+  "mediaType",
+  "muted",
+  "paused",
+  "pictureInPicture",
+  "playing",
+  "playsInline",
+  "remotePlaybackState",
+  "remotePlaybackType",
+  "seeking",
+  "started",
+  "streamType",
+  "viewType",
+  "waiting"
+];
+
+const mediaPlayerProps = {
+  artist: "",
+  artwork: null,
+  autoplay: false,
+  autoPlay: false,
+  clipStartTime: 0,
+  clipEndTime: 0,
+  controls: false,
+  currentTime: 0,
+  crossorigin: null,
+  crossOrigin: null,
+  duration: -1,
+  fullscreenOrientation: "landscape",
+  googleCast: {},
+  load: "visible",
+  posterLoad: "visible",
+  logLevel: "silent",
+  loop: false,
+  muted: false,
+  paused: true,
+  playsinline: false,
+  playsInline: false,
+  playbackRate: 1,
+  poster: "",
+  preload: "metadata",
+  preferNativeHLS: false,
+  src: "",
+  title: "",
+  controlsDelay: 2e3,
+  hideControlsOnMouseLeave: false,
+  viewType: "unknown",
+  streamType: "unknown",
+  volume: 1,
+  liveEdgeTolerance: 10,
+  minLiveDVRWindow: 60,
+  keyDisabled: false,
+  keyTarget: "player",
+  keyShortcuts: MEDIA_KEY_SHORTCUTS,
+  storage: null
+};
+
+class MediaLoadController extends MediaPlayerController {
+  #type;
+  #callback;
+  constructor(type, callback) {
+    super();
+    this.#type = type;
+    this.#callback = callback;
+  }
+  async onAttach(el) {
+    if (IS_SERVER) return;
+    const load = this.$props[this.#type]();
+    if (load === "eager") {
+      requestAnimationFrame(this.#callback);
+    } else if (load === "idle") {
+      waitIdlePeriod(this.#callback);
+    } else if (load === "visible") {
+      let dispose, observer = new IntersectionObserver((entries) => {
+        if (!this.scope) return;
+        if (entries[0].isIntersecting) {
+          dispose?.();
+          dispose = void 0;
+          this.#callback();
+        }
+      });
+      observer.observe(el);
+      dispose = onDispose(() => observer.disconnect());
+    }
+  }
+}
+
+class MediaPlayerDelegate {
+  #handle;
+  #media;
+  constructor(handle, media) {
+    this.#handle = handle;
+    this.#media = media;
+  }
+  notify(type, ...init) {
+    if (IS_SERVER) return;
+    this.#handle(
+      new DOMEvent(type, {
+        detail: init?.[0],
+        trigger: init?.[1]
+      })
+    );
+  }
+  async ready(info, trigger) {
+    if (IS_SERVER) return;
+    return untrack(async () => {
+      this.#media; const {
+        autoPlay,
+        canPlay,
+        started,
+        duration,
+        seekable,
+        buffered,
+        remotePlaybackInfo,
+        playsInline,
+        savedState,
+        source
+      } = this.#media.$state;
+      if (canPlay()) return;
+      const detail = {
+        duration: info?.duration ?? duration(),
+        seekable: info?.seekable ?? seekable(),
+        buffered: info?.buffered ?? buffered(),
+        provider: this.#media.$provider()
+      };
+      this.notify("can-play", detail, trigger);
+      tick();
+      let provider = this.#media.$provider(), { storage, qualities } = this.#media, { muted, volume, clipStartTime, playbackRate } = this.#media.$props;
+      await storage?.onLoad?.(source());
+      const savedPlaybackTime = savedState()?.currentTime, savedPausedState = savedState()?.paused, storageTime = await storage?.getTime(), startTime = savedPlaybackTime ?? storageTime ?? clipStartTime(), shouldAutoPlay = savedPausedState === false || savedPausedState !== true && !started() && autoPlay();
+      if (provider) {
+        provider.setVolume(await storage?.getVolume() ?? volume());
+        provider.setMuted(muted() || !!await storage?.getMuted());
+        const audioGain = await storage?.getAudioGain() ?? 1;
+        if (audioGain > 1) provider.audioGain?.setGain?.(audioGain);
+        provider.setPlaybackRate?.(await storage?.getPlaybackRate() ?? playbackRate());
+        provider.setPlaysInline?.(playsInline());
+        if (startTime > 0) provider.setCurrentTime(startTime);
+      }
+      const prefQuality = await storage?.getVideoQuality();
+      if (prefQuality && qualities.length) {
+        let currentQuality = null, currentScore = Infinity;
+        for (const quality of qualities) {
+          const score = Math.abs(prefQuality.width - quality.width) + Math.abs(prefQuality.height - quality.height) + (prefQuality.bitrate ? Math.abs(prefQuality.bitrate - (quality.bitrate ?? 0)) : 0);
+          if (score < currentScore) {
+            currentQuality = quality;
+            currentScore = score;
+          }
+        }
+        if (currentQuality) currentQuality.selected = true;
+      }
+      if (canPlay() && shouldAutoPlay) {
+        await this.#attemptAutoplay(trigger);
+      } else if (storageTime && storageTime > 0) {
+        this.notify("started", void 0, trigger);
+      }
+      remotePlaybackInfo.set(null);
+    });
+  }
+  async #attemptAutoplay(trigger) {
+    const {
+      player,
+      $state: { autoPlaying, muted }
+    } = this.#media;
+    autoPlaying.set(true);
+    const attemptEvent = new DOMEvent("auto-play-attempt", { trigger });
+    try {
+      await player.play(attemptEvent);
+    } catch (error) {
+    }
+  }
+}
+
+class Queue {
+  #queue = /* @__PURE__ */ new Map();
+  /**
+   * Queue the given `item` under the given `key` to be processed at a later time by calling
+   * `serve(key)`.
+   */
+  enqueue(key, item) {
+    this.#queue.set(key, item);
+  }
+  /**
+   * Process item in queue for the given `key`.
+   */
+  serve(key) {
+    const value = this.peek(key);
+    this.#queue.delete(key);
+    return value;
+  }
+  /**
+   * Peek at item in queue for the given `key`.
+   */
+  peek(key) {
+    return this.#queue.get(key);
+  }
+  /**
+   * Removes queued item under the given `key`.
+   */
+  delete(key) {
+    this.#queue.delete(key);
+  }
+  /**
+   * Clear all items in the queue.
+   */
+  clear() {
+    this.#queue.clear();
+  }
+}
+
+class RequestQueue {
+  #serving = false;
+  #pending = deferredPromise();
+  #queue = /* @__PURE__ */ new Map();
+  /**
+   * The number of callbacks that are currently in queue.
+   */
+  get size() {
+    return this.#queue.size;
+  }
+  /**
+   * Whether items in the queue are being served immediately, otherwise they're queued to
+   * be processed later.
+   */
+  get isServing() {
+    return this.#serving;
+  }
+  /**
+   * Waits for the queue to be flushed (ie: start serving).
+   */
+  async waitForFlush() {
+    if (this.#serving) return;
+    await this.#pending.promise;
+  }
+  /**
+   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
+   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
+   * then the callback will be invoked immediately.
+   *
+   * @param key - Uniquely identifies this callback so duplicates are ignored.
+   * @param callback - The function to call when this item in the queue is being served.
+   */
+  enqueue(key, callback) {
+    if (this.#serving) {
+      callback();
+      return;
+    }
+    this.#queue.delete(key);
+    this.#queue.set(key, callback);
+  }
+  /**
+   * Invokes the callback with the given `key` in the queue (if it exists).
+   */
+  serve(key) {
+    this.#queue.get(key)?.();
+    this.#queue.delete(key);
+  }
+  /**
+   * Flush all queued items and start serving future requests immediately until `stop()` is called.
+   */
+  start() {
+    this.#flush();
+    this.#serving = true;
+    if (this.#queue.size > 0) this.#flush();
+  }
+  /**
+   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
+   */
+  stop() {
+    this.#serving = false;
+  }
+  /**
+   * Stop serving requests, empty the request queue, and release any promises waiting for the
+   * queue to flush.
+   */
+  reset() {
+    this.stop();
+    this.#queue.clear();
+    this.#release();
+  }
+  #flush() {
+    for (const key of this.#queue.keys()) this.serve(key);
+    this.#release();
+  }
+  #release() {
+    this.#pending.resolve();
+    this.#pending = deferredPromise();
+  }
+}
+
+class MediaRequestManager extends MediaPlayerController {
+  #stateMgr;
+  #request;
+  #media;
+  controls;
+  #fullscreen;
+  #orientation;
+  #$provider;
+  #providerQueue = new RequestQueue();
+  constructor(stateMgr, request, media) {
+    super();
+    this.#stateMgr = stateMgr;
+    this.#request = request;
+    this.#media = media;
+    this.#$provider = media.$provider;
+    this.controls = new MediaControls();
+    this.#fullscreen = new FullscreenController();
+    this.#orientation = new ScreenOrientationController();
+  }
+  onAttach() {
+    this.listen("fullscreen-change", this.#onFullscreenChange.bind(this));
+  }
+  onConnect(el) {
+    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), events = new EventsController(el), handleRequest = this.#handleRequest.bind(this);
+    for (const name of names) {
+      if (name.startsWith("media-")) {
+        events.add(name, handleRequest);
+      }
+    }
+    this.#attachLoadPlayListener();
+    effect(this.#watchProvider.bind(this));
+    effect(this.#watchControlsDelayChange.bind(this));
+    effect(this.#watchAudioGainSupport.bind(this));
+    effect(this.#watchAirPlaySupport.bind(this));
+    effect(this.#watchGoogleCastSupport.bind(this));
+    effect(this.#watchFullscreenSupport.bind(this));
+    effect(this.#watchPiPSupport.bind(this));
+  }
+  onDestroy() {
+    try {
+      const destroyEvent = this.createEvent("destroy"), { pictureInPicture, fullscreen } = this.$state;
+      if (fullscreen()) this.exitFullscreen("prefer-media", destroyEvent);
+      if (pictureInPicture()) this.exitPictureInPicture(destroyEvent);
+    } catch (e) {
+    }
+    this.#providerQueue.reset();
+  }
+  #attachLoadPlayListener() {
+    const { load } = this.$props, { canLoad } = this.$state;
+    if (load() !== "play" || canLoad()) return;
+    const off = this.listen("media-play-request", (event) => {
+      this.#handleLoadPlayStrategy(event);
+      off();
+    });
+  }
+  #watchProvider() {
+    const provider = this.#$provider(), canPlay = this.$state.canPlay();
+    if (provider && canPlay) {
+      this.#providerQueue.start();
+    }
+    return () => {
+      this.#providerQueue.stop();
+    };
+  }
+  #handleRequest(event) {
+    event.stopPropagation();
+    if (event.defaultPrevented) return;
+    if (!this[event.type]) return;
+    if (peek(this.#$provider)) {
+      this[event.type](event);
+    } else {
+      this.#providerQueue.enqueue(event.type, () => {
+        if (peek(this.#$provider)) this[event.type](event);
+      });
+    }
+  }
+  async play(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, paused, autoPlaying } = this.$state;
+    if (this.#handleLoadPlayStrategy(trigger)) return;
+    if (!peek(paused)) return;
+    if (trigger) this.#request.queue.enqueue("media-play-request", trigger);
+    const isAutoPlaying = peek(autoPlaying);
+    try {
+      const provider = peek(this.#$provider);
+      throwIfNotReadyForPlayback(provider, peek(canPlay));
+      return await provider.play();
+    } catch (error) {
+      const errorEvent = this.createEvent("play-fail", {
+        detail: coerceToError(error),
+        trigger
+      });
+      errorEvent.autoPlay = isAutoPlaying;
+      this.#stateMgr.handle(errorEvent);
+      throw error;
+    }
+  }
+  #handleLoadPlayStrategy(trigger) {
+    const { load } = this.$props, { canLoad } = this.$state;
+    if (load() === "play" && !canLoad()) {
+      const event = this.createEvent("media-start-loading", { trigger });
+      this.dispatchEvent(event);
+      this.#providerQueue.enqueue("media-play-request", async () => {
+        try {
+          await this.play(event);
+        } catch (error) {
+        }
+      });
+      return true;
+    }
+    return false;
+  }
+  async pause(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, paused } = this.$state;
+    if (peek(paused)) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-pause-request", trigger);
+    }
+    try {
+      const provider = peek(this.#$provider);
+      throwIfNotReadyForPlayback(provider, peek(canPlay));
+      return await provider.pause();
+    } catch (error) {
+      this.#request.queue.delete("media-pause-request");
+      throw error;
+    }
+  }
+  setAudioGain(gain, trigger) {
+    const { audioGain, canSetAudioGain } = this.$state;
+    if (audioGain() === gain) return;
+    const provider = this.#$provider();
+    if (!provider?.audioGain || !canSetAudioGain()) {
+      throw Error("[vidstack] audio gain api not available");
+    }
+    if (trigger) {
+      this.#request.queue.enqueue("media-audio-gain-change-request", trigger);
+    }
+    provider.audioGain.setGain(gain);
+  }
+  seekToLiveEdge(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, live, liveEdge, canSeek, liveSyncPosition, seekableEnd, userBehindLiveEdge } = this.$state;
+    userBehindLiveEdge.set(false);
+    if (peek(() => !live() || liveEdge() || !canSeek())) return;
+    const provider = peek(this.#$provider);
+    throwIfNotReadyForPlayback(provider, peek(canPlay));
+    if (trigger) this.#request.queue.enqueue("media-seek-request", trigger);
+    const end = seekableEnd() - 2;
+    provider.setCurrentTime(Math.min(end, liveSyncPosition() ?? end));
+  }
+  #wasPIPActive = false;
+  async enterFullscreen(target = "prefer-media", trigger) {
+    if (IS_SERVER) return;
+    const adapter = this.#getFullscreenAdapter(target);
+    throwIfFullscreenNotSupported(target, adapter);
+    if (adapter.active) return;
+    if (peek(this.$state.pictureInPicture)) {
+      this.#wasPIPActive = true;
+      await this.exitPictureInPicture(trigger);
+    }
+    if (trigger) {
+      this.#request.queue.enqueue("media-enter-fullscreen-request", trigger);
+    }
+    return adapter.enter();
+  }
+  async exitFullscreen(target = "prefer-media", trigger) {
+    if (IS_SERVER) return;
+    const adapter = this.#getFullscreenAdapter(target);
+    throwIfFullscreenNotSupported(target, adapter);
+    if (!adapter.active) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-exit-fullscreen-request", trigger);
+    }
+    try {
+      const result = await adapter.exit();
+      if (this.#wasPIPActive && peek(this.$state.canPictureInPicture)) {
+        await this.enterPictureInPicture();
+      }
+      return result;
+    } finally {
+      this.#wasPIPActive = false;
+    }
+  }
+  #getFullscreenAdapter(target) {
+    const provider = peek(this.#$provider);
+    return target === "prefer-media" && this.#fullscreen.supported || target === "media" ? this.#fullscreen : provider?.fullscreen;
+  }
+  async enterPictureInPicture(trigger) {
+    if (IS_SERVER) return;
+    this.#throwIfPIPNotSupported();
+    if (this.$state.pictureInPicture()) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-enter-pip-request", trigger);
+    }
+    return await this.#$provider().pictureInPicture.enter();
+  }
+  async exitPictureInPicture(trigger) {
+    if (IS_SERVER) return;
+    this.#throwIfPIPNotSupported();
+    if (!this.$state.pictureInPicture()) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-exit-pip-request", trigger);
+    }
+    return await this.#$provider().pictureInPicture.exit();
+  }
+  #throwIfPIPNotSupported() {
+    if (this.$state.canPictureInPicture()) return;
+    throw Error(
+      "[vidstack] no pip support"
+    );
+  }
+  #watchControlsDelayChange() {
+    this.controls.defaultDelay = this.$props.controlsDelay();
+  }
+  #watchAudioGainSupport() {
+    const { canSetAudioGain } = this.$state, supported = !!this.#$provider()?.audioGain?.supported;
+    canSetAudioGain.set(supported);
+  }
+  #watchAirPlaySupport() {
+    const { canAirPlay } = this.$state, supported = !!this.#$provider()?.airPlay?.supported;
+    canAirPlay.set(supported);
+  }
+  #watchGoogleCastSupport() {
+    const { canGoogleCast, source } = this.$state, supported = IS_CHROME && !IS_IOS && canGoogleCastSrc(source());
+    canGoogleCast.set(supported);
+  }
+  #watchFullscreenSupport() {
+    const { canFullscreen } = this.$state, supported = this.#fullscreen.supported || !!this.#$provider()?.fullscreen?.supported;
+    canFullscreen.set(supported);
+  }
+  #watchPiPSupport() {
+    const { canPictureInPicture } = this.$state, supported = !!this.#$provider()?.pictureInPicture?.supported;
+    canPictureInPicture.set(supported);
+  }
+  async ["media-airplay-request"](event) {
+    try {
+      await this.requestAirPlay(event);
+    } catch (error) {
+    }
+  }
+  async requestAirPlay(trigger) {
+    try {
+      const adapter = this.#$provider()?.airPlay;
+      if (!adapter?.supported) {
+        throw Error(false ? "AirPlay adapter not available on provider." : "No AirPlay adapter.");
+      }
+      if (trigger) {
+        this.#request.queue.enqueue("media-airplay-request", trigger);
+      }
+      return await adapter.prompt();
+    } catch (error) {
+      this.#request.queue.delete("media-airplay-request");
+      throw error;
+    }
+  }
+  async ["media-google-cast-request"](event) {
+    try {
+      await this.requestGoogleCast(event);
+    } catch (error) {
+    }
+  }
+  #googleCastLoader;
+  async requestGoogleCast(trigger) {
+    try {
+      const { canGoogleCast } = this.$state;
+      if (!peek(canGoogleCast)) {
+        const error = Error(
+          false ? "Google Cast not available on this platform." : "Cast not available."
+        );
+        error.code = "CAST_NOT_AVAILABLE";
+        throw error;
+      }
+      preconnect("https://www.gstatic.com");
+      if (!this.#googleCastLoader) {
+        const $module = await import('./vidstack-BnZ6XdXq.js').then(function (n) { return n.loader; });
+        this.#googleCastLoader = new $module.GoogleCastLoader();
+      }
+      await this.#googleCastLoader.prompt(this.#media);
+      if (trigger) {
+        this.#request.queue.enqueue("media-google-cast-request", trigger);
+      }
+      const isConnecting = peek(this.$state.remotePlaybackState) !== "disconnected";
+      if (isConnecting) {
+        this.$state.savedState.set({
+          paused: peek(this.$state.paused),
+          currentTime: peek(this.$state.currentTime)
+        });
+      }
+      this.$state.remotePlaybackLoader.set(isConnecting ? this.#googleCastLoader : null);
+    } catch (error) {
+      this.#request.queue.delete("media-google-cast-request");
+      throw error;
+    }
+  }
+  ["media-clip-start-change-request"](event) {
+    const { clipStartTime } = this.$state;
+    clipStartTime.set(event.detail);
+  }
+  ["media-clip-end-change-request"](event) {
+    const { clipEndTime } = this.$state;
+    clipEndTime.set(event.detail);
+    this.dispatch("duration-change", {
+      detail: event.detail,
+      trigger: event
+    });
+  }
+  ["media-duration-change-request"](event) {
+    const { providedDuration, clipEndTime } = this.$state;
+    providedDuration.set(event.detail);
+    if (clipEndTime() <= 0) {
+      this.dispatch("duration-change", {
+        detail: event.detail,
+        trigger: event
+      });
+    }
+  }
+  ["media-audio-track-change-request"](event) {
+    const { logger, audioTracks } = this.#media;
+    if (audioTracks.readonly) {
+      return;
+    }
+    const index = event.detail, track = audioTracks[index];
+    if (track) {
+      const key = event.type;
+      this.#request.queue.enqueue(key, event);
+      track.selected = true;
+    }
+  }
+  async ["media-enter-fullscreen-request"](event) {
+    try {
+      await this.enterFullscreen(event.detail, event);
+    } catch (error) {
+      this.#onFullscreenError(error, event);
+    }
+  }
+  async ["media-exit-fullscreen-request"](event) {
+    try {
+      await this.exitFullscreen(event.detail, event);
+    } catch (error) {
+      this.#onFullscreenError(error, event);
+    }
+  }
+  async #onFullscreenChange(event) {
+    const lockType = peek(this.$props.fullscreenOrientation), isFullscreen = event.detail;
+    if (isUndefined(lockType) || lockType === "none" || !this.#orientation.supported) return;
+    if (isFullscreen) {
+      if (this.#orientation.locked) return;
+      this.dispatch("media-orientation-lock-request", {
+        detail: lockType,
+        trigger: event
+      });
+    } else if (this.#orientation.locked) {
+      this.dispatch("media-orientation-unlock-request", {
+        trigger: event
+      });
+    }
+  }
+  #onFullscreenError(error, request) {
+    this.#stateMgr.handle(
+      this.createEvent("fullscreen-error", {
+        detail: coerceToError(error)
+      })
+    );
+  }
+  async ["media-orientation-lock-request"](event) {
+    const key = event.type;
+    try {
+      this.#request.queue.enqueue(key, event);
+      await this.#orientation.lock(event.detail);
+    } catch (error) {
+      this.#request.queue.delete(key);
+    }
+  }
+  async ["media-orientation-unlock-request"](event) {
+    const key = event.type;
+    try {
+      this.#request.queue.enqueue(key, event);
+      await this.#orientation.unlock();
+    } catch (error) {
+      this.#request.queue.delete(key);
+    }
+  }
+  async ["media-enter-pip-request"](event) {
+    try {
+      await this.enterPictureInPicture(event);
+    } catch (error) {
+      this.#onPictureInPictureError(error, event);
+    }
+  }
+  async ["media-exit-pip-request"](event) {
+    try {
+      await this.exitPictureInPicture(event);
+    } catch (error) {
+      this.#onPictureInPictureError(error, event);
+    }
+  }
+  #onPictureInPictureError(error, request) {
+    this.#stateMgr.handle(
+      this.createEvent("picture-in-picture-error", {
+        detail: coerceToError(error)
+      })
+    );
+  }
+  ["media-live-edge-request"](event) {
+    const { live, liveEdge, canSeek } = this.$state;
+    if (!live() || liveEdge() || !canSeek()) return;
+    this.#request.queue.enqueue("media-seek-request", event);
+    try {
+      this.seekToLiveEdge();
+    } catch (error) {
+      this.#request.queue.delete("media-seek-request");
+    }
+  }
+  async ["media-loop-request"](event) {
+    try {
+      this.#request.looping = true;
+      this.#request.replaying = true;
+      await this.play(event);
+    } catch (error) {
+      this.#request.looping = false;
+    }
+  }
+  ["media-user-loop-change-request"](event) {
+    this.$state.userPrefersLoop.set(event.detail);
+  }
+  async ["media-pause-request"](event) {
+    if (this.$state.paused()) return;
+    try {
+      await this.pause(event);
+    } catch (error) {
+    }
+  }
+  async ["media-play-request"](event) {
+    if (!this.$state.paused()) return;
+    try {
+      await this.play(event);
+    } catch (e) {
+    }
+  }
+  ["media-rate-change-request"](event) {
+    const { playbackRate, canSetPlaybackRate } = this.$state;
+    if (playbackRate() === event.detail || !canSetPlaybackRate()) return;
+    const provider = this.#$provider();
+    if (!provider?.setPlaybackRate) return;
+    this.#request.queue.enqueue("media-rate-change-request", event);
+    provider.setPlaybackRate(event.detail);
+  }
+  ["media-audio-gain-change-request"](event) {
+    try {
+      this.setAudioGain(event.detail, event);
+    } catch (e) {
+    }
+  }
+  ["media-quality-change-request"](event) {
+    const { qualities, storage, logger } = this.#media;
+    if (qualities.readonly) {
+      return;
+    }
+    this.#request.queue.enqueue("media-quality-change-request", event);
+    const index = event.detail;
+    if (index < 0) {
+      qualities.autoSelect(event);
+      if (event.isOriginTrusted) storage?.setVideoQuality?.(null);
+    } else {
+      const quality = qualities[index];
+      if (quality) {
+        quality.selected = true;
+        if (event.isOriginTrusted) {
+          storage?.setVideoQuality?.({
+            id: quality.id,
+            width: quality.width,
+            height: quality.height,
+            bitrate: quality.bitrate
+          });
+        }
+      }
+    }
+  }
+  ["media-pause-controls-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.controls.pause(event);
+  }
+  ["media-resume-controls-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.controls.resume(event);
+  }
+  ["media-seek-request"](event) {
+    const { canSeek, ended, live, seekableEnd, userBehindLiveEdge } = this.$state, seekTime = event.detail;
+    if (ended()) this.#request.replaying = true;
+    const key = event.type;
+    this.#request.seeking = false;
+    this.#request.queue.delete(key);
+    const boundedTime = boundTime(seekTime, this.$state);
+    if (!Number.isFinite(boundedTime) || !canSeek()) return;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setCurrentTime(boundedTime);
+    if (live() && event.isOriginTrusted && Math.abs(seekableEnd() - boundedTime) >= 2) {
+      userBehindLiveEdge.set(true);
+    }
+  }
+  ["media-seeking-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.$state.seeking.set(true);
+    this.#request.seeking = true;
+  }
+  ["media-start-loading"](event) {
+    if (this.$state.canLoad()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#stateMgr.handle(this.createEvent("can-load"));
+  }
+  ["media-poster-start-loading"](event) {
+    if (this.$state.canLoadPoster()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#stateMgr.handle(this.createEvent("can-load-poster"));
+  }
+  ["media-text-track-change-request"](event) {
+    const { index, mode } = event.detail, track = this.#media.textTracks[index];
+    if (track) {
+      const key = event.type;
+      this.#request.queue.enqueue(key, event);
+      track.setMode(mode, event);
+    }
+  }
+  ["media-mute-request"](event) {
+    if (this.$state.muted()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setMuted(true);
+  }
+  ["media-unmute-request"](event) {
+    const { muted, volume } = this.$state;
+    if (!muted()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#media.$provider().setMuted(false);
+    if (volume() === 0) {
+      this.#request.queue.enqueue(key, event);
+      this.#$provider().setVolume(0.25);
+    }
+  }
+  ["media-volume-change-request"](event) {
+    const { muted, volume } = this.$state;
+    const newVolume = event.detail;
+    if (volume() === newVolume) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setVolume(newVolume);
+    if (newVolume > 0 && muted()) {
+      this.#request.queue.enqueue(key, event);
+      this.#$provider().setMuted(false);
+    }
+  }
+  #logError(title, error, request) {
+    return;
+  }
+}
+function throwIfNotReadyForPlayback(provider, canPlay) {
+  if (provider && canPlay) return;
+  throw Error(
+    "[vidstack] media not ready"
+  );
+}
+function throwIfFullscreenNotSupported(target, fullscreen) {
+  if (fullscreen?.supported) return;
+  throw Error(
+    "[vidstack] no fullscreen support"
+  );
+}
+class MediaRequestContext {
+  seeking = false;
+  looping = false;
+  replaying = false;
+  queue = new Queue();
+}
+
+const TRACKED_EVENT = /* @__PURE__ */ new Set([
+  "auto-play",
+  "auto-play-fail",
+  "can-load",
+  "sources-change",
+  "source-change",
+  "load-start",
+  "abort",
+  "error",
+  "loaded-metadata",
+  "loaded-data",
+  "can-play",
+  "play",
+  "play-fail",
+  "pause",
+  "playing",
+  "seeking",
+  "seeked",
+  "waiting"
+]);
+
+class MediaStateManager extends MediaPlayerController {
+  #request;
+  #media;
+  #trackedEvents = /* @__PURE__ */ new Map();
+  #clipEnded = false;
+  #playedIntervals = [];
+  #playedInterval = [-1, -1];
+  #firingWaiting = false;
+  #waitingTrigger;
+  constructor(request, media) {
+    super();
+    this.#request = request;
+    this.#media = media;
+  }
+  onAttach(el) {
+    el.setAttribute("aria-busy", "true");
+    new EventsController(this).add("fullscreen-change", this["fullscreen-change"].bind(this)).add("fullscreen-error", this["fullscreen-error"].bind(this)).add("orientation-change", this["orientation-change"].bind(this));
+  }
+  onConnect(el) {
+    effect(this.#watchCanSetVolume.bind(this));
+    this.#addTextTrackListeners();
+    this.#addQualityListeners();
+    this.#addAudioTrackListeners();
+    this.#resumePlaybackOnConnect();
+    onDispose(this.#pausePlaybackOnDisconnect.bind(this));
+  }
+  onDestroy() {
+    const { audioTracks, qualities, textTracks } = this.#media;
+    audioTracks[ListSymbol.reset]();
+    qualities[ListSymbol.reset]();
+    textTracks[ListSymbol.reset]();
+    this.#stopWatchingQualityResize();
+  }
+  handle(event) {
+    if (!this.scope) return;
+    const type = event.type;
+    untrack(() => this[event.type]?.(event));
+    if (!IS_SERVER) {
+      if (TRACKED_EVENT.has(type)) this.#trackedEvents.set(type, event);
+      this.dispatch(event);
+    }
+  }
+  #isPlayingOnDisconnect = false;
+  #resumePlaybackOnConnect() {
+    if (!this.#isPlayingOnDisconnect) return;
+    requestAnimationFrame(() => {
+      if (!this.scope) return;
+      this.#media.remote.play(new DOMEvent("dom-connect"));
+    });
+    this.#isPlayingOnDisconnect = false;
+  }
+  #pausePlaybackOnDisconnect() {
+    if (this.#isPlayingOnDisconnect) return;
+    this.#isPlayingOnDisconnect = !this.$state.paused();
+    this.#media.$provider()?.pause();
+  }
+  #resetTracking() {
+    this.#stopWaiting();
+    this.#clipEnded = false;
+    this.#request.replaying = false;
+    this.#request.looping = false;
+    this.#firingWaiting = false;
+    this.#waitingTrigger = void 0;
+    this.#trackedEvents.clear();
+  }
+  #satisfyRequest(request, event) {
+    const requestEvent = this.#request.queue.serve(request);
+    if (!requestEvent) return;
+    event.request = requestEvent;
+    event.triggers.add(requestEvent);
+  }
+  #addTextTrackListeners() {
+    this.#onTextTracksChange();
+    this.#onTextTrackModeChange();
+    const textTracks = this.#media.textTracks;
+    new EventsController(textTracks).add("add", this.#onTextTracksChange.bind(this)).add("remove", this.#onTextTracksChange.bind(this)).add("mode-change", this.#onTextTrackModeChange.bind(this));
+  }
+  #addQualityListeners() {
+    const qualities = this.#media.qualities;
+    new EventsController(qualities).add("add", this.#onQualitiesChange.bind(this)).add("remove", this.#onQualitiesChange.bind(this)).add("change", this.#onQualityChange.bind(this)).add("auto-change", this.#onAutoQualityChange.bind(this)).add("readonly-change", this.#onCanSetQualityChange.bind(this));
+  }
+  #addAudioTrackListeners() {
+    const audioTracks = this.#media.audioTracks;
+    new EventsController(audioTracks).add("add", this.#onAudioTracksChange.bind(this)).add("remove", this.#onAudioTracksChange.bind(this)).add("change", this.#onAudioTrackChange.bind(this));
+  }
+  #onTextTracksChange(event) {
+    const { textTracks } = this.$state;
+    textTracks.set(this.#media.textTracks.toArray());
+    this.dispatch("text-tracks-change", {
+      detail: textTracks(),
+      trigger: event
+    });
+  }
+  #onTextTrackModeChange(event) {
+    if (event) this.#satisfyRequest("media-text-track-change-request", event);
+    const current = this.#media.textTracks.selected, { textTrack } = this.$state;
+    if (textTrack() !== current) {
+      textTrack.set(current);
+      this.dispatch("text-track-change", {
+        detail: current,
+        trigger: event
+      });
+    }
+  }
+  #onAudioTracksChange(event) {
+    const { audioTracks } = this.$state;
+    audioTracks.set(this.#media.audioTracks.toArray());
+    this.dispatch("audio-tracks-change", {
+      detail: audioTracks(),
+      trigger: event
+    });
+  }
+  #onAudioTrackChange(event) {
+    const { audioTrack } = this.$state;
+    audioTrack.set(this.#media.audioTracks.selected);
+    if (event) this.#satisfyRequest("media-audio-track-change-request", event);
+    this.dispatch("audio-track-change", {
+      detail: audioTrack(),
+      trigger: event
+    });
+  }
+  #onQualitiesChange(event) {
+    const { qualities } = this.$state;
+    qualities.set(this.#media.qualities.toArray());
+    this.dispatch("qualities-change", {
+      detail: qualities(),
+      trigger: event
+    });
+  }
+  #onQualityChange(event) {
+    const { quality } = this.$state;
+    quality.set(this.#media.qualities.selected);
+    if (event) this.#satisfyRequest("media-quality-change-request", event);
+    this.dispatch("quality-change", {
+      detail: quality(),
+      trigger: event
+    });
+  }
+  #onAutoQualityChange() {
+    const { qualities } = this.#media, isAuto = qualities.auto;
+    this.$state.autoQuality.set(isAuto);
+    if (!isAuto) this.#stopWatchingQualityResize();
+  }
+  #stopQualityResizeEffect = null;
+  #watchQualityResize() {
+    this.#stopWatchingQualityResize();
+    this.#stopQualityResizeEffect = effect(() => {
+      const { qualities } = this.#media, { mediaWidth, mediaHeight } = this.$state, w = mediaWidth(), h = mediaHeight();
+      if (w === 0 || h === 0) return;
+      let selectedQuality = null, minScore = Infinity;
+      for (const quality of qualities) {
+        const score = Math.abs(quality.width - w) + Math.abs(quality.height - h);
+        if (score < minScore) {
+          minScore = score;
+          selectedQuality = quality;
+        }
+      }
+      if (selectedQuality) {
+        qualities[ListSymbol.select](
+          selectedQuality,
+          true,
+          new DOMEvent("resize", { detail: { width: w, height: h } })
+        );
+      }
+    });
+  }
+  #stopWatchingQualityResize() {
+    this.#stopQualityResizeEffect?.();
+    this.#stopQualityResizeEffect = null;
+  }
+  #onCanSetQualityChange() {
+    this.$state.canSetQuality.set(!this.#media.qualities.readonly);
+  }
+  #watchCanSetVolume() {
+    const { canSetVolume, isGoogleCastConnected } = this.$state;
+    if (isGoogleCastConnected()) {
+      canSetVolume.set(false);
+      return;
+    }
+    canChangeVolume().then(canSetVolume.set);
+  }
+  ["provider-change"](event) {
+    const prevProvider = this.#media.$provider(), newProvider = event.detail;
+    if (prevProvider?.type === newProvider?.type) return;
+    prevProvider?.destroy?.();
+    prevProvider?.scope?.dispose();
+    this.#media.$provider.set(event.detail);
+    if (prevProvider && event.detail === null) {
+      this.#resetMediaState(event);
+    }
+  }
+  ["provider-loader-change"](event) {
+  }
+  ["auto-play"](event) {
+    this.$state.autoPlayError.set(null);
+  }
+  ["auto-play-fail"](event) {
+    this.$state.autoPlayError.set(event.detail);
+    this.#resetTracking();
+  }
+  ["can-load"](event) {
+    this.$state.canLoad.set(true);
+    this.#trackedEvents.set("can-load", event);
+    this.#media.textTracks[TextTrackSymbol.canLoad]();
+    this.#satisfyRequest("media-start-loading", event);
+  }
+  ["can-load-poster"](event) {
+    this.$state.canLoadPoster.set(true);
+    this.#trackedEvents.set("can-load-poster", event);
+    this.#satisfyRequest("media-poster-start-loading", event);
+  }
+  ["media-type-change"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const viewType = this.$state.viewType();
+    this.$state.mediaType.set(event.detail);
+    const providedViewType = this.$state.providedViewType(), currentViewType = providedViewType === "unknown" ? event.detail : providedViewType;
+    if (viewType !== currentViewType) {
+      if (IS_SERVER) {
+        this.$state.inferredViewType.set(currentViewType);
+      } else {
+        setTimeout(() => {
+          requestAnimationFrame(() => {
+            if (!this.scope) return;
+            this.$state.inferredViewType.set(event.detail);
+            this.dispatch("view-type-change", {
+              detail: currentViewType,
+              trigger: event
+            });
+          });
+        }, 0);
+      }
+    }
+  }
+  ["stream-type-change"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const { streamType, inferredStreamType } = this.$state;
+    inferredStreamType.set(event.detail);
+    event.detail = streamType();
+  }
+  ["rate-change"](event) {
+    const { storage } = this.#media, { canPlay } = this.$state;
+    this.$state.playbackRate.set(event.detail);
+    this.#satisfyRequest("media-rate-change-request", event);
+    if (canPlay()) {
+      storage?.setPlaybackRate?.(event.detail);
+    }
+  }
+  ["remote-playback-change"](event) {
+    const { remotePlaybackState, remotePlaybackType } = this.$state, { type, state } = event.detail, isConnected = state === "connected";
+    remotePlaybackType.set(type);
+    remotePlaybackState.set(state);
+    const key = type === "airplay" ? "media-airplay-request" : "media-google-cast-request";
+    if (isConnected) {
+      this.#satisfyRequest(key, event);
+    } else {
+      const requestEvent = this.#request.queue.peek(key);
+      if (requestEvent) {
+        event.request = requestEvent;
+        event.triggers.add(requestEvent);
+      }
+    }
+  }
+  ["sources-change"](event) {
+    const prevSources = this.$state.sources(), newSources = event.detail;
+    this.$state.sources.set(newSources);
+    this.#onSourceQualitiesChange(prevSources, newSources, event);
+  }
+  #onSourceQualitiesChange(prevSources, newSources, trigger) {
+    let { qualities } = this.#media, added = false, removed = false;
+    for (const prevSrc of prevSources) {
+      if (!isVideoQualitySrc(prevSrc)) continue;
+      const exists = newSources.some((s) => s.src === prevSrc.src);
+      if (!exists) {
+        const quality = qualities.getBySrc(prevSrc.src);
+        if (quality) {
+          qualities[ListSymbol.remove](quality, trigger);
+          removed = true;
+        }
+      }
+    }
+    if (removed && !qualities.length) {
+      this.$state.savedState.set(null);
+      qualities[ListSymbol.reset](trigger);
+    }
+    for (const src of newSources) {
+      if (!isVideoQualitySrc(src) || qualities.getBySrc(src.src)) continue;
+      const quality = {
+        id: src.id ?? src.height + "p",
+        bitrate: null,
+        codec: null,
+        ...src,
+        selected: false
+      };
+      qualities[ListSymbol.add](quality, trigger);
+      added = true;
+    }
+    if (added && !qualities[QualitySymbol.enableAuto]) {
+      this.#watchQualityResize();
+      qualities[QualitySymbol.enableAuto] = this.#watchQualityResize.bind(this);
+      qualities[QualitySymbol.setAuto](true, trigger);
+    }
+  }
+  ["source-change"](event) {
+    event.isQualityChange = event.originEvent?.type === "quality-change";
+    const source = event.detail;
+    this.#resetMediaState(event, event.isQualityChange);
+    this.#trackedEvents.set(event.type, event);
+    this.$state.source.set(source);
+    this.el?.setAttribute("aria-busy", "true");
+  }
+  #resetMediaState(event, isSourceQualityChange = false) {
+    const { audioTracks, qualities } = this.#media;
+    if (!isSourceQualityChange) {
+      this.#playedIntervals = [];
+      this.#playedInterval = [-1, -1];
+      audioTracks[ListSymbol.reset](event);
+      qualities[ListSymbol.reset](event);
+      softResetMediaState(this.$state, isSourceQualityChange);
+      this.#resetTracking();
+      return;
+    }
+    softResetMediaState(this.$state, isSourceQualityChange);
+    this.#resetTracking();
+  }
+  ["abort"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const canLoadEvent = this.#trackedEvents.get("can-load");
+    if (canLoadEvent && !event.triggers.hasType("can-load")) {
+      event.triggers.add(canLoadEvent);
+    }
+  }
+  ["load-start"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+  }
+  ["error"](event) {
+    this.$state.error.set(event.detail);
+    const abortEvent = this.#trackedEvents.get("abort");
+    if (abortEvent) event.triggers.add(abortEvent);
+  }
+  ["loaded-metadata"](event) {
+    const loadStartEvent = this.#trackedEvents.get("load-start");
+    if (loadStartEvent) event.triggers.add(loadStartEvent);
+  }
+  ["loaded-data"](event) {
+    const loadStartEvent = this.#trackedEvents.get("load-start");
+    if (loadStartEvent) event.triggers.add(loadStartEvent);
+  }
+  ["can-play"](event) {
+    const loadedMetadata = this.#trackedEvents.get("loaded-metadata");
+    if (loadedMetadata) event.triggers.add(loadedMetadata);
+    this.#onCanPlayDetail(event.detail);
+    this.el?.setAttribute("aria-busy", "false");
+  }
+  ["can-play-through"](event) {
+    this.#onCanPlayDetail(event.detail);
+    const canPlay = this.#trackedEvents.get("can-play");
+    if (canPlay) event.triggers.add(canPlay);
+  }
+  #onCanPlayDetail(detail) {
+    const { seekable, buffered, intrinsicDuration, canPlay } = this.$state;
+    canPlay.set(true);
+    buffered.set(detail.buffered);
+    seekable.set(detail.seekable);
+    const seekableEnd = getTimeRangesEnd(detail.seekable) ?? Infinity;
+    intrinsicDuration.set(seekableEnd);
+  }
+  ["duration-change"](event) {
+    const { live, intrinsicDuration, providedDuration, clipEndTime, ended } = this.$state, time = event.detail;
+    if (!live()) {
+      const duration = !Number.isNaN(time) ? time : 0;
+      intrinsicDuration.set(duration);
+      if (ended()) this.#onEndPrecisionChange(event);
+    }
+    if (providedDuration() > 0 || clipEndTime() > 0) {
+      event.stopImmediatePropagation();
+    }
+  }
+  ["progress"](event) {
+    const { buffered, seekable } = this.$state, { buffered: newBuffered, seekable: newSeekable } = event.detail, newBufferedEnd = getTimeRangesEnd(newBuffered), hasBufferedLengthChanged = newBuffered.length !== buffered().length, hasBufferedEndChanged = newBufferedEnd !== getTimeRangesEnd(buffered()), newSeekableEnd = getTimeRangesEnd(newSeekable), hasSeekableLengthChanged = newSeekable.length !== seekable().length, hasSeekableEndChanged = newSeekableEnd !== getTimeRangesEnd(seekable());
+    if (hasBufferedLengthChanged || hasBufferedEndChanged) {
+      buffered.set(newBuffered);
+    }
+    if (hasSeekableLengthChanged || hasSeekableEndChanged) {
+      seekable.set(newSeekable);
+    }
+  }
+  ["play"](event) {
+    const {
+      paused,
+      autoPlayError,
+      ended,
+      autoPlaying,
+      playsInline,
+      pointer,
+      muted,
+      viewType,
+      live,
+      userBehindLiveEdge
+    } = this.$state;
+    this.#resetPlaybackIfNeeded();
+    if (!paused()) {
+      event.stopImmediatePropagation();
+      return;
+    }
+    event.autoPlay = autoPlaying();
+    const waitingEvent = this.#trackedEvents.get("waiting");
+    if (waitingEvent) event.triggers.add(waitingEvent);
+    this.#satisfyRequest("media-play-request", event);
+    this.#trackedEvents.set("play", event);
+    paused.set(false);
+    autoPlayError.set(null);
+    if (event.autoPlay) {
+      this.handle(
+        this.createEvent("auto-play", {
+          detail: { muted: muted() },
+          trigger: event
+        })
+      );
+      autoPlaying.set(false);
+    }
+    if (ended() || this.#request.replaying) {
+      this.#request.replaying = false;
+      ended.set(false);
+      this.handle(this.createEvent("replay", { trigger: event }));
+    }
+    if (!playsInline() && viewType() === "video" && pointer() === "coarse") {
+      this.#media.remote.enterFullscreen("prefer-media", event);
+    }
+    if (live() && !userBehindLiveEdge()) {
+      this.#media.remote.seekToLiveEdge(event);
+    }
+  }
+  #resetPlaybackIfNeeded(trigger) {
+    const provider = peek(this.#media.$provider);
+    if (!provider) return;
+    const { ended, seekableStart, clipEndTime, currentTime, realCurrentTime, duration } = this.$state;
+    const shouldReset = ended() || realCurrentTime() < seekableStart() || clipEndTime() > 0 && realCurrentTime() >= clipEndTime() || Math.abs(currentTime() - duration()) < 0.1;
+    if (shouldReset) {
+      this.dispatch("media-seek-request", {
+        detail: seekableStart(),
+        trigger
+      });
+    }
+    return shouldReset;
+  }
+  ["play-fail"](event) {
+    const { muted, autoPlaying } = this.$state;
+    const playEvent = this.#trackedEvents.get("play");
+    if (playEvent) event.triggers.add(playEvent);
+    this.#satisfyRequest("media-play-request", event);
+    const { paused, playing } = this.$state;
+    paused.set(true);
+    playing.set(false);
+    this.#resetTracking();
+    this.#trackedEvents.set("play-fail", event);
+    if (event.autoPlay) {
+      this.handle(
+        this.createEvent("auto-play-fail", {
+          detail: {
+            muted: muted(),
+            error: event.detail
+          },
+          trigger: event
+        })
+      );
+      autoPlaying.set(false);
+    }
+  }
+  ["playing"](event) {
+    const playEvent = this.#trackedEvents.get("play"), seekedEvent = this.#trackedEvents.get("seeked");
+    if (playEvent) event.triggers.add(playEvent);
+    else if (seekedEvent) event.triggers.add(seekedEvent);
+    setTimeout(() => this.#resetTracking(), 0);
+    const {
+      paused,
+      playing,
+      live,
+      liveSyncPosition,
+      seekableEnd,
+      started,
+      currentTime,
+      seeking,
+      ended
+    } = this.$state;
+    paused.set(false);
+    playing.set(true);
+    seeking.set(false);
+    ended.set(false);
+    if (this.#request.looping) {
+      this.#request.looping = false;
+      return;
+    }
+    if (live() && !started() && currentTime() === 0) {
+      const end = liveSyncPosition() ?? seekableEnd() - 2;
+      if (Number.isFinite(end)) this.#media.$provider().setCurrentTime(end);
+    }
+    this["started"](event);
+  }
+  ["started"](event) {
+    const { started } = this.$state;
+    if (!started()) {
+      started.set(true);
+      this.handle(this.createEvent("started", { trigger: event }));
+    }
+  }
+  ["pause"](event) {
+    if (!this.el?.isConnected) {
+      this.#isPlayingOnDisconnect = true;
+    }
+    this.#satisfyRequest("media-pause-request", event);
+    const seekedEvent = this.#trackedEvents.get("seeked");
+    if (seekedEvent) event.triggers.add(seekedEvent);
+    const { paused, playing } = this.$state;
+    paused.set(true);
+    playing.set(false);
+    if (this.#clipEnded) {
+      setTimeout(() => {
+        this.handle(this.createEvent("end", { trigger: event }));
+        this.#clipEnded = false;
+      }, 0);
+    }
+    this.#resetTracking();
+  }
+  ["time-change"](event) {
+    if (this.#request.looping) {
+      event.stopImmediatePropagation();
+      return;
+    }
+    let { waiting, played, clipEndTime, realCurrentTime, currentTime } = this.$state, newTime = event.detail, endTime = clipEndTime();
+    realCurrentTime.set(newTime);
+    this.#updatePlayed();
+    waiting.set(false);
+    for (const track of this.#media.textTracks) {
+      track[TextTrackSymbol.updateActiveCues](newTime, event);
+    }
+    if (endTime > 0 && newTime >= endTime) {
+      this.#clipEnded = true;
+      this.dispatch("media-pause-request", { trigger: event });
+    }
+    this.#saveTime();
+    this.dispatch("time-update", {
+      detail: { currentTime: currentTime(), played: played() },
+      trigger: event
+    });
+  }
+  #updatePlayed() {
+    const { currentTime, played, paused } = this.$state;
+    if (paused()) return;
+    this.#playedInterval = updateTimeIntervals(
+      this.#playedIntervals,
+      this.#playedInterval,
+      currentTime()
+    );
+    played.set(new TimeRange(this.#playedIntervals));
+  }
+  // Called to update time again incase duration precision has changed.
+  #onEndPrecisionChange(trigger) {
+    const { clipStartTime, clipEndTime, duration } = this.$state, isClipped = clipStartTime() > 0 || clipEndTime() > 0;
+    if (isClipped) return;
+    this.handle(
+      this.createEvent("time-change", {
+        detail: duration(),
+        trigger
+      })
+    );
+  }
+  #saveTime() {
+    const { storage } = this.#media, { canPlay, realCurrentTime } = this.$state;
+    if (canPlay()) {
+      storage?.setTime?.(realCurrentTime());
+    }
+  }
+  ["audio-gain-change"](event) {
+    const { storage } = this.#media, { canPlay, audioGain } = this.$state;
+    audioGain.set(event.detail);
+    this.#satisfyRequest("media-audio-gain-change-request", event);
+    if (canPlay()) storage?.setAudioGain?.(audioGain());
+  }
+  ["volume-change"](event) {
+    const { storage } = this.#media, { volume, muted, canPlay } = this.$state, detail = event.detail;
+    volume.set(detail.volume);
+    muted.set(detail.muted || detail.volume === 0);
+    this.#satisfyRequest("media-volume-change-request", event);
+    this.#satisfyRequest(detail.muted ? "media-mute-request" : "media-unmute-request", event);
+    if (canPlay()) {
+      storage?.setVolume?.(volume());
+      storage?.setMuted?.(muted());
+    }
+  }
+  ["seeking"] = functionThrottle(
+    (event) => {
+      const { seeking, realCurrentTime, paused } = this.$state;
+      seeking.set(true);
+      realCurrentTime.set(event.detail);
+      this.#satisfyRequest("media-seeking-request", event);
+      if (paused()) {
+        this.#waitingTrigger = event;
+        this.#fireWaiting();
+      }
+      this.#playedInterval = [-1, -1];
+    },
+    150,
+    { leading: true }
+  );
+  ["seeked"](event) {
+    const { seeking, currentTime, realCurrentTime, paused, seekableEnd, ended, live } = this.$state;
+    if (this.#request.seeking) {
+      seeking.set(true);
+      event.stopImmediatePropagation();
+    } else if (seeking()) {
+      const waitingEvent = this.#trackedEvents.get("waiting");
+      if (waitingEvent) event.triggers.add(waitingEvent);
+      const seekingEvent = this.#trackedEvents.get("seeking");
+      if (seekingEvent && !event.triggers.has(seekingEvent)) {
+        event.triggers.add(seekingEvent);
+      }
+      if (paused()) this.#stopWaiting();
+      seeking.set(false);
+      realCurrentTime.set(event.detail);
+      this.#satisfyRequest("media-seek-request", event);
+      const origin = event?.originEvent;
+      if (origin?.isTrusted && !(origin instanceof MessageEvent) && !/seek/.test(origin.type)) {
+        this["started"](event);
+      }
+    }
+    if (!live()) {
+      if (Math.floor(currentTime()) !== Math.floor(seekableEnd())) {
+        ended.set(false);
+      } else {
+        this.end(event);
+      }
+    }
+  }
+  ["waiting"](event) {
+    if (this.#firingWaiting || this.#request.seeking) return;
+    event.stopImmediatePropagation();
+    this.#waitingTrigger = event;
+    this.#fireWaiting();
+  }
+  #fireWaiting = functionDebounce(() => {
+    if (!this.#waitingTrigger) return;
+    this.#firingWaiting = true;
+    const { waiting, playing } = this.$state;
+    waiting.set(true);
+    playing.set(false);
+    const event = this.createEvent("waiting", { trigger: this.#waitingTrigger });
+    this.#trackedEvents.set("waiting", event);
+    this.dispatch(event);
+    this.#waitingTrigger = void 0;
+    this.#firingWaiting = false;
+  }, 300);
+  ["end"](event) {
+    const { loop, ended } = this.$state;
+    if (!loop() && ended()) return;
+    if (loop()) {
+      setTimeout(() => {
+        requestAnimationFrame(() => {
+          this.#resetPlaybackIfNeeded(event);
+          this.dispatch("media-loop-request", { trigger: event });
+        });
+      }, 10);
+      return;
+    }
+    setTimeout(() => this.#onEnded(event), 0);
+  }
+  #onEnded(event) {
+    const { storage } = this.#media, { paused, seeking, ended, duration } = this.$state;
+    this.#onEndPrecisionChange(event);
+    if (!paused()) {
+      this.dispatch("pause", { trigger: event });
+    }
+    if (seeking()) {
+      this.dispatch("seeked", {
+        detail: duration(),
+        trigger: event
+      });
+    }
+    ended.set(true);
+    this.#resetTracking();
+    storage?.setTime?.(duration(), true);
+    this.dispatch("ended", {
+      trigger: event
+    });
+  }
+  #stopWaiting() {
+    this.#fireWaiting.cancel();
+    this.$state.waiting.set(false);
+  }
+  ["fullscreen-change"](event) {
+    const isFullscreen = event.detail;
+    this.$state.fullscreen.set(isFullscreen);
+    this.#satisfyRequest(
+      isFullscreen ? "media-enter-fullscreen-request" : "media-exit-fullscreen-request",
+      event
+    );
+  }
+  ["fullscreen-error"](event) {
+    this.#satisfyRequest("media-enter-fullscreen-request", event);
+    this.#satisfyRequest("media-exit-fullscreen-request", event);
+  }
+  ["orientation-change"](event) {
+    const isLocked = event.detail.lock;
+    this.#satisfyRequest(
+      isLocked ? "media-orientation-lock-request" : "media-orientation-unlock-request",
+      event
+    );
+  }
+  ["picture-in-picture-change"](event) {
+    const isPiP = event.detail;
+    this.$state.pictureInPicture.set(isPiP);
+    this.#satisfyRequest(isPiP ? "media-enter-pip-request" : "media-exit-pip-request", event);
+  }
+  ["picture-in-picture-error"](event) {
+    this.#satisfyRequest("media-enter-pip-request", event);
+    this.#satisfyRequest("media-exit-pip-request", event);
+  }
+  ["title-change"](event) {
+    if (!event.trigger) return;
+    event.stopImmediatePropagation();
+    this.$state.inferredTitle.set(event.detail);
+  }
+  ["poster-change"](event) {
+    if (!event.trigger) return;
+    event.stopImmediatePropagation();
+    this.$state.inferredPoster.set(event.detail);
+  }
+}
+
+class MediaStateSync extends MediaPlayerController {
+  onSetup() {
+    this.#init();
+    if (IS_SERVER) return;
+    const effects = [
+      this.#watchMetadata,
+      this.#watchAutoplay,
+      this.#watchClipStartTime,
+      this.#watchClipEndTime,
+      this.#watchControls,
+      this.#watchCrossOrigin,
+      this.#watchDuration,
+      this.#watchLive,
+      this.#watchLiveEdge,
+      this.#watchLiveTolerance,
+      this.#watchLoop,
+      this.#watchPlaysInline,
+      this.#watchPoster,
+      this.#watchProvidedTypes,
+      this.#watchTitle
+    ];
+    for (const callback of effects) {
+      effect(callback.bind(this));
+    }
+  }
+  #init() {
+    const providedProps = {
+      duration: "providedDuration",
+      loop: "providedLoop",
+      poster: "providedPoster",
+      streamType: "providedStreamType",
+      title: "providedTitle",
+      viewType: "providedViewType"
+    };
+    const skip = /* @__PURE__ */ new Set([
+      "currentTime",
+      "paused",
+      "playbackRate",
+      "volume"
+    ]);
+    for (const prop of Object.keys(this.$props)) {
+      if (skip.has(prop)) continue;
+      this.$state[providedProps[prop] ?? prop]?.set(this.$props[prop]());
+    }
+    this.$state.muted.set(this.$props.muted() || this.$props.volume() === 0);
+  }
+  // Sync "provided" props with internal state. Provided props are used to differentiate from
+  // provider inferred values.
+  #watchProvidedTypes() {
+    const { viewType, streamType, title, poster, loop } = this.$props, $state = this.$state;
+    $state.providedPoster.set(poster());
+    $state.providedStreamType.set(streamType());
+    $state.providedViewType.set(viewType());
+    $state.providedTitle.set(title());
+    $state.providedLoop.set(loop());
+  }
+  #watchLogLevel() {
+    return;
+  }
+  #watchMetadata() {
+    const { artist, artwork } = this.$props;
+    this.$state.artist.set(artist());
+    this.$state.artwork.set(artwork());
+  }
+  #watchTitle() {
+    const { title } = this.$state;
+    this.dispatch("title-change", { detail: title() });
+  }
+  #watchAutoplay() {
+    const autoPlay = this.$props.autoPlay() || this.$props.autoplay();
+    this.$state.autoPlay.set(autoPlay);
+    this.dispatch("auto-play-change", { detail: autoPlay });
+  }
+  #watchLoop() {
+    const loop = this.$state.loop();
+    this.dispatch("loop-change", { detail: loop });
+  }
+  #watchControls() {
+    const controls = this.$props.controls();
+    this.$state.controls.set(controls);
+  }
+  #watchPoster() {
+    const { poster } = this.$state;
+    this.dispatch("poster-change", { detail: poster() });
+  }
+  #watchCrossOrigin() {
+    const crossOrigin = this.$props.crossOrigin() ?? this.$props.crossorigin(), value = crossOrigin === true ? "" : crossOrigin;
+    this.$state.crossOrigin.set(value);
+  }
+  #watchDuration() {
+    const { duration } = this.$props;
+    this.dispatch("media-duration-change-request", {
+      detail: duration()
+    });
+  }
+  #watchPlaysInline() {
+    const inline = this.$props.playsInline() || this.$props.playsinline();
+    this.$state.playsInline.set(inline);
+    this.dispatch("plays-inline-change", { detail: inline });
+  }
+  #watchClipStartTime() {
+    const { clipStartTime } = this.$props;
+    this.dispatch("media-clip-start-change-request", {
+      detail: clipStartTime()
+    });
+  }
+  #watchClipEndTime() {
+    const { clipEndTime } = this.$props;
+    this.dispatch("media-clip-end-change-request", {
+      detail: clipEndTime()
+    });
+  }
+  #watchLive() {
+    this.dispatch("live-change", { detail: this.$state.live() });
+  }
+  #watchLiveTolerance() {
+    this.$state.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());
+    this.$state.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());
+  }
+  #watchLiveEdge() {
+    this.dispatch("live-edge-change", { detail: this.$state.liveEdge() });
+  }
+}
+
+const actions = ["play", "pause", "seekforward", "seekbackward", "seekto"];
+class NavigatorMediaSession extends MediaPlayerController {
+  onConnect() {
+    effect(this.#onMetadataChange.bind(this));
+    effect(this.#onPlaybackStateChange.bind(this));
+    const handleAction = this.#handleAction.bind(this);
+    for (const action of actions) {
+      navigator.mediaSession.setActionHandler(action, handleAction);
+    }
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  #onDisconnect() {
+    for (const action of actions) {
+      navigator.mediaSession.setActionHandler(action, null);
+    }
+  }
+  #onMetadataChange() {
+    const { title, artist, artwork, poster } = this.$state;
+    navigator.mediaSession.metadata = new MediaMetadata({
+      title: title(),
+      artist: artist(),
+      artwork: artwork() ?? [{ src: poster() }]
+    });
+  }
+  #onPlaybackStateChange() {
+    const { canPlay, paused } = this.$state;
+    navigator.mediaSession.playbackState = !canPlay() ? "none" : paused() ? "paused" : "playing";
+  }
+  #handleAction(details) {
+    const trigger = new DOMEvent(`media-session-action`, { detail: details });
+    switch (details.action) {
+      case "play":
+        this.dispatch("media-play-request", { trigger });
+        break;
+      case "pause":
+        this.dispatch("media-pause-request", { trigger });
+        break;
+      case "seekto":
+      case "seekforward":
+      case "seekbackward":
+        this.dispatch("media-seek-request", {
+          detail: isNumber(details.seekTime) ? details.seekTime : this.$state.currentTime() + (details.seekOffset ?? (details.action === "seekforward" ? 10 : -10)),
+          trigger
+        });
+        break;
+    }
+  }
+}
+
+let $keyboard = signal(false);
+if (!IS_SERVER) {
+  listenEvent(document, "pointerdown", () => {
+    $keyboard.set(false);
+  });
+  listenEvent(document, "keydown", (e) => {
+    if (e.metaKey || e.altKey || e.ctrlKey) return;
+    $keyboard.set(true);
+  });
+}
+class FocusVisibleController extends ViewController {
+  #focused = signal(false);
+  onConnect(el) {
+    effect(() => {
+      const events = new EventsController(el);
+      if (!$keyboard()) {
+        this.#focused.set(false);
+        updateFocusAttr(el, false);
+        events.add("pointerenter", this.#onPointerEnter.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this));
+        return;
+      }
+      const active = document.activeElement === el;
+      this.#focused.set(active);
+      updateFocusAttr(el, active);
+      events.add("focus", this.#onFocus.bind(this)).add("blur", this.#onBlur.bind(this));
+    });
+  }
+  focused() {
+    return this.#focused();
+  }
+  #onFocus() {
+    this.#focused.set(true);
+    updateFocusAttr(this.el, true);
+  }
+  #onBlur() {
+    this.#focused.set(false);
+    updateFocusAttr(this.el, false);
+  }
+  #onPointerEnter() {
+    updateHoverAttr(this.el, true);
+  }
+  #onPointerLeave() {
+    updateHoverAttr(this.el, false);
+  }
+}
+function updateFocusAttr(el, isFocused) {
+  setAttribute(el, "data-focus", isFocused);
+  setAttribute(el, "data-hocus", isFocused);
+}
+function updateHoverAttr(el, isHovering) {
+  setAttribute(el, "data-hocus", isHovering);
+  setAttribute(el, "data-hover", isHovering);
+}
+
+class MediaPlayer extends Component {
+  static props = mediaPlayerProps;
+  static state = mediaState;
+  #media;
+  #stateMgr;
+  #requestMgr;
+  canPlayQueue = new RequestQueue();
+  remoteControl;
+  get #provider() {
+    return this.#media.$provider();
+  }
+  get #props() {
+    return this.$props;
+  }
+  constructor() {
+    super();
+    new MediaStateSync();
+    const context = {
+      player: this,
+      qualities: new VideoQualityList(),
+      audioTracks: new AudioTrackList(),
+      storage: null,
+      $provider: signal(null),
+      $providerSetup: signal(false),
+      $props: this.$props,
+      $state: this.$state
+    };
+    context.remote = this.remoteControl = new MediaRemoteControl(
+      void 0
+    );
+    context.remote.setPlayer(this);
+    context.textTracks = new TextTrackList();
+    context.textTracks[TextTrackSymbol.crossOrigin] = this.$state.crossOrigin;
+    context.textRenderers = new TextRenderers(context);
+    context.ariaKeys = {};
+    this.#media = context;
+    provideContext(mediaContext, context);
+    this.orientation = new ScreenOrientationController();
+    new FocusVisibleController();
+    new MediaKeyboardController(context);
+    const request = new MediaRequestContext();
+    this.#stateMgr = new MediaStateManager(request, context);
+    this.#requestMgr = new MediaRequestManager(this.#stateMgr, request, context);
+    context.delegate = new MediaPlayerDelegate(this.#stateMgr.handle.bind(this.#stateMgr), context);
+    context.notify = context.delegate.notify.bind(context.delegate);
+    if (typeof navigator !== "undefined" && "mediaSession" in navigator) {
+      new NavigatorMediaSession();
+    }
+    new MediaLoadController("load", this.startLoading.bind(this));
+    new MediaLoadController("posterLoad", this.startLoadingPoster.bind(this));
+  }
+  onSetup() {
+    this.#setupMediaAttributes();
+    effect(this.#watchCanPlay.bind(this));
+    effect(this.#watchMuted.bind(this));
+    effect(this.#watchPaused.bind(this));
+    effect(this.#watchVolume.bind(this));
+    effect(this.#watchCurrentTime.bind(this));
+    effect(this.#watchPlaysInline.bind(this));
+    effect(this.#watchPlaybackRate.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-player", "");
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "region");
+    effect(this.#watchStorage.bind(this));
+    if (IS_SERVER) this.#watchTitle();
+    else effect(this.#watchTitle.bind(this));
+    if (IS_SERVER) this.#watchOrientation();
+    else effect(this.#watchOrientation.bind(this));
+    listenEvent(el, "find-media-player", this.#onFindPlayer.bind(this));
+  }
+  onConnect(el) {
+    if (IS_IPHONE) setAttribute(el, "data-iphone", "");
+    const pointerQuery = window.matchMedia("(pointer: coarse)");
+    this.#onPointerChange(pointerQuery);
+    pointerQuery.onchange = this.#onPointerChange.bind(this);
+    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
+    resize.observe(el);
+    effect(this.#onResize.bind(this));
+    this.dispatch("media-player-connect", {
+      detail: this,
+      bubbles: true,
+      composed: true
+    });
+    onDispose(() => {
+      resize.disconnect();
+      pointerQuery.onchange = null;
+    });
+  }
+  onDestroy() {
+    this.#media.player = null;
+    this.canPlayQueue.reset();
+  }
+  #skipTitleUpdate = false;
+  #watchTitle() {
+    const el = this.$el, { title, live, viewType, providedTitle } = this.$state, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media", currentTitle = title();
+    setAttribute(
+      this.el,
+      "aria-label",
+      `${typeText} Player` + (currentTitle ? ` - ${currentTitle}` : "")
+    );
+    if (!IS_SERVER && el?.hasAttribute("title")) {
+      this.#skipTitleUpdate = true;
+      el?.removeAttribute("title");
+    }
+  }
+  #watchOrientation() {
+    const orientation = this.orientation.landscape ? "landscape" : "portrait";
+    this.$state.orientation.set(orientation);
+    setAttribute(this.el, "data-orientation", orientation);
+    this.#onResize();
+  }
+  #watchCanPlay() {
+    if (this.$state.canPlay() && this.#provider) this.canPlayQueue.start();
+    else this.canPlayQueue.stop();
+  }
+  #setupMediaAttributes() {
+    if (MediaPlayer[MEDIA_ATTRIBUTES]) {
+      this.setAttributes(MediaPlayer[MEDIA_ATTRIBUTES]);
+      return;
+    }
+    const $attrs = {
+      "data-load": function() {
+        return this.$props.load();
+      },
+      "data-captions": function() {
+        const track = this.$state.textTrack();
+        return !!track && isTrackCaptionKind(track);
+      },
+      "data-ios-controls": function() {
+        return this.$state.iOSControls();
+      },
+      "data-controls": function() {
+        return this.controls.showing;
+      },
+      "data-buffering": function() {
+        const { canLoad, canPlay, waiting } = this.$state;
+        return canLoad() && (!canPlay() || waiting());
+      },
+      "data-error": function() {
+        const { error } = this.$state;
+        return !!error();
+      },
+      "data-autoplay-error": function() {
+        const { autoPlayError } = this.$state;
+        return !!autoPlayError();
+      }
+    };
+    const alias = {
+      autoPlay: "autoplay",
+      canAirPlay: "can-airplay",
+      canPictureInPicture: "can-pip",
+      pictureInPicture: "pip",
+      playsInline: "playsinline",
+      remotePlaybackState: "remote-state",
+      remotePlaybackType: "remote-type",
+      isAirPlayConnected: "airplay",
+      isGoogleCastConnected: "google-cast"
+    };
+    for (const prop2 of mediaAttributes) {
+      const attrName = "data-" + (alias[prop2] ?? camelToKebabCase(prop2));
+      $attrs[attrName] = function() {
+        return this.$state[prop2]();
+      };
+    }
+    delete $attrs.title;
+    MediaPlayer[MEDIA_ATTRIBUTES] = $attrs;
+    this.setAttributes($attrs);
+  }
+  #onFindPlayer(event) {
+    event.detail(this);
+  }
+  #onResize() {
+    if (IS_SERVER || !this.el) return;
+    const width = this.el.clientWidth, height = this.el.clientHeight;
+    this.$state.width.set(width);
+    this.$state.height.set(height);
+    setStyle(this.el, "--player-width", width + "px");
+    setStyle(this.el, "--player-height", height + "px");
+  }
+  #onPointerChange(queryList) {
+    if (IS_SERVER) return;
+    const pointer = queryList.matches ? "coarse" : "fine";
+    setAttribute(this.el, "data-pointer", pointer);
+    this.$state.pointer.set(pointer);
+    this.#onResize();
+  }
+  /**
+   * The current media provider.
+   */
+  get provider() {
+    return this.#provider;
+  }
+  /**
+   * Media controls settings.
+   */
+  get controls() {
+    return this.#requestMgr.controls;
+  }
+  set controls(controls) {
+    this.#props.controls.set(controls);
+  }
+  /**
+   * Controls the screen orientation of the current browser window and dispatches orientation
+   * change events on the player.
+   */
+  orientation;
+  /**
+   * The title of the current media.
+   */
+  get title() {
+    return peek(this.$state.title);
+  }
+  set title(newTitle) {
+    if (this.#skipTitleUpdate) {
+      this.#skipTitleUpdate = false;
+      return;
+    }
+    this.#props.title.set(newTitle);
+  }
+  /**
+   * A list of all `VideoQuality` objects representing the set of available video renditions.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/video-quality}
+   */
+  get qualities() {
+    return this.#media.qualities;
+  }
+  /**
+   * A list of all `AudioTrack` objects representing the set of available audio tracks.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/audio-tracks}
+   */
+  get audioTracks() {
+    return this.#media.audioTracks;
+  }
+  /**
+   * A list of all `TextTrack` objects representing the set of available text tracks.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/text-tracks}
+   */
+  get textTracks() {
+    return this.#media.textTracks;
+  }
+  /**
+   * Contains text renderers which are responsible for loading, parsing, and rendering text
+   * tracks.
+   */
+  get textRenderers() {
+    return this.#media.textRenderers;
+  }
+  get duration() {
+    return this.$state.duration();
+  }
+  set duration(duration) {
+    this.#props.duration.set(duration);
+  }
+  get paused() {
+    return peek(this.$state.paused);
+  }
+  set paused(paused) {
+    this.#queuePausedUpdate(paused);
+  }
+  #watchPaused() {
+    this.#queuePausedUpdate(this.$props.paused());
+  }
+  #queuePausedUpdate(paused) {
+    if (paused) {
+      this.canPlayQueue.enqueue("paused", () => this.#requestMgr.pause());
+    } else this.canPlayQueue.enqueue("paused", () => this.#requestMgr.play());
+  }
+  get muted() {
+    return peek(this.$state.muted);
+  }
+  set muted(muted) {
+    this.#queueMutedUpdate(muted);
+  }
+  #watchMuted() {
+    this.#queueMutedUpdate(this.$props.muted());
+  }
+  #queueMutedUpdate(muted) {
+    this.canPlayQueue.enqueue("muted", () => {
+      if (this.#provider) this.#provider.setMuted(muted);
+    });
+  }
+  get currentTime() {
+    return peek(this.$state.currentTime);
+  }
+  set currentTime(time) {
+    this.#queueCurrentTimeUpdate(time);
+  }
+  #watchCurrentTime() {
+    this.#queueCurrentTimeUpdate(this.$props.currentTime());
+  }
+  #queueCurrentTimeUpdate(time) {
+    this.canPlayQueue.enqueue("currentTime", () => {
+      const { currentTime } = this.$state;
+      if (time === peek(currentTime)) return;
+      peek(() => {
+        if (!this.#provider) return;
+        const boundedTime = boundTime(time, this.$state);
+        if (Number.isFinite(boundedTime)) {
+          this.#provider.setCurrentTime(boundedTime);
+        }
+      });
+    });
+  }
+  get volume() {
+    return peek(this.$state.volume);
+  }
+  set volume(volume) {
+    this.#queueVolumeUpdate(volume);
+  }
+  #watchVolume() {
+    this.#queueVolumeUpdate(this.$props.volume());
+  }
+  #queueVolumeUpdate(volume) {
+    const clampedVolume = clampNumber(0, volume, 1);
+    this.canPlayQueue.enqueue("volume", () => {
+      if (this.#provider) this.#provider.setVolume(clampedVolume);
+    });
+  }
+  get playbackRate() {
+    return peek(this.$state.playbackRate);
+  }
+  set playbackRate(rate) {
+    this.#queuePlaybackRateUpdate(rate);
+  }
+  #watchPlaybackRate() {
+    this.#queuePlaybackRateUpdate(this.$props.playbackRate());
+  }
+  #queuePlaybackRateUpdate(rate) {
+    this.canPlayQueue.enqueue("rate", () => {
+      if (this.#provider) this.#provider.setPlaybackRate?.(rate);
+    });
+  }
+  #watchPlaysInline() {
+    this.#queuePlaysInlineUpdate(this.$props.playsInline());
+  }
+  #queuePlaysInlineUpdate(inline) {
+    this.canPlayQueue.enqueue("playsinline", () => {
+      if (this.#provider) this.#provider.setPlaysInline?.(inline);
+    });
+  }
+  #watchStorage() {
+    let storageValue = this.$props.storage(), storage = isString(storageValue) ? new LocalMediaStorage() : storageValue;
+    if (storage?.onChange) {
+      const { source } = this.$state, playerId = isString(storageValue) ? storageValue : this.el?.id, mediaId = computed(this.#computeMediaId.bind(this));
+      effect(() => storage.onChange(source(), mediaId(), playerId || void 0));
+    }
+    this.#media.storage = storage;
+    this.#media.textTracks.setStorage(storage);
+    onDispose(() => {
+      storage?.onDestroy?.();
+      this.#media.storage = null;
+      this.#media.textTracks.setStorage(null);
+    });
+  }
+  #computeMediaId() {
+    const { clipStartTime, clipEndTime } = this.$props, { source } = this.$state, src = source();
+    return src.src ? `${src.src}:${clipStartTime()}:${clipEndTime()}` : null;
+  }
+  /**
+   * Begins/resumes playback of the media. If this method is called programmatically before the
+   * user has interacted with the player, the promise may be rejected subject to the browser's
+   * autoplay policies. This method will throw if called before media is ready for playback.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play}
+   */
+  async play(trigger) {
+    return this.#requestMgr.play(trigger);
+  }
+  /**
+   * Pauses playback of the media. This method will throw if called before media is ready for
+   * playback.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause}
+   */
+  async pause(trigger) {
+    return this.#requestMgr.pause(trigger);
+  }
+  /**
+   * Attempts to display the player in fullscreen. The promise will resolve if successful, and
+   * reject if not. This method will throw if any fullscreen API is _not_ currently available.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/fullscreen}
+   */
+  async enterFullscreen(target, trigger) {
+    return this.#requestMgr.enterFullscreen(target, trigger);
+  }
+  /**
+   * Attempts to display the player inline by exiting fullscreen. This method will throw if any
+   * fullscreen API is _not_ currently available.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/fullscreen}
+   */
+  async exitFullscreen(target, trigger) {
+    return this.#requestMgr.exitFullscreen(target, trigger);
+  }
+  /**
+   * Attempts to display the player in picture-in-picture mode. This method will throw if PIP is
+   * not supported. This method will also return a `PictureInPictureWindow` if the current
+   * provider supports it.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
+   */
+  enterPictureInPicture(trigger) {
+    return this.#requestMgr.enterPictureInPicture(trigger);
+  }
+  /**
+   * Attempts to display the player in inline by exiting picture-in-picture mode. This method
+   * will throw if not supported.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
+   */
+  exitPictureInPicture(trigger) {
+    return this.#requestMgr.exitPictureInPicture(trigger);
+  }
+  /**
+   * Sets the current time to the live edge (i.e., `duration`). This is a no-op for non-live
+   * streams and will throw if called before media is ready for playback.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/live}
+   */
+  seekToLiveEdge(trigger) {
+    this.#requestMgr.seekToLiveEdge(trigger);
+  }
+  /**
+   * Called when media can begin loading. Calling this method will trigger the initial provider
+   * loading process. Calling it more than once has no effect.
+   *
+   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoading(trigger) {
+    this.#media.notify("can-load", void 0, trigger);
+  }
+  /**
+   * Called when the poster image can begin loading. Calling it more than once has no effect.
+   *
+   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoadingPoster(trigger) {
+    this.#media.notify("can-load-poster", void 0, trigger);
+  }
+  /**
+   * Request Apple AirPlay picker to open.
+   */
+  requestAirPlay(trigger) {
+    return this.#requestMgr.requestAirPlay(trigger);
+  }
+  /**
+   * Request Google Cast device picker to open. The Google Cast framework will be loaded if it
+   * hasn't yet.
+   */
+  requestGoogleCast(trigger) {
+    return this.#requestMgr.requestGoogleCast(trigger);
+  }
+  /**
+   * Set the audio gain, amplifying volume and enabling a maximum volume above 100%.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/audio-gain}
+   */
+  setAudioGain(gain, trigger) {
+    return this.#requestMgr.setAudioGain(gain, trigger);
+  }
+  destroy() {
+    super.destroy();
+    this.#media.remote.setPlayer(null);
+    this.dispatch("destroy");
+  }
+}
+const mediaplayer__proto = MediaPlayer.prototype;
+prop(mediaplayer__proto, "canPlayQueue");
+prop(mediaplayer__proto, "remoteControl");
+prop(mediaplayer__proto, "provider");
+prop(mediaplayer__proto, "controls");
+prop(mediaplayer__proto, "orientation");
+prop(mediaplayer__proto, "title");
+prop(mediaplayer__proto, "qualities");
+prop(mediaplayer__proto, "audioTracks");
+prop(mediaplayer__proto, "textTracks");
+prop(mediaplayer__proto, "textRenderers");
+prop(mediaplayer__proto, "duration");
+prop(mediaplayer__proto, "paused");
+prop(mediaplayer__proto, "muted");
+prop(mediaplayer__proto, "currentTime");
+prop(mediaplayer__proto, "volume");
+prop(mediaplayer__proto, "playbackRate");
+method(mediaplayer__proto, "play");
+method(mediaplayer__proto, "pause");
+method(mediaplayer__proto, "enterFullscreen");
+method(mediaplayer__proto, "exitFullscreen");
+method(mediaplayer__proto, "enterPictureInPicture");
+method(mediaplayer__proto, "exitPictureInPicture");
+method(mediaplayer__proto, "seekToLiveEdge");
+method(mediaplayer__proto, "startLoading");
+method(mediaplayer__proto, "startLoadingPoster");
+method(mediaplayer__proto, "requestAirPlay");
+method(mediaplayer__proto, "requestGoogleCast");
+method(mediaplayer__proto, "setAudioGain");
+
+function resolveStreamTypeFromDASHManifest(manifestSrc, requestInit) {
+  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
+    return /type="static"/.test(manifest) ? "on-demand" : "live";
+  });
+}
+function resolveStreamTypeFromHLSManifest(manifestSrc, requestInit) {
+  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
+    const renditionURI = resolveHLSRenditionURI(manifest);
+    if (renditionURI) {
+      return resolveStreamTypeFromHLSManifest(
+        /^https?:/.test(renditionURI) ? renditionURI : new URL(renditionURI, manifestSrc).href,
+        requestInit
+      );
+    }
+    const streamType = /EXT-X-PLAYLIST-TYPE:\s*VOD/.test(manifest) ? "on-demand" : "live";
+    if (streamType === "live" && resolveTargetDuration(manifest) >= 10 && (/#EXT-X-DVR-ENABLED:\s*true/.test(manifest) || manifest.includes("#EXT-X-DISCONTINUITY"))) {
+      return "live:dvr";
+    }
+    return streamType;
+  });
+}
+function resolveHLSRenditionURI(manifest) {
+  const matches = manifest.match(/#EXT-X-STREAM-INF:[^\n]+(\n[^\n]+)*/g);
+  return matches ? matches[0].split("\n")[1].trim() : null;
+}
+function resolveTargetDuration(manifest) {
+  const lines = manifest.split("\n");
+  for (const line of lines) {
+    if (line.startsWith("#EXT-X-TARGETDURATION")) {
+      const duration = parseFloat(line.split(":")[1]);
+      if (!isNaN(duration)) {
+        return duration;
+      }
+    }
+  }
+  return -1;
+}
+
+const sourceTypes = /* @__PURE__ */ new Map();
+class SourceSelection {
+  #initialize = false;
+  #loaders;
+  #domSources;
+  #media;
+  #loader;
+  constructor(domSources, media, loader, customLoaders = []) {
+    this.#domSources = domSources;
+    this.#media = media;
+    this.#loader = loader;
+    const DASH_LOADER = new DASHProviderLoader(), HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader(), YOUTUBE_LOADER = new YouTubeProviderLoader(), VIMEO_LOADER = new VimeoProviderLoader(), EMBED_LOADERS = [YOUTUBE_LOADER, VIMEO_LOADER];
+    this.#loaders = computed(() => {
+      const remoteLoader = media.$state.remotePlaybackLoader();
+      const loaders = media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, HLS_LOADER, ...EMBED_LOADERS, ...customLoaders] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, ...EMBED_LOADERS, ...customLoaders];
+      return remoteLoader ? [remoteLoader, ...loaders] : loaders;
+    });
+    const { $state } = media;
+    $state.sources.set(normalizeSrc(media.$props.src()));
+    for (const src of $state.sources()) {
+      const loader2 = this.#loaders().find((loader3) => loader3.canPlay(src));
+      if (!loader2) continue;
+      const mediaType = loader2.mediaType(src);
+      media.$state.source.set(src);
+      media.$state.mediaType.set(mediaType);
+      media.$state.inferredViewType.set(mediaType);
+      this.#loader.set(loader2);
+      this.#initialize = true;
+      break;
+    }
+  }
+  connect() {
+    const loader = this.#loader();
+    if (this.#initialize) {
+      this.#notifySourceChange(this.#media.$state.source(), loader);
+      this.#notifyLoaderChange(loader);
+      this.#initialize = false;
+    }
+    effect(this.#onSourcesChange.bind(this));
+    effect(this.#onSourceChange.bind(this));
+    effect(this.#onSetup.bind(this));
+    effect(this.#onLoadSource.bind(this));
+    effect(this.#onLoadPoster.bind(this));
+  }
+  #onSourcesChange() {
+    this.#media.notify("sources-change", [
+      ...normalizeSrc(this.#media.$props.src()),
+      ...this.#domSources()
+    ]);
+  }
+  #onSourceChange() {
+    const { $state } = this.#media;
+    const sources = $state.sources(), currentSource = peek($state.source), newSource = this.#findNewSource(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;
+    if (noMatch) {
+      const { crossOrigin } = $state, credentials = getRequestCredentials(crossOrigin()), abort = new AbortController();
+      Promise.all(
+        sources.map(
+          (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
+            method: "HEAD",
+            credentials,
+            signal: abort.signal
+          }).then((res) => {
+            source.type = res.headers.get("content-type") || "??";
+            sourceTypes.set(source.src, source.type);
+            return source;
+          }).catch(() => source) : source
+        )
+      ).then((sources2) => {
+        if (abort.signal.aborted) return;
+        const newSource2 = this.#findNewSource(peek($state.source), sources2);
+        tick();
+        if (!newSource2.src) {
+          this.#media.notify("error", {
+            message: "Failed to load resource.",
+            code: 4
+          });
+        }
+      });
+      return () => abort.abort();
+    }
+    tick();
+  }
+  #findNewSource(currentSource, sources) {
+    let newSource = { src: "", type: "" }, newLoader = null, triggerEvent = new DOMEvent("sources-change", { detail: { sources } }), loaders = this.#loaders(), { started, paused, currentTime, quality, savedState } = this.#media.$state;
+    for (const src of sources) {
+      const loader = loaders.find((loader2) => loader2.canPlay(src));
+      if (loader) {
+        newSource = src;
+        newLoader = loader;
+        break;
+      }
+    }
+    if (isVideoQualitySrc(newSource)) {
+      const currentQuality = quality(), sourceQuality = sources.find((s) => s.src === currentQuality?.src);
+      if (peek(started)) {
+        savedState.set({
+          paused: peek(paused),
+          currentTime: peek(currentTime)
+        });
+      } else {
+        savedState.set(null);
+      }
+      if (sourceQuality) {
+        newSource = sourceQuality;
+        triggerEvent = new DOMEvent("quality-change", {
+          detail: { quality: currentQuality }
+        });
+      }
+    }
+    if (!isSameSrc(currentSource, newSource)) {
+      this.#notifySourceChange(newSource, newLoader, triggerEvent);
+    }
+    if (newLoader !== peek(this.#loader)) {
+      this.#notifyLoaderChange(newLoader, triggerEvent);
+    }
+    return newSource;
+  }
+  #notifySourceChange(src, loader, trigger) {
+    this.#media.notify("source-change", src, trigger);
+    this.#media.notify("media-type-change", loader?.mediaType(src) || "unknown", trigger);
+  }
+  #notifyLoaderChange(loader, trigger) {
+    this.#media.$providerSetup.set(false);
+    this.#media.notify("provider-change", null, trigger);
+    loader && peek(() => loader.preconnect?.(this.#media));
+    this.#loader.set(loader);
+    this.#media.notify("provider-loader-change", loader, trigger);
+  }
+  #onSetup() {
+    const provider = this.#media.$provider();
+    if (!provider || peek(this.#media.$providerSetup)) return;
+    if (this.#media.$state.canLoad()) {
+      scoped(() => provider.setup(), provider.scope);
+      this.#media.$providerSetup.set(true);
+      return;
+    }
+    peek(() => provider.preconnect?.());
+  }
+  #onLoadSource() {
+    if (!this.#media.$providerSetup()) return;
+    const provider = this.#media.$provider(), source = this.#media.$state.source(), crossOrigin = peek(this.#media.$state.crossOrigin), preferNativeHLS = peek(this.#media.$props.preferNativeHLS);
+    if (isSameSrc(provider?.currentSrc, source)) {
+      return;
+    }
+    if (this.#media.$state.canLoad()) {
+      const abort = new AbortController();
+      if (isHLSSrc(source)) {
+        if (preferNativeHLS || !isHLSSupported()) {
+          resolveStreamTypeFromHLSManifest(source.src, {
+            credentials: getRequestCredentials(crossOrigin),
+            signal: abort.signal
+          }).then((streamType) => {
+            this.#media.notify("stream-type-change", streamType);
+          }).catch(noop);
+        }
+      } else if (isDASHSrc(source)) {
+        resolveStreamTypeFromDASHManifest(source.src, {
+          credentials: getRequestCredentials(crossOrigin),
+          signal: abort.signal
+        }).then((streamType) => {
+          this.#media.notify("stream-type-change", streamType);
+        }).catch(noop);
+      } else {
+        this.#media.notify("stream-type-change", "on-demand");
+      }
+      peek(() => {
+        const preload = peek(this.#media.$state.preload);
+        return provider?.loadSource(source, preload).catch((error) => {
+        });
+      });
+      return () => abort.abort();
+    }
+    try {
+      isString(source.src) && preconnect(new URL(source.src).origin);
+    } catch (error) {
+    }
+  }
+  #onLoadPoster() {
+    const loader = this.#loader(), { providedPoster, source, canLoadPoster } = this.#media.$state;
+    if (!loader || !loader.loadPoster || !source() || !canLoadPoster() || providedPoster()) return;
+    const abort = new AbortController(), trigger = new DOMEvent("source-change", { detail: source });
+    loader.loadPoster(source(), this.#media, abort).then((url) => {
+      this.#media.notify("poster-change", url || "", trigger);
+    }).catch(() => {
+      this.#media.notify("poster-change", "", trigger);
+    });
+    return () => {
+      abort.abort();
+    };
+  }
+}
+function normalizeSrc(src) {
+  return (isArray(src) ? src : [src]).map((src2) => {
+    if (isString(src2)) {
+      return { src: src2, type: inferType(src2) };
+    } else {
+      return { ...src2, type: inferType(src2.src, src2.type) };
+    }
+  });
+}
+function inferType(src, type) {
+  if (isString(type) && type.length) {
+    return type;
+  } else if (isString(src) && sourceTypes.has(src)) {
+    return sourceTypes.get(src);
+  } else if (!type && isHLSSrc({ src, type: "" })) {
+    return "application/x-mpegurl";
+  } else if (!type && isDASHSrc({ src, type: "" })) {
+    return "application/dash+xml";
+  } else if (!isString(src) || src.startsWith("blob:")) {
+    return "video/object";
+  } else if (src.includes("youtube") || src.includes("youtu.be")) {
+    return "video/youtube";
+  } else if (src.includes("vimeo") && !src.includes("progressive_redirect") && !src.includes(".m3u8")) {
+    return "video/vimeo";
+  }
+  return "?";
+}
+function isSameSrc(a, b) {
+  return a?.src === b?.src && a?.type === b?.type;
+}
+
+class Tracks {
+  #domTracks;
+  #media;
+  #prevTracks = [];
+  constructor(domTracks, media) {
+    this.#domTracks = domTracks;
+    this.#media = media;
+    effect(this.#onTracksChange.bind(this));
+  }
+  #onTracksChange() {
+    const newTracks = this.#domTracks();
+    for (const oldTrack of this.#prevTracks) {
+      if (!newTracks.some((t) => t.id === oldTrack.id)) {
+        const track = oldTrack.id && this.#media.textTracks.getById(oldTrack.id);
+        if (track) this.#media.textTracks.remove(track);
+      }
+    }
+    for (const newTrack of newTracks) {
+      const id = newTrack.id || TextTrack.createId(newTrack);
+      if (!this.#media.textTracks.getById(id)) {
+        newTrack.id = id;
+        this.#media.textTracks.add(newTrack);
+      }
+    }
+    this.#prevTracks = newTracks;
+  }
+}
+
+class MediaProvider extends Component {
+  static props = {
+    loaders: []
+  };
+  static state = new State({
+    loader: null
+  });
+  #media;
+  #sources;
+  #domSources = signal([]);
+  #domTracks = signal([]);
+  #loader = null;
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#sources = new SourceSelection(
+      this.#domSources,
+      this.#media,
+      this.$state.loader,
+      this.$props.loaders()
+    );
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-provider", "");
+  }
+  onConnect(el) {
+    this.#sources.connect();
+    new Tracks(this.#domTracks, this.#media);
+    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
+    resize.observe(el);
+    const mutations = new MutationObserver(this.#onMutation.bind(this));
+    mutations.observe(el, { attributes: true, childList: true });
+    this.#onResize();
+    this.#onMutation();
+    onDispose(() => {
+      resize.disconnect();
+      mutations.disconnect();
+    });
+  }
+  #loadRafId = -1;
+  load(target) {
+    target?.setAttribute("aria-hidden", "true");
+    window.cancelAnimationFrame(this.#loadRafId);
+    this.#loadRafId = requestAnimationFrame(() => this.#runLoader(target));
+    onDispose(() => {
+      window.cancelAnimationFrame(this.#loadRafId);
+    });
+  }
+  #runLoader(target) {
+    if (!this.scope) return;
+    const loader = this.$state.loader(), { $provider } = this.#media;
+    if (this.#loader === loader && loader?.target === target && peek($provider)) return;
+    this.#destroyProvider();
+    this.#loader = loader;
+    if (loader) loader.target = target || null;
+    if (!loader || !target) return;
+    loader.load(this.#media).then((provider) => {
+      if (!this.scope) return;
+      if (peek(this.$state.loader) !== loader) return;
+      this.#media.notify("provider-change", provider);
+    });
+  }
+  onDestroy() {
+    this.#loader = null;
+    this.#destroyProvider();
+  }
+  #destroyProvider() {
+    this.#media?.notify("provider-change", null);
+  }
+  #onResize() {
+    if (!this.el) return;
+    const { player, $state } = this.#media, width = this.el.offsetWidth, height = this.el.offsetHeight;
+    if (!player) return;
+    $state.mediaWidth.set(width);
+    $state.mediaHeight.set(height);
+    if (player.el) {
+      setStyle(player.el, "--media-width", width + "px");
+      setStyle(player.el, "--media-height", height + "px");
+    }
+  }
+  #onMutation() {
+    const sources = [], tracks = [], children = this.el.children;
+    for (const el of children) {
+      if (el.hasAttribute("data-vds")) continue;
+      if (el instanceof HTMLSourceElement) {
+        const src = {
+          id: el.id,
+          src: el.src,
+          type: el.type
+        };
+        for (const prop of ["id", "src", "width", "height", "bitrate", "codec"]) {
+          const value = el.getAttribute(`data-${prop}`);
+          if (isString(value)) src[prop] = /id|src|codec/.test(prop) ? value : Number(value);
+        }
+        sources.push(src);
+      } else if (el instanceof HTMLTrackElement) {
+        const track = {
+          src: el.src,
+          kind: el.track.kind,
+          language: el.srclang,
+          label: el.label,
+          default: el.default,
+          type: el.getAttribute("data-type")
+        };
+        tracks.push({
+          id: el.id || TextTrack.createId(track),
+          ...track
+        });
+      }
+    }
+    this.#domSources.set(sources);
+    this.#domTracks.set(tracks);
+    tick();
+  }
+}
+const mediaprovider__proto = MediaProvider.prototype;
+method(mediaprovider__proto, "load");
+
+class MediaAnnouncer extends Component {
+  static props = {
+    translations: null
+  };
+  static state = new State({
+    label: null,
+    busy: false
+  });
+  #media;
+  #initializing = false;
+  onSetup() {
+    this.#media = useMediaContext();
+  }
+  onAttach(el) {
+    el.style.display = "contents";
+  }
+  onConnect(el) {
+    el.setAttribute("data-media-announcer", "");
+    setAttributeIfEmpty(el, "role", "status");
+    setAttributeIfEmpty(el, "aria-live", "polite");
+    const { busy } = this.$state;
+    this.setAttributes({
+      "aria-busy": () => busy() ? "true" : null
+    });
+    this.#initializing = true;
+    effect(this.#watchPaused.bind(this));
+    effect(this.#watchVolume.bind(this));
+    effect(this.#watchCaptions.bind(this));
+    effect(this.#watchFullscreen.bind(this));
+    effect(this.#watchPiP.bind(this));
+    effect(this.#watchSeeking.bind(this));
+    effect(this.#watchLabel.bind(this));
+    tick();
+    this.#initializing = false;
+  }
+  #watchPaused() {
+    const { paused } = this.#media.$state;
+    this.#setLabel(!paused() ? "Play" : "Pause");
+  }
+  #watchFullscreen() {
+    const { fullscreen } = this.#media.$state;
+    this.#setLabel(fullscreen() ? "Enter Fullscreen" : "Exit Fullscreen");
+  }
+  #watchPiP() {
+    const { pictureInPicture } = this.#media.$state;
+    this.#setLabel(pictureInPicture() ? "Enter PiP" : "Exit PiP");
+  }
+  #watchCaptions() {
+    const { textTrack } = this.#media.$state;
+    this.#setLabel(textTrack() ? "Closed-Captions On" : "Closed-Captions Off");
+  }
+  #watchVolume() {
+    const { muted, volume, audioGain } = this.#media.$state;
+    this.#setLabel(
+      muted() || volume() === 0 ? "Mute" : `${Math.round(volume() * (audioGain() ?? 1) * 100)}% ${this.#translate("Volume")}`
+    );
+  }
+  #startedSeekingAt = -1;
+  #seekTimer = -1;
+  #watchSeeking() {
+    const { seeking, currentTime } = this.#media.$state, isSeeking = seeking();
+    if (this.#startedSeekingAt > 0) {
+      window.clearTimeout(this.#seekTimer);
+      this.#seekTimer = window.setTimeout(() => {
+        if (!this.scope) return;
+        const newTime = peek(currentTime), seconds = Math.abs(newTime - this.#startedSeekingAt);
+        if (seconds >= 1) {
+          const isForward = newTime >= this.#startedSeekingAt, spokenTime = formatSpokenTime(seconds);
+          this.#setLabel(
+            `${this.#translate(isForward ? "Seek Forward" : "Seek Backward")} ${spokenTime}`
+          );
+        }
+        this.#startedSeekingAt = -1;
+        this.#seekTimer = -1;
+      }, 300);
+    } else if (isSeeking) {
+      this.#startedSeekingAt = peek(currentTime);
+    }
+  }
+  #translate(word) {
+    const { translations } = this.$props;
+    return translations?.()?.[word || ""] ?? word;
+  }
+  #watchLabel() {
+    const { label, busy } = this.$state, $label = this.#translate(label());
+    if (this.#initializing) return;
+    busy.set(true);
+    const id = window.setTimeout(() => void busy.set(false), 150);
+    this.el && setAttribute(this.el, "aria-label", $label);
+    if (isString($label)) {
+      this.dispatch("change", { detail: $label });
+    }
+    return () => window.clearTimeout(id);
+  }
+  #setLabel(word) {
+    const { label } = this.$state;
+    label.set(word);
+  }
+}
+
+class Controls extends Component {
+  static props = {
+    hideDelay: 2e3,
+    hideOnMouseLeave: false
+  };
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    effect(this.#watchProps.bind(this));
+  }
+  onAttach(el) {
+    const { pictureInPicture, fullscreen } = this.#media.$state;
+    setStyle(el, "pointer-events", "none");
+    setAttributeIfEmpty(el, "role", "group");
+    this.setAttributes({
+      "data-visible": this.#isShowing.bind(this),
+      "data-fullscreen": fullscreen,
+      "data-pip": pictureInPicture
+    });
+    effect(() => {
+      this.dispatch("change", { detail: this.#isShowing() });
+    });
+    effect(this.#hideControls.bind(this));
+    effect(() => {
+      const isFullscreen = fullscreen();
+      for (const side of ["top", "right", "bottom", "left"]) {
+        setStyle(el, `padding-${side}`, isFullscreen && `env(safe-area-inset-${side})`);
+      }
+    });
+  }
+  #hideControls() {
+    if (!this.el) return;
+    const { nativeControls } = this.#media.$state, isHidden = nativeControls();
+    setAttribute(this.el, "aria-hidden", isHidden ? "true" : null);
+    setStyle(this.el, "display", isHidden ? "none" : null);
+  }
+  #watchProps() {
+    const { controls } = this.#media.player, { hideDelay, hideOnMouseLeave } = this.$props;
+    controls.defaultDelay = hideDelay() === 2e3 ? this.#media.$props.controlsDelay() : hideDelay();
+    controls.hideOnMouseLeave = hideOnMouseLeave();
+  }
+  #isShowing() {
+    const { controlsVisible } = this.#media.$state;
+    return controlsVisible();
+  }
+}
+
+class ControlsGroup extends Component {
+  onAttach(el) {
+    if (!el.style.pointerEvents) setStyle(el, "pointer-events", "auto");
+  }
+}
+
+class Popper extends ViewController {
+  #delegate;
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+    effect(this.#watchTrigger.bind(this));
+  }
+  onDestroy() {
+    this.#stopAnimationEndListener?.();
+    this.#stopAnimationEndListener = null;
+  }
+  #watchTrigger() {
+    const trigger = this.#delegate.trigger();
+    if (!trigger) {
+      this.hide();
+      return;
+    }
+    const show = this.show.bind(this), hide = this.hide.bind(this);
+    this.#delegate.listen(trigger, show, hide);
+  }
+  #showTimerId = -1;
+  #hideRafId = -1;
+  #stopAnimationEndListener = null;
+  show(trigger) {
+    this.#cancelShowing();
+    window.cancelAnimationFrame(this.#hideRafId);
+    this.#hideRafId = -1;
+    this.#stopAnimationEndListener?.();
+    this.#stopAnimationEndListener = null;
+    this.#showTimerId = window.setTimeout(() => {
+      this.#showTimerId = -1;
+      const content = this.#delegate.content();
+      if (content) content.style.removeProperty("display");
+      peek(() => this.#delegate.onChange(true, trigger));
+    }, this.#delegate.showDelay?.() ?? 0);
+  }
+  hide(trigger) {
+    this.#cancelShowing();
+    peek(() => this.#delegate.onChange(false, trigger));
+    this.#hideRafId = requestAnimationFrame(() => {
+      this.#cancelShowing();
+      this.#hideRafId = -1;
+      const content = this.#delegate.content();
+      if (content) {
+        const onHide = () => {
+          content.style.display = "none";
+          this.#stopAnimationEndListener = null;
+        };
+        const isAnimated = hasAnimation(content);
+        if (isAnimated) {
+          this.#stopAnimationEndListener?.();
+          const stop = listenEvent(content, "animationend", onHide, { once: true });
+          this.#stopAnimationEndListener = stop;
+        } else {
+          onHide();
+        }
+      }
+    });
+  }
+  #cancelShowing() {
+    window.clearTimeout(this.#showTimerId);
+    this.#showTimerId = -1;
+  }
+}
+
+const tooltipContext = createContext();
+
+let id = 0;
+class Tooltip extends Component {
+  static props = {
+    showDelay: 700
+  };
+  #id = `media-tooltip-${++id}`;
+  #trigger = signal(null);
+  #content = signal(null);
+  #showing = signal(false);
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { showDelay } = this.$props;
+    new Popper({
+      trigger: this.#trigger,
+      content: this.#content,
+      showDelay,
+      listen(trigger, show, hide) {
+        effect(() => {
+          if ($keyboard()) listenEvent(trigger, "focus", show);
+          listenEvent(trigger, "blur", hide);
+        });
+        new EventsController(trigger).add("touchstart", (e) => e.preventDefault(), { passive: false }).add("mouseenter", show).add("mouseleave", hide);
+      },
+      onChange: this.#onShowingChange.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  onSetup() {
+    provideContext(tooltipContext, {
+      trigger: this.#trigger,
+      content: this.#content,
+      showing: this.#showing,
+      attachTrigger: this.#attachTrigger.bind(this),
+      detachTrigger: this.#detachTrigger.bind(this),
+      attachContent: this.#attachContent.bind(this),
+      detachContent: this.#detachContent.bind(this)
+    });
+  }
+  #attachTrigger(el) {
+    this.#trigger.set(el);
+    let tooltipName = el.getAttribute("data-media-tooltip");
+    if (tooltipName) {
+      this.el?.setAttribute(`data-media-${tooltipName}-tooltip`, "");
+    }
+    setAttribute(el, "data-describedby", this.#id);
+  }
+  #detachTrigger(el) {
+    el.removeAttribute("data-describedby");
+    el.removeAttribute("aria-describedby");
+    this.#trigger.set(null);
+  }
+  #attachContent(el) {
+    el.setAttribute("id", this.#id);
+    el.style.display = "none";
+    setAttributeIfEmpty(el, "role", "tooltip");
+    this.#content.set(el);
+  }
+  #detachContent(el) {
+    el.removeAttribute("id");
+    el.removeAttribute("role");
+    this.#content.set(null);
+  }
+  #onShowingChange(isShowing) {
+    const trigger = this.#trigger(), content = this.#content();
+    if (trigger) {
+      setAttribute(trigger, "aria-describedby", isShowing ? this.#id : null);
+    }
+    for (const el of [this.el, trigger, content]) {
+      el && setAttribute(el, "data-visible", isShowing);
+    }
+    this.#showing.set(isShowing);
+  }
+}
+
+class TooltipTrigger extends Component {
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onConnect(el) {
+    onDispose(
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        this.#attach();
+        const tooltip = useContext(tooltipContext);
+        onDispose(() => {
+          const button = this.#getButton();
+          button && tooltip.detachTrigger(button);
+        });
+      })
+    );
+  }
+  #attach() {
+    const button = this.#getButton(), tooltip = useContext(tooltipContext);
+    button && tooltip.attachTrigger(button);
+  }
+  #getButton() {
+    const candidate = this.el.firstElementChild;
+    return candidate?.localName === "button" || candidate?.getAttribute("role") === "button" ? candidate : this.el;
+  }
+}
+
+class TooltipContent extends Component {
+  static props = {
+    placement: "top center",
+    offset: 0,
+    alignOffset: 0
+  };
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { placement } = this.$props;
+    this.setAttributes({
+      "data-placement": placement
+    });
+  }
+  onAttach(el) {
+    this.#attach(el);
+    Object.assign(el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+  }
+  onConnect(el) {
+    this.#attach(el);
+    const tooltip = useContext(tooltipContext);
+    onDispose(() => tooltip.detachContent(el));
+    onDispose(
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        effect(this.#watchPlacement.bind(this));
+      })
+    );
+  }
+  #attach(el) {
+    const tooltip = useContext(tooltipContext);
+    tooltip.attachContent(el);
+  }
+  #watchPlacement() {
+    const { showing } = useContext(tooltipContext);
+    if (!showing()) return;
+    const { placement, offset: mainOffset, alignOffset } = this.$props;
+    return autoPlacement(this.el, this.#getTrigger(), placement(), {
+      offsetVarName: "media-tooltip",
+      xOffset: alignOffset(),
+      yOffset: mainOffset()
+    });
+  }
+  #getTrigger() {
+    return useContext(tooltipContext).trigger();
+  }
+}
+
+class ToggleButtonController extends ViewController {
+  static props = {
+    disabled: false
+  };
+  #delegate;
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+    new FocusVisibleController();
+    if (delegate.keyShortcut) {
+      new ARIAKeyShortcuts(delegate.keyShortcut);
+    }
+  }
+  onSetup() {
+    const { disabled } = this.$props;
+    this.setAttributes({
+      "data-pressed": this.#delegate.isPresssed,
+      "aria-pressed": this.#isARIAPressed.bind(this),
+      "aria-disabled": () => disabled() ? "true" : null
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+  }
+  onConnect(el) {
+    const events = onPress(el, this.#onMaybePress.bind(this));
+    for (const type of ["click", "touchstart"]) {
+      events.add(type, this.#onInteraction.bind(this), {
+        passive: true
+      });
+    }
+  }
+  #isARIAPressed() {
+    return ariaBool$1(this.#delegate.isPresssed());
+  }
+  #onPressed(event) {
+    if (isWriteSignal(this.#delegate.isPresssed)) {
+      this.#delegate.isPresssed.set((p) => !p);
+    }
+  }
+  #onMaybePress(event) {
+    const disabled = this.$props.disabled() || this.el.hasAttribute("data-disabled");
+    if (disabled) {
+      event.preventDefault();
+      event.stopImmediatePropagation();
+      return;
+    }
+    event.preventDefault();
+    (this.#delegate.onPress ?? this.#onPressed).call(this, event);
+  }
+  #onInteraction(event) {
+    if (this.$props.disabled()) {
+      event.preventDefault();
+      event.stopImmediatePropagation();
+    }
+  }
+}
+
+class ToggleButton extends Component {
+  static props = {
+    disabled: false,
+    defaultPressed: false
+  };
+  #pressed = signal(false);
+  /**
+   * Whether the toggle is currently in a `pressed` state.
+   */
+  get pressed() {
+    return this.#pressed();
+  }
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#pressed
+    });
+  }
+}
+const togglebutton__proto = ToggleButton.prototype;
+prop(togglebutton__proto, "pressed");
+
+function ariaBool(value) {
+  return value ? "true" : "false";
+}
+function $ariaBool(signal) {
+  return () => ariaBool(signal());
+}
+
+class AirPlayButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { canAirPlay, isAirPlayConnected } = this.#media.$state;
+    this.setAttributes({
+      "data-active": isAirPlayConnected,
+      "data-supported": canAirPlay,
+      "data-state": this.#getState.bind(this),
+      "aria-hidden": $ariaBool(() => !canAirPlay())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "airplay");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    remote.requestAirPlay(event);
+  }
+  #isPressed() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "airplay" && remotePlaybackState() !== "disconnected";
+  }
+  #getState() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "airplay" && remotePlaybackState();
+  }
+  #getDefaultLabel() {
+    const { remotePlaybackState } = this.#media.$state;
+    return `AirPlay ${remotePlaybackState()}`;
+  }
+}
+
+class GoogleCastButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { canGoogleCast, isGoogleCastConnected } = this.#media.$state;
+    this.setAttributes({
+      "data-active": isGoogleCastConnected,
+      "data-supported": canGoogleCast,
+      "data-state": this.#getState.bind(this),
+      "aria-hidden": $ariaBool(() => !canGoogleCast())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "google-cast");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    remote.requestGoogleCast(event);
+  }
+  #isPressed() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "google-cast" && remotePlaybackState() !== "disconnected";
+  }
+  #getState() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "google-cast" && remotePlaybackState();
+  }
+  #getDefaultLabel() {
+    const { remotePlaybackState } = this.#media.$state;
+    return `Google Cast ${remotePlaybackState()}`;
+  }
+}
+
+class PlayButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "togglePaused",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { paused, ended } = this.#media.$state;
+    this.setAttributes({
+      "data-paused": paused,
+      "data-ended": ended
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "play");
+    setARIALabel(el, "Play");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.pause(event) : remote.play(event);
+  }
+  #isPressed() {
+    const { paused } = this.#media.$state;
+    return !paused();
+  }
+}
+
+class CaptionButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleCaptions",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "data-active": this.#isPressed.bind(this),
+      "data-supported": () => !this.#isHidden(),
+      "aria-hidden": $ariaBool(this.#isHidden.bind(this))
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "caption");
+    setARIALabel(el, "Captions");
+  }
+  #onPress(event) {
+    this.#media.remote.toggleCaptions(event);
+  }
+  #isPressed() {
+    const { textTrack } = this.#media.$state, track = textTrack();
+    return !!track && isTrackCaptionKind(track);
+  }
+  #isHidden() {
+    const { hasCaptions } = this.#media.$state;
+    return !hasCaptions();
+  }
+}
+
+class FullscreenButton extends Component {
+  static props = {
+    ...ToggleButtonController.props,
+    target: "prefer-media"
+  };
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleFullscreen",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { fullscreen } = this.#media.$state, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      "data-active": fullscreen,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "fullscreen");
+    setARIALabel(el, "Fullscreen");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote, target = this.$props.target();
+    this.#isPressed() ? remote.exitFullscreen(target, event) : remote.enterFullscreen(target, event);
+  }
+  #isPressed() {
+    const { fullscreen } = this.#media.$state;
+    return fullscreen();
+  }
+  #isSupported() {
+    const { canFullscreen } = this.#media.$state;
+    return canFullscreen();
+  }
+}
+
+class MuteButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleMuted",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "data-muted": this.#isPressed.bind(this),
+      "data-state": this.#getState.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-mute-button", "");
+    el.setAttribute("data-media-tooltip", "mute");
+    setARIALabel(el, "Mute");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.unmute(event) : remote.mute(event);
+  }
+  #isPressed() {
+    const { muted, volume } = this.#media.$state;
+    return muted() || volume() === 0;
+  }
+  #getState() {
+    const { muted, volume } = this.#media.$state, $volume = volume();
+    if (muted() || $volume === 0) return "muted";
+    else if ($volume >= 0.5) return "high";
+    else if ($volume < 0.5) return "low";
+  }
+}
+
+class PIPButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "togglePictureInPicture",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { pictureInPicture } = this.#media.$state, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      "data-active": pictureInPicture,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "pip");
+    setARIALabel(el, "PiP");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.exitPictureInPicture(event) : remote.enterPictureInPicture(event);
+  }
+  #isPressed() {
+    const { pictureInPicture } = this.#media.$state;
+    return pictureInPicture();
+  }
+  #isSupported() {
+    const { canPictureInPicture } = this.#media.$state;
+    return canPictureInPicture();
+  }
+}
+
+class SeekButton extends Component {
+  static props = {
+    disabled: false,
+    seconds: 30
+  };
+  #media;
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { seeking } = this.#media.$state, { seconds } = this.$props, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      seconds,
+      "data-seeking": seeking,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+    el.setAttribute("data-media-tooltip", "seek");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  onConnect(el) {
+    onPress(el, this.#onPress.bind(this));
+  }
+  #isSupported() {
+    const { canSeek } = this.#media.$state;
+    return canSeek();
+  }
+  #getDefaultLabel() {
+    const { seconds } = this.$props;
+    return `Seek ${seconds() > 0 ? "forward" : "backward"} ${seconds()} seconds`;
+  }
+  #onPress(event) {
+    const { seconds, disabled } = this.$props;
+    if (disabled()) return;
+    const { currentTime } = this.#media.$state, seekTo = currentTime() + seconds();
+    this.#media.remote.seek(seekTo, event);
+  }
+}
+
+class LiveButton extends Component {
+  static props = {
+    disabled: false
+  };
+  #media;
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { disabled } = this.$props, { live, liveEdge } = this.#media.$state, isHidden = () => !live();
+    this.setAttributes({
+      "data-edge": liveEdge,
+      "data-hidden": isHidden,
+      "aria-disabled": $ariaBool(() => disabled() || liveEdge()),
+      "aria-hidden": $ariaBool(isHidden)
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+    el.setAttribute("data-media-tooltip", "live");
+  }
+  onConnect(el) {
+    onPress(el, this.#onPress.bind(this));
+  }
+  #onPress(event) {
+    const { disabled } = this.$props, { liveEdge } = this.#media.$state;
+    if (disabled() || liveEdge()) return;
+    this.#media.remote.seekToLiveEdge(event);
+  }
+}
+
+const sliderState = new State({
+  min: 0,
+  max: 100,
+  value: 0,
+  step: 1,
+  pointerValue: 0,
+  focused: false,
+  dragging: false,
+  pointing: false,
+  hidden: false,
+  get active() {
+    return this.dragging || this.focused || this.pointing;
+  },
+  get fillRate() {
+    return calcRate(this.min, this.max, this.value);
+  },
+  get fillPercent() {
+    return this.fillRate * 100;
+  },
+  get pointerRate() {
+    return calcRate(this.min, this.max, this.pointerValue);
+  },
+  get pointerPercent() {
+    return this.pointerRate * 100;
+  }
+});
+function calcRate(min, max, value) {
+  const range = max - min, offset = value - min;
+  return range > 0 ? offset / range : 0;
+}
+
+class IntersectionObserverController extends ViewController {
+  #init;
+  #observer;
+  constructor(init) {
+    super();
+    this.#init = init;
+  }
+  onConnect(el) {
+    this.#observer = new IntersectionObserver((entries) => {
+      this.#init.callback?.(entries, this.#observer);
+    }, this.#init);
+    this.#observer.observe(el);
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  /**
+   * Disconnect any active intersection observers.
+   */
+  #onDisconnect() {
+    this.#observer?.disconnect();
+    this.#observer = void 0;
+  }
+}
+
+const sliderContext = createContext();
+const sliderObserverContext = createContext();
+
+function getClampedValue(min, max, value, step) {
+  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
+}
+function getValueFromRate(min, max, rate, step) {
+  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * Math.round(stepRatio);
+  return min + steps;
+}
+
+const SliderKeyDirection = {
+  Left: -1,
+  ArrowLeft: -1,
+  Up: 1,
+  ArrowUp: 1,
+  Right: 1,
+  ArrowRight: 1,
+  Down: -1,
+  ArrowDown: -1
+};
+class SliderEventsController extends ViewController {
+  #delegate;
+  #media;
+  #observer;
+  constructor(delegate, media) {
+    super();
+    this.#delegate = delegate;
+    this.#media = media;
+  }
+  onSetup() {
+    if (hasProvidedContext(sliderObserverContext)) {
+      this.#observer = useContext(sliderObserverContext);
+    }
+  }
+  onConnect(el) {
+    effect(this.#attachEventListeners.bind(this, el));
+    effect(this.#attachPointerListeners.bind(this, el));
+    if (this.#delegate.swipeGesture) effect(this.#watchSwipeGesture.bind(this));
+  }
+  #watchSwipeGesture() {
+    const { pointer } = this.#media.$state;
+    if (pointer() !== "coarse" || !this.#delegate.swipeGesture()) {
+      this.#provider = null;
+      return;
+    }
+    this.#provider = this.#media.player.el?.querySelector(
+      "media-provider,[data-media-provider]"
+    );
+    if (!this.#provider) return;
+    new EventsController(this.#provider).add("touchstart", this.#onTouchStart.bind(this), {
+      passive: true
+    }).add("touchmove", this.#onTouchMove.bind(this), { passive: false });
+  }
+  #provider = null;
+  #touch = null;
+  #touchStartValue = null;
+  #onTouchStart(event) {
+    this.#touch = event.touches[0];
+  }
+  #onTouchMove(event) {
+    if (isNull(this.#touch) || isTouchPinchEvent(event)) return;
+    const touch = event.touches[0], xDiff = touch.clientX - this.#touch.clientX, yDiff = touch.clientY - this.#touch.clientY, isDragging = this.$state.dragging();
+    if (!isDragging && Math.abs(yDiff) > 5) {
+      return;
+    }
+    if (isDragging) return;
+    event.preventDefault();
+    if (Math.abs(xDiff) > 20) {
+      this.#touch = touch;
+      this.#touchStartValue = this.$state.value();
+      this.#onStartDragging(this.#touchStartValue, event);
+    }
+  }
+  #attachEventListeners(el) {
+    const { hidden } = this.$props;
+    listenEvent(el, "focus", this.#onFocus.bind(this));
+    if (hidden() || this.#delegate.isDisabled()) return;
+    new EventsController(el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("pointerenter", this.#onPointerEnter.bind(this)).add("pointermove", this.#onPointerMove.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this)).add("pointerdown", this.#onPointerDown.bind(this));
+  }
+  #attachPointerListeners(el) {
+    if (this.#delegate.isDisabled() || !this.$state.dragging()) return;
+    new EventsController(document).add("pointerup", this.#onDocumentPointerUp.bind(this), { capture: true }).add("pointermove", this.#onDocumentPointerMove.bind(this)).add("touchmove", this.#onDocumentTouchMove.bind(this), {
+      passive: false
+    });
+  }
+  #onFocus() {
+    this.#updatePointerValue(this.$state.value());
+  }
+  #updateValue(newValue, trigger) {
+    const { value, min, max, dragging } = this.$state;
+    const clampedValue = Math.max(min(), Math.min(newValue, max()));
+    value.set(clampedValue);
+    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
+    this.dispatch(event);
+    this.#delegate.onValueChange?.(event);
+    if (dragging()) {
+      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
+      this.dispatch(event2);
+      this.#delegate.onDragValueChange?.(event2);
+    }
+  }
+  #updatePointerValue(value, trigger) {
+    const { pointerValue, dragging } = this.$state;
+    pointerValue.set(value);
+    this.dispatch("pointer-value-change", { detail: value, trigger });
+    if (dragging()) {
+      this.#updateValue(value, trigger);
+    }
+  }
+  #getPointerValue(event) {
+    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$state;
+    if (this.$props.orientation() === "vertical") {
+      const { bottom: trackBottom, height: trackHeight } = rect;
+      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
+    } else {
+      if (this.#touch && isNumber(this.#touchStartValue)) {
+        const { width } = this.#provider.getBoundingClientRect(), rate = (event.clientX - this.#touch.clientX) / width, range = max() - min(), diff = range * Math.abs(rate);
+        thumbPositionRate = (rate < 0 ? this.#touchStartValue - diff : this.#touchStartValue + diff) / range;
+      } else {
+        const { left: trackLeft, width: trackWidth } = rect;
+        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
+      }
+    }
+    return Math.max(
+      min(),
+      Math.min(
+        max(),
+        this.#delegate.roundValue(
+          getValueFromRate(min(), max(), thumbPositionRate, this.#delegate.getStep())
+        )
+      )
+    );
+  }
+  #onPointerEnter(event) {
+    this.$state.pointing.set(true);
+  }
+  #onPointerMove(event) {
+    const { dragging } = this.$state;
+    if (dragging()) return;
+    this.#updatePointerValue(this.#getPointerValue(event), event);
+  }
+  #onPointerLeave(event) {
+    this.$state.pointing.set(false);
+  }
+  #onPointerDown(event) {
+    if (event.button !== 0) return;
+    const value = this.#getPointerValue(event);
+    this.#onStartDragging(value, event);
+    this.#updatePointerValue(value, event);
+  }
+  #onStartDragging(value, trigger) {
+    const { dragging } = this.$state;
+    if (dragging()) return;
+    dragging.set(true);
+    this.#media.remote.pauseControls(trigger);
+    const event = this.createEvent("drag-start", { detail: value, trigger });
+    this.dispatch(event);
+    this.#delegate.onDragStart?.(event);
+    this.#observer?.onDragStart?.();
+  }
+  #onStopDragging(value, trigger) {
+    const { dragging } = this.$state;
+    if (!dragging()) return;
+    dragging.set(false);
+    this.#media.remote.resumeControls(trigger);
+    const event = this.createEvent("drag-end", { detail: value, trigger });
+    this.dispatch(event);
+    this.#delegate.onDragEnd?.(event);
+    this.#touch = null;
+    this.#touchStartValue = null;
+    this.#observer?.onDragEnd?.();
+  }
+  // -------------------------------------------------------------------------------------------
+  // Keyboard Events
+  // -------------------------------------------------------------------------------------------
+  #lastDownKey;
+  #repeatedKeys = false;
+  #onKeyDown(event) {
+    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);
+    if (!isValidKey) return;
+    const { key } = event, jumpValue = this.#calcJumpValue(event);
+    if (!isNull(jumpValue)) {
+      this.#updatePointerValue(jumpValue, event);
+      this.#updateValue(jumpValue, event);
+      return;
+    }
+    const newValue = this.#calcNewKeyValue(event);
+    if (!this.#repeatedKeys) {
+      this.#repeatedKeys = key === this.#lastDownKey;
+      if (!this.$state.dragging() && this.#repeatedKeys) {
+        this.#onStartDragging(newValue, event);
+      }
+    }
+    this.#updatePointerValue(newValue, event);
+    this.#lastDownKey = key;
+  }
+  #onKeyUp(event) {
+    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);
+    if (!isValidKey || !isNull(this.#calcJumpValue(event))) return;
+    const newValue = this.#repeatedKeys ? this.$state.pointerValue() : this.#calcNewKeyValue(event);
+    this.#updateValue(newValue, event);
+    this.#onStopDragging(newValue, event);
+    this.#lastDownKey = "";
+    this.#repeatedKeys = false;
+  }
+  #calcJumpValue(event) {
+    let key = event.key, { min, max } = this.$state;
+    if (key === "Home" || key === "PageUp") {
+      return min();
+    } else if (key === "End" || key === "PageDown") {
+      return max();
+    } else if (!event.metaKey && /^[0-9]$/.test(key)) {
+      return (max() - min()) / 10 * Number(key);
+    }
+    return null;
+  }
+  #calcNewKeyValue(event) {
+    const { key, shiftKey } = event;
+    event.preventDefault();
+    event.stopPropagation();
+    const { shiftKeyMultiplier } = this.$props;
+    const { min, max, value, pointerValue } = this.$state, step = this.#delegate.getStep(), keyStep = this.#delegate.getKeyStep();
+    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, currentValue = this.#repeatedKeys ? pointerValue() : this.#delegate.getValue?.() ?? value(), steps = (currentValue + diff) / step;
+    return Math.max(min(), Math.min(max(), Number((step * steps).toFixed(3))));
+  }
+  // -------------------------------------------------------------------------------------------
+  // Document (Pointer Events)
+  // -------------------------------------------------------------------------------------------
+  #onDocumentPointerUp(event) {
+    if (event.button !== 0) return;
+    event.preventDefault();
+    event.stopImmediatePropagation();
+    const value = this.#getPointerValue(event);
+    this.#updatePointerValue(value, event);
+    this.#onStopDragging(value, event);
+  }
+  #onDocumentTouchMove(event) {
+    event.preventDefault();
+  }
+  #onDocumentPointerMove = functionThrottle(
+    (event) => {
+      this.#updatePointerValue(this.#getPointerValue(event), event);
+    },
+    20,
+    { leading: true }
+  );
+}
+
+const sliderValueFormatContext = createContext(() => ({}));
+
+class SliderController extends ViewController {
+  static props = {
+    hidden: false,
+    disabled: false,
+    step: 1,
+    keyStep: 1,
+    orientation: "horizontal",
+    shiftKeyMultiplier: 5
+  };
+  #media;
+  #delegate;
+  #isVisible = signal(true);
+  #isIntersecting = signal(true);
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const focus = new FocusVisibleController();
+    focus.attach(this);
+    this.$state.focused = focus.focused.bind(focus);
+    if (!hasProvidedContext(sliderValueFormatContext)) {
+      provideContext(sliderValueFormatContext, {
+        default: "value"
+      });
+    }
+    provideContext(sliderContext, {
+      orientation: this.$props.orientation,
+      disabled: this.#delegate.isDisabled,
+      preview: signal(null)
+    });
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchStep.bind(this));
+    effect(this.#watchDisabled.bind(this));
+    this.#setupAttrs();
+    new SliderEventsController(this.#delegate, this.#media).attach(this);
+    new IntersectionObserverController({
+      callback: this.#onIntersectionChange.bind(this)
+    }).attach(this);
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "role", "slider");
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "autocomplete", "off");
+    if (IS_SERVER) this.#watchCSSVars();
+    else effect(this.#watchCSSVars.bind(this));
+  }
+  onConnect(el) {
+    onDispose(observeVisibility(el, this.#isVisible.set));
+    effect(this.#watchHidden.bind(this));
+  }
+  #onIntersectionChange(entries) {
+    this.#isIntersecting.set(entries[0].isIntersecting);
+  }
+  // -------------------------------------------------------------------------------------------
+  // Watch
+  // -------------------------------------------------------------------------------------------
+  #watchHidden() {
+    const { hidden } = this.$props;
+    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting.bind(this));
+  }
+  #watchValue() {
+    const { dragging, value, min, max } = this.$state;
+    if (peek(dragging)) return;
+    value.set(getClampedValue(min(), max(), value(), this.#delegate.getStep()));
+  }
+  #watchStep() {
+    this.$state.step.set(this.#delegate.getStep());
+  }
+  #watchDisabled() {
+    if (!this.#delegate.isDisabled()) return;
+    const { dragging, pointing } = this.$state;
+    dragging.set(false);
+    pointing.set(false);
+  }
+  // -------------------------------------------------------------------------------------------
+  // ARIA
+  // -------------------------------------------------------------------------------------------
+  #getARIADisabled() {
+    return ariaBool$1(this.#delegate.isDisabled());
+  }
+  // -------------------------------------------------------------------------------------------
+  // Attributes
+  // -------------------------------------------------------------------------------------------
+  #setupAttrs() {
+    const { orientation } = this.$props, { dragging, active, pointing } = this.$state;
+    this.setAttributes({
+      "data-dragging": dragging,
+      "data-pointing": pointing,
+      "data-active": active,
+      "aria-disabled": this.#getARIADisabled.bind(this),
+      "aria-valuemin": this.#delegate.aria.valueMin ?? this.$state.min,
+      "aria-valuemax": this.#delegate.aria.valueMax ?? this.$state.max,
+      "aria-valuenow": this.#delegate.aria.valueNow,
+      "aria-valuetext": this.#delegate.aria.valueText,
+      "aria-orientation": orientation
+    });
+  }
+  #watchCSSVars() {
+    const { fillPercent, pointerPercent } = this.$state;
+    this.#updateSliderVars(round(fillPercent(), 3), round(pointerPercent(), 3));
+  }
+  #updateSliderVars = animationFrameThrottle((fillPercent, pointerPercent) => {
+    this.el?.style.setProperty("--slider-fill", fillPercent + "%");
+    this.el?.style.setProperty("--slider-pointer", pointerPercent + "%");
+  });
+}
+
+class Slider extends Component {
+  static props = {
+    ...SliderController.props,
+    min: 0,
+    max: 100,
+    value: 0
+  };
+  static state = sliderState;
+  constructor() {
+    super();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.$props.disabled,
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      }
+    });
+  }
+  onSetup() {
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchMinMax.bind(this));
+  }
+  // -------------------------------------------------------------------------------------------
+  // Props
+  // -------------------------------------------------------------------------------------------
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const { value, max } = this.$state;
+    return round(value() / max() * 100, 2) + "%";
+  }
+  // -------------------------------------------------------------------------------------------
+  // Watch
+  // -------------------------------------------------------------------------------------------
+  #watchValue() {
+    const { value } = this.$props;
+    this.$state.value.set(value());
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+}
+
+const cache = /* @__PURE__ */ new Map(), pending = /* @__PURE__ */ new Map();
+class ThumbnailsLoader {
+  #media;
+  #src;
+  #crossOrigin;
+  $images = signal([]);
+  static create(src, crossOrigin) {
+    const media = useMediaContext();
+    return new ThumbnailsLoader(src, crossOrigin, media);
+  }
+  constructor(src, crossOrigin, media) {
+    this.#src = src;
+    this.#crossOrigin = crossOrigin;
+    this.#media = media;
+    effect(this.#onLoadCues.bind(this));
+  }
+  #onLoadCues() {
+    const { canLoad } = this.#media.$state;
+    if (!canLoad()) return;
+    const src = this.#src();
+    if (!src) return;
+    if (isString(src) && cache.has(src)) {
+      const cues = cache.get(src);
+      cache.delete(src);
+      cache.set(src, cues);
+      if (cache.size > 99) {
+        const firstKey = cache.keys().next().value;
+        cache.delete(firstKey);
+      }
+      this.$images.set(cache.get(src));
+    } else if (isString(src)) {
+      const crossOrigin = this.#crossOrigin(), currentKey = src + "::" + crossOrigin;
+      if (!pending.has(currentKey)) {
+        const promise = new Promise(async (resolve, reject) => {
+          try {
+            const response = await fetch(src, {
+              credentials: getRequestCredentials(crossOrigin)
+            }), isJSON = response.headers.get("content-type") === "application/json";
+            if (isJSON) {
+              const json = await response.json();
+              if (isArray(json)) {
+                if (json[0] && "text" in json[0]) {
+                  resolve(this.#processVTTCues(json));
+                } else {
+                  for (let i = 0; i < json.length; i++) {
+                    const image = json[i];
+                    assert(isObject(image), false);
+                    assert(
+                      "url" in image && isString(image.url),
+                      false
+                    );
+                    assert(
+                      "startTime" in image && isNumber(image.startTime),
+                      false
+                    );
+                  }
+                  resolve(json);
+                }
+              } else {
+                resolve(this.#processStoryboard(json));
+              }
+              return;
+            }
+            import('media-captions').then(async ({ parseResponse }) => {
+              try {
+                const { cues } = await parseResponse(response);
+                resolve(this.#processVTTCues(cues));
+              } catch (e) {
+                reject(e);
+              }
+            });
+          } catch (e) {
+            reject(e);
+          }
+        }).then((images) => {
+          cache.set(currentKey, images);
+          return images;
+        }).catch((error) => {
+          this.#onError(src, error);
+        }).finally(() => {
+          if (isString(currentKey)) pending.delete(currentKey);
+        });
+        pending.set(currentKey, promise);
+      }
+      pending.get(currentKey)?.then((images) => {
+        this.$images.set(images || []);
+      });
+    } else if (isArray(src)) {
+      try {
+        this.$images.set(this.#processImages(src));
+      } catch (error) {
+        this.#onError(src, error);
+      }
+    } else {
+      try {
+        this.$images.set(this.#processStoryboard(src));
+      } catch (error) {
+        this.#onError(src, error);
+      }
+    }
+    return () => {
+      this.$images.set([]);
+    };
+  }
+  #processImages(images) {
+    const baseURL = this.#resolveBaseUrl();
+    return images.map((img, i) => {
+      assert(
+        img.url && isString(img.url));
+      assert(
+        "startTime" in img && isNumber(img.startTime));
+      return {
+        ...img,
+        url: isString(img.url) ? this.#resolveURL(img.url, baseURL) : img.url
+      };
+    });
+  }
+  #processStoryboard(board) {
+    assert(isString(board.url));
+    assert(isArray(board.tiles) && board.tiles?.length);
+    const url = new URL(board.url), images = [];
+    const tileWidth = "tile_width" in board ? board.tile_width : board.tileWidth, tileHeight = "tile_height" in board ? board.tile_height : board.tileHeight;
+    for (const tile of board.tiles) {
+      images.push({
+        url,
+        startTime: "start" in tile ? tile.start : tile.startTime,
+        width: tileWidth,
+        height: tileHeight,
+        coords: { x: tile.x, y: tile.y }
+      });
+    }
+    return images;
+  }
+  #processVTTCues(cues) {
+    for (let i = 0; i < cues.length; i++) {
+      const cue = cues[i];
+      assert(
+        "startTime" in cue && isNumber(cue.startTime));
+      assert(
+        "text" in cue && isString(cue.text));
+    }
+    const images = [], baseURL = this.#resolveBaseUrl();
+    for (const cue of cues) {
+      const [url, hash] = cue.text.split("#"), data = this.#resolveData(hash);
+      images.push({
+        url: this.#resolveURL(url, baseURL),
+        startTime: cue.startTime,
+        endTime: cue.endTime,
+        width: data?.w,
+        height: data?.h,
+        coords: data && isNumber(data.x) && isNumber(data.y) ? { x: data.x, y: data.y } : void 0
+      });
+    }
+    return images;
+  }
+  #resolveBaseUrl() {
+    let baseURL = peek(this.#src);
+    if (!isString(baseURL) || !/^https?:/.test(baseURL)) {
+      return location.href;
+    }
+    return baseURL;
+  }
+  #resolveURL(src, baseURL) {
+    return /^https?:/.test(src) ? new URL(src) : new URL(src, baseURL);
+  }
+  #resolveData(hash) {
+    if (!hash) return {};
+    const [hashProps, values] = hash.split("="), hashValues = values?.split(","), data = {};
+    if (!hashProps || !hashValues) {
+      return null;
+    }
+    for (let i = 0; i < hashProps.length; i++) {
+      const value = +hashValues[i];
+      if (!isNaN(value)) data[hashProps[i]] = value;
+    }
+    return data;
+  }
+  #onError(src, error) {
+    return;
+  }
+}
+
+class Thumbnail extends Component {
+  static props = {
+    src: null,
+    time: 0,
+    crossOrigin: null
+  };
+  static state = new State({
+    src: "",
+    img: null,
+    thumbnails: [],
+    activeThumbnail: null,
+    crossOrigin: null,
+    loading: false,
+    error: null,
+    hidden: false
+  });
+  media;
+  #loader;
+  #styleResets = [];
+  onSetup() {
+    this.media = useMediaContext();
+    this.#loader = ThumbnailsLoader.create(this.$props.src, this.$state.crossOrigin);
+    this.#watchCrossOrigin();
+    this.setAttributes({
+      "data-loading": this.#isLoading.bind(this),
+      "data-error": this.#hasError.bind(this),
+      "data-hidden": this.$state.hidden,
+      "aria-hidden": $ariaBool(this.$state.hidden)
+    });
+  }
+  onConnect(el) {
+    effect(this.#watchImg.bind(this));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#onLoadStart.bind(this));
+    effect(this.#onFindActiveThumbnail.bind(this));
+    effect(this.#resize.bind(this));
+  }
+  #watchImg() {
+    const img = this.$state.img();
+    if (!img) return;
+    new EventsController(img).add("load", this.#onLoaded.bind(this)).add("error", this.#onError.bind(this));
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
+  }
+  #onLoadStart() {
+    const { src, loading, error } = this.$state;
+    if (src()) {
+      loading.set(true);
+      error.set(null);
+    }
+    return () => {
+      this.#resetStyles();
+      loading.set(false);
+      error.set(null);
+    };
+  }
+  #onLoaded() {
+    const { loading, error } = this.$state;
+    this.#resize();
+    loading.set(false);
+    error.set(null);
+  }
+  #onError(event) {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(event);
+  }
+  #isLoading() {
+    const { loading, hidden } = this.$state;
+    return !hidden() && loading();
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error());
+  }
+  #watchHidden() {
+    const { hidden } = this.$state, { duration } = this.media.$state, images = this.#loader.$images();
+    hidden.set(this.#hasError() || !Number.isFinite(duration()) || images.length === 0);
+  }
+  getTime() {
+    return this.$props.time();
+  }
+  #onFindActiveThumbnail() {
+    let images = this.#loader.$images();
+    if (!images.length) return;
+    let time = this.getTime(), { src, activeThumbnail } = this.$state, activeIndex = -1, activeImage = null;
+    for (let i = images.length - 1; i >= 0; i--) {
+      const image = images[i];
+      if (time >= image.startTime && (!image.endTime || time < image.endTime)) {
+        activeIndex = i;
+        break;
+      }
+    }
+    if (images[activeIndex]) {
+      activeImage = images[activeIndex];
+    }
+    activeThumbnail.set(activeImage);
+    src.set(activeImage?.url.href || "");
+  }
+  #resize() {
+    if (!this.scope || this.$state.hidden()) return;
+    const rootEl = this.el, imgEl = this.$state.img(), thumbnail = this.$state.activeThumbnail();
+    if (!imgEl || !thumbnail || !rootEl) return;
+    let width = thumbnail.width ?? imgEl.naturalWidth, height = thumbnail?.height ?? imgEl.naturalHeight, {
+      maxWidth,
+      maxHeight,
+      minWidth,
+      minHeight,
+      width: elWidth,
+      height: elHeight
+    } = getComputedStyle(this.el);
+    if (minWidth === "100%") minWidth = parseFloat(elWidth) + "";
+    if (minHeight === "100%") minHeight = parseFloat(elHeight) + "";
+    let minRatio = Math.max(parseInt(minWidth) / width, parseInt(minHeight) / height), maxRatio = Math.min(
+      Math.max(parseInt(minWidth), parseInt(maxWidth)) / width,
+      Math.max(parseInt(minHeight), parseInt(maxHeight)) / height
+    ), scale = !isNaN(maxRatio) && maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
+    this.#style(rootEl, "--thumbnail-width", `${width * scale}px`);
+    this.#style(rootEl, "--thumbnail-height", `${height * scale}px`);
+    this.#style(rootEl, "--thumbnail-aspect-ratio", String(round(width / height, 5)));
+    this.#style(imgEl, "width", `${imgEl.naturalWidth * scale}px`);
+    this.#style(imgEl, "height", `${imgEl.naturalHeight * scale}px`);
+    this.#style(
+      imgEl,
+      "transform",
+      thumbnail.coords ? `translate(-${thumbnail.coords.x * scale}px, -${thumbnail.coords.y * scale}px)` : ""
+    );
+    this.#style(imgEl, "max-width", "none");
+  }
+  #style(el, name, value) {
+    el.style.setProperty(name, value);
+    this.#styleResets.push(() => el.style.removeProperty(name));
+  }
+  #resetStyles() {
+    for (const reset of this.#styleResets) reset();
+    this.#styleResets = [];
+  }
+}
+
+class SliderThumbnail extends Thumbnail {
+  #slider;
+  onAttach(el) {
+    this.#slider = useState(Slider.state);
+  }
+  getTime() {
+    const { duration, clipStartTime } = this.media.$state;
+    return clipStartTime() + this.#slider.pointerRate() * duration();
+  }
+}
+
+class SliderVideo extends Component {
+  static props = {
+    src: null,
+    crossOrigin: null
+  };
+  static state = new State({
+    video: null,
+    src: null,
+    crossOrigin: null,
+    canPlay: false,
+    error: null,
+    hidden: false
+  });
+  #media;
+  #slider;
+  get video() {
+    return this.$state.video();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#slider = useState(Slider.state);
+    this.#watchCrossOrigin();
+    this.setAttributes({
+      "data-loading": this.#isLoading.bind(this),
+      "data-hidden": this.$state.hidden,
+      "data-error": this.#hasError.bind(this),
+      "aria-hidden": $ariaBool(this.$state.hidden)
+    });
+  }
+  onAttach(el) {
+    effect(this.#watchVideo.bind(this));
+    effect(this.#watchSrc.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#onSrcChange.bind(this));
+    effect(this.#onUpdateTime.bind(this));
+  }
+  #watchVideo() {
+    const video = this.$state.video();
+    if (!video) return;
+    if (video.readyState >= 2) this.#onCanPlay();
+    new EventsController(video).add("canplay", this.#onCanPlay.bind(this)).add("error", this.#onError.bind(this));
+  }
+  #watchSrc() {
+    const { src } = this.$state, { canLoad } = this.#media.$state;
+    src.set(canLoad() ? this.$props.src() : null);
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
+  }
+  #isLoading() {
+    const { canPlay, hidden } = this.$state;
+    return !canPlay() && !hidden();
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error);
+  }
+  #watchHidden() {
+    const { src, hidden } = this.$state, { canLoad, duration } = this.#media.$state;
+    hidden.set(canLoad() && (!src() || this.#hasError() || !Number.isFinite(duration())));
+  }
+  #onSrcChange() {
+    const { src, canPlay, error } = this.$state;
+    src();
+    canPlay.set(false);
+    error.set(null);
+  }
+  #onCanPlay(event) {
+    const { canPlay, error } = this.$state;
+    canPlay.set(true);
+    error.set(null);
+    this.dispatch("can-play", { trigger: event });
+  }
+  #onError(event) {
+    const { canPlay, error } = this.$state;
+    canPlay.set(false);
+    error.set(event);
+    this.dispatch("error", { trigger: event });
+  }
+  #onUpdateTime() {
+    const { video, canPlay } = this.$state, { duration } = this.#media.$state, { pointerRate } = this.#slider, media = video(), canUpdate = canPlay() && media && Number.isFinite(duration()) && Number.isFinite(pointerRate());
+    if (canUpdate) {
+      media.currentTime = pointerRate() * duration();
+    }
+  }
+}
+const slidervideo__proto = SliderVideo.prototype;
+prop(slidervideo__proto, "video");
+
+class SliderValue extends Component {
+  static props = {
+    type: "pointer",
+    format: null,
+    showHours: false,
+    showMs: false,
+    padHours: null,
+    padMinutes: null,
+    decimalPlaces: 2
+  };
+  #format;
+  #text;
+  #slider;
+  onSetup() {
+    this.#slider = useState(Slider.state);
+    this.#format = useContext(sliderValueFormatContext);
+    this.#text = computed(this.getValueText.bind(this));
+  }
+  /**
+   * Returns the current value formatted as text based on prop settings.
+   */
+  getValueText() {
+    const {
+      type,
+      format: $format,
+      decimalPlaces,
+      padHours,
+      padMinutes,
+      showHours,
+      showMs
+    } = this.$props, { value: sliderValue, pointerValue, min, max } = this.#slider, format = $format?.() ?? this.#format.default;
+    const value = type() === "current" ? sliderValue() : pointerValue();
+    if (format === "percent") {
+      const range = max() - min();
+      const percent = value / range * 100;
+      return (this.#format.percent ?? round)(percent, decimalPlaces()) + "%";
+    } else if (format === "time") {
+      return (this.#format.time ?? formatTime)(value, {
+        padHrs: padHours(),
+        padMins: padMinutes(),
+        showHrs: showHours(),
+        showMs: showMs()
+      });
+    } else {
+      return (this.#format.value?.(value) ?? value.toFixed(2)) + "";
+    }
+  }
+}
+const slidervalue__proto = SliderValue.prototype;
+method(slidervalue__proto, "getValueText");
+
+class SliderPreview extends Component {
+  static props = {
+    offset: 0,
+    noClamp: false
+  };
+  #slider;
+  onSetup() {
+    this.#slider = useContext(sliderContext);
+    const { active } = useState(Slider.state);
+    this.setAttributes({
+      "data-visible": active
+    });
+  }
+  onAttach(el) {
+    Object.assign(el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+  }
+  onConnect(el) {
+    const { preview } = this.#slider;
+    preview.set(el);
+    onDispose(() => preview.set(null));
+    effect(this.#updatePlacement.bind(this));
+    const resize = new ResizeObserver(this.#updatePlacement.bind(this));
+    resize.observe(el);
+    onDispose(() => resize.disconnect());
+  }
+  #updatePlacement = animationFrameThrottle(() => {
+    const { disabled, orientation } = this.#slider;
+    if (disabled()) return;
+    const el = this.el, { offset, noClamp } = this.$props;
+    if (!el) return;
+    updateSliderPreviewPlacement(el, {
+      clamp: !noClamp(),
+      offset: offset(),
+      orientation: orientation()
+    });
+  });
+}
+function updateSliderPreviewPlacement(el, {
+  clamp,
+  offset,
+  orientation
+}) {
+  const computedStyle = getComputedStyle(el), width = parseFloat(computedStyle.width), height = parseFloat(computedStyle.height), styles = {
+    top: null,
+    right: null,
+    bottom: null,
+    left: null
+  };
+  styles[orientation === "horizontal" ? "bottom" : "left"] = `calc(100% + var(--media-slider-preview-offset, ${offset}px))`;
+  if (orientation === "horizontal") {
+    const widthHalf = width / 2;
+    if (!clamp) {
+      styles.left = `calc(var(--slider-pointer) - ${widthHalf}px)`;
+    } else {
+      const leftClamp = `max(0px, calc(var(--slider-pointer) - ${widthHalf}px))`, rightClamp = `calc(100% - ${width}px)`;
+      styles.left = `min(${leftClamp}, ${rightClamp})`;
+    }
+  } else {
+    const heightHalf = height / 2;
+    if (!clamp) {
+      styles.bottom = `calc(var(--slider-pointer) - ${heightHalf}px)`;
+    } else {
+      const topClamp = `max(${heightHalf}px, calc(var(--slider-pointer) - ${heightHalf}px))`, bottomClamp = `calc(100% - ${height}px)`;
+      styles.bottom = `min(${topClamp}, ${bottomClamp})`;
+    }
+  }
+  Object.assign(el.style, styles);
+}
+
+class VolumeSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    keyStep: 5,
+    shiftKeyMultiplier: 2
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    const { audioGain } = this.#media.$state;
+    provideContext(sliderValueFormatContext, {
+      default: "percent",
+      value(value) {
+        return (value * (audioGain() ?? 1)).toFixed(2);
+      },
+      percent(value) {
+        return Math.round(value * (audioGain() ?? 1));
+      }
+    });
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueMax: this.#getARIAValueMax.bind(this),
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchVolume.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-volume-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Volume");
+    const { canSetVolume } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetVolume,
+      "aria-hidden": $ariaBool(() => !canSetVolume())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state, { audioGain } = this.#media.$state;
+    return Math.round(value() * (audioGain() ?? 1));
+  }
+  #getARIAValueText() {
+    const { value, max } = this.$state, { audioGain } = this.#media.$state;
+    return round(value() / max() * (audioGain() ?? 1) * 100, 2) + "%";
+  }
+  #getARIAValueMax() {
+    const { audioGain } = this.#media.$state;
+    return this.$state.max() * (audioGain() ?? 1);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetVolume } = this.#media.$state;
+    return disabled() || !canSetVolume();
+  }
+  #watchVolume() {
+    const { muted, volume } = this.#media.$state;
+    const newValue = muted() ? 0 : volume() * 100;
+    this.$state.value.set(newValue);
+    this.dispatch("value-change", { detail: newValue });
+  }
+  #throttleVolumeChange = functionThrottle(this.#onVolumeChange.bind(this), 25);
+  #onVolumeChange(event) {
+    if (!event.trigger) return;
+    const mediaVolume = round(event.detail / 100, 3);
+    this.#media.remote.changeVolume(mediaVolume, event);
+  }
+  #onValueChange(event) {
+    this.#throttleVolumeChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttleVolumeChange(event);
+  }
+}
+
+class AudioGainSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 25,
+    keyStep: 25,
+    shiftKeyMultiplier: 2,
+    min: 0,
+    max: 300
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(sliderValueFormatContext, {
+      default: "percent",
+      percent: (_, decimalPlaces) => {
+        return round(this.$state.value(), decimalPlaces) + "%";
+      }
+    });
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMinMax.bind(this));
+    effect(this.#watchAudioGain.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-audio-gain-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Audio Boost");
+    const { canSetAudioGain } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetAudioGain,
+      "aria-hidden": $ariaBool(() => !canSetAudioGain())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const { value } = this.$state;
+    return value() + "%";
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+  #watchAudioGain() {
+    const { audioGain } = this.#media.$state, value = ((audioGain() ?? 1) - 1) * 100;
+    this.$state.value.set(value);
+    this.dispatch("value-change", { detail: value });
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetAudioGain } = this.#media.$state;
+    return disabled() || !canSetAudioGain();
+  }
+  #onAudioGainChange(event) {
+    if (!event.trigger) return;
+    const gain = round(1 + event.detail / 100, 2);
+    this.#media.remote.changeAudioGain(gain, event);
+  }
+  #onValueChange(event) {
+    this.#onAudioGainChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#onAudioGainChange(event);
+  }
+}
+
+class SpeedSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 0.25,
+    keyStep: 0.25,
+    shiftKeyMultiplier: 2,
+    min: 0,
+    max: 2
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: this.#roundValue,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMinMax.bind(this));
+    effect(this.#watchPlaybackRate.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-speed-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Speed");
+    const { canSetPlaybackRate } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetPlaybackRate,
+      "aria-hidden": $ariaBool(() => !canSetPlaybackRate())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return value();
+  }
+  #getARIAValueText() {
+    const { value } = this.$state;
+    return value() + "x";
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+  #watchPlaybackRate() {
+    const { playbackRate } = this.#media.$state;
+    const newValue = playbackRate();
+    this.$state.value.set(newValue);
+    this.dispatch("value-change", { detail: newValue });
+  }
+  #roundValue(value) {
+    return round(value, 2);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetPlaybackRate } = this.#media.$state;
+    return disabled() || !canSetPlaybackRate();
+  }
+  #throttledSpeedChange = functionThrottle(this.#onPlaybackRateChange.bind(this), 25);
+  #onPlaybackRateChange(event) {
+    if (!event.trigger) return;
+    const rate = event.detail;
+    this.#media.remote.changePlaybackRate(rate, event);
+  }
+  #onValueChange(event) {
+    this.#throttledSpeedChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttledSpeedChange(event);
+  }
+}
+
+class QualitySlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 1,
+    keyStep: 1,
+    shiftKeyMultiplier: 1
+  };
+  static state = sliderState;
+  #media;
+  #sortedQualities = computed(() => {
+    const { qualities } = this.#media.$state;
+    return sortVideoQualities(qualities());
+  });
+  onSetup() {
+    this.#media = useMediaContext();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMax.bind(this));
+    effect(this.#watchQuality.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-quality-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Video Quality");
+    const { qualities, canSetQuality } = this.#media.$state, $supported = computed(() => canSetQuality() && qualities().length > 0);
+    this.setAttributes({
+      "data-supported": $supported,
+      "aria-hidden": $ariaBool(() => !$supported())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return value();
+  }
+  #getARIAValueText() {
+    const { quality } = this.#media.$state;
+    if (!quality()) return "";
+    const { height, bitrate } = quality(), bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null;
+    return height ? `${height}p${bitrateText ? ` (${bitrateText})` : ""}` : "Auto";
+  }
+  #watchMax() {
+    const $qualities = this.#sortedQualities();
+    this.$state.max.set(Math.max(0, $qualities.length - 1));
+  }
+  #watchQuality() {
+    let { quality } = this.#media.$state, $qualities = this.#sortedQualities(), value = Math.max(0, $qualities.indexOf(quality()));
+    this.$state.value.set(value);
+    this.dispatch("value-change", { detail: value });
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetQuality, qualities } = this.#media.$state;
+    return disabled() || qualities().length <= 1 || !canSetQuality();
+  }
+  #throttledQualityChange = functionThrottle(this.#onQualityChange.bind(this), 25);
+  #onQualityChange(event) {
+    if (!event.trigger) return;
+    const { qualities } = this.#media, quality = peek(this.#sortedQualities)[event.detail];
+    this.#media.remote.changeQuality(qualities.indexOf(quality), event);
+  }
+  #onValueChange(event) {
+    this.#throttledQualityChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttledQualityChange(event);
+  }
+}
+
+class TimeSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 0.1,
+    keyStep: 5,
+    shiftKeyMultiplier: 2,
+    pauseWhileDragging: false,
+    noSwipeGesture: false,
+    seekingRequestThrottle: 100
+  };
+  static state = sliderState;
+  #media;
+  #dispatchSeeking;
+  #chapter = signal(null);
+  constructor() {
+    super();
+    const { noSwipeGesture } = this.$props;
+    new SliderController({
+      swipeGesture: () => !noSwipeGesture(),
+      getValue: this.#getValue.bind(this),
+      getStep: this.#getStep.bind(this),
+      getKeyStep: this.#getKeyStep.bind(this),
+      roundValue: this.#roundValue,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragStart: this.#onDragStart.bind(this),
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onDragEnd: this.#onDragEnd.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(sliderValueFormatContext, {
+      default: "time",
+      value: this.#formatValue.bind(this),
+      time: this.#formatTime.bind(this)
+    });
+    this.setAttributes({
+      "data-chapters": this.#hasChapters.bind(this)
+    });
+    this.setStyles({
+      "--slider-progress": this.#calcBufferedPercent.bind(this)
+    });
+    effect(this.#watchCurrentTime.bind(this));
+    effect(this.#watchSeekingThrottle.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-time-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Seek");
+  }
+  onConnect(el) {
+    effect(this.#watchPreviewing.bind(this));
+    watchActiveTextTrack(this.#media.textTracks, "chapters", this.#chapter.set);
+  }
+  #calcBufferedPercent() {
+    const { bufferedEnd, duration } = this.#media.$state;
+    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + "%";
+  }
+  #hasChapters() {
+    const { duration } = this.#media.$state;
+    return this.#chapter()?.cues.length && Number.isFinite(duration()) && duration() > 0;
+  }
+  #watchSeekingThrottle() {
+    this.#dispatchSeeking = functionThrottle(
+      this.#seeking.bind(this),
+      this.$props.seekingRequestThrottle()
+    );
+  }
+  #watchCurrentTime() {
+    if (this.$state.hidden()) return;
+    const { value, dragging } = this.$state, newValue = this.#getValue();
+    if (!peek(dragging)) {
+      value.set(newValue);
+      this.dispatch("value-change", { detail: newValue });
+    }
+  }
+  #watchPreviewing() {
+    const player = this.#media.player.el, { preview } = useContext(sliderContext);
+    player && preview() && setAttribute(player, "data-preview", this.$state.active());
+  }
+  #seeking(time, event) {
+    this.#media.remote.seeking(time, event);
+  }
+  #seek(time, percent, event) {
+    this.#dispatchSeeking.cancel();
+    const { live } = this.#media.$state;
+    if (live() && percent >= 99) {
+      this.#media.remote.seekToLiveEdge(event);
+      return;
+    }
+    this.#media.remote.seek(time, event);
+  }
+  #playingBeforeDragStart = false;
+  #onDragStart(event) {
+    const { pauseWhileDragging } = this.$props;
+    if (pauseWhileDragging()) {
+      const { paused } = this.#media.$state;
+      this.#playingBeforeDragStart = !paused();
+      this.#media.remote.pause(event);
+    }
+  }
+  #onDragValueChange(event) {
+    this.#dispatchSeeking(this.#percentToTime(event.detail), event);
+  }
+  #onDragEnd(event) {
+    const { seeking } = this.#media.$state;
+    if (!peek(seeking)) this.#seeking(this.#percentToTime(event.detail), event);
+    const percent = event.detail;
+    this.#seek(this.#percentToTime(percent), percent, event);
+    const { pauseWhileDragging } = this.$props;
+    if (pauseWhileDragging() && this.#playingBeforeDragStart) {
+      this.#media.remote.play(event);
+      this.#playingBeforeDragStart = false;
+    }
+  }
+  #onValueChange(event) {
+    const { dragging } = this.$state;
+    if (dragging() || !event.trigger) return;
+    this.#onDragEnd(event);
+  }
+  // -------------------------------------------------------------------------------------------
+  // Props
+  // -------------------------------------------------------------------------------------------
+  #getValue() {
+    const { currentTime } = this.#media.$state;
+    return this.#timeToPercent(currentTime());
+  }
+  #getStep() {
+    const value = this.$props.step() / this.#media.$state.duration() * 100;
+    return Number.isFinite(value) ? value : 1;
+  }
+  #getKeyStep() {
+    const value = this.$props.keyStep() / this.#media.$state.duration() * 100;
+    return Number.isFinite(value) ? value : 1;
+  }
+  #roundValue(value) {
+    return round(value, 3);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSeek } = this.#media.$state;
+    return disabled() || !canSeek();
+  }
+  // -------------------------------------------------------------------------------------------
+  // ARIA
+  // -------------------------------------------------------------------------------------------
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const time = this.#percentToTime(this.$state.value()), { duration } = this.#media.$state;
+    return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : "live";
+  }
+  // -------------------------------------------------------------------------------------------
+  // Format
+  // -------------------------------------------------------------------------------------------
+  #percentToTime(percent) {
+    const { duration } = this.#media.$state;
+    return round(percent / 100 * duration(), 5);
+  }
+  #timeToPercent(time) {
+    const { liveEdge, duration } = this.#media.$state, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));
+    return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
+  }
+  #formatValue(percent) {
+    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state;
+    return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : "LIVE";
+  }
+  #formatTime(percent, options) {
+    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state, value = live() ? time - duration() : time;
+    return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(Math.abs(value), options)}` : "LIVE";
+  }
+}
+
+class SliderChapters extends Component {
+  static props = {
+    disabled: false
+  };
+  #media;
+  #sliderState;
+  #updateScope;
+  #titleRef = null;
+  #refs = [];
+  #$track = signal(null);
+  #$cues = signal([]);
+  #activeIndex = signal(-1);
+  #activePointerIndex = signal(-1);
+  #bufferedIndex = 0;
+  get cues() {
+    return this.#$cues();
+  }
+  get activeCue() {
+    return this.#$cues()[this.#activeIndex()] || null;
+  }
+  get activePointerCue() {
+    return this.#$cues()[this.#activePointerIndex()] || null;
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#sliderState = useState(TimeSlider.state);
+  }
+  onAttach(el) {
+    watchActiveTextTrack(this.#media.textTracks, "chapters", this.#setTrack.bind(this));
+    effect(this.#watchSource.bind(this));
+  }
+  onConnect() {
+    onDispose(() => this.#reset.bind(this));
+  }
+  onDestroy() {
+    this.#setTrack(null);
+  }
+  setRefs(refs) {
+    this.#refs = refs;
+    this.#updateScope?.dispose();
+    if (this.#refs.length === 1) {
+      const el = this.#refs[0];
+      el.style.width = "100%";
+      el.style.setProperty("--chapter-fill", "var(--slider-fill)");
+      el.style.setProperty("--chapter-progress", "var(--slider-progress)");
+    } else if (this.#refs.length > 0) {
+      scoped(() => this.#watch(), this.#updateScope = createScope());
+    }
+  }
+  #setTrack(track) {
+    if (peek(this.#$track) === track) return;
+    this.#reset();
+    this.#$track.set(track);
+  }
+  #reset() {
+    this.#refs = [];
+    this.#$cues.set([]);
+    this.#activeIndex.set(-1);
+    this.#activePointerIndex.set(-1);
+    this.#bufferedIndex = 0;
+    this.#updateScope?.dispose();
+  }
+  #watch() {
+    if (!this.#refs.length) return;
+    effect(this.#watchUpdates.bind(this));
+  }
+  #watchUpdates() {
+    const { hidden } = this.#sliderState;
+    if (hidden()) return;
+    effect(this.#watchContainerWidths.bind(this));
+    effect(this.#watchFillPercent.bind(this));
+    effect(this.#watchPointerPercent.bind(this));
+    effect(this.#watchBufferedPercent.bind(this));
+  }
+  #watchContainerWidths() {
+    const cues = this.#$cues();
+    if (!cues.length) return;
+    let cue, { seekableStart, seekableEnd } = this.#media.$state, startTime = seekableStart(), endTime = seekableEnd() || cues[cues.length - 1].endTime, duration = endTime - startTime, remainingWidth = 100;
+    for (let i = 0; i < cues.length; i++) {
+      cue = cues[i];
+      if (this.#refs[i]) {
+        const width = i === cues.length - 1 ? remainingWidth : round((cue.endTime - Math.max(startTime, cue.startTime)) / duration * 100, 3);
+        this.#refs[i].style.width = width + "%";
+        remainingWidth -= width;
+      }
+    }
+  }
+  #watchFillPercent() {
+    let { liveEdge, seekableStart, seekableEnd } = this.#media.$state, { fillPercent, value } = this.#sliderState, cues = this.#$cues(), isLiveEdge = liveEdge(), prevActiveIndex = peek(this.#activeIndex), currentChapter = cues[prevActiveIndex];
+    let currentActiveIndex = isLiveEdge ? this.#$cues.length - 1 : this.#findActiveChapterIndex(
+      currentChapter ? currentChapter.startTime / seekableEnd() * 100 <= peek(value) ? prevActiveIndex : 0 : 0,
+      fillPercent()
+    );
+    if (isLiveEdge || !currentChapter) {
+      this.#updateFillPercents(0, cues.length, 100);
+    } else if (currentActiveIndex > prevActiveIndex) {
+      this.#updateFillPercents(prevActiveIndex, currentActiveIndex, 100);
+    } else if (currentActiveIndex < prevActiveIndex) {
+      this.#updateFillPercents(currentActiveIndex + 1, prevActiveIndex + 1, 0);
+    }
+    const percent = isLiveEdge ? 100 : this.#calcPercent(
+      cues[currentActiveIndex],
+      fillPercent(),
+      seekableStart(),
+      this.#getEndTime(cues)
+    );
+    this.#updateFillPercent(this.#refs[currentActiveIndex], percent);
+    this.#activeIndex.set(currentActiveIndex);
+  }
+  #watchPointerPercent() {
+    let { pointing, pointerPercent } = this.#sliderState;
+    if (!pointing()) {
+      this.#activePointerIndex.set(-1);
+      return;
+    }
+    const activeIndex = this.#findActiveChapterIndex(0, pointerPercent());
+    this.#activePointerIndex.set(activeIndex);
+  }
+  #updateFillPercents(start, end, percent) {
+    for (let i = start; i < end; i++) this.#updateFillPercent(this.#refs[i], percent);
+  }
+  #updateFillPercent(ref, percent) {
+    if (!ref) return;
+    ref.style.setProperty("--chapter-fill", percent + "%");
+    setAttribute(ref, "data-active", percent > 0 && percent < 100);
+    setAttribute(ref, "data-ended", percent === 100);
+  }
+  #findActiveChapterIndex(startIndex, percent) {
+    let chapterPercent = 0, cues = this.#$cues();
+    if (percent === 0) return 0;
+    else if (percent === 100) return cues.length - 1;
+    let { seekableStart } = this.#media.$state, startTime = seekableStart(), endTime = this.#getEndTime(cues);
+    for (let i = startIndex; i < cues.length; i++) {
+      chapterPercent = this.#calcPercent(cues[i], percent, startTime, endTime);
+      if (chapterPercent >= 0 && chapterPercent < 100) return i;
+    }
+    return 0;
+  }
+  #watchBufferedPercent() {
+    this.#updateBufferedPercent(this.#bufferedPercent());
+  }
+  #updateBufferedPercent = animationFrameThrottle((bufferedPercent) => {
+    let percent, cues = this.#$cues(), { seekableStart } = this.#media.$state, startTime = seekableStart(), endTime = this.#getEndTime(cues);
+    for (let i = this.#bufferedIndex; i < this.#refs.length; i++) {
+      percent = this.#calcPercent(cues[i], bufferedPercent, startTime, endTime);
+      this.#refs[i]?.style.setProperty("--chapter-progress", percent + "%");
+      if (percent < 100) {
+        this.#bufferedIndex = i;
+        break;
+      }
+    }
+  });
+  #bufferedPercent = computed(this.#calcMediaBufferedPercent.bind(this));
+  #calcMediaBufferedPercent() {
+    const { bufferedEnd, duration } = this.#media.$state;
+    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1), 3) * 100;
+  }
+  #getEndTime(cues) {
+    const { seekableEnd } = this.#media.$state, endTime = seekableEnd();
+    return Number.isFinite(endTime) ? endTime : cues[cues.length - 1]?.endTime || 0;
+  }
+  #calcPercent(cue, percent, startTime, endTime) {
+    if (!cue) return 0;
+    const cues = this.#$cues();
+    if (cues.length === 0) return 0;
+    const duration = endTime - startTime, cueStartTime = Math.max(0, cue.startTime - startTime), cueEndTime = Math.min(endTime, cue.endTime) - startTime;
+    const startRatio = cueStartTime / duration, startPercent = startRatio * 100, endPercent = Math.min(1, startRatio + (cueEndTime - cueStartTime) / duration) * 100;
+    return Math.max(
+      0,
+      round(
+        percent >= endPercent ? 100 : (percent - startPercent) / (endPercent - startPercent) * 100,
+        3
+      )
+    );
+  }
+  #fillGaps(cues) {
+    let chapters = [], { seekableStart, seekableEnd, duration } = this.#media.$state, startTime = seekableStart(), endTime = seekableEnd();
+    cues = cues.filter((cue) => cue.startTime <= endTime && cue.endTime >= startTime);
+    const firstCue = cues[0];
+    if (firstCue && firstCue.startTime > startTime) {
+      chapters.push(new window.VTTCue(startTime, firstCue.startTime, ""));
+    }
+    for (let i = 0; i < cues.length - 1; i++) {
+      const currentCue = cues[i], nextCue = cues[i + 1];
+      chapters.push(currentCue);
+      if (nextCue) {
+        const timeDiff = nextCue.startTime - currentCue.endTime;
+        if (timeDiff > 0) {
+          chapters.push(new window.VTTCue(currentCue.endTime, currentCue.endTime + timeDiff, ""));
+        }
+      }
+    }
+    const lastCue = cues[cues.length - 1];
+    if (lastCue) {
+      chapters.push(lastCue);
+      const endTime2 = duration();
+      if (endTime2 >= 0 && endTime2 - lastCue.endTime > 1) {
+        chapters.push(new window.VTTCue(lastCue.endTime, duration(), ""));
+      }
+    }
+    return chapters;
+  }
+  #watchSource() {
+    const { source } = this.#media.$state;
+    source();
+    this.#onTrackChange();
+  }
+  #onTrackChange() {
+    if (!this.scope) return;
+    const { disabled } = this.$props;
+    if (disabled()) {
+      this.#$cues.set([]);
+      this.#activeIndex.set(0);
+      this.#bufferedIndex = 0;
+      return;
+    }
+    const track = this.#$track();
+    if (track) {
+      const onCuesChange = this.#onCuesChange.bind(this);
+      onCuesChange();
+      new EventsController(track).add("add-cue", onCuesChange).add("remove-cue", onCuesChange);
+      effect(this.#watchMediaDuration.bind(this));
+    }
+    this.#titleRef = this.#findChapterTitleRef();
+    if (this.#titleRef) effect(this.#onChapterTitleChange.bind(this));
+    return () => {
+      if (this.#titleRef) {
+        this.#titleRef.textContent = "";
+        this.#titleRef = null;
+      }
+    };
+  }
+  #watchMediaDuration() {
+    this.#media.$state.duration();
+    this.#onCuesChange();
+  }
+  #onCuesChange = functionDebounce(
+    () => {
+      const track = peek(this.#$track);
+      if (!this.scope || !track || !track.cues.length) return;
+      this.#$cues.set(this.#fillGaps(track.cues));
+      this.#activeIndex.set(0);
+      this.#bufferedIndex = 0;
+    },
+    150,
+    true
+  );
+  #onChapterTitleChange() {
+    const cue = this.activePointerCue || this.activeCue;
+    if (this.#titleRef) this.#titleRef.textContent = cue?.text || "";
+  }
+  #findParentSlider() {
+    let node = this.el;
+    while (node && node.getAttribute("role") !== "slider") {
+      node = node.parentElement;
+    }
+    return node;
+  }
+  #findChapterTitleRef() {
+    const slider = this.#findParentSlider();
+    return slider ? slider.querySelector('[data-part="chapter-title"]') : null;
+  }
+}
+const sliderchapters__proto = SliderChapters.prototype;
+prop(sliderchapters__proto, "cues");
+prop(sliderchapters__proto, "activeCue");
+prop(sliderchapters__proto, "activePointerCue");
+method(sliderchapters__proto, "setRefs");
+
+const menuContext = createContext();
+
+function scrollIntoView(el, options) {
+  const scrolls = r(el, options);
+  for (const { el: el2, top, left } of scrolls) {
+    el2.scroll({ top, left, behavior: options.behavior });
+  }
+}
+function scrollIntoCenter(el, options = {}) {
+  scrollIntoView(el, {
+    scrollMode: "if-needed",
+    block: "center",
+    inline: "center",
+    ...options
+  });
+}
+
+const FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
+  "a[href]",
+  "[tabindex]",
+  "input",
+  "select",
+  "button"
+].map((selector) => `${selector}:not([aria-hidden='true'])`).join(",");
+const VALID_KEYS = /* @__PURE__ */ new Set([
+  "Escape",
+  "Tab",
+  "ArrowUp",
+  "ArrowDown",
+  "Home",
+  "PageUp",
+  "End",
+  "PageDown",
+  "Enter",
+  " "
+]);
+class MenuFocusController {
+  #index = -1;
+  #el = null;
+  #elements = [];
+  #delegate;
+  get items() {
+    return this.#elements;
+  }
+  constructor(delegate) {
+    this.#delegate = delegate;
+  }
+  attachMenu(el) {
+    listenEvent(el, "focus", this.#onFocus.bind(this));
+    this.#el = el;
+    onDispose(() => {
+      this.#el = null;
+    });
+  }
+  listen() {
+    if (!this.#el) return;
+    this.update();
+    new EventsController(this.#el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this));
+    onDispose(() => {
+      this.#index = -1;
+      this.#elements = [];
+    });
+  }
+  update() {
+    this.#index = 0;
+    this.#elements = this.#getFocusableElements();
+  }
+  scroll(index = this.#findActiveIndex()) {
+    const element = this.#elements[index];
+    if (element) {
+      requestAnimationFrame(() => {
+        requestAnimationFrame(() => {
+          scrollIntoCenter(element, {
+            behavior: "smooth",
+            boundary: (el) => {
+              return !el.hasAttribute("data-root");
+            }
+          });
+        });
+      });
+    }
+  }
+  focusActive(scroll = true) {
+    const index = this.#findActiveIndex();
+    this.#focusAt(index >= 0 ? index : 0, scroll);
+  }
+  #focusAt(index, scroll = true) {
+    this.#index = index;
+    if (this.#elements[index]) {
+      this.#elements[index].focus({ preventScroll: true });
+      if (scroll) this.scroll(index);
+    } else {
+      this.#el?.focus({ preventScroll: true });
+    }
+  }
+  #findActiveIndex() {
+    return this.#elements.findIndex(
+      (el) => document.activeElement === el || el.getAttribute("role") === "menuitemradio" && el.getAttribute("aria-checked") === "true"
+    );
+  }
+  #onFocus() {
+    if (this.#index >= 0) return;
+    this.update();
+    this.focusActive();
+  }
+  #validateKeyEvent(event) {
+    const el = event.target;
+    if (wasEnterKeyPressed(event) && el instanceof Element) {
+      const role = el.getAttribute("role");
+      return !/a|input|select|button/.test(el.localName) && !role;
+    }
+    return VALID_KEYS.has(event.key);
+  }
+  #onKeyUp(event) {
+    if (!this.#validateKeyEvent(event)) return;
+    event.stopPropagation();
+    event.preventDefault();
+  }
+  #onKeyDown(event) {
+    if (!this.#validateKeyEvent(event)) return;
+    event.stopPropagation();
+    event.preventDefault();
+    switch (event.key) {
+      case "Escape":
+        this.#delegate.closeMenu(event);
+        break;
+      case "Tab":
+        this.#focusAt(this.#nextIndex(event.shiftKey ? -1 : 1));
+        break;
+      case "ArrowUp":
+        this.#focusAt(this.#nextIndex(-1));
+        break;
+      case "ArrowDown":
+        this.#focusAt(this.#nextIndex(1));
+        break;
+      case "Home":
+      case "PageUp":
+        this.#focusAt(0);
+        break;
+      case "End":
+      case "PageDown":
+        this.#focusAt(this.#elements.length - 1);
+        break;
+    }
+  }
+  #nextIndex(delta) {
+    let index = this.#index;
+    do {
+      index = (index + delta + this.#elements.length) % this.#elements.length;
+    } while (this.#elements[index]?.offsetParent === null);
+    return index;
+  }
+  #getFocusableElements() {
+    if (!this.#el) return [];
+    const focusableElements = this.#el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
+    const is = (node) => {
+      return node.getAttribute("role") === "menu";
+    };
+    for (const el of focusableElements) {
+      if (isHTMLElement(el) && el.offsetParent !== null && // does not have display: none
+      isElementParent(this.#el, el, is)) {
+        elements.push(el);
+      }
+    }
+    return elements;
+  }
+}
+
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __decorateClass = (decorators, target, key, kind) => {
+  var result = __getOwnPropDesc(target, key) ;
+  for (var i = decorators.length - 1, decorator; i >= 0; i--)
+    if (decorator = decorators[i])
+      result = (decorator(target, key, result) ) || result;
+  if (result) __defProp(target, key, result);
+  return result;
+};
+let idCount = 0;
+class Menu extends Component {
+  static props = {
+    showDelay: 0
+  };
+  #media;
+  #menuId;
+  #menuButtonId;
+  #expanded = signal(false);
+  #disabled = signal(false);
+  #trigger = signal(null);
+  #content = signal(null);
+  #parentMenu;
+  #submenus = /* @__PURE__ */ new Set();
+  #menuObserver = null;
+  #popper;
+  #focus;
+  #isSliderActive = false;
+  #isTriggerDisabled = signal(false);
+  #transitionCallbacks = /* @__PURE__ */ new Set();
+  get triggerElement() {
+    return this.#trigger();
+  }
+  get contentElement() {
+    return this.#content();
+  }
+  get isSubmenu() {
+    return !!this.#parentMenu;
+  }
+  constructor() {
+    super();
+    const { showDelay } = this.$props;
+    this.#popper = new Popper({
+      trigger: this.#trigger,
+      content: this.#content,
+      showDelay,
+      listen: (trigger, show, hide) => {
+        onPress(trigger, (event) => {
+          if (this.#expanded()) hide(event);
+          else show(event);
+        });
+        const closeTarget = this.#getCloseTarget();
+        if (closeTarget) {
+          onPress(closeTarget, (event) => {
+            event.stopPropagation();
+            hide(event);
+          });
+        }
+      },
+      onChange: this.#onExpandedChange.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const currentIdCount = ++idCount;
+    this.#menuId = `media-menu-${currentIdCount}`;
+    this.#menuButtonId = `media-menu-button-${currentIdCount}`;
+    this.#focus = new MenuFocusController({
+      closeMenu: this.close.bind(this)
+    });
+    if (hasProvidedContext(menuContext)) {
+      this.#parentMenu = useContext(menuContext);
+    }
+    this.#observeSliders();
+    this.setAttributes({
+      "data-open": this.#expanded,
+      "data-root": !this.isSubmenu,
+      "data-submenu": this.isSubmenu,
+      "data-disabled": this.#isDisabled.bind(this)
+    });
+    provideContext(menuContext, {
+      button: this.#trigger,
+      content: this.#content,
+      expanded: this.#expanded,
+      hint: signal(""),
+      submenu: !!this.#parentMenu,
+      disable: this.#disable.bind(this),
+      attachMenuButton: this.#attachMenuButton.bind(this),
+      attachMenuItems: this.#attachMenuItems.bind(this),
+      attachObserver: this.#attachObserver.bind(this),
+      disableMenuButton: this.#disableMenuButton.bind(this),
+      addSubmenu: this.#addSubmenu.bind(this),
+      onTransitionEvent: (callback) => {
+        this.#transitionCallbacks.add(callback);
+        onDispose(() => {
+          this.#transitionCallbacks.delete(callback);
+        });
+      }
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  onConnect(el) {
+    effect(this.#watchExpanded.bind(this));
+    if (this.isSubmenu) {
+      this.#parentMenu?.addSubmenu(this);
+    }
+  }
+  onDestroy() {
+    this.#trigger.set(null);
+    this.#content.set(null);
+    this.#menuObserver = null;
+    this.#transitionCallbacks.clear();
+  }
+  #observeSliders() {
+    let sliderActiveTimer = -1, parentSliderObserver = hasProvidedContext(sliderObserverContext) ? useContext(sliderObserverContext) : null;
+    provideContext(sliderObserverContext, {
+      onDragStart: () => {
+        parentSliderObserver?.onDragStart?.();
+        window.clearTimeout(sliderActiveTimer);
+        sliderActiveTimer = -1;
+        this.#isSliderActive = true;
+      },
+      onDragEnd: () => {
+        parentSliderObserver?.onDragEnd?.();
+        sliderActiveTimer = window.setTimeout(() => {
+          this.#isSliderActive = false;
+          sliderActiveTimer = -1;
+        }, 300);
+      }
+    });
+  }
+  #watchExpanded() {
+    const expanded = this.#isExpanded();
+    if (!this.isSubmenu) this.#onResize();
+    this.#updateMenuItemsHidden(expanded);
+    if (!expanded) return;
+    effect(() => {
+      const { height } = this.#media.$state, content = this.#content();
+      content && setStyle(content, "--player-height", height() + "px");
+    });
+    this.#focus.listen();
+    this.listen("pointerup", this.#onPointerUp.bind(this));
+    listenEvent(window, "pointerup", this.#onWindowPointerUp.bind(this));
+  }
+  #attachMenuButton(button) {
+    const el = button.el, isMenuItem = this.isSubmenu, isARIADisabled = $ariaBool(this.#isDisabled.bind(this));
+    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
+    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
+    setAttribute(el, "id", this.#menuButtonId);
+    setAttribute(el, "aria-haspopup", "menu");
+    setAttribute(el, "aria-expanded", "false");
+    setAttribute(el, "data-root", !this.isSubmenu);
+    setAttribute(el, "data-submenu", this.isSubmenu);
+    const watchAttrs = () => {
+      setAttribute(el, "data-open", this.#expanded());
+      setAttribute(el, "aria-disabled", isARIADisabled());
+    };
+    if (IS_SERVER) watchAttrs();
+    else effect(watchAttrs);
+    this.#trigger.set(el);
+    onDispose(() => {
+      this.#trigger.set(null);
+    });
+  }
+  #attachMenuItems(items) {
+    const el = items.el;
+    el.style.setProperty("display", "none");
+    setAttribute(el, "id", this.#menuId);
+    setAttributeIfEmpty(el, "role", "menu");
+    setAttributeIfEmpty(el, "tabindex", "-1");
+    setAttribute(el, "data-root", !this.isSubmenu);
+    setAttribute(el, "data-submenu", this.isSubmenu);
+    this.#content.set(el);
+    onDispose(() => this.#content.set(null));
+    const watchAttrs = () => setAttribute(el, "data-open", this.#expanded());
+    if (IS_SERVER) watchAttrs();
+    else effect(watchAttrs);
+    this.#focus.attachMenu(el);
+    this.#updateMenuItemsHidden(false);
+    const onTransition = this.#onResizeTransition.bind(this);
+    if (!this.isSubmenu) {
+      items.listen("transitionstart", onTransition);
+      items.listen("transitionend", onTransition);
+      items.listen("animationend", this.#onResize);
+      items.listen("vds-menu-resize", this.#onResize);
+    } else {
+      this.#parentMenu?.onTransitionEvent(onTransition);
+    }
+  }
+  #attachObserver(observer) {
+    this.#menuObserver = observer;
+  }
+  #updateMenuItemsHidden(expanded) {
+    const content = peek(this.#content);
+    if (content) setAttribute(content, "aria-hidden", ariaBool$1(!expanded));
+  }
+  #disableMenuButton(disabled) {
+    this.#isTriggerDisabled.set(disabled);
+  }
+  #wasKeyboardExpand = false;
+  #onExpandedChange(isExpanded, event) {
+    this.#wasKeyboardExpand = isKeyboardEvent(event);
+    event?.stopPropagation();
+    if (this.#expanded() === isExpanded) return;
+    if (this.#isDisabled()) {
+      if (isExpanded) this.#popper.hide(event);
+      return;
+    }
+    this.el?.dispatchEvent(
+      new Event("vds-menu-resize", {
+        bubbles: true,
+        composed: true
+      })
+    );
+    const trigger = this.#trigger(), content = this.#content();
+    if (trigger) {
+      setAttribute(trigger, "aria-controls", isExpanded && this.#menuId);
+      setAttribute(trigger, "aria-expanded", ariaBool$1(isExpanded));
+    }
+    if (content) setAttribute(content, "aria-labelledby", isExpanded && this.#menuButtonId);
+    this.#expanded.set(isExpanded);
+    this.#toggleMediaControls(event);
+    tick();
+    if (this.#wasKeyboardExpand) {
+      if (isExpanded) content?.focus();
+      else trigger?.focus();
+      for (const el of [this.el, content]) {
+        el && el.setAttribute("data-keyboard", "");
+      }
+    } else {
+      for (const el of [this.el, content]) {
+        el && el.removeAttribute("data-keyboard");
+      }
+    }
+    this.dispatch(isExpanded ? "open" : "close", { trigger: event });
+    if (isExpanded) {
+      if (!this.isSubmenu && this.#media.activeMenu !== this) {
+        this.#media.activeMenu?.close(event);
+        this.#media.activeMenu = this;
+      }
+      this.#menuObserver?.onOpen?.(event);
+    } else {
+      if (this.isSubmenu) {
+        for (const el of this.#submenus) el.close(event);
+      } else {
+        this.#media.activeMenu = null;
+      }
+      this.#menuObserver?.onClose?.(event);
+    }
+    if (isExpanded) {
+      requestAnimationFrame(this.#updateFocus.bind(this));
+    }
+  }
+  #updateFocus() {
+    if (this.#isTransitionActive || this.#isSubmenuOpen) return;
+    this.#focus.update();
+    requestAnimationFrame(() => {
+      if (this.#wasKeyboardExpand) {
+        this.#focus.focusActive();
+      } else {
+        this.#focus.scroll();
+      }
+    });
+  }
+  #isExpanded() {
+    return !this.#isDisabled() && this.#expanded();
+  }
+  #isDisabled() {
+    return this.#disabled() || this.#isTriggerDisabled();
+  }
+  #disable(disabled) {
+    this.#disabled.set(disabled);
+  }
+  #onPointerUp(event) {
+    const content = this.#content();
+    if (this.#isSliderActive || content && isEventInside(content, event)) {
+      return;
+    }
+    event.stopPropagation();
+  }
+  #onWindowPointerUp(event) {
+    const content = this.#content();
+    if (this.#isSliderActive || content && isEventInside(content, event)) {
+      return;
+    }
+    this.close(event);
+  }
+  #getCloseTarget() {
+    const target = this.el?.querySelector('[data-part="close-target"]');
+    return this.el && target && isElementParent(this.el, target, (node) => node.getAttribute("role") === "menu") ? target : null;
+  }
+  #toggleMediaControls(trigger) {
+    if (this.isSubmenu) return;
+    if (this.#expanded()) this.#media.remote.pauseControls(trigger);
+    else this.#media.remote.resumeControls(trigger);
+  }
+  #addSubmenu(menu) {
+    this.#submenus.add(menu);
+    new EventsController(menu).add("open", this.#onSubmenuOpenBind).add("close", this.#onSubmenuCloseBind);
+    onDispose(this.#removeSubmenuBind);
+  }
+  #removeSubmenuBind = this.#removeSubmenu.bind(this);
+  #removeSubmenu(menu) {
+    this.#submenus.delete(menu);
+  }
+  #isSubmenuOpen = false;
+  #onSubmenuOpenBind = this.#onSubmenuOpen.bind(this);
+  #onSubmenuOpen(event) {
+    this.#isSubmenuOpen = true;
+    const content = this.#content();
+    if (this.isSubmenu) {
+      this.triggerElement?.setAttribute("aria-hidden", "true");
+    }
+    for (const target of this.#submenus) {
+      if (target !== event.target) {
+        for (const el of [target.el, target.triggerElement]) {
+          el?.setAttribute("aria-hidden", "true");
+        }
+      }
+    }
+    if (content) {
+      const el = event.target.el;
+      for (const child of content.children) {
+        if (child.contains(el)) {
+          child.setAttribute("data-open", "");
+        } else if (child !== el) {
+          child.setAttribute("data-hidden", "");
+        }
+      }
+    }
+  }
+  #onSubmenuCloseBind = this.#onSubmenuClose.bind(this);
+  #onSubmenuClose(event) {
+    this.#isSubmenuOpen = false;
+    const content = this.#content();
+    if (this.isSubmenu) {
+      this.triggerElement?.setAttribute("aria-hidden", "false");
+    }
+    for (const target of this.#submenus) {
+      for (const el of [target.el, target.triggerElement]) {
+        el?.setAttribute("aria-hidden", "false");
+      }
+    }
+    if (content) {
+      for (const child of content.children) {
+        child.removeAttribute("data-open");
+        child.removeAttribute("data-hidden");
+      }
+    }
+  }
+  #onResize = animationFrameThrottle(() => {
+    const content = peek(this.#content);
+    if (!content || IS_SERVER) return;
+    let height = 0, styles = getComputedStyle(content), children = [...content.children];
+    for (const prop2 of ["paddingTop", "paddingBottom", "borderTopWidth", "borderBottomWidth"]) {
+      height += parseFloat(styles[prop2]) || 0;
+    }
+    for (const child of children) {
+      if (isHTMLElement(child) && child.style.display === "contents") {
+        children.push(...child.children);
+      } else if (child.nodeType === 3) {
+        height += parseFloat(getComputedStyle(child).fontSize);
+      } else if (isHTMLElement(child)) {
+        if (!isElementVisible(child)) continue;
+        const style = getComputedStyle(child);
+        height += child.offsetHeight + (parseFloat(style.marginTop) || 0) + (parseFloat(style.marginBottom) || 0);
+      }
+    }
+    setStyle(content, "--menu-height", height + "px");
+  });
+  #isTransitionActive = false;
+  #onResizeTransition(event) {
+    const content = this.#content();
+    if (content && event.propertyName === "height") {
+      this.#isTransitionActive = event.type === "transitionstart";
+      setAttribute(content, "data-transition", this.#isTransitionActive ? "height" : null);
+      if (this.#expanded()) this.#updateFocus();
+    }
+    for (const callback of this.#transitionCallbacks) callback(event);
+  }
+  open(trigger) {
+    if (peek(this.#expanded)) return;
+    this.#popper.show(trigger);
+    tick();
+  }
+  close(trigger) {
+    if (!peek(this.#expanded)) return;
+    this.#popper.hide(trigger);
+    tick();
+  }
+}
+__decorateClass([
+  prop
+], Menu.prototype, "triggerElement");
+__decorateClass([
+  prop
+], Menu.prototype, "contentElement");
+__decorateClass([
+  prop
+], Menu.prototype, "isSubmenu");
+__decorateClass([
+  method
+], Menu.prototype, "open");
+__decorateClass([
+  method
+], Menu.prototype, "close");
+
+class MenuButton extends Component {
+  static props = {
+    disabled: false
+  };
+  #menu;
+  #hintEl = signal(null);
+  get expanded() {
+    return this.#menu?.expanded() ?? false;
+  }
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#menu = useContext(menuContext);
+  }
+  onAttach(el) {
+    this.#menu.attachMenuButton(this);
+    effect(this.#watchDisabled.bind(this));
+    setAttributeIfEmpty(el, "type", "button");
+  }
+  onConnect(el) {
+    effect(this.#watchHintEl.bind(this));
+    this.#onMutation();
+    const mutations = new MutationObserver(this.#onMutation.bind(this));
+    mutations.observe(el, { attributeFilter: ["data-part"], childList: true, subtree: true });
+    onDispose(() => mutations.disconnect());
+    onPress(el, (trigger) => {
+      this.dispatch("select", { trigger });
+    });
+  }
+  #watchDisabled() {
+    this.#menu.disableMenuButton(this.$props.disabled());
+  }
+  #watchHintEl() {
+    const el = this.#hintEl();
+    if (!el) return;
+    effect(() => {
+      const text = this.#menu.hint();
+      if (text) el.textContent = text;
+    });
+  }
+  #onMutation() {
+    const hintEl = this.el?.querySelector('[data-part="hint"]');
+    this.#hintEl.set(hintEl ?? null);
+  }
+}
+const menubutton__proto = MenuButton.prototype;
+prop(menubutton__proto, "expanded");
+
+class MenuItem extends MenuButton {
+}
+
+class MenuPortal extends Component {
+  static props = {
+    container: null,
+    disabled: false
+  };
+  #target = null;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(menuPortalContext, {
+      attach: this.#attachElement.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  // Need this so connect scope is defined.
+  onConnect(el) {
+  }
+  onDestroy() {
+    this.#target?.remove();
+    this.#target = null;
+  }
+  #attachElement(el) {
+    this.#portal(false);
+    this.#target = el;
+    requestScopedAnimationFrame(() => {
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        effect(this.#watchDisabled.bind(this));
+      });
+    });
+  }
+  #watchDisabled() {
+    const { fullscreen } = this.#media.$state, { disabled } = this.$props;
+    this.#portal(disabled() === "fullscreen" ? !fullscreen() : !disabled());
+  }
+  #portal(shouldPortal) {
+    if (!this.#target) return;
+    let container = this.#getContainer(this.$props.container());
+    if (!container) return;
+    const isPortalled = this.#target.parentElement === container;
+    setAttribute(this.#target, "data-portal", shouldPortal);
+    if (shouldPortal) {
+      if (!isPortalled) {
+        this.#target.remove();
+        container.append(this.#target);
+      }
+    } else if (isPortalled && this.#target.parentElement === container) {
+      this.#target.remove();
+      this.el?.append(this.#target);
+    }
+  }
+  #getContainer(selector) {
+    if (isHTMLElement(selector)) return selector;
+    return selector ? document.querySelector(selector) : document.body;
+  }
+}
+const menuPortalContext = createContext();
+
+class MenuItems extends Component {
+  static props = {
+    placement: null,
+    offset: 0,
+    alignOffset: 0
+  };
+  #menu;
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { placement } = this.$props;
+    this.setAttributes({
+      "data-placement": placement
+    });
+  }
+  onAttach(el) {
+    this.#menu = useContext(menuContext);
+    this.#menu.attachMenuItems(this);
+    if (hasProvidedContext(menuPortalContext)) {
+      const portal = useContext(menuPortalContext);
+      if (portal) {
+        provideContext(menuPortalContext, null);
+        portal.attach(el);
+        onDispose(() => portal.attach(null));
+      }
+    }
+  }
+  onConnect(el) {
+    effect(this.#watchPlacement.bind(this));
+  }
+  #watchPlacement() {
+    const { expanded } = this.#menu;
+    if (!this.el || !expanded()) return;
+    const placement = this.$props.placement();
+    if (!placement) return;
+    Object.assign(this.el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+    const { offset: mainOffset, alignOffset } = this.$props;
+    onDispose(
+      autoPlacement(this.el, this.#getButton(), placement, {
+        offsetVarName: "media-menu",
+        xOffset: alignOffset(),
+        yOffset: mainOffset()
+      })
+    );
+    onDispose(this.#hide.bind(this));
+  }
+  #hide() {
+    if (!this.el) return;
+    this.el.removeAttribute("style");
+    this.el.style.display = "none";
+  }
+  #getButton() {
+    return this.#menu.button();
+  }
+}
+
+const radioControllerContext = createContext();
+
+class RadioGroupController extends ViewController {
+  #group = /* @__PURE__ */ new Set();
+  #value = signal("");
+  #controller = null;
+  onValueChange;
+  get values() {
+    return Array.from(this.#group).map((radio) => radio.value());
+  }
+  get value() {
+    return this.#value();
+  }
+  set value(value) {
+    this.#onChange(value);
+  }
+  onSetup() {
+    provideContext(radioControllerContext, {
+      add: this.#addRadio.bind(this),
+      remove: this.#removeRadio.bind(this)
+    });
+  }
+  onAttach(el) {
+    const isMenuItem = hasProvidedContext(menuContext);
+    if (!isMenuItem) setAttributeIfEmpty(el, "role", "radiogroup");
+    this.setAttributes({ value: this.#value });
+  }
+  onDestroy() {
+    this.#group.clear();
+  }
+  #addRadio(radio) {
+    if (this.#group.has(radio)) return;
+    this.#group.add(radio);
+    radio.onCheck = this.#onChangeBind;
+    radio.check(radio.value() === this.#value());
+  }
+  #removeRadio(radio) {
+    radio.onCheck = null;
+    this.#group.delete(radio);
+  }
+  #onChangeBind = this.#onChange.bind(this);
+  #onChange(newValue, trigger) {
+    const currentValue = peek(this.#value);
+    if (!newValue || newValue === currentValue) return;
+    const currentRadio = this.#findRadio(currentValue), newRadio = this.#findRadio(newValue);
+    currentRadio?.check(false, trigger);
+    newRadio?.check(true, trigger);
+    this.#value.set(newValue);
+    this.onValueChange?.(newValue, trigger);
+  }
+  #findRadio(newValue) {
+    for (const radio of this.#group) {
+      if (newValue === peek(radio.value)) return radio;
+    }
+    return null;
+  }
+}
+
+class RadioGroup extends Component {
+  static props = {
+    value: ""
+  };
+  #controller;
+  /**
+   * A list of radio values that belong this group.
+   */
+  get values() {
+    return this.#controller.values;
+  }
+  /**
+   * The radio value that is checked in this group.
+   */
+  get value() {
+    return this.#controller.value;
+  }
+  set value(newValue) {
+    this.#controller.value = newValue;
+  }
+  constructor() {
+    super();
+    this.#controller = new RadioGroupController();
+    this.#controller.onValueChange = this.#onValueChange.bind(this);
+  }
+  onSetup() {
+    if (IS_SERVER) this.#watchValue();
+    else effect(this.#watchValue.bind(this));
+  }
+  #watchValue() {
+    this.#controller.value = this.$props.value();
+  }
+  #onValueChange(value, trigger) {
+    const event = this.createEvent("change", { detail: value, trigger });
+    this.dispatch(event);
+  }
+}
+const radiogroup__proto = RadioGroup.prototype;
+prop(radiogroup__proto, "values");
+prop(radiogroup__proto, "value");
+
+class Radio extends Component {
+  static props = {
+    value: ""
+  };
+  #checked = signal(false);
+  #controller = {
+    value: this.$props.value,
+    check: this.#check.bind(this),
+    onCheck: null
+  };
+  /**
+   * Whether this radio is currently checked.
+   */
+  get checked() {
+    return this.#checked();
+  }
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.setAttributes({
+      value: this.$props.value,
+      "data-checked": this.#checked,
+      "aria-checked": $ariaBool(this.#checked)
+    });
+  }
+  onAttach(el) {
+    const isMenuItem = hasProvidedContext(menuContext);
+    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
+    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitemradio" : "radio");
+    effect(this.#watchValue.bind(this));
+  }
+  onConnect(el) {
+    this.#addToGroup();
+    onPress(el, this.#onPress.bind(this));
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  #onDisconnect() {
+    scoped(() => {
+      const group = useContext(radioControllerContext);
+      group.remove(this.#controller);
+    }, this.connectScope);
+  }
+  #addToGroup() {
+    const group = useContext(radioControllerContext);
+    group.add(this.#controller);
+  }
+  #watchValue() {
+    const { value } = this.$props, newValue = value();
+    if (peek(this.#checked)) {
+      this.#controller.onCheck?.(newValue);
+    }
+  }
+  #onPress(event) {
+    if (peek(this.#checked)) return;
+    this.#onChange(true, event);
+    this.#onSelect(event);
+    this.#controller.onCheck?.(peek(this.$props.value), event);
+  }
+  #check(value, trigger) {
+    if (peek(this.#checked) === value) return;
+    this.#onChange(value, trigger);
+  }
+  #onChange(value, trigger) {
+    this.#checked.set(value);
+    this.dispatch("change", { detail: value, trigger });
+  }
+  #onSelect(trigger) {
+    this.dispatch("select", { trigger });
+  }
+}
+const radio__proto = Radio.prototype;
+prop(radio__proto, "checked");
+
+class Gesture extends Component {
+  static props = {
+    disabled: false,
+    event: void 0,
+    action: void 0
+  };
+  #media;
+  #provider = null;
+  onSetup() {
+    this.#media = useMediaContext();
+    const { event, action } = this.$props;
+    this.setAttributes({
+      event,
+      action
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-gesture", "");
+    el.style.setProperty("pointer-events", "none");
+  }
+  onConnect(el) {
+    this.#provider = this.#media.player.el?.querySelector(
+      "[data-media-provider]"
+    );
+    effect(this.#attachListener.bind(this));
+  }
+  #attachListener() {
+    let eventType = this.$props.event(), disabled = this.$props.disabled();
+    if (!this.#provider || !eventType || disabled) return;
+    if (/^dbl/.test(eventType)) {
+      eventType = eventType.split(/^dbl/)[1];
+    }
+    if (eventType === "pointerup" || eventType === "pointerdown") {
+      const pointer = this.#media.$state.pointer();
+      if (pointer === "coarse") {
+        eventType = eventType === "pointerup" ? "touchend" : "touchstart";
+      }
+    }
+    listenEvent(
+      this.#provider,
+      eventType,
+      this.#acceptEvent.bind(this),
+      { passive: false }
+    );
+  }
+  #presses = 0;
+  #pressTimerId = -1;
+  #acceptEvent(event) {
+    if (this.$props.disabled() || isPointerEvent(event) && (event.button !== 0 || this.#media.activeMenu) || isTouchEvent(event) && this.#media.activeMenu || isTouchPinchEvent(event) || !this.#inBounds(event)) {
+      return;
+    }
+    event.MEDIA_GESTURE = true;
+    event.preventDefault();
+    const eventType = peek(this.$props.event), isDblEvent = eventType?.startsWith("dbl");
+    if (!isDblEvent) {
+      if (this.#presses === 0) {
+        setTimeout(() => {
+          if (this.#presses === 1) this.#handleEvent(event);
+        }, 250);
+      }
+    } else if (this.#presses === 1) {
+      queueMicrotask(() => this.#handleEvent(event));
+      clearTimeout(this.#pressTimerId);
+      this.#presses = 0;
+      return;
+    }
+    if (this.#presses === 0) {
+      this.#pressTimerId = window.setTimeout(() => {
+        this.#presses = 0;
+      }, 275);
+    }
+    this.#presses++;
+  }
+  #handleEvent(event) {
+    this.el.setAttribute("data-triggered", "");
+    requestAnimationFrame(() => {
+      if (this.#isTopLayer()) {
+        this.#performAction(peek(this.$props.action), event);
+      }
+      requestAnimationFrame(() => {
+        this.el.removeAttribute("data-triggered");
+      });
+    });
+  }
+  /** Validate event occurred in gesture bounds. */
+  #inBounds(event) {
+    if (!this.el) return false;
+    if (isPointerEvent(event) || isMouseEvent(event) || isTouchEvent(event)) {
+      const touch = isTouchEvent(event) ? event.changedTouches[0] ?? event.touches[0] : void 0;
+      const clientX = touch?.clientX ?? event.clientX;
+      const clientY = touch?.clientY ?? event.clientY;
+      const rect = this.el.getBoundingClientRect();
+      const inBounds = clientY >= rect.top && clientY <= rect.bottom && clientX >= rect.left && clientX <= rect.right;
+      return event.type.includes("leave") ? !inBounds : inBounds;
+    }
+    return true;
+  }
+  /** Validate gesture has the highest z-index in this triggered group. */
+  #isTopLayer() {
+    const gestures = this.#media.player.el.querySelectorAll(
+      "[data-media-gesture][data-triggered]"
+    );
+    return Array.from(gestures).sort(
+      (a, b) => +getComputedStyle(b).zIndex - +getComputedStyle(a).zIndex
+    )[0] === this.el;
+  }
+  #performAction(action, trigger) {
+    if (!action) return;
+    const willTriggerEvent = new DOMEvent("will-trigger", {
+      detail: action,
+      cancelable: true,
+      trigger
+    });
+    this.dispatchEvent(willTriggerEvent);
+    if (willTriggerEvent.defaultPrevented) return;
+    const [method, value] = action.replace(/:([a-z])/, "-$1").split(":");
+    if (action.includes(":fullscreen")) {
+      this.#media.remote.toggleFullscreen("prefer-media", trigger);
+    } else if (action.includes("seek:")) {
+      this.#media.remote.seek(peek(this.#media.$state.currentTime) + (+value || 0), trigger);
+    } else {
+      this.#media.remote[kebabToCamelCase(method)](trigger);
+    }
+    this.dispatch("trigger", {
+      detail: action,
+      trigger
+    });
+  }
+}
+
+class CaptionsTextRenderer {
+  priority = 10;
+  #track = null;
+  #renderer;
+  #events;
+  constructor(renderer) {
+    this.#renderer = renderer;
+  }
+  attach() {
+  }
+  canRender() {
+    return true;
+  }
+  detach() {
+    this.#events?.abort();
+    this.#events = void 0;
+    this.#renderer.reset();
+    this.#track = null;
+  }
+  changeTrack(track) {
+    if (!track || this.#track === track) return;
+    this.#events?.abort();
+    this.#events = new EventsController(track);
+    if (track.readyState < 2) {
+      this.#renderer.reset();
+      this.#events.add("load", () => this.#changeTrack(track), { once: true });
+    } else {
+      this.#changeTrack(track);
+    }
+    this.#events.add("add-cue", (event) => {
+      this.#renderer.addCue(event.detail);
+    }).add("remove-cue", (event) => {
+      this.#renderer.removeCue(event.detail);
+    });
+    this.#track = track;
+  }
+  #changeTrack(track) {
+    this.#renderer.changeTrack({
+      cues: [...track.cues],
+      regions: [...track.regions]
+    });
+  }
+}
+
+class Captions extends Component {
+  static props = {
+    textDir: "ltr",
+    exampleText: "Captions look like this."
+  };
+  #media;
+  static lib = signal(null);
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "aria-hidden": $ariaBool(this.#isHidden.bind(this))
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("pointer-events", "none");
+  }
+  onConnect(el) {
+    if (!Captions.lib()) {
+      import('media-captions').then((lib) => Captions.lib.set(lib));
+    }
+    effect(this.#watchViewType.bind(this));
+  }
+  #isHidden() {
+    const { textTrack, remotePlaybackState, iOSControls } = this.#media.$state, track = textTrack();
+    return iOSControls() || remotePlaybackState() === "connected" || !track || !isTrackCaptionKind(track);
+  }
+  #watchViewType() {
+    if (!Captions.lib()) return;
+    const { viewType } = this.#media.$state;
+    if (viewType() === "audio") {
+      return this.#setupAudioView();
+    } else {
+      return this.#setupVideoView();
+    }
+  }
+  #setupAudioView() {
+    effect(this.#onTrackChange.bind(this));
+    this.#listenToFontStyleChanges(null);
+    return () => {
+      this.el.textContent = "";
+    };
+  }
+  #onTrackChange() {
+    if (this.#isHidden()) return;
+    this.#onCueChange();
+    const { textTrack } = this.#media.$state;
+    listenEvent(textTrack(), "cue-change", this.#onCueChange.bind(this));
+    effect(this.#onUpdateTimedNodes.bind(this));
+  }
+  #onCueChange() {
+    this.el.textContent = "";
+    if (this.#hideExampleTimer >= 0) {
+      this.#removeExample();
+    }
+    const { realCurrentTime, textTrack } = this.#media.$state, { renderVTTCueString } = Captions.lib(), time = peek(realCurrentTime), activeCues = peek(textTrack).activeCues;
+    for (const cue of activeCues) {
+      const displayEl = this.#createCueDisplayElement(), cueEl = this.#createCueElement();
+      cueEl.innerHTML = renderVTTCueString(cue, time);
+      displayEl.append(cueEl);
+      this.el.append(cueEl);
+    }
+  }
+  #onUpdateTimedNodes() {
+    const { realCurrentTime } = this.#media.$state, { updateTimedVTTCueNodes } = Captions.lib();
+    updateTimedVTTCueNodes(this.el, realCurrentTime());
+  }
+  #setupVideoView() {
+    const { CaptionsRenderer } = Captions.lib(), renderer = new CaptionsRenderer(this.el), textRenderer = new CaptionsTextRenderer(renderer);
+    this.#media.textRenderers.add(textRenderer);
+    effect(this.#watchTextDirection.bind(this, renderer));
+    effect(this.#watchMediaTime.bind(this, renderer));
+    this.#listenToFontStyleChanges(renderer);
+    return () => {
+      this.el.textContent = "";
+      this.#media.textRenderers.remove(textRenderer);
+      renderer.destroy();
+    };
+  }
+  #watchTextDirection(renderer) {
+    renderer.dir = this.$props.textDir();
+  }
+  #watchMediaTime(renderer) {
+    if (this.#isHidden()) return;
+    const { realCurrentTime, textTrack } = this.#media.$state;
+    renderer.currentTime = realCurrentTime();
+    if (this.#hideExampleTimer >= 0 && textTrack()?.activeCues[0]) {
+      this.#removeExample();
+    }
+  }
+  #listenToFontStyleChanges(renderer) {
+    const player = this.#media.player;
+    if (!player) return;
+    const onChange = this.#onFontStyleChange.bind(this, renderer);
+    listenEvent(player, "vds-font-change", onChange);
+  }
+  #onFontStyleChange(renderer) {
+    if (this.#hideExampleTimer >= 0) {
+      this.#hideExample();
+      return;
+    }
+    const { textTrack } = this.#media.$state;
+    if (!textTrack()?.activeCues[0]) {
+      this.#showExample();
+    } else {
+      renderer?.update(true);
+    }
+  }
+  #showExample() {
+    const display = this.#createCueDisplayElement();
+    setAttribute(display, "data-example", "");
+    const cue = this.#createCueElement();
+    setAttribute(cue, "data-example", "");
+    cue.textContent = this.$props.exampleText();
+    display?.append(cue);
+    this.el?.append(display);
+    this.el?.setAttribute("data-example", "");
+    this.#hideExample();
+  }
+  #hideExampleTimer = -1;
+  #hideExample() {
+    window.clearTimeout(this.#hideExampleTimer);
+    this.#hideExampleTimer = window.setTimeout(this.#removeExample.bind(this), 2500);
+  }
+  #removeExample() {
+    this.el?.removeAttribute("data-example");
+    if (this.el?.querySelector("[data-example]")) this.el.textContent = "";
+    this.#hideExampleTimer = -1;
+  }
+  #createCueDisplayElement() {
+    const el = document.createElement("div");
+    setAttribute(el, "data-part", "cue-display");
+    return el;
+  }
+  #createCueElement() {
+    const el = document.createElement("div");
+    setAttribute(el, "data-part", "cue");
+    return el;
+  }
+}
+
+class Poster extends Component {
+  static props = {
+    src: null,
+    alt: null,
+    crossOrigin: null
+  };
+  static state = new State({
+    img: null,
+    src: null,
+    alt: null,
+    crossOrigin: null,
+    loading: true,
+    error: null,
+    hidden: false
+  });
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#watchSrc();
+    this.#watchAlt();
+    this.#watchCrossOrigin();
+    this.#watchHidden();
+  }
+  onAttach(el) {
+    el.style.setProperty("pointer-events", "none");
+    effect(this.#watchImg.bind(this));
+    effect(this.#watchSrc.bind(this));
+    effect(this.#watchAlt.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#watchHidden.bind(this));
+    const { started } = this.#media.$state;
+    this.setAttributes({
+      "data-visible": () => !started() && !this.$state.hidden(),
+      "data-loading": this.#isLoading.bind(this),
+      "data-error": this.#hasError.bind(this),
+      "data-hidden": this.$state.hidden
+    });
+  }
+  onConnect(el) {
+    effect(this.#onPreconnect.bind(this));
+    effect(this.#onLoadStart.bind(this));
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error());
+  }
+  #onPreconnect() {
+    const { canLoadPoster, poster } = this.#media.$state;
+    if (!canLoadPoster() && poster()) preconnect(poster(), "preconnect");
+  }
+  #watchHidden() {
+    const { src } = this.$props, { poster, nativeControls } = this.#media.$state;
+    this.el && setAttribute(this.el, "display", nativeControls() ? "none" : null);
+    this.$state.hidden.set(this.#hasError() || !(src() || poster()) || nativeControls());
+  }
+  #isLoading() {
+    const { loading, hidden } = this.$state;
+    return !hidden() && loading();
+  }
+  #watchImg() {
+    const img = this.$state.img();
+    if (!img) return;
+    new EventsController(img).add("load", this.#onLoad.bind(this)).add("error", this.#onError.bind(this));
+    if (img.complete) this.#onLoad();
+  }
+  #prevSrc = "";
+  #watchSrc() {
+    const { poster: defaultPoster } = this.#media.$props, { canLoadPoster, providedPoster, inferredPoster } = this.#media.$state;
+    const src = this.$props.src() || "", poster = src || defaultPoster() || inferredPoster();
+    if (this.#prevSrc === providedPoster()) {
+      providedPoster.set(src);
+    }
+    this.$state.src.set(canLoadPoster() && poster.length ? poster : null);
+    this.#prevSrc = src;
+  }
+  #watchAlt() {
+    const { src } = this.$props, { alt } = this.$state, { poster } = this.#media.$state;
+    alt.set(src() || poster() ? this.$props.alt() : null);
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin, poster: src } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(
+      /ytimg\.com|vimeo/.test(src() || "") ? null : crossOrigin === true ? "anonymous" : crossOrigin
+    );
+  }
+  #onLoadStart() {
+    const { loading, error } = this.$state, { canLoadPoster, poster } = this.#media.$state;
+    loading.set(canLoadPoster() && !!poster());
+    error.set(null);
+  }
+  #onLoad() {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(null);
+  }
+  #onError(event) {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(event);
+  }
+}
+
+class Time extends Component {
+  static props = {
+    type: "current",
+    showHours: false,
+    padHours: null,
+    padMinutes: null,
+    remainder: false,
+    toggle: false,
+    hidden: false
+  };
+  static state = new State({
+    timeText: "",
+    hidden: false
+  });
+  #media;
+  #invert = signal(null);
+  #isVisible = signal(true);
+  #isIntersecting = signal(true);
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#watchTime();
+    const { type } = this.$props;
+    this.setAttributes({
+      "data-type": type,
+      "data-remainder": this.#shouldInvert.bind(this)
+    });
+    new IntersectionObserverController({
+      callback: this.#onIntersectionChange.bind(this)
+    }).attach(this);
+  }
+  onAttach(el) {
+    if (!el.hasAttribute("role")) effect(this.#watchRole.bind(this));
+    effect(this.#watchTime.bind(this));
+  }
+  onConnect(el) {
+    onDispose(observeVisibility(el, this.#isVisible.set));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#watchToggle.bind(this));
+  }
+  #onIntersectionChange(entries) {
+    this.#isIntersecting.set(entries[0].isIntersecting);
+  }
+  #watchHidden() {
+    const { hidden } = this.$props;
+    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting());
+  }
+  #watchToggle() {
+    if (!this.$props.toggle()) {
+      this.#invert.set(null);
+      return;
+    }
+    if (this.el) {
+      onPress(this.el, this.#onToggle.bind(this));
+    }
+  }
+  #watchTime() {
+    const { hidden, timeText } = this.$state, { duration } = this.#media.$state;
+    if (hidden()) return;
+    const { type, padHours, padMinutes, showHours } = this.$props, seconds = this.#getSeconds(type()), $duration = duration(), shouldInvert = this.#shouldInvert();
+    if (!Number.isFinite(seconds + $duration)) {
+      timeText.set("LIVE");
+      return;
+    }
+    const time = shouldInvert ? Math.max(0, $duration - seconds) : seconds, formattedTime = formatTime(time, {
+      padHrs: padHours(),
+      padMins: padMinutes(),
+      showHrs: showHours()
+    });
+    timeText.set((shouldInvert ? "-" : "") + formattedTime);
+  }
+  #watchRole() {
+    if (!this.el) return;
+    const { toggle } = this.$props;
+    setAttribute(this.el, "role", toggle() ? "timer" : null);
+    setAttribute(this.el, "tabindex", toggle() ? 0 : null);
+  }
+  #getSeconds(type) {
+    const { bufferedEnd, duration, currentTime } = this.#media.$state;
+    switch (type) {
+      case "buffered":
+        return bufferedEnd();
+      case "duration":
+        return duration();
+      default:
+        return currentTime();
+    }
+  }
+  #shouldInvert() {
+    return this.$props.remainder() && this.#invert() !== false;
+  }
+  #onToggle(event) {
+    event.preventDefault();
+    if (this.#invert() === null) {
+      this.#invert.set(!this.$props.remainder());
+      return;
+    }
+    this.#invert.set((v) => !v);
+  }
+}
+
+class MediaPlayerInstance extends MediaPlayer {
+}
+class MediaProviderInstance extends MediaProvider {
+}
+class MediaAnnouncerInstance extends MediaAnnouncer {
+}
+class ControlsInstance extends Controls {
+}
+class ControlsGroupInstance extends ControlsGroup {
+}
+class ToggleButtonInstance extends ToggleButton {
+}
+class CaptionButtonInstance extends CaptionButton {
+}
+class FullscreenButtonInstance extends FullscreenButton {
+}
+class LiveButtonInstance extends LiveButton {
+}
+class MuteButtonInstance extends MuteButton {
+}
+class PIPButtonInstance extends PIPButton {
+}
+class PlayButtonInstance extends PlayButton {
+}
+class AirPlayButtonInstance extends AirPlayButton {
+}
+class GoogleCastButtonInstance extends GoogleCastButton {
+}
+class SeekButtonInstance extends SeekButton {
+}
+class TooltipInstance extends Tooltip {
+}
+class TooltipTriggerInstance extends TooltipTrigger {
+}
+class TooltipContentInstance extends TooltipContent {
+}
+class SliderInstance extends Slider {
+}
+class TimeSliderInstance extends TimeSlider {
+}
+class VolumeSliderInstance extends VolumeSlider {
+}
+class AudioGainSliderInstance extends AudioGainSlider {
+}
+class SpeedSliderInstance extends SpeedSlider {
+}
+class QualitySliderInstance extends QualitySlider {
+}
+class SliderThumbnailInstance extends SliderThumbnail {
+}
+class SliderValueInstance extends SliderValue {
+}
+class SliderVideoInstance extends SliderVideo {
+}
+class SliderPreviewInstance extends SliderPreview {
+}
+class SliderChaptersInstance extends SliderChapters {
+}
+class MenuInstance extends Menu {
+}
+class MenuButtonInstance extends MenuButton {
+}
+class MenuItemsInstance extends MenuItems {
+}
+class MenuItemInstance extends MenuItem {
+}
+class MenuPortalInstance extends MenuPortal {
+}
+class RadioGroupInstance extends RadioGroup {
+}
+class RadioInstance extends Radio {
+}
+class CaptionsInstance extends Captions {
+}
+class GestureInstance extends Gesture {
+}
+class PosterInstance extends Poster {
+}
+class ThumbnailInstance extends Thumbnail {
+}
+class TimeInstance extends Time {
+}
+
+const Slot = React.forwardRef((props, forwardedRef) => {
+  const { children, ...slotProps } = props;
+  const childrenArray = React.Children.toArray(children);
+  const slottable = childrenArray.find(isSlottable);
+  if (slottable) {
+    const newElement = slottable.props.children;
+    const newChildren = childrenArray.map((child) => {
+      if (child === slottable) {
+        if (React.Children.count(newElement) > 1) return React.Children.only(null);
+        return React.isValidElement(newElement) ? newElement.props.children : null;
+      } else {
+        return child;
+      }
+    });
+    return /* @__PURE__ */ React.createElement(SlotClone, { ...slotProps, ref: forwardedRef }, React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null);
+  }
+  return /* @__PURE__ */ React.createElement(SlotClone, { ...slotProps, ref: forwardedRef }, children);
+});
+Slot.displayName = "Slot";
+const SlotClone = React.forwardRef((props, forwardedRef) => {
+  const { children, ...slotProps } = props;
+  if (React.isValidElement(children)) {
+    return React.cloneElement(children, {
+      ...mergeProps(slotProps, children.props),
+      ref: forwardedRef ? composeRefs(forwardedRef, children.ref) : children.ref
+    });
+  }
+  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
+});
+SlotClone.displayName = "SlotClone";
+const Slottable = ({ children }) => {
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
+};
+function isSlottable(child) {
+  return React.isValidElement(child) && child.type === Slottable;
+}
+function mergeProps(slotProps, childProps) {
+  const overrideProps = { ...childProps };
+  for (const propName in childProps) {
+    const slotPropValue = slotProps[propName];
+    const childPropValue = childProps[propName];
+    const isHandler = /^on[A-Z]/.test(propName);
+    if (isHandler) {
+      if (slotPropValue && childPropValue) {
+        overrideProps[propName] = (...args) => {
+          childPropValue(...args);
+          slotPropValue(...args);
+        };
+      } else if (slotPropValue) {
+        overrideProps[propName] = slotPropValue;
+      }
+    } else if (propName === "style") {
+      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
+    } else if (propName === "className") {
+      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
+    }
+  }
+  return { ...slotProps, ...overrideProps };
+}
+
+const NODES = ["button", "div", "span", "img", "video", "audio"];
+const Primitive = NODES.reduce((primitives, node) => {
+  const Node = React.forwardRef((props, forwardedRef) => {
+    const { asChild, ...primitiveProps } = props;
+    const Comp = asChild ? Slot : node;
+    return /* @__PURE__ */ React.createElement(Comp, { ...primitiveProps, ref: forwardedRef });
+  });
+  Node.displayName = `Primitive.${node}`;
+  return { ...primitives, [node]: Node };
+}, {});
+
+function isRemotionProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "REMOTION";
+}
+function isRemotionSrc(src) {
+  return src?.type === "video/remotion";
+}
+
+const sliderStateRecord = SliderInstance.state.record, initialSliderStore = Object.keys(sliderStateRecord).reduce(
+  (store, prop) => ({
+    ...store,
+    [prop]() {
+      return sliderStateRecord[prop];
+    }
+  }),
+  {}
+);
+function useSliderState(prop, ref) {
+  const $state = useStateContext(sliderState);
+  return useSignal((ref?.current?.$state || $state || initialSliderStore)[prop]);
+}
+function useSliderStore(ref) {
+  const $state = useStateContext(sliderState);
+  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialSliderStore);
+}
+
+const mediaStateRecord = MediaPlayerInstance.state.record, initialMediaStore = Object.keys(mediaStateRecord).reduce(
+  (store, prop) => ({
+    ...store,
+    [prop]() {
+      return mediaStateRecord[prop];
+    }
+  }),
+  {}
+);
+function useMediaState(prop, ref) {
+  const $state = useStateContext(mediaState);
+  return useSignal((ref?.current?.$state || $state || initialMediaStore)[prop]);
+}
+function useMediaStore(ref) {
+  const $state = useStateContext(mediaState);
+  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialMediaStore);
+}
+
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLAirPlayAdapter, HTMLMediaProvider, IS_CHROME, IS_IOS, IS_SERVER, List, ListSymbol, LiveButtonInstance, LocalMediaStorage, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaPlayerInstance, MediaProviderInstance, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, Primitive, QualitySliderInstance, QualitySymbol, RAFLoop, RadioGroupController, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrack, TextTrackList, TextTrackSymbol, ThumbnailInstance, ThumbnailsLoader, TimeInstance, TimeRange, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProvider, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, appendParamsToURL, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, coerceToError, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHLSSupported, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isRemotionProvider, isRemotionSrc, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, loadScript, mediaContext, mediaState, menuContext, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, preconnect, sliderState, softResetMediaState, sortVideoQualities, updateSliderPreviewPlacement, updateTimeIntervals, useMediaContext, useMediaState, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange };
diff --git a/prod/chunks/vidstack-Xu8hy52p.js b/prod/chunks/vidstack-8hvVfGIw.js
similarity index 99%
rename from prod/chunks/vidstack-Xu8hy52p.js
rename to prod/chunks/vidstack-8hvVfGIw.js
index b4906ab7e53c6e1869a56e18198ffbf8a54abe56..2714b38b30411f5af2f0de715ee015a6a9ab19e5 100644
--- a/prod/chunks/vidstack-Xu8hy52p.js
+++ b/prod/chunks/vidstack-8hvVfGIw.js
@@ -1,7 +1,7 @@
 "use client"
 
 import { peek, listenEvent, effect, DOMEvent, isString, camelToKebabCase, isUndefined, isFunction } from './vidstack-CNjv_Zem.js';
-import { QualitySymbol, RAFLoop, TextTrack, TextTrackSymbol, ListSymbol, IS_CHROME, coerceToError, loadScript, VideoProvider, isHLSSupported, preconnect } from './vidstack-D6dKrFOZ.js';
+import { QualitySymbol, RAFLoop, TextTrack, TextTrackSymbol, ListSymbol, IS_CHROME, coerceToError, loadScript, VideoProvider, isHLSSupported, preconnect } from './vidstack-BY07IoHR.js';
 import 'react';
 import '@floating-ui/dom';
 
diff --git a/prod/chunks/vidstack-D2cUZes0.js b/prod/chunks/vidstack-B4GpH7JE.js
similarity index 98%
rename from prod/chunks/vidstack-D2cUZes0.js
rename to prod/chunks/vidstack-B4GpH7JE.js
index a61b0b2b02229216e22648eb38697f17f22a9c25..46033dabca4e46aa420fb8dab6c22d09a6044c5b 100644
--- a/prod/chunks/vidstack-D2cUZes0.js
+++ b/prod/chunks/vidstack-B4GpH7JE.js
@@ -1,8 +1,8 @@
 "use client"
 
 import { createScope, signal, effect, isString, deferredPromise, isObject, isNumber, isBoolean } from './vidstack-CNjv_Zem.js';
-import { preconnect, TimeRange } from './vidstack-D6dKrFOZ.js';
-import { EmbedProvider } from './vidstack-CbSFenOv.js';
+import { preconnect, TimeRange } from './vidstack-3ABKqYU9.js';
+import { EmbedProvider } from './vidstack-BVcvqNg8.js';
 import { resolveYouTubeVideoId } from './vidstack-Zc3I7oOd.js';
 import 'react';
 import '@floating-ui/dom';
diff --git a/prod/chunks/vidstack-BDYuUZKb.js b/prod/chunks/vidstack-BBy6wGkT.js
similarity index 99%
rename from prod/chunks/vidstack-BDYuUZKb.js
rename to prod/chunks/vidstack-BBy6wGkT.js
index 93b3601daf25ae624ef0751887ef96424e840115..7b064f8fc5ab76407b363a6a3286b379baf1e778 100644
--- a/prod/chunks/vidstack-BDYuUZKb.js
+++ b/prod/chunks/vidstack-BBy6wGkT.js
@@ -2,8 +2,8 @@
 
 import * as React from 'react';
 import { createReactComponent, composeRefs, listenEvent, useReactScope, scoped, signal, computed, effect, EventsController, useSignal } from './vidstack-CNjv_Zem.js';
-import { Primitive, MediaAnnouncerInstance, ControlsInstance, ControlsGroupInstance, TooltipInstance, TooltipTriggerInstance, TooltipContentInstance, GoogleCastButtonInstance, QualitySliderInstance, AudioGainSliderInstance, SpeedSliderInstance, useMediaState, watchActiveTextTrack, CaptionsInstance, formatTime, formatSpokenTime } from './vidstack-D6dKrFOZ.js';
-import { sliderCallbacks, Preview, Steps, Thumb, Track as Track$1, TrackFill as TrackFill$1, Value, useMediaContext } from './vidstack-DP0Brh65.js';
+import { Primitive, MediaAnnouncerInstance, ControlsInstance, ControlsGroupInstance, TooltipInstance, TooltipTriggerInstance, TooltipContentInstance, GoogleCastButtonInstance, QualitySliderInstance, AudioGainSliderInstance, SpeedSliderInstance, useMediaState, watchActiveTextTrack, CaptionsInstance, formatTime, formatSpokenTime } from './vidstack-CwFL6mmL.js';
+import { sliderCallbacks, Preview, Steps, Thumb, Track as Track$1, TrackFill as TrackFill$1, Value, useMediaContext } from './vidstack-BKi5uu_j.js';
 
 const MediaAnnouncerBridge = createReactComponent(MediaAnnouncerInstance, {
   events: ["onChange"]
diff --git a/prod/chunks/vidstack-DP0Brh65.js b/prod/chunks/vidstack-BKi5uu_j.js
similarity index 99%
rename from prod/chunks/vidstack-DP0Brh65.js
rename to prod/chunks/vidstack-BKi5uu_j.js
index a80c5650f96ce411f697dcb4c07747dd31b79a1c..c141d81930c8fb171556787610f3206138a3c603 100644
--- a/prod/chunks/vidstack-DP0Brh65.js
+++ b/prod/chunks/vidstack-BKi5uu_j.js
@@ -2,7 +2,7 @@
 
 import * as React from 'react';
 import { useReactContext, createReactComponent, composeRefs, useSignal, noop, useStateContext, signal, effect, isString } from './vidstack-CNjv_Zem.js';
-import { mediaContext, Primitive, AirPlayButtonInstance, PlayButtonInstance, CaptionButtonInstance, FullscreenButtonInstance, MuteButtonInstance, PIPButtonInstance, SeekButtonInstance, LiveButtonInstance, SliderValueInstance, useSliderState, SliderInstance, SliderPreviewInstance, VolumeSliderInstance, IS_SERVER, ThumbnailInstance, TimeSliderInstance, SliderChaptersInstance, SliderThumbnailInstance, SliderVideoInstance, mediaState, RadioGroupInstance, RadioInstance, useMediaState, MenuInstance, MenuButtonInstance, MenuItemsInstance, MenuItemInstance, GestureInstance, TimeInstance, isTrackCaptionKind } from './vidstack-D6dKrFOZ.js';
+import { mediaContext, Primitive, AirPlayButtonInstance, PlayButtonInstance, CaptionButtonInstance, FullscreenButtonInstance, MuteButtonInstance, PIPButtonInstance, SeekButtonInstance, LiveButtonInstance, SliderValueInstance, useSliderState, SliderInstance, SliderPreviewInstance, VolumeSliderInstance, IS_SERVER, ThumbnailInstance, TimeSliderInstance, SliderChaptersInstance, SliderThumbnailInstance, SliderVideoInstance, mediaState, RadioGroupInstance, RadioInstance, useMediaState, MenuInstance, MenuButtonInstance, MenuItemsInstance, MenuItemInstance, GestureInstance, TimeInstance, isTrackCaptionKind } from './vidstack-CwFL6mmL.js';
 import { createPortal } from 'react-dom';
 
 function useMediaContext() {
diff --git a/prod/chunks/vidstack-B-YW57m0.js b/prod/chunks/vidstack-BQRr1gez.js
similarity index 98%
rename from prod/chunks/vidstack-B-YW57m0.js
rename to prod/chunks/vidstack-BQRr1gez.js
index 4adcb87296ce2c6d01246831bd93412cb6a6621b..a9e5492319f296ac6422b67fdd6ed38ac4f71613 100644
--- a/prod/chunks/vidstack-B-YW57m0.js
+++ b/prod/chunks/vidstack-BQRr1gez.js
@@ -1,6 +1,6 @@
 "use client"
 
-import { IS_CHROME, IS_IOS, canGoogleCastSrc, IS_SERVER, loadScript } from './vidstack-D6dKrFOZ.js';
+import { IS_CHROME, IS_IOS, canGoogleCastSrc, IS_SERVER, loadScript } from './vidstack-BY07IoHR.js';
 import { listenEvent, peek } from './vidstack-CNjv_Zem.js';
 
 function getCastFrameworkURL() {
@@ -109,7 +109,7 @@ class GoogleCastLoader {
     if (!this.#player) {
       throw Error("[vidstack] google cast player was not initialized");
     }
-    return new (await import('./vidstack-BFbyAy5g.js')).GoogleCastProvider(this.#player, ctx);
+    return new (await import('./vidstack-GSrM5t5G.js')).GoogleCastProvider(this.#player, ctx);
   }
   async #loadCastFramework(ctx) {
     if (hasLoadedCastFramework()) return;
diff --git a/prod/chunks/vidstack-CbSFenOv.js b/prod/chunks/vidstack-BVcvqNg8.js
similarity index 96%
rename from prod/chunks/vidstack-CbSFenOv.js
rename to prod/chunks/vidstack-BVcvqNg8.js
index 1b8be3329cfce373084b5e1a4322a12255ae139a..4928b90a27a4044d3cc6da673ad7612ebdb24d07 100644
--- a/prod/chunks/vidstack-CbSFenOv.js
+++ b/prod/chunks/vidstack-BVcvqNg8.js
@@ -1,6 +1,6 @@
 "use client"
 
-import { appendParamsToURL, IS_SERVER } from './vidstack-D6dKrFOZ.js';
+import { appendParamsToURL, IS_SERVER } from './vidstack-3ABKqYU9.js';
 import { signal, listenEvent, effect, peek, isString } from './vidstack-CNjv_Zem.js';
 
 class EmbedProvider {
diff --git a/prod/chunks/vidstack-BY07IoHR.js b/prod/chunks/vidstack-BY07IoHR.js
new file mode 100644
index 0000000000000000000000000000000000000000..76293096ef14eccc29ee4367c16ed182d585021c
--- /dev/null
+++ b/prod/chunks/vidstack-BY07IoHR.js
@@ -0,0 +1,11183 @@
+"use client"
+
+import * as React from 'react';
+import { isString, isNumber, isFunction, isUndefined, waitTimeout, isArray, isBoolean, isNull, deferredPromise, listenEvent, scoped, getScope, EventsTarget, DOMEvent, State, fscreen, tick, createContext, useContext, Component, functionThrottle, setAttribute, effect, isTouchEvent, isDOMNode, EventsController, isKeyboardClick, setStyle, onDispose, untrack, functionDebounce, ViewController, signal, peek, isKeyboardEvent, isNil, createScope, camelToKebabCase, waitIdlePeriod, prop, method, provideContext, animationFrameThrottle, uppercaseFirstChar, computed, noop, ariaBool as ariaBool$1, isWriteSignal, hasProvidedContext, isObject, useState, r, wasEnterKeyPressed, isPointerEvent, isMouseEvent, kebabToCamelCase, composeRefs, useStateContext, useSignal, useSignalRecord } from './vidstack-CNjv_Zem.js';
+import { autoUpdate, computePosition, flip, shift } from '@floating-ui/dom';
+
+function isVideoQualitySrc(src) {
+  return !isString(src) && "width" in src && "height" in src && isNumber(src.width) && isNumber(src.height);
+}
+
+const IS_SERVER = typeof document === "undefined";
+
+const UA = IS_SERVER ? "" : navigator?.userAgent.toLowerCase() || "";
+const IS_IOS = !IS_SERVER && /iphone|ipad|ipod|ios|crios|fxios/i.test(UA);
+const IS_IPHONE = !IS_SERVER && /(iphone|ipod)/gi.test(navigator?.platform || "");
+const IS_CHROME = !IS_SERVER && !!window.chrome;
+const IS_SAFARI = !IS_SERVER && (!!window.safari || IS_IOS);
+function canOrientScreen() {
+  return canRotateScreen() && isFunction(screen.orientation.unlock);
+}
+function canRotateScreen() {
+  return !IS_SERVER && !isUndefined(window.screen.orientation) && !isUndefined(window.screen.orientation.lock);
+}
+function canPlayAudioType(audio, type) {
+  if (IS_SERVER) return false;
+  if (!audio) audio = document.createElement("audio");
+  return audio.canPlayType(type).length > 0;
+}
+function canPlayVideoType(video, type) {
+  if (IS_SERVER) return false;
+  if (!video) video = document.createElement("video");
+  return video.canPlayType(type).length > 0;
+}
+function canPlayHLSNatively(video) {
+  if (IS_SERVER) return false;
+  if (!video) video = document.createElement("video");
+  return video.canPlayType("application/vnd.apple.mpegurl").length > 0;
+}
+function canUsePictureInPicture(video) {
+  if (IS_SERVER) return false;
+  return !!document.pictureInPictureEnabled && !video?.disablePictureInPicture;
+}
+function canUseVideoPresentation(video) {
+  if (IS_SERVER) return false;
+  return isFunction(video?.webkitSupportsPresentationMode) && isFunction(video?.webkitSetPresentationMode);
+}
+async function canChangeVolume() {
+  const video = document.createElement("video");
+  video.volume = 0.5;
+  await waitTimeout(0);
+  return video.volume === 0.5;
+}
+function getMediaSource() {
+  return IS_SERVER ? void 0 : window?.ManagedMediaSource ?? window?.MediaSource ?? window?.WebKitMediaSource;
+}
+function getSourceBuffer() {
+  return IS_SERVER ? void 0 : window?.SourceBuffer ?? window?.WebKitSourceBuffer;
+}
+function isHLSSupported() {
+  if (IS_SERVER) return false;
+  const MediaSource = getMediaSource();
+  if (isUndefined(MediaSource)) return false;
+  const isTypeSupported = MediaSource && isFunction(MediaSource.isTypeSupported) && MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
+  const SourceBuffer = getSourceBuffer();
+  const isSourceBufferValid = isUndefined(SourceBuffer) || !isUndefined(SourceBuffer.prototype) && isFunction(SourceBuffer.prototype.appendBuffer) && isFunction(SourceBuffer.prototype.remove);
+  return !!isTypeSupported && !!isSourceBufferValid;
+}
+function isDASHSupported() {
+  return isHLSSupported();
+}
+
+class TimeRange {
+  #ranges;
+  get length() {
+    return this.#ranges.length;
+  }
+  constructor(start, end) {
+    if (isArray(start)) {
+      this.#ranges = start;
+    } else if (!isUndefined(start) && !isUndefined(end)) {
+      this.#ranges = [[start, end]];
+    } else {
+      this.#ranges = [];
+    }
+  }
+  start(index) {
+    return this.#ranges[index][0] ?? Infinity;
+  }
+  end(index) {
+    return this.#ranges[index][1] ?? Infinity;
+  }
+}
+function getTimeRangesStart(range) {
+  if (!range.length) return null;
+  let min = range.start(0);
+  for (let i = 1; i < range.length; i++) {
+    const value = range.start(i);
+    if (value < min) min = value;
+  }
+  return min;
+}
+function getTimeRangesEnd(range) {
+  if (!range.length) return null;
+  let max = range.end(0);
+  for (let i = 1; i < range.length; i++) {
+    const value = range.end(i);
+    if (value > max) max = value;
+  }
+  return max;
+}
+function normalizeTimeIntervals(intervals) {
+  if (intervals.length <= 1) {
+    return intervals;
+  }
+  intervals.sort((a, b) => a[0] - b[0]);
+  let normalized = [], current = intervals[0];
+  for (let i = 1; i < intervals.length; i++) {
+    const next = intervals[i];
+    if (current[1] >= next[0] - 1) {
+      current = [current[0], Math.max(current[1], next[1])];
+    } else {
+      normalized.push(current);
+      current = next;
+    }
+  }
+  normalized.push(current);
+  return normalized;
+}
+function updateTimeIntervals(intervals, interval, value) {
+  let start = interval[0], end = interval[1];
+  if (value < start) {
+    return [value, -1];
+  } else if (value === start) {
+    return interval;
+  } else if (start === -1) {
+    interval[0] = value;
+    return interval;
+  } else if (value > start) {
+    interval[1] = value;
+    if (end === -1) intervals.push(interval);
+  }
+  normalizeTimeIntervals(intervals);
+  return interval;
+}
+
+const AUDIO_EXTENSIONS = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx|flac)($|\?)/i;
+const AUDIO_TYPES = /* @__PURE__ */ new Set([
+  "audio/mpeg",
+  "audio/ogg",
+  "audio/3gp",
+  "audio/mp3",
+  "audio/webm",
+  "audio/flac",
+  "audio/m4a",
+  "audio/m4b",
+  "audio/mp4a",
+  "audio/mp4"
+]);
+const VIDEO_EXTENSIONS = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i;
+const VIDEO_TYPES = /* @__PURE__ */ new Set([
+  "video/mp4",
+  "video/webm",
+  "video/3gp",
+  "video/ogg",
+  "video/avi",
+  "video/mpeg"
+]);
+const HLS_VIDEO_EXTENSIONS = /\.(m3u8)($|\?)/i;
+const DASH_VIDEO_EXTENSIONS = /\.(mpd)($|\?)/i;
+const HLS_VIDEO_TYPES = /* @__PURE__ */ new Set([
+  // Apple sanctioned
+  "application/vnd.apple.mpegurl",
+  // Apple sanctioned for backwards compatibility
+  "audio/mpegurl",
+  // Very common
+  "audio/x-mpegurl",
+  // Very common
+  "application/x-mpegurl",
+  // Included for completeness
+  "video/x-mpegurl",
+  "video/mpegurl",
+  "application/mpegurl"
+]);
+const DASH_VIDEO_TYPES = /* @__PURE__ */ new Set(["application/dash+xml"]);
+function isAudioSrc({ src, type }) {
+  return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
+}
+function isVideoSrc(src) {
+  return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && (IS_SERVER || canPlayHLSNatively()) : src.type === "video/object";
+}
+function isHLSSrc({ src, type }) {
+  return isString(src) && HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type);
+}
+function isDASHSrc({ src, type }) {
+  return isString(src) && DASH_VIDEO_EXTENSIONS.test(src) || DASH_VIDEO_TYPES.has(type);
+}
+function canGoogleCastSrc(src) {
+  return isString(src.src) && (isAudioSrc(src) || isVideoSrc(src) || isHLSSrc(src));
+}
+function isMediaStream(src) {
+  return !IS_SERVER && typeof window.MediaStream !== "undefined" && src instanceof window.MediaStream;
+}
+
+function appendParamsToURL(baseUrl, params) {
+  const url = new URL(baseUrl);
+  for (const key of Object.keys(params)) {
+    url.searchParams.set(key, params[key] + "");
+  }
+  return url.toString();
+}
+function preconnect(url, rel = "preconnect") {
+  if (IS_SERVER) return false;
+  const exists = document.querySelector(`link[href="${url}"]`);
+  if (!isNull(exists)) return true;
+  const link = document.createElement("link");
+  link.rel = rel;
+  link.href = url;
+  link.crossOrigin = "true";
+  document.head.append(link);
+  return true;
+}
+const pendingRequests = {};
+function loadScript(src) {
+  if (pendingRequests[src]) return pendingRequests[src].promise;
+  const promise = deferredPromise(), exists = document.querySelector(`script[src="${src}"]`);
+  if (!isNull(exists)) {
+    promise.resolve();
+    return promise.promise;
+  }
+  pendingRequests[src] = promise;
+  const script = document.createElement("script");
+  script.src = src;
+  script.onload = () => {
+    promise.resolve();
+    delete pendingRequests[src];
+  };
+  script.onerror = () => {
+    promise.reject();
+    delete pendingRequests[src];
+  };
+  setTimeout(() => document.head.append(script), 0);
+  return promise.promise;
+}
+function getRequestCredentials(crossOrigin) {
+  return crossOrigin === "use-credentials" ? "include" : isString(crossOrigin) ? "same-origin" : void 0;
+}
+function getDownloadFile({
+  title,
+  src,
+  download
+}) {
+  const url = isBoolean(download) || download === "" ? src.src : isString(download) ? download : download?.url;
+  if (!isValidFileDownload({ url, src, download })) return null;
+  return {
+    url,
+    name: !isBoolean(download) && !isString(download) && download?.filename || title.toLowerCase() || "media"
+  };
+}
+function isValidFileDownload({
+  url,
+  src,
+  download
+}) {
+  return isString(url) && (download && download !== true || isAudioSrc(src) || isVideoSrc(src));
+}
+
+const CROSS_ORIGIN = Symbol(0), READY_STATE = Symbol(0), UPDATE_ACTIVE_CUES = Symbol(0), CAN_LOAD = Symbol(0), ON_MODE_CHANGE = Symbol(0), NATIVE = Symbol(0), NATIVE_HLS = Symbol(0);
+const TextTrackSymbol = {
+  crossOrigin: CROSS_ORIGIN,
+  readyState: READY_STATE,
+  updateActiveCues: UPDATE_ACTIVE_CUES,
+  canLoad: CAN_LOAD,
+  onModeChange: ON_MODE_CHANGE,
+  native: NATIVE,
+  nativeHLS: NATIVE_HLS
+};
+
+function findActiveCue(cues, time) {
+  for (let i = 0, len = cues.length; i < len; i++) {
+    if (isCueActive(cues[i], time)) return cues[i];
+  }
+  return null;
+}
+function isCueActive(cue, time) {
+  return time >= cue.startTime && time < cue.endTime;
+}
+function watchActiveTextTrack(tracks, kind, onChange) {
+  let currentTrack = null, scope = getScope();
+  function onModeChange() {
+    const kinds = isString(kind) ? [kind] : kind, track = tracks.toArray().find((track2) => kinds.includes(track2.kind) && track2.mode === "showing");
+    if (track === currentTrack) return;
+    if (!track) {
+      onChange(null);
+      currentTrack = null;
+      return;
+    }
+    if (track.readyState == 2) {
+      onChange(track);
+    } else {
+      onChange(null);
+      scoped(() => {
+        const off = listenEvent(
+          track,
+          "load",
+          () => {
+            onChange(track);
+            off();
+          },
+          { once: true }
+        );
+      }, scope);
+    }
+    currentTrack = track;
+  }
+  onModeChange();
+  return listenEvent(tracks, "mode-change", onModeChange);
+}
+function watchCueTextChange(tracks, kind, callback) {
+  watchActiveTextTrack(tracks, kind, (track) => {
+    if (!track) {
+      callback("");
+      return;
+    }
+    const onCueChange = () => {
+      const activeCue = track?.activeCues[0];
+      callback(activeCue?.text || "");
+    };
+    onCueChange();
+    listenEvent(track, "cue-change", onCueChange);
+  });
+}
+
+class TextTrack extends EventsTarget {
+  static createId(track) {
+    return `vds-${track.type}-${track.kind}-${track.src ?? track.label ?? "?"}`;
+  }
+  src;
+  content;
+  type;
+  encoding;
+  id = "";
+  label = "";
+  language = "";
+  kind;
+  default = false;
+  #canLoad = false;
+  #currentTime = 0;
+  #mode = "disabled";
+  #metadata = {};
+  #regions = [];
+  #cues = [];
+  #activeCues = [];
+  /** @internal */
+  [TextTrackSymbol.readyState] = 0;
+  /** @internal */
+  [TextTrackSymbol.crossOrigin];
+  /** @internal */
+  [TextTrackSymbol.onModeChange] = null;
+  /** @internal */
+  [TextTrackSymbol.native] = null;
+  get metadata() {
+    return this.#metadata;
+  }
+  get regions() {
+    return this.#regions;
+  }
+  get cues() {
+    return this.#cues;
+  }
+  get activeCues() {
+    return this.#activeCues;
+  }
+  /**
+   * - 0: Not Loading
+   * - 1: Loading
+   * - 2: Ready
+   * - 3: Error
+   */
+  get readyState() {
+    return this[TextTrackSymbol.readyState];
+  }
+  get mode() {
+    return this.#mode;
+  }
+  set mode(mode) {
+    this.setMode(mode);
+  }
+  constructor(init) {
+    super();
+    for (const prop of Object.keys(init)) this[prop] = init[prop];
+    if (!this.type) this.type = "vtt";
+    if (!IS_SERVER && init.content) {
+      this.#parseContent(init);
+    } else if (!init.src) {
+      this[TextTrackSymbol.readyState] = 2;
+    }
+  }
+  addCue(cue, trigger) {
+    let i = 0, length = this.#cues.length;
+    for (i = 0; i < length; i++) if (cue.endTime <= this.#cues[i].startTime) break;
+    if (i === length) this.#cues.push(cue);
+    else this.#cues.splice(i, 0, cue);
+    if (!(cue instanceof TextTrackCue)) {
+      this[TextTrackSymbol.native]?.track.addCue(cue);
+    }
+    this.dispatchEvent(new DOMEvent("add-cue", { detail: cue, trigger }));
+    if (isCueActive(cue, this.#currentTime)) {
+      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+    }
+  }
+  removeCue(cue, trigger) {
+    const index = this.#cues.indexOf(cue);
+    if (index >= 0) {
+      const isActive = this.#activeCues.includes(cue);
+      this.#cues.splice(index, 1);
+      this[TextTrackSymbol.native]?.track.removeCue(cue);
+      this.dispatchEvent(new DOMEvent("remove-cue", { detail: cue, trigger }));
+      if (isActive) {
+        this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+      }
+    }
+  }
+  setMode(mode, trigger) {
+    if (this.#mode === mode) return;
+    this.#mode = mode;
+    if (mode === "disabled") {
+      this.#activeCues = [];
+      this.#activeCuesChanged();
+    } else if (this.readyState === 2) {
+      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
+    } else {
+      this.#load();
+    }
+    this.dispatchEvent(new DOMEvent("mode-change", { detail: this, trigger }));
+    this[TextTrackSymbol.onModeChange]?.();
+  }
+  /** @internal */
+  [TextTrackSymbol.updateActiveCues](currentTime, trigger) {
+    this.#currentTime = currentTime;
+    if (this.mode === "disabled" || !this.#cues.length) return;
+    const activeCues = [];
+    for (let i = 0, length = this.#cues.length; i < length; i++) {
+      const cue = this.#cues[i];
+      if (isCueActive(cue, currentTime)) activeCues.push(cue);
+    }
+    let changed = activeCues.length !== this.#activeCues.length;
+    if (!changed) {
+      for (let i = 0; i < activeCues.length; i++) {
+        if (!this.#activeCues.includes(activeCues[i])) {
+          changed = true;
+          break;
+        }
+      }
+    }
+    this.#activeCues = activeCues;
+    if (changed) this.#activeCuesChanged(trigger);
+  }
+  /** @internal */
+  [TextTrackSymbol.canLoad]() {
+    this.#canLoad = true;
+    if (this.#mode !== "disabled") this.#load();
+  }
+  #parseContent(init) {
+    import('media-captions').then(({ parseText, VTTCue, VTTRegion }) => {
+      if (!isString(init.content) || init.type === "json") {
+        this.#parseJSON(init.content, VTTCue, VTTRegion);
+        if (this.readyState !== 3) this.#ready();
+      } else {
+        parseText(init.content, { type: init.type }).then(({ cues, regions }) => {
+          this.#cues = cues;
+          this.#regions = regions;
+          this.#ready();
+        });
+      }
+    });
+  }
+  async #load() {
+    if (!this.#canLoad || this[TextTrackSymbol.readyState] > 0) return;
+    this[TextTrackSymbol.readyState] = 1;
+    this.dispatchEvent(new DOMEvent("load-start"));
+    if (!this.src) {
+      this.#ready();
+      return;
+    }
+    try {
+      const { parseResponse, VTTCue, VTTRegion } = await import('media-captions'), crossOrigin = this[TextTrackSymbol.crossOrigin]?.();
+      const response = fetch(this.src, {
+        headers: this.type === "json" ? { "Content-Type": "application/json" } : void 0,
+        credentials: getRequestCredentials(crossOrigin)
+      });
+      if (this.type === "json") {
+        this.#parseJSON(await (await response).text(), VTTCue, VTTRegion);
+      } else if (this.type === "lrc") {
+        const buffer = await response.then((r) => r.arrayBuffer());
+        let content = new TextDecoder("utf-8").decode(buffer);
+        if (/�/.test(content))
+          content = new TextDecoder("gbk").decode(buffer);
+        this.#parseLRC(content, VTTCue);
+      } else {
+        const { errors, metadata, regions, cues } = await parseResponse(response, {
+          type: this.type,
+          encoding: this.encoding
+        });
+        if (errors[0]?.code === 0) {
+          throw errors[0];
+        } else {
+          this.#metadata = metadata;
+          this.#regions = regions;
+          this.#cues = cues;
+        }
+      }
+      this.#ready();
+    } catch (error) {
+      this.#error(error);
+    }
+  }
+  #ready() {
+    this[TextTrackSymbol.readyState] = 2;
+    if (!this.src || this.type !== "vtt") {
+      const native = this[TextTrackSymbol.native];
+      if (native && !native.managed) {
+        for (const cue of this.#cues) native.track.addCue(cue);
+      }
+    }
+    const loadEvent = new DOMEvent("load");
+    this[TextTrackSymbol.updateActiveCues](this.#currentTime, loadEvent);
+    this.dispatchEvent(loadEvent);
+  }
+  #error(error) {
+    this[TextTrackSymbol.readyState] = 3;
+    this.dispatchEvent(new DOMEvent("error", { detail: error }));
+  }
+  #parseLRC(content, VTTCue) {
+    try {
+      const { cues } = parseLRCCaptionsFile(content, VTTCue);
+      this.#cues = cues;
+    } catch (error) {
+      this.#error(error);
+    }
+  }
+  #parseJSON(json, VTTCue, VTTRegion) {
+    try {
+      const { regions, cues } = parseJSONCaptionsFile(json, VTTCue, VTTRegion);
+      this.#regions = regions;
+      this.#cues = cues;
+    } catch (error) {
+      this.#error(error);
+    }
+  }
+  #activeCuesChanged(trigger) {
+    this.dispatchEvent(new DOMEvent("cue-change", { trigger }));
+  }
+}
+const captionRE = /captions|subtitles/;
+function isTrackCaptionKind(track) {
+  return captionRE.test(track.kind);
+}
+function parseLRCCaptionsFile(content, Cue) {
+  const lines = content.trim().split("\n");
+  const cues = [];
+  const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
+  const computedTime = (times) => +(parseInt(times[0]) * 60) + parseInt(times[1]) + parseInt(times[2].padEnd(3, "0")) / 1e3;
+  for (let i = 0; i < lines.length; i++) {
+    const line = lines[i];
+    const match = timeRegex.exec(line);
+    if (match) {
+      const [fullMatch, minutes, seconds, milliseconds] = match;
+      const text = line.slice(fullMatch.length).trim();
+      const startTime = computedTime([minutes, seconds, milliseconds]);
+      let endTime = startTime + 5;
+      for (let j = i + 1; j < lines.length; j++) {
+        const nextMatch = timeRegex.exec(lines[j]);
+        if (nextMatch) {
+          endTime = computedTime([nextMatch[1], nextMatch[2], nextMatch[3]]);
+          break;
+        }
+      }
+      const cue = new Cue(startTime, endTime, text);
+      cues.push(cue);
+    }
+  }
+  return { cues };
+}
+function parseJSONCaptionsFile(json, Cue, Region) {
+  const content = isString(json) ? JSON.parse(json) : json;
+  let regions = [], cues = [];
+  if (content.regions && Region) {
+    regions = content.regions.map((region) => Object.assign(new Region(), region));
+  }
+  if (content.cues || isArray(content)) {
+    cues = (isArray(content) ? content : content.cues).filter((content2) => isNumber(content2.startTime) && isNumber(content2.endTime)).map((cue) => Object.assign(new Cue(0, 0, ""), cue));
+  }
+  return { regions, cues };
+}
+
+const mediaState = new State({
+  artist: "",
+  artwork: null,
+  audioTrack: null,
+  audioTracks: [],
+  autoPlay: false,
+  autoPlayError: null,
+  audioGain: null,
+  buffered: new TimeRange(),
+  canLoad: false,
+  canLoadPoster: false,
+  canFullscreen: false,
+  canOrientScreen: canOrientScreen(),
+  canPictureInPicture: false,
+  canPlay: false,
+  clipStartTime: 0,
+  clipEndTime: 0,
+  controls: false,
+  get iOSControls() {
+    return IS_IPHONE && this.mediaType === "video" && (!this.playsInline || !fscreen.fullscreenEnabled && this.fullscreen);
+  },
+  get nativeControls() {
+    return this.controls || this.iOSControls;
+  },
+  controlsVisible: false,
+  get controlsHidden() {
+    return !this.controlsVisible;
+  },
+  crossOrigin: null,
+  ended: false,
+  error: null,
+  fullscreen: false,
+  get loop() {
+    return this.providedLoop || this.userPrefersLoop;
+  },
+  logLevel: "silent",
+  mediaType: "unknown",
+  muted: false,
+  paused: true,
+  played: new TimeRange(),
+  playing: false,
+  playsInline: false,
+  pictureInPicture: false,
+  preload: "metadata",
+  playbackRate: 1,
+  qualities: [],
+  quality: null,
+  autoQuality: false,
+  canSetQuality: true,
+  canSetPlaybackRate: true,
+  canSetVolume: false,
+  canSetAudioGain: false,
+  seekable: new TimeRange(),
+  seeking: false,
+  source: { src: "", type: "" },
+  sources: [],
+  started: false,
+  textTracks: [],
+  textTrack: null,
+  get hasCaptions() {
+    return this.textTracks.filter(isTrackCaptionKind).length > 0;
+  },
+  volume: 1,
+  waiting: false,
+  realCurrentTime: 0,
+  get currentTime() {
+    return this.ended ? this.duration : this.clipStartTime > 0 ? Math.max(0, Math.min(this.realCurrentTime - this.clipStartTime, this.duration)) : this.realCurrentTime;
+  },
+  providedDuration: -1,
+  intrinsicDuration: 0,
+  get duration() {
+    return this.seekableWindow;
+  },
+  get title() {
+    return this.providedTitle || this.inferredTitle;
+  },
+  get poster() {
+    return this.providedPoster || this.inferredPoster;
+  },
+  get viewType() {
+    return this.providedViewType !== "unknown" ? this.providedViewType : this.inferredViewType;
+  },
+  get streamType() {
+    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
+  },
+  get currentSrc() {
+    return this.source;
+  },
+  get bufferedStart() {
+    const start = getTimeRangesStart(this.buffered) ?? 0;
+    return Math.max(start, this.clipStartTime);
+  },
+  get bufferedEnd() {
+    const end = getTimeRangesEnd(this.buffered) ?? 0;
+    return Math.min(this.seekableEnd, Math.max(0, end - this.clipStartTime));
+  },
+  get bufferedWindow() {
+    return Math.max(0, this.bufferedEnd - this.bufferedStart);
+  },
+  get seekableStart() {
+    if (this.isLiveDVR && this.liveDVRWindow > 0) {
+      return Math.max(0, this.seekableEnd - this.liveDVRWindow);
+    }
+    const start = getTimeRangesStart(this.seekable) ?? 0;
+    return Math.max(start, this.clipStartTime);
+  },
+  get seekableEnd() {
+    if (this.providedDuration > 0) return this.providedDuration;
+    const end = this.liveSyncPosition > 0 ? this.liveSyncPosition : this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
+    return this.clipEndTime > 0 ? Math.min(this.clipEndTime, end) : end;
+  },
+  get seekableWindow() {
+    const window = this.seekableEnd - this.seekableStart;
+    return !isNaN(window) ? Math.max(0, window) : Infinity;
+  },
+  // ~~ remote playback ~~
+  canAirPlay: false,
+  canGoogleCast: false,
+  remotePlaybackState: "disconnected",
+  remotePlaybackType: "none",
+  remotePlaybackLoader: null,
+  remotePlaybackInfo: null,
+  get isAirPlayConnected() {
+    return this.remotePlaybackType === "airplay" && this.remotePlaybackState === "connected";
+  },
+  get isGoogleCastConnected() {
+    return this.remotePlaybackType === "google-cast" && this.remotePlaybackState === "connected";
+  },
+  // ~~ responsive design ~~
+  pointer: "fine",
+  orientation: "landscape",
+  width: 0,
+  height: 0,
+  mediaWidth: 0,
+  mediaHeight: 0,
+  lastKeyboardAction: null,
+  // ~~ user props ~~
+  userBehindLiveEdge: false,
+  // ~~ live props ~~
+  liveEdgeTolerance: 10,
+  minLiveDVRWindow: 60,
+  get canSeek() {
+    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.duration) && (!this.isLiveDVR || this.duration >= this.liveDVRWindow);
+  },
+  get live() {
+    return this.streamType.includes("live") || !Number.isFinite(this.duration);
+  },
+  get liveEdgeStart() {
+    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, this.seekableEnd - this.liveEdgeTolerance) : 0;
+  },
+  get liveEdge() {
+    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
+  },
+  get liveEdgeWindow() {
+    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
+  },
+  get isLiveDVR() {
+    return /:dvr/.test(this.streamType);
+  },
+  get liveDVRWindow() {
+    return Math.max(this.inferredLiveDVRWindow, this.minLiveDVRWindow);
+  },
+  // ~~ internal props ~~
+  autoPlaying: false,
+  providedTitle: "",
+  inferredTitle: "",
+  providedLoop: false,
+  userPrefersLoop: false,
+  providedPoster: "",
+  inferredPoster: "",
+  inferredViewType: "unknown",
+  providedViewType: "unknown",
+  providedStreamType: "unknown",
+  inferredStreamType: "unknown",
+  liveSyncPosition: null,
+  inferredLiveDVRWindow: 0,
+  savedState: null
+});
+const RESET_ON_SRC_QUALITY_CHANGE = /* @__PURE__ */ new Set([
+  "autoPlayError",
+  "autoPlaying",
+  "buffered",
+  "canPlay",
+  "error",
+  "paused",
+  "played",
+  "playing",
+  "seekable",
+  "seeking",
+  "waiting"
+]);
+const RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
+  ...RESET_ON_SRC_QUALITY_CHANGE,
+  "ended",
+  "inferredPoster",
+  "inferredStreamType",
+  "inferredTitle",
+  "intrinsicDuration",
+  "inferredLiveDVRWindow",
+  "liveSyncPosition",
+  "realCurrentTime",
+  "savedState",
+  "started",
+  "userBehindLiveEdge"
+]);
+function softResetMediaState($media, isSourceQualityChange = false) {
+  const filter = isSourceQualityChange ? RESET_ON_SRC_QUALITY_CHANGE : RESET_ON_SRC_CHANGE;
+  mediaState.reset($media, (prop) => filter.has(prop));
+  tick();
+}
+function boundTime(time, store) {
+  const clippedTime = time + store.clipStartTime(), isStart = Math.floor(time) === Math.floor(store.seekableStart()), isEnd = Math.floor(clippedTime) === Math.floor(store.seekableEnd());
+  if (isStart) {
+    return store.seekableStart();
+  }
+  if (isEnd) {
+    return store.seekableEnd();
+  }
+  if (store.isLiveDVR() && store.liveDVRWindow() > 0 && clippedTime < store.seekableEnd() - store.liveDVRWindow()) {
+    return store.bufferedStart();
+  }
+  return Math.min(Math.max(store.seekableStart() + 0.1, clippedTime), store.seekableEnd() - 0.1);
+}
+
+const mediaContext = createContext();
+function useMediaContext() {
+  return useContext(mediaContext);
+}
+
+class MediaRemoteControl {
+  #target = null;
+  #player = null;
+  #prevTrackIndex = -1;
+  #logger;
+  constructor(logger = void 0) {
+    this.#logger = logger;
+  }
+  /**
+   * Set the target from which to dispatch media requests events from. The events should bubble
+   * up from this target to the player element.
+   *
+   * @example
+   * ```ts
+   * const button = document.querySelector('button');
+   * remote.setTarget(button);
+   * ```
+   */
+  setTarget(target) {
+    this.#target = target;
+  }
+  /**
+   * Returns the current player element. This method will attempt to find the player by
+   * searching up from either the given `target` or default target set via `remote.setTarget`.
+   *
+   * @example
+   * ```ts
+   * const player = remote.getPlayer();
+   * ```
+   */
+  getPlayer(target) {
+    if (this.#player) return this.#player;
+    (target ?? this.#target)?.dispatchEvent(
+      new DOMEvent("find-media-player", {
+        detail: (player) => void (this.#player = player),
+        bubbles: true,
+        composed: true
+      })
+    );
+    return this.#player;
+  }
+  /**
+   * Set the current player element so the remote can support toggle methods such as
+   * `togglePaused` as they rely on the current media state.
+   */
+  setPlayer(player) {
+    this.#player = player;
+  }
+  /**
+   * Dispatch a request to start the media loading process. This will only work if the media
+   * player has been initialized with a custom loading strategy `load="custom">`.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoading(trigger) {
+    this.#dispatchRequest("media-start-loading", trigger);
+  }
+  /**
+   * Dispatch a request to start the poster loading process. This will only work if the media
+   * player has been initialized with a custom poster loading strategy `posterLoad="custom">`.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoadingPoster(trigger) {
+    this.#dispatchRequest("media-poster-start-loading", trigger);
+  }
+  /**
+   * Dispatch a request to connect to AirPlay.
+   *
+   * @see {@link https://www.apple.com/au/airplay}
+   */
+  requestAirPlay(trigger) {
+    this.#dispatchRequest("media-airplay-request", trigger);
+  }
+  /**
+   * Dispatch a request to connect to Google Cast.
+   *
+   * @see {@link https://developers.google.com/cast/docs/overview}
+   */
+  requestGoogleCast(trigger) {
+    this.#dispatchRequest("media-google-cast-request", trigger);
+  }
+  /**
+   * Dispatch a request to begin/resume media playback.
+   */
+  play(trigger) {
+    this.#dispatchRequest("media-play-request", trigger);
+  }
+  /**
+   * Dispatch a request to pause media playback.
+   */
+  pause(trigger) {
+    this.#dispatchRequest("media-pause-request", trigger);
+  }
+  /**
+   * Dispatch a request to set the media volume to mute (0).
+   */
+  mute(trigger) {
+    this.#dispatchRequest("media-mute-request", trigger);
+  }
+  /**
+   * Dispatch a request to unmute the media volume and set it back to it's previous state.
+   */
+  unmute(trigger) {
+    this.#dispatchRequest("media-unmute-request", trigger);
+  }
+  /**
+   * Dispatch a request to enter fullscreen.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  enterFullscreen(target, trigger) {
+    this.#dispatchRequest("media-enter-fullscreen-request", trigger, target);
+  }
+  /**
+   * Dispatch a request to exit fullscreen.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  exitFullscreen(target, trigger) {
+    this.#dispatchRequest("media-exit-fullscreen-request", trigger, target);
+  }
+  /**
+   * Dispatch a request to lock the screen orientation.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/screen-orientation#remote-control}
+   */
+  lockScreenOrientation(lockType, trigger) {
+    this.#dispatchRequest("media-orientation-lock-request", trigger, lockType);
+  }
+  /**
+   * Dispatch a request to unlock the screen orientation.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/screen-orientation#remote-control}
+   */
+  unlockScreenOrientation(trigger) {
+    this.#dispatchRequest("media-orientation-unlock-request", trigger);
+  }
+  /**
+   * Dispatch a request to enter picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  enterPictureInPicture(trigger) {
+    this.#dispatchRequest("media-enter-pip-request", trigger);
+  }
+  /**
+   * Dispatch a request to exit picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  exitPictureInPicture(trigger) {
+    this.#dispatchRequest("media-exit-pip-request", trigger);
+  }
+  /**
+   * Notify the media player that a seeking process is happening and to seek to the given `time`.
+   */
+  seeking(time, trigger) {
+    this.#dispatchRequest("media-seeking-request", trigger, time);
+  }
+  /**
+   * Notify the media player that a seeking operation has completed and to seek to the given `time`.
+   * This is generally called after a series of `remote.seeking()` calls.
+   */
+  seek(time, trigger) {
+    this.#dispatchRequest("media-seek-request", trigger, time);
+  }
+  seekToLiveEdge(trigger) {
+    this.#dispatchRequest("media-live-edge-request", trigger);
+  }
+  /**
+   * Dispatch a request to update the length of the media in seconds.
+   *
+   * @example
+   * ```ts
+   * remote.changeDuration(100); // 100 seconds
+   * ```
+   */
+  changeDuration(duration, trigger) {
+    this.#dispatchRequest("media-duration-change-request", trigger, duration);
+  }
+  /**
+   * Dispatch a request to update the clip start time. This is the time at which media playback
+   * should start at.
+   *
+   * @example
+   * ```ts
+   * remote.changeClipStart(100); // start at 100 seconds
+   * ```
+   */
+  changeClipStart(startTime, trigger) {
+    this.#dispatchRequest("media-clip-start-change-request", trigger, startTime);
+  }
+  /**
+   * Dispatch a request to update the clip end time. This is the time at which media playback
+   * should end at.
+   *
+   * @example
+   * ```ts
+   * remote.changeClipEnd(100); // end at 100 seconds
+   * ```
+   */
+  changeClipEnd(endTime, trigger) {
+    this.#dispatchRequest("media-clip-end-change-request", trigger, endTime);
+  }
+  /**
+   * Dispatch a request to update the media volume to the given `volume` level which is a value
+   * between 0 and 1.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/audio-gain#remote-control}
+   * @example
+   * ```ts
+   * remote.changeVolume(0); // 0%
+   * remote.changeVolume(0.05); // 5%
+   * remote.changeVolume(0.5); // 50%
+   * remote.changeVolume(0.75); // 70%
+   * remote.changeVolume(1); // 100%
+   * ```
+   */
+  changeVolume(volume, trigger) {
+    this.#dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
+  }
+  /**
+   * Dispatch a request to change the current audio track.
+   *
+   * @example
+   * ```ts
+   * remote.changeAudioTrack(1); // track at index 1
+   * ```
+   */
+  changeAudioTrack(index, trigger) {
+    this.#dispatchRequest("media-audio-track-change-request", trigger, index);
+  }
+  /**
+   * Dispatch a request to change the video quality. The special value `-1` represents auto quality
+   * selection.
+   *
+   * @example
+   * ```ts
+   * remote.changeQuality(-1); // auto
+   * remote.changeQuality(1); // quality at index 1
+   * ```
+   */
+  changeQuality(index, trigger) {
+    this.#dispatchRequest("media-quality-change-request", trigger, index);
+  }
+  /**
+   * Request auto quality selection.
+   */
+  requestAutoQuality(trigger) {
+    this.changeQuality(-1, trigger);
+  }
+  /**
+   * Dispatch a request to change the mode of the text track at the given index.
+   *
+   * @example
+   * ```ts
+   * remote.changeTextTrackMode(1, 'showing'); // track at index 1
+   * ```
+   */
+  changeTextTrackMode(index, mode, trigger) {
+    this.#dispatchRequest("media-text-track-change-request", trigger, {
+      index,
+      mode
+    });
+  }
+  /**
+   * Dispatch a request to change the media playback rate.
+   *
+   * @example
+   * ```ts
+   * remote.changePlaybackRate(0.5); // Half the normal speed
+   * remote.changePlaybackRate(1); // Normal speed
+   * remote.changePlaybackRate(1.5); // 50% faster than normal
+   * remote.changePlaybackRate(2); // Double the normal speed
+   * ```
+   */
+  changePlaybackRate(rate, trigger) {
+    this.#dispatchRequest("media-rate-change-request", trigger, rate);
+  }
+  /**
+   * Dispatch a request to change the media audio gain.
+   *
+   * @example
+   * ```ts
+   * remote.changeAudioGain(1); // Disable audio gain
+   * remote.changeAudioGain(1.5); // 50% louder
+   * remote.changeAudioGain(2); // 100% louder
+   * ```
+   */
+  changeAudioGain(gain, trigger) {
+    this.#dispatchRequest("media-audio-gain-change-request", trigger, gain);
+  }
+  /**
+   * Dispatch a request to resume idle tracking on controls.
+   */
+  resumeControls(trigger) {
+    this.#dispatchRequest("media-resume-controls-request", trigger);
+  }
+  /**
+   * Dispatch a request to pause controls idle tracking. Pausing tracking will result in the
+   * controls being visible until `remote.resumeControls()` is called. This method
+   * is generally used when building custom controls and you'd like to prevent the UI from
+   * disappearing.
+   *
+   * @example
+   * ```ts
+   * // Prevent controls hiding while menu is being interacted with.
+   * function onSettingsOpen() {
+   *   remote.pauseControls();
+   * }
+   *
+   * function onSettingsClose() {
+   *   remote.resumeControls();
+   * }
+   * ```
+   */
+  pauseControls(trigger) {
+    this.#dispatchRequest("media-pause-controls-request", trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media playback state.
+   */
+  togglePaused(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.paused) this.play(trigger);
+    else this.pause(trigger);
+  }
+  /**
+   * Dispatch a request to toggle the controls visibility.
+   */
+  toggleControls(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (!player.controls.showing) {
+      player.controls.show(0, trigger);
+    } else {
+      player.controls.hide(0, trigger);
+    }
+  }
+  /**
+   * Dispatch a request to toggle the media muted state.
+   */
+  toggleMuted(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.muted) this.unmute(trigger);
+    else this.mute(trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media fullscreen state.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
+   */
+  toggleFullscreen(target, trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.fullscreen) this.exitFullscreen(target, trigger);
+    else this.enterFullscreen(target, trigger);
+  }
+  /**
+   * Dispatch a request to toggle the media picture-in-picture mode.
+   *
+   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
+   */
+  togglePictureInPicture(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.pictureInPicture) this.exitPictureInPicture(trigger);
+    else this.enterPictureInPicture(trigger);
+  }
+  /**
+   * Show captions.
+   */
+  showCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    let tracks = player.state.textTracks, index = this.#prevTrackIndex;
+    if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
+      index = -1;
+    }
+    if (index === -1) {
+      index = tracks.findIndex((track) => isTrackCaptionKind(track) && track.default);
+    }
+    if (index === -1) {
+      index = tracks.findIndex((track) => isTrackCaptionKind(track));
+    }
+    if (index >= 0) this.changeTextTrackMode(index, "showing", trigger);
+    this.#prevTrackIndex = -1;
+  }
+  /**
+   * Turn captions off.
+   */
+  disableCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    const tracks = player.state.textTracks, track = player.state.textTrack;
+    if (track) {
+      const index = tracks.indexOf(track);
+      this.changeTextTrackMode(index, "disabled", trigger);
+      this.#prevTrackIndex = index;
+    }
+  }
+  /**
+   * Dispatch a request to toggle the current captions mode.
+   */
+  toggleCaptions(trigger) {
+    const player = this.getPlayer(trigger?.target);
+    if (!player) {
+      return;
+    }
+    if (player.state.textTrack) {
+      this.disableCaptions();
+    } else {
+      this.showCaptions();
+    }
+  }
+  userPrefersLoopChange(prefersLoop, trigger) {
+    this.#dispatchRequest("media-user-loop-change-request", trigger, prefersLoop);
+  }
+  #dispatchRequest(type, trigger, detail) {
+    const request = new DOMEvent(type, {
+      bubbles: true,
+      composed: true,
+      cancelable: true,
+      detail,
+      trigger
+    });
+    let target = trigger?.target || null;
+    if (target && target instanceof Component) target = target.el;
+    const shouldUsePlayer = !target || target === document || target === window || target === document.body || this.#player?.el && target instanceof Node && !this.#player.el.contains(target);
+    target = shouldUsePlayer ? this.#target ?? this.getPlayer()?.el : target ?? this.#target;
+    if (this.#player) {
+      if (type === "media-play-request" && !this.#player.state.canLoad) {
+        target?.dispatchEvent(request);
+      } else {
+        this.#player.canPlayQueue.enqueue(type, () => target?.dispatchEvent(request));
+      }
+    } else {
+      target?.dispatchEvent(request);
+    }
+  }
+  #noPlayerWarning(method) {
+  }
+}
+
+class LocalMediaStorage {
+  playerId = "vds-player";
+  mediaId = null;
+  #data = {
+    volume: null,
+    muted: null,
+    audioGain: null,
+    time: null,
+    lang: null,
+    captions: null,
+    rate: null,
+    quality: null
+  };
+  async getVolume() {
+    return this.#data.volume;
+  }
+  async setVolume(volume) {
+    this.#data.volume = volume;
+    this.save();
+  }
+  async getMuted() {
+    return this.#data.muted;
+  }
+  async setMuted(muted) {
+    this.#data.muted = muted;
+    this.save();
+  }
+  async getTime() {
+    return this.#data.time;
+  }
+  async setTime(time, ended) {
+    const shouldClear = time < 0;
+    this.#data.time = !shouldClear ? time : null;
+    if (shouldClear || ended) this.saveTime();
+    else this.saveTimeThrottled();
+  }
+  async getLang() {
+    return this.#data.lang;
+  }
+  async setLang(lang) {
+    this.#data.lang = lang;
+    this.save();
+  }
+  async getCaptions() {
+    return this.#data.captions;
+  }
+  async setCaptions(enabled) {
+    this.#data.captions = enabled;
+    this.save();
+  }
+  async getPlaybackRate() {
+    return this.#data.rate;
+  }
+  async setPlaybackRate(rate) {
+    this.#data.rate = rate;
+    this.save();
+  }
+  async getAudioGain() {
+    return this.#data.audioGain;
+  }
+  async setAudioGain(gain) {
+    this.#data.audioGain = gain;
+    this.save();
+  }
+  async getVideoQuality() {
+    return this.#data.quality;
+  }
+  async setVideoQuality(quality) {
+    this.#data.quality = quality;
+    this.save();
+  }
+  onChange(src, mediaId, playerId = "vds-player") {
+    const savedData = playerId ? localStorage.getItem(playerId) : null, savedTime = mediaId ? localStorage.getItem(mediaId) : null;
+    this.playerId = playerId;
+    this.mediaId = mediaId;
+    this.#data = {
+      volume: null,
+      muted: null,
+      audioGain: null,
+      lang: null,
+      captions: null,
+      rate: null,
+      quality: null,
+      ...savedData ? JSON.parse(savedData) : {},
+      time: savedTime ? +savedTime : null
+    };
+  }
+  save() {
+    if (IS_SERVER || !this.playerId) return;
+    const data = JSON.stringify({ ...this.#data, time: void 0 });
+    localStorage.setItem(this.playerId, data);
+  }
+  saveTimeThrottled = functionThrottle(this.saveTime.bind(this), 1e3);
+  saveTime() {
+    if (IS_SERVER || !this.mediaId) return;
+    const data = (this.#data.time ?? 0).toString();
+    localStorage.setItem(this.mediaId, data);
+  }
+}
+
+const ADD = Symbol(0), REMOVE = Symbol(0), RESET = Symbol(0), SELECT = Symbol(0), READONLY = Symbol(0), SET_READONLY = Symbol(0), ON_RESET = Symbol(0), ON_REMOVE = Symbol(0), ON_USER_SELECT = Symbol(0);
+const ListSymbol = {
+  add: ADD,
+  remove: REMOVE,
+  reset: RESET,
+  select: SELECT,
+  readonly: READONLY,
+  setReadonly: SET_READONLY,
+  onReset: ON_RESET,
+  onRemove: ON_REMOVE,
+  onUserSelect: ON_USER_SELECT
+};
+
+class List extends EventsTarget {
+  items = [];
+  /** @internal */
+  [ListSymbol.readonly] = false;
+  get length() {
+    return this.items.length;
+  }
+  get readonly() {
+    return this[ListSymbol.readonly];
+  }
+  /**
+   * Returns the index of the first occurrence of the given item, or -1 if it is not present.
+   */
+  indexOf(item) {
+    return this.items.indexOf(item);
+  }
+  /**
+   * Returns an item matching the given `id`, or `null` if not present.
+   */
+  getById(id) {
+    if (id === "") return null;
+    return this.items.find((item) => item.id === id) ?? null;
+  }
+  /**
+   * Transform list to an array.
+   */
+  toArray() {
+    return [...this.items];
+  }
+  [Symbol.iterator]() {
+    return this.items.values();
+  }
+  /** @internal */
+  [ListSymbol.add](item, trigger) {
+    const index = this.items.length;
+    if (!("" + index in this)) {
+      Object.defineProperty(this, index, {
+        get() {
+          return this.items[index];
+        }
+      });
+    }
+    if (this.items.includes(item)) return;
+    this.items.push(item);
+    this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
+  }
+  /** @internal */
+  [ListSymbol.remove](item, trigger) {
+    const index = this.items.indexOf(item);
+    if (index >= 0) {
+      this[ListSymbol.onRemove]?.(item, trigger);
+      this.items.splice(index, 1);
+      this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
+    }
+  }
+  /** @internal */
+  [ListSymbol.reset](trigger) {
+    for (const item of [...this.items]) this[ListSymbol.remove](item, trigger);
+    this.items = [];
+    this[ListSymbol.setReadonly](false, trigger);
+    this[ListSymbol.onReset]?.();
+  }
+  /** @internal */
+  [ListSymbol.setReadonly](readonly, trigger) {
+    if (this[ListSymbol.readonly] === readonly) return;
+    this[ListSymbol.readonly] = readonly;
+    this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
+  }
+}
+
+const SELECTED = Symbol(0);
+class SelectList extends List {
+  get selected() {
+    return this.items.find((item) => item.selected) ?? null;
+  }
+  get selectedIndex() {
+    return this.items.findIndex((item) => item.selected);
+  }
+  /** @internal */
+  [ListSymbol.onRemove](item, trigger) {
+    this[ListSymbol.select](item, false, trigger);
+  }
+  /** @internal */
+  [ListSymbol.add](item, trigger) {
+    item[SELECTED] = false;
+    Object.defineProperty(item, "selected", {
+      get() {
+        return this[SELECTED];
+      },
+      set: (selected) => {
+        if (this.readonly) return;
+        this[ListSymbol.onUserSelect]?.();
+        this[ListSymbol.select](item, selected);
+      }
+    });
+    super[ListSymbol.add](item, trigger);
+  }
+  /** @internal */
+  [ListSymbol.select](item, selected, trigger) {
+    if (selected === item?.[SELECTED]) return;
+    const prev = this.selected;
+    if (item) item[SELECTED] = selected;
+    const changed = !selected ? prev === item : prev !== item;
+    if (changed) {
+      if (prev) prev[SELECTED] = false;
+      this.dispatchEvent(
+        new DOMEvent("change", {
+          detail: {
+            prev,
+            current: this.selected
+          },
+          trigger
+        })
+      );
+    }
+  }
+}
+
+class AudioTrackList extends SelectList {
+}
+
+function round(num, decimalPlaces = 2) {
+  return Number(num.toFixed(decimalPlaces));
+}
+function getNumberOfDecimalPlaces(num) {
+  return String(num).split(".")[1]?.length ?? 0;
+}
+function clampNumber(min, value, max) {
+  return Math.max(min, Math.min(max, value));
+}
+
+function isEventInside(el, event) {
+  const target = event.composedPath()[0];
+  return isDOMNode(target) && el.contains(target);
+}
+const rafJobs = /* @__PURE__ */ new Set();
+if (!IS_SERVER) {
+  let processJobs = function() {
+    for (const job of rafJobs) {
+      try {
+        job();
+      } catch (e) {
+      }
+    }
+    window.requestAnimationFrame(processJobs);
+  };
+  processJobs();
+}
+function scheduleRafJob(job) {
+  rafJobs.add(job);
+  return () => rafJobs.delete(job);
+}
+function setAttributeIfEmpty(target, name, value) {
+  if (!target.hasAttribute(name)) target.setAttribute(name, value);
+}
+function setARIALabel(target, $label) {
+  if (target.hasAttribute("aria-label") || target.hasAttribute("data-no-label")) return;
+  if (!isFunction($label)) {
+    setAttribute(target, "aria-label", $label);
+    return;
+  }
+  function updateAriaDescription() {
+    setAttribute(target, "aria-label", $label());
+  }
+  if (IS_SERVER) updateAriaDescription();
+  else effect(updateAriaDescription);
+}
+function isElementVisible(el) {
+  const style = getComputedStyle(el);
+  return style.display !== "none" && parseInt(style.opacity) > 0;
+}
+function checkVisibility(el) {
+  return !!el && ("checkVisibility" in el ? el.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true }) : isElementVisible(el));
+}
+function observeVisibility(el, callback) {
+  return scheduleRafJob(() => callback(checkVisibility(el)));
+}
+function isElementParent(owner, node, test) {
+  while (node) {
+    if (node === owner) {
+      return true;
+    } else if (test?.(node)) {
+      break;
+    } else {
+      node = node.parentElement;
+    }
+  }
+  return false;
+}
+function onPress(target, handler) {
+  return new EventsController(target).add("pointerup", (event) => {
+    if (event.button === 0 && !event.defaultPrevented) handler(event);
+  }).add("keydown", (event) => {
+    if (isKeyboardClick(event)) handler(event);
+  });
+}
+function isTouchPinchEvent(event) {
+  return isTouchEvent(event) && (event.touches.length > 1 || event.changedTouches.length > 1);
+}
+function requestScopedAnimationFrame(callback) {
+  if (IS_SERVER) return callback();
+  let scope = getScope(), id = window.requestAnimationFrame(() => {
+    scoped(callback, scope);
+    id = -1;
+  });
+  return () => void window.cancelAnimationFrame(id);
+}
+function autoPlacement(el, trigger, placement, {
+  offsetVarName,
+  xOffset,
+  yOffset,
+  ...options
+}) {
+  if (!el) return;
+  const floatingPlacement = placement.replace(" ", "-").replace("-center", "");
+  setStyle(el, "visibility", !trigger ? "hidden" : null);
+  if (!trigger) return;
+  let isTop = placement.includes("top");
+  const negateX = (x) => placement.includes("left") ? `calc(-1 * ${x})` : x, negateY = (y) => isTop ? `calc(-1 * ${y})` : y;
+  return autoUpdate(trigger, el, () => {
+    computePosition(trigger, el, {
+      placement: floatingPlacement,
+      middleware: [
+        ...options.middleware ?? [],
+        flip({ fallbackAxisSideDirection: "start", crossAxis: false }),
+        shift()
+      ],
+      ...options
+    }).then(({ x, y, middlewareData }) => {
+      const hasFlipped = !!middlewareData.flip?.index;
+      isTop = placement.includes(hasFlipped ? "bottom" : "top");
+      el.setAttribute(
+        "data-placement",
+        hasFlipped ? placement.startsWith("top") ? placement.replace("top", "bottom") : placement.replace("bottom", "top") : placement
+      );
+      Object.assign(el.style, {
+        top: `calc(${y + "px"} + ${negateY(
+          yOffset ? yOffset + "px" : `var(--${offsetVarName}-y-offset, 0px)`
+        )})`,
+        left: `calc(${x + "px"} + ${negateX(
+          xOffset ? xOffset + "px" : `var(--${offsetVarName}-x-offset, 0px)`
+        )})`
+      });
+    });
+  });
+}
+function hasAnimation(el) {
+  const styles = getComputedStyle(el);
+  return styles.animationName !== "none";
+}
+function isHTMLElement(el) {
+  return el instanceof HTMLElement;
+}
+
+class NativeTextRenderer {
+  priority = 0;
+  #display = true;
+  #video = null;
+  #track = null;
+  #tracks = /* @__PURE__ */ new Set();
+  canRender(_, video) {
+    return !!video;
+  }
+  attach(video) {
+    this.#video = video;
+    if (video) video.textTracks.onchange = this.#onChange.bind(this);
+  }
+  addTrack(track) {
+    this.#tracks.add(track);
+    this.#attachTrack(track);
+  }
+  removeTrack(track) {
+    track[TextTrackSymbol.native]?.remove?.();
+    track[TextTrackSymbol.native] = null;
+    this.#tracks.delete(track);
+  }
+  changeTrack(track) {
+    const current = track?.[TextTrackSymbol.native];
+    if (current && current.track.mode !== "showing") {
+      current.track.mode = "showing";
+    }
+    this.#track = track;
+  }
+  setDisplay(display) {
+    this.#display = display;
+    this.#onChange();
+  }
+  detach() {
+    if (this.#video) this.#video.textTracks.onchange = null;
+    for (const track of this.#tracks) this.removeTrack(track);
+    this.#tracks.clear();
+    this.#video = null;
+    this.#track = null;
+  }
+  #attachTrack(track) {
+    if (!this.#video) return;
+    const el = track[TextTrackSymbol.native] ??= this.#createTrackElement(track);
+    if (isHTMLElement(el)) {
+      this.#video.append(el);
+      el.track.mode = el.default ? "showing" : "disabled";
+    }
+  }
+  #createTrackElement(track) {
+    const el = document.createElement("track"), isDefault = track.default || track.mode === "showing", isSupported = track.src && track.type === "vtt";
+    el.id = track.id;
+    el.src = isSupported ? track.src : "";
+    el.label = track.label;
+    el.kind = track.kind;
+    el.default = isDefault;
+    track.language && (el.srclang = track.language);
+    if (isDefault && !isSupported) {
+      this.#copyCues(track, el.track);
+    }
+    return el;
+  }
+  #copyCues(track, native) {
+    if (track.src && track.type === "vtt" || native.cues?.length) return;
+    for (const cue of track.cues) native.addCue(cue);
+  }
+  #onChange(event) {
+    for (const track of this.#tracks) {
+      const native = track[TextTrackSymbol.native];
+      if (!native) continue;
+      if (!this.#display) {
+        native.track.mode = native.managed ? "hidden" : "disabled";
+        continue;
+      }
+      const isShowing = native.track.mode === "showing";
+      if (isShowing) this.#copyCues(track, native.track);
+      track.setMode(isShowing ? "showing" : "disabled", event);
+    }
+  }
+}
+
+class TextRenderers {
+  #video = null;
+  #textTracks;
+  #renderers = [];
+  #media;
+  #nativeDisplay = false;
+  #nativeRenderer = null;
+  #customRenderer = null;
+  constructor(media) {
+    this.#media = media;
+    const textTracks = media.textTracks;
+    this.#textTracks = textTracks;
+    effect(this.#watchControls.bind(this));
+    onDispose(this.#detach.bind(this));
+    new EventsController(textTracks).add("add", this.#onAddTrack.bind(this)).add("remove", this.#onRemoveTrack.bind(this)).add("mode-change", this.#update.bind(this));
+  }
+  #watchControls() {
+    const { nativeControls } = this.#media.$state;
+    this.#nativeDisplay = nativeControls();
+    this.#update();
+  }
+  add(renderer) {
+    this.#renderers.push(renderer);
+    untrack(this.#update.bind(this));
+  }
+  remove(renderer) {
+    renderer.detach();
+    this.#renderers.splice(this.#renderers.indexOf(renderer), 1);
+    untrack(this.#update.bind(this));
+  }
+  /** @internal */
+  attachVideo(video) {
+    requestAnimationFrame(() => {
+      this.#video = video;
+      if (video) {
+        this.#nativeRenderer = new NativeTextRenderer();
+        this.#nativeRenderer.attach(video);
+        for (const track of this.#textTracks) this.#addNativeTrack(track);
+      }
+      this.#update();
+    });
+  }
+  #addNativeTrack(track) {
+    if (!isTrackCaptionKind(track)) return;
+    this.#nativeRenderer?.addTrack(track);
+  }
+  #removeNativeTrack(track) {
+    if (!isTrackCaptionKind(track)) return;
+    this.#nativeRenderer?.removeTrack(track);
+  }
+  #onAddTrack(event) {
+    this.#addNativeTrack(event.detail);
+  }
+  #onRemoveTrack(event) {
+    this.#removeNativeTrack(event.detail);
+  }
+  #update() {
+    const currentTrack = this.#textTracks.selected;
+    if (this.#video && (this.#nativeDisplay || currentTrack?.[TextTrackSymbol.nativeHLS])) {
+      this.#customRenderer?.changeTrack(null);
+      this.#nativeRenderer?.setDisplay(true);
+      this.#nativeRenderer?.changeTrack(currentTrack);
+      return;
+    }
+    this.#nativeRenderer?.setDisplay(false);
+    this.#nativeRenderer?.changeTrack(null);
+    if (!currentTrack) {
+      this.#customRenderer?.changeTrack(null);
+      return;
+    }
+    const customRenderer = this.#renderers.sort((a, b) => a.priority - b.priority).find((renderer) => renderer.canRender(currentTrack, this.#video));
+    if (this.#customRenderer !== customRenderer) {
+      this.#customRenderer?.detach();
+      customRenderer?.attach(this.#video);
+      this.#customRenderer = customRenderer ?? null;
+    }
+    customRenderer?.changeTrack(currentTrack);
+  }
+  #detach() {
+    this.#nativeRenderer?.detach();
+    this.#nativeRenderer = null;
+    this.#customRenderer?.detach();
+    this.#customRenderer = null;
+  }
+}
+
+class TextTrackList extends List {
+  #canLoad = false;
+  #defaults = {};
+  #storage = null;
+  #preferredLang = null;
+  /** @internal */
+  [TextTrackSymbol.crossOrigin];
+  constructor() {
+    super();
+  }
+  get selected() {
+    const track = this.items.find((t) => t.mode === "showing" && isTrackCaptionKind(t));
+    return track ?? null;
+  }
+  get selectedIndex() {
+    const selected = this.selected;
+    return selected ? this.indexOf(selected) : -1;
+  }
+  get preferredLang() {
+    return this.#preferredLang;
+  }
+  set preferredLang(lang) {
+    this.#preferredLang = lang;
+    this.#saveLang(lang);
+  }
+  add(init, trigger) {
+    const isTrack = init instanceof TextTrack, track = isTrack ? init : new TextTrack(init), kind = init.kind === "captions" || init.kind === "subtitles" ? "captions" : init.kind;
+    if (this.#defaults[kind] && init.default) delete init.default;
+    track.addEventListener("mode-change", this.#onTrackModeChangeBind);
+    this[ListSymbol.add](track, trigger);
+    track[TextTrackSymbol.crossOrigin] = this[TextTrackSymbol.crossOrigin];
+    if (this.#canLoad) track[TextTrackSymbol.canLoad]();
+    if (init.default) this.#defaults[kind] = track;
+    this.#selectTracks();
+    return this;
+  }
+  remove(track, trigger) {
+    this.#pendingRemoval = track;
+    if (!this.items.includes(track)) return;
+    if (track === this.#defaults[track.kind]) delete this.#defaults[track.kind];
+    track.mode = "disabled";
+    track[TextTrackSymbol.onModeChange] = null;
+    track.removeEventListener("mode-change", this.#onTrackModeChangeBind);
+    this[ListSymbol.remove](track, trigger);
+    this.#pendingRemoval = null;
+    return this;
+  }
+  clear(trigger) {
+    for (const track of [...this.items]) {
+      this.remove(track, trigger);
+    }
+    return this;
+  }
+  getByKind(kind) {
+    const kinds = Array.isArray(kind) ? kind : [kind];
+    return this.items.filter((track) => kinds.includes(track.kind));
+  }
+  /** @internal */
+  [TextTrackSymbol.canLoad]() {
+    if (this.#canLoad) return;
+    for (const track of this.items) track[TextTrackSymbol.canLoad]();
+    this.#canLoad = true;
+    this.#selectTracks();
+  }
+  #selectTracks = functionDebounce(async () => {
+    if (!this.#canLoad) return;
+    if (!this.#preferredLang && this.#storage) {
+      this.#preferredLang = await this.#storage.getLang();
+    }
+    const showCaptions = await this.#storage?.getCaptions(), kinds = [
+      ["captions", "subtitles"],
+      "chapters",
+      "descriptions",
+      "metadata"
+    ];
+    for (const kind of kinds) {
+      const tracks = this.getByKind(kind);
+      if (tracks.find((t) => t.mode === "showing")) continue;
+      const preferredTrack = this.#preferredLang ? tracks.find((track2) => track2.language === this.#preferredLang) : null;
+      const defaultTrack = isArray(kind) ? this.#defaults[kind.find((kind2) => this.#defaults[kind2]) || ""] : this.#defaults[kind];
+      const track = preferredTrack ?? defaultTrack, isCaptionsKind = track && isTrackCaptionKind(track);
+      if (track && (!isCaptionsKind || showCaptions !== false)) {
+        track.mode = "showing";
+        if (isCaptionsKind) this.#saveCaptionsTrack(track);
+      }
+    }
+  }, 300);
+  #pendingRemoval = null;
+  #onTrackModeChangeBind = this.#onTrackModeChange.bind(this);
+  #onTrackModeChange(event) {
+    const track = event.detail;
+    if (this.#storage && isTrackCaptionKind(track) && track !== this.#pendingRemoval) {
+      this.#saveCaptionsTrack(track);
+    }
+    if (track.mode === "showing") {
+      const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
+      for (const t of this.items) {
+        if (t.mode === "showing" && t != track && kinds.includes(t.kind)) {
+          t.mode = "disabled";
+        }
+      }
+    }
+    this.dispatchEvent(
+      new DOMEvent("mode-change", {
+        detail: event.detail,
+        trigger: event
+      })
+    );
+  }
+  #saveCaptionsTrack(track) {
+    if (track.mode !== "disabled") {
+      this.#saveLang(track.language);
+    }
+    this.#storage?.setCaptions?.(track.mode === "showing");
+  }
+  #saveLang(lang) {
+    this.#storage?.setLang?.(this.#preferredLang = lang);
+  }
+  setStorage(storage) {
+    this.#storage = storage;
+  }
+}
+
+const SET_AUTO = Symbol(0), ENABLE_AUTO = Symbol(0);
+const QualitySymbol = {
+  setAuto: SET_AUTO,
+  enableAuto: ENABLE_AUTO
+};
+
+class VideoQualityList extends SelectList {
+  #auto = false;
+  /**
+   * Configures quality switching:
+   *
+   * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
+   * request if any, flush the whole buffer, and fetch fragment matching with current position
+   * and requested quality level.
+   *
+   * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
+   * already buffered next fragment.
+   *
+   * - `load`: Set quality level for next loaded fragment.
+   *
+   * @see {@link https://www.vidstack.io/docs/player/api/video-quality#switch}
+   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
+   */
+  switch = "current";
+  /**
+   * Whether automatic quality selection is enabled.
+   */
+  get auto() {
+    return this.#auto || this.readonly;
+  }
+  /** @internal */
+  [QualitySymbol.enableAuto];
+  /** @internal */
+  [ListSymbol.onUserSelect]() {
+    this[QualitySymbol.setAuto](false);
+  }
+  /** @internal */
+  [ListSymbol.onReset](trigger) {
+    this[QualitySymbol.enableAuto] = void 0;
+    this[QualitySymbol.setAuto](false, trigger);
+  }
+  /**
+   * Request automatic quality selection (if supported). This will be a no-op if the list is
+   * `readonly` as that already implies auto-selection.
+   */
+  autoSelect(trigger) {
+    if (this.readonly || this.#auto || !this[QualitySymbol.enableAuto]) return;
+    this[QualitySymbol.enableAuto]?.(trigger);
+    this[QualitySymbol.setAuto](true, trigger);
+  }
+  getBySrc(src) {
+    return this.items.find((quality) => quality.src === src);
+  }
+  /** @internal */
+  [QualitySymbol.setAuto](auto, trigger) {
+    if (this.#auto === auto) return;
+    this.#auto = auto;
+    this.dispatchEvent(
+      new DOMEvent("auto-change", {
+        detail: auto,
+        trigger
+      })
+    );
+  }
+}
+
+function sortVideoQualities(qualities, desc) {
+  return [...qualities].sort(desc ? compareVideoQualityDesc : compareVideoQualityAsc);
+}
+function compareVideoQualityAsc(a, b) {
+  return a.height === b.height ? (a.bitrate ?? 0) - (b.bitrate ?? 0) : a.height - b.height;
+}
+function compareVideoQualityDesc(a, b) {
+  return b.height === a.height ? (b.bitrate ?? 0) - (a.bitrate ?? 0) : b.height - a.height;
+}
+
+function isAudioProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "AUDIO";
+}
+function isVideoProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "VIDEO";
+}
+function isHLSProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "HLS";
+}
+function isDASHProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "DASH";
+}
+function isYouTubeProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "YOUTUBE";
+}
+function isVimeoProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "VIMEO";
+}
+function isGoogleCastProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "GOOGLE_CAST";
+}
+function isHTMLAudioElement(element) {
+  return !IS_SERVER && element instanceof HTMLAudioElement;
+}
+function isHTMLVideoElement(element) {
+  return !IS_SERVER && element instanceof HTMLVideoElement;
+}
+function isHTMLMediaElement(element) {
+  return isHTMLAudioElement(element) || isHTMLVideoElement(element);
+}
+function isHTMLIFrameElement(element) {
+  return !IS_SERVER && element instanceof HTMLIFrameElement;
+}
+
+class MediaPlayerController extends ViewController {
+}
+
+const MEDIA_KEY_SHORTCUTS = {
+  togglePaused: "k Space",
+  toggleMuted: "m",
+  toggleFullscreen: "f",
+  togglePictureInPicture: "i",
+  toggleCaptions: "c",
+  seekBackward: "j J ArrowLeft",
+  seekForward: "l L ArrowRight",
+  volumeUp: "ArrowUp",
+  volumeDown: "ArrowDown",
+  speedUp: ">",
+  slowDown: "<"
+};
+const MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Ctrl"]), BUTTON_SELECTORS = 'button, [role="button"]', IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"], [role="timer"]';
+class MediaKeyboardController extends MediaPlayerController {
+  #media;
+  constructor(media) {
+    super();
+    this.#media = media;
+  }
+  onConnect() {
+    effect(this.#onTargetChange.bind(this));
+  }
+  #onTargetChange() {
+    const { keyDisabled, keyTarget } = this.$props;
+    if (keyDisabled()) return;
+    const target = keyTarget() === "player" ? this.el : document, $active = signal(false);
+    if (target === this.el) {
+      new EventsController(this.el).add("focusin", () => $active.set(true)).add("focusout", (event) => {
+        if (!this.el.contains(event.target)) $active.set(false);
+      });
+    } else {
+      if (!peek($active)) $active.set(document.querySelector("[data-media-player]") === this.el);
+      listenEvent(document, "focusin", (event) => {
+        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
+        if (activePlayer !== void 0) $active.set(this.el === activePlayer);
+      });
+    }
+    effect(() => {
+      if (!$active()) return;
+      new EventsController(target).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("keydown", this.#onPreventVideoKeys.bind(this), { capture: true });
+    });
+  }
+  #onKeyUp(event) {
+    const focusedEl = document.activeElement;
+    if (!event.key || !this.$state.canSeek() || focusedEl?.matches(IGNORE_SELECTORS)) {
+      return;
+    }
+    let { method, value } = this.#getMatchingMethod(event);
+    if (!isString(value) && !isArray(value)) {
+      value?.onKeyUp?.({
+        event,
+        player: this.#media.player,
+        remote: this.#media.remote
+      });
+      value?.callback?.(event, this.#media.remote);
+      return;
+    }
+    if (method?.startsWith("seek")) {
+      event.preventDefault();
+      event.stopPropagation();
+      if (this.#timeSlider) {
+        this.#forwardTimeKeyboardEvent(event, method === "seekForward");
+        this.#timeSlider = null;
+      } else {
+        this.#media.remote.seek(this.#seekTotal, event);
+        this.#seekTotal = void 0;
+      }
+    }
+    if (method?.startsWith("volume")) {
+      const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
+      volumeSlider?.dispatchEvent(
+        new KeyboardEvent("keyup", {
+          key: method === "volumeUp" ? "Up" : "Down",
+          shiftKey: event.shiftKey,
+          trigger: event
+        })
+      );
+    }
+  }
+  #onKeyDown(event) {
+    if (!event.key || MODIFIER_KEYS.has(event.key)) return;
+    const focusedEl = document.activeElement;
+    if (focusedEl?.matches(IGNORE_SELECTORS) || isKeyboardClick(event) && focusedEl?.matches(BUTTON_SELECTORS)) {
+      return;
+    }
+    let { method, value } = this.#getMatchingMethod(event), isNumberPress = !event.metaKey && /^[0-9]$/.test(event.key);
+    if (!isString(value) && !isArray(value) && !isNumberPress) {
+      value?.onKeyDown?.({
+        event,
+        player: this.#media.player,
+        remote: this.#media.remote
+      });
+      value?.callback?.(event, this.#media.remote);
+      return;
+    }
+    if (!method && isNumberPress) {
+      event.preventDefault();
+      event.stopPropagation();
+      this.#media.remote.seek(this.$state.duration() / 10 * Number(event.key), event);
+      return;
+    }
+    if (!method) return;
+    event.preventDefault();
+    event.stopPropagation();
+    switch (method) {
+      case "seekForward":
+      case "seekBackward":
+        this.#seeking(event, method, method === "seekForward");
+        break;
+      case "volumeUp":
+      case "volumeDown":
+        const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
+        if (volumeSlider) {
+          volumeSlider.dispatchEvent(
+            new KeyboardEvent("keydown", {
+              key: method === "volumeUp" ? "Up" : "Down",
+              shiftKey: event.shiftKey,
+              trigger: event
+            })
+          );
+        } else {
+          const value2 = event.shiftKey ? 0.1 : 0.05;
+          this.#media.remote.changeVolume(
+            this.$state.volume() + (method === "volumeUp" ? +value2 : -value2),
+            event
+          );
+        }
+        break;
+      case "toggleFullscreen":
+        this.#media.remote.toggleFullscreen("prefer-media", event);
+        break;
+      case "speedUp":
+      case "slowDown":
+        const playbackRate = this.$state.playbackRate();
+        this.#media.remote.changePlaybackRate(
+          Math.max(0.25, Math.min(2, playbackRate + (method === "speedUp" ? 0.25 : -0.25))),
+          event
+        );
+        break;
+      default:
+        this.#media.remote[method]?.(event);
+    }
+    this.$state.lastKeyboardAction.set({
+      action: method,
+      event
+    });
+  }
+  #onPreventVideoKeys(event) {
+    if (isHTMLMediaElement(event.target) && this.#getMatchingMethod(event).method) {
+      event.preventDefault();
+    }
+  }
+  #getMatchingMethod(event) {
+    const keyShortcuts = {
+      ...this.$props.keyShortcuts(),
+      ...this.#media.ariaKeys
+    };
+    const method = Object.keys(keyShortcuts).find((method2) => {
+      const value = keyShortcuts[method2], keys = isArray(value) ? value.join(" ") : isString(value) ? value : value?.keys;
+      const combinations = (isArray(keys) ? keys : keys?.split(" "))?.map(
+        (key) => replaceSymbolKeys(key).replace(/Control/g, "Ctrl").split("+")
+      );
+      return combinations?.some((combo) => {
+        const modifierKeys = new Set(combo.filter((key) => MODIFIER_KEYS.has(key)));
+        for (const modKey of MODIFIER_KEYS) {
+          const modKeyProp = modKey.toLowerCase() + "Key";
+          if (!modifierKeys.has(modKey) && event[modKeyProp]) {
+            return false;
+          }
+        }
+        return combo.every((key) => {
+          return MODIFIER_KEYS.has(key) ? event[key.toLowerCase() + "Key"] : event.key === key.replace("Space", " ");
+        });
+      });
+    });
+    return {
+      method,
+      value: method ? keyShortcuts[method] : null
+    };
+  }
+  #seekTotal;
+  #calcSeekAmount(event, type) {
+    const seekBy = event.shiftKey ? 10 : 5;
+    return this.#seekTotal = Math.max(
+      0,
+      Math.min(
+        (this.#seekTotal ?? this.$state.currentTime()) + (type === "seekForward" ? +seekBy : -seekBy),
+        this.$state.duration()
+      )
+    );
+  }
+  #timeSlider = null;
+  #forwardTimeKeyboardEvent(event, forward) {
+    this.#timeSlider?.dispatchEvent(
+      new KeyboardEvent(event.type, {
+        key: !forward ? "Left" : "Right",
+        shiftKey: event.shiftKey,
+        trigger: event
+      })
+    );
+  }
+  #seeking(event, type, forward) {
+    if (!this.$state.canSeek()) return;
+    if (!this.#timeSlider) {
+      this.#timeSlider = this.el.querySelector("[data-media-time-slider]");
+    }
+    if (this.#timeSlider) {
+      this.#forwardTimeKeyboardEvent(event, forward);
+    } else {
+      this.#media.remote.seeking(this.#calcSeekAmount(event, type), event);
+    }
+  }
+}
+const SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
+function replaceSymbolKeys(key) {
+  return key.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
+}
+
+class ARIAKeyShortcuts extends ViewController {
+  #shortcut;
+  constructor(shortcut) {
+    super();
+    this.#shortcut = shortcut;
+  }
+  onAttach(el) {
+    const { $props, ariaKeys } = useMediaContext(), keys = el.getAttribute("aria-keyshortcuts");
+    if (keys) {
+      ariaKeys[this.#shortcut] = keys;
+      if (!IS_SERVER) {
+        onDispose(() => {
+          delete ariaKeys[this.#shortcut];
+        });
+      }
+      return;
+    }
+    const shortcuts = $props.keyShortcuts()[this.#shortcut];
+    if (shortcuts) {
+      const keys2 = isArray(shortcuts) ? shortcuts.join(" ") : isString(shortcuts) ? shortcuts : shortcuts?.keys;
+      el.setAttribute("aria-keyshortcuts", isArray(keys2) ? keys2.join(" ") : keys2);
+    }
+  }
+}
+
+class MediaControls extends MediaPlayerController {
+  #idleTimer = -2;
+  #pausedTracking = false;
+  #hideOnMouseLeave = signal(false);
+  #isMouseOutside = signal(false);
+  #focusedItem = null;
+  #canIdle = signal(true);
+  /**
+   * The default amount of delay in milliseconds while media playback is progressing without user
+   * activity to indicate an idle state (i.e., hide controls).
+   *
+   * @defaultValue 2000
+   */
+  defaultDelay = 2e3;
+  /**
+   * Whether controls can hide after a delay in user interaction. If this is false, controls will
+   * not hide and be user controlled.
+   */
+  get canIdle() {
+    return this.#canIdle();
+  }
+  set canIdle(canIdle) {
+    this.#canIdle.set(canIdle);
+  }
+  /**
+   * Whether controls visibility should be toggled when the mouse enters and leaves the player
+   * container.
+   *
+   * @defaultValue false
+   */
+  get hideOnMouseLeave() {
+    const { hideControlsOnMouseLeave } = this.$props;
+    return this.#hideOnMouseLeave() || hideControlsOnMouseLeave();
+  }
+  set hideOnMouseLeave(hide) {
+    this.#hideOnMouseLeave.set(hide);
+  }
+  /**
+   * Whether media controls are currently visible.
+   */
+  get showing() {
+    return this.$state.controlsVisible();
+  }
+  /**
+   * Show controls.
+   */
+  show(delay = 0, trigger) {
+    this.#clearIdleTimer();
+    if (!this.#pausedTracking) {
+      this.#changeVisibility(true, delay, trigger);
+    }
+  }
+  /**
+   * Hide controls.
+   */
+  hide(delay = this.defaultDelay, trigger) {
+    this.#clearIdleTimer();
+    if (!this.#pausedTracking) {
+      this.#changeVisibility(false, delay, trigger);
+    }
+  }
+  /**
+   * Whether all idle tracking on controls should be paused until resumed again.
+   */
+  pause(trigger) {
+    this.#pausedTracking = true;
+    this.#clearIdleTimer();
+    this.#changeVisibility(true, 0, trigger);
+  }
+  resume(trigger) {
+    this.#pausedTracking = false;
+    if (this.$state.paused()) return;
+    this.#changeVisibility(false, this.defaultDelay, trigger);
+  }
+  onConnect() {
+    effect(this.#init.bind(this));
+  }
+  #init() {
+    const { viewType } = this.$state;
+    if (!this.el || !this.#canIdle()) return;
+    if (viewType() === "audio") {
+      this.show();
+      return;
+    }
+    effect(this.#watchMouse.bind(this));
+    effect(this.#watchPaused.bind(this));
+    const onPlay = this.#onPlay.bind(this), onPause = this.#onPause.bind(this), onEnd = this.#onEnd.bind(this);
+    new EventsController(this.el).add("can-play", (event) => this.show(0, event)).add("play", onPlay).add("pause", onPause).add("end", onEnd).add("auto-play-fail", onPause);
+  }
+  #watchMouse() {
+    if (!this.el) return;
+    const { started, pointer, paused } = this.$state;
+    if (!started() || pointer() !== "fine") return;
+    const events = new EventsController(this.el), shouldHideOnMouseLeave = this.hideOnMouseLeave;
+    if (!shouldHideOnMouseLeave || !this.#isMouseOutside()) {
+      effect(() => {
+        if (!paused()) events.add("pointermove", this.#onStopIdle.bind(this));
+      });
+    }
+    if (shouldHideOnMouseLeave) {
+      events.add("mouseenter", this.#onMouseEnter.bind(this)).add("mouseleave", this.#onMouseLeave.bind(this));
+    }
+  }
+  #watchPaused() {
+    const { paused, started, autoPlayError } = this.$state;
+    if (paused() || autoPlayError() && !started()) return;
+    const onStopIdle = this.#onStopIdle.bind(this);
+    effect(() => {
+      if (!this.el) return;
+      const pointer = this.$state.pointer(), isTouch = pointer === "coarse", events = new EventsController(this.el), eventTypes = [isTouch ? "touchend" : "pointerup", "keydown"];
+      for (const eventType of eventTypes) {
+        events.add(eventType, onStopIdle, { passive: false });
+      }
+    });
+  }
+  #onPlay(event) {
+    if (event.triggers.hasType("ended")) return;
+    this.show(0, event);
+    this.hide(void 0, event);
+  }
+  #onPause(event) {
+    this.show(0, event);
+  }
+  #onEnd(event) {
+    const { loop } = this.$state;
+    if (loop()) this.hide(0, event);
+  }
+  #onMouseEnter(event) {
+    this.#isMouseOutside.set(false);
+    this.show(0, event);
+    this.hide(void 0, event);
+  }
+  #onMouseLeave(event) {
+    this.#isMouseOutside.set(true);
+    this.hide(0, event);
+  }
+  #clearIdleTimer() {
+    window.clearTimeout(this.#idleTimer);
+    this.#idleTimer = -1;
+  }
+  #onStopIdle(event) {
+    if (
+      // @ts-expect-error
+      event.MEDIA_GESTURE || this.#pausedTracking || isTouchPinchEvent(event)
+    ) {
+      return;
+    }
+    if (isKeyboardEvent(event)) {
+      if (event.key === "Escape") {
+        this.el?.focus();
+        this.#focusedItem = null;
+      } else if (this.#focusedItem) {
+        event.preventDefault();
+        requestAnimationFrame(() => {
+          this.#focusedItem?.focus();
+          this.#focusedItem = null;
+        });
+      }
+    }
+    this.show(0, event);
+    this.hide(this.defaultDelay, event);
+  }
+  #changeVisibility(visible, delay, trigger) {
+    if (delay === 0) {
+      this.#onChange(visible, trigger);
+      return;
+    }
+    this.#idleTimer = window.setTimeout(() => {
+      if (!this.scope) return;
+      this.#onChange(visible && !this.#pausedTracking, trigger);
+    }, delay);
+  }
+  #onChange(visible, trigger) {
+    if (this.$state.controlsVisible() === visible) return;
+    this.$state.controlsVisible.set(visible);
+    if (!visible && document.activeElement && this.el?.contains(document.activeElement)) {
+      this.#focusedItem = document.activeElement;
+      requestAnimationFrame(() => {
+        this.el?.focus({ preventScroll: true });
+      });
+    }
+    this.dispatch("controls-change", {
+      detail: visible,
+      trigger
+    });
+  }
+}
+
+const CAN_FULLSCREEN = fscreen.fullscreenEnabled;
+class FullscreenController extends ViewController {
+  /**
+   * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be
+   * listened to globally on the document so we need to know if they relate to the current host
+   * element or not.
+   */
+  #listening = false;
+  #active = false;
+  get active() {
+    return this.#active;
+  }
+  get supported() {
+    return CAN_FULLSCREEN;
+  }
+  onConnect() {
+    new EventsController(fscreen).add("fullscreenchange", this.#onChange.bind(this)).add("fullscreenerror", this.#onError.bind(this));
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  async #onDisconnect() {
+    if (CAN_FULLSCREEN) await this.exit();
+  }
+  #onChange(event) {
+    const active = isFullscreen(this.el);
+    if (active === this.#active) return;
+    if (!active) this.#listening = false;
+    this.#active = active;
+    this.dispatch("fullscreen-change", { detail: active, trigger: event });
+  }
+  #onError(event) {
+    if (!this.#listening) return;
+    this.dispatch("fullscreen-error", { detail: null, trigger: event });
+    this.#listening = false;
+  }
+  async enter() {
+    try {
+      this.#listening = true;
+      if (!this.el || isFullscreen(this.el)) return;
+      assertFullscreenAPI();
+      return fscreen.requestFullscreen(this.el);
+    } catch (error) {
+      this.#listening = false;
+      throw error;
+    }
+  }
+  async exit() {
+    if (!this.el || !isFullscreen(this.el)) return;
+    assertFullscreenAPI();
+    return fscreen.exitFullscreen();
+  }
+}
+function canFullscreen() {
+  return CAN_FULLSCREEN;
+}
+function isFullscreen(host) {
+  if (fscreen.fullscreenElement === host) return true;
+  try {
+    return host.matches(
+      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
+      fscreen.fullscreenPseudoClass
+    );
+  } catch (error) {
+    return false;
+  }
+}
+function assertFullscreenAPI() {
+  if (CAN_FULLSCREEN) return;
+  throw Error(
+    "[vidstack] no fullscreen API"
+  );
+}
+
+class ScreenOrientationController extends ViewController {
+  #type = signal(this.#getScreenOrientation());
+  #locked = signal(false);
+  #currentLock;
+  /**
+   * The current screen orientation type.
+   *
+   * @signal
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
+   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
+   */
+  get type() {
+    return this.#type();
+  }
+  /**
+   * Whether the screen orientation is currently locked.
+   *
+   * @signal
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
+   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
+   */
+  get locked() {
+    return this.#locked();
+  }
+  /**
+   * Whether the viewport is in a portrait orientation.
+   *
+   * @signal
+   */
+  get portrait() {
+    return this.#type().startsWith("portrait");
+  }
+  /**
+   * Whether the viewport is in a landscape orientation.
+   *
+   * @signal
+   */
+  get landscape() {
+    return this.#type().startsWith("landscape");
+  }
+  /**
+   * Whether the native Screen Orientation API is available.
+   */
+  static supported = canOrientScreen();
+  /**
+   * Whether the native Screen Orientation API is available.
+   */
+  get supported() {
+    return ScreenOrientationController.supported;
+  }
+  onConnect() {
+    if (this.supported) {
+      listenEvent(screen.orientation, "change", this.#onOrientationChange.bind(this));
+    } else {
+      const query = window.matchMedia("(orientation: landscape)");
+      query.onchange = this.#onOrientationChange.bind(this);
+      onDispose(() => query.onchange = null);
+    }
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  async #onDisconnect() {
+    if (this.supported && this.#locked()) await this.unlock();
+  }
+  #onOrientationChange(event) {
+    this.#type.set(this.#getScreenOrientation());
+    this.dispatch("orientation-change", {
+      detail: {
+        orientation: peek(this.#type),
+        lock: this.#currentLock
+      },
+      trigger: event
+    });
+  }
+  /**
+   * Locks the orientation of the screen to the desired orientation type using the
+   * Screen Orientation API.
+   *
+   * @param lockType - The screen lock orientation type.
+   * @throws Error - If screen orientation API is unavailable.
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
+   * @see {@link https://w3c.github.io/screen-orientation}
+   */
+  async lock(lockType) {
+    if (peek(this.#locked) || this.#currentLock === lockType) return;
+    this.#assertScreenOrientationAPI();
+    await screen.orientation.lock(lockType);
+    this.#locked.set(true);
+    this.#currentLock = lockType;
+  }
+  /**
+   * Unlocks the orientation of the screen to it's default state using the Screen Orientation
+   * API. This method will throw an error if the API is unavailable.
+   *
+   * @throws Error - If screen orientation API is unavailable.
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
+   * @see {@link https://w3c.github.io/screen-orientation}
+   */
+  async unlock() {
+    if (!peek(this.#locked)) return;
+    this.#assertScreenOrientationAPI();
+    this.#currentLock = void 0;
+    await screen.orientation.unlock();
+    this.#locked.set(false);
+  }
+  #assertScreenOrientationAPI() {
+    if (this.supported) return;
+    throw Error(
+      "[vidstack] no orientation API"
+    );
+  }
+  #getScreenOrientation() {
+    if (IS_SERVER) return "portrait-primary";
+    if (this.supported) return window.screen.orientation.type;
+    return window.innerWidth >= window.innerHeight ? "landscape-primary" : "portrait-primary";
+  }
+}
+
+class AudioProviderLoader {
+  name = "audio";
+  target;
+  canPlay(src) {
+    if (!isAudioSrc(src)) return false;
+    return IS_SERVER || !isString(src.src) || src.type === "?" || canPlayAudioType(this.target, src.type);
+  }
+  mediaType() {
+    return "audio";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load audio provider server-side");
+    }
+    return new (await import('./vidstack-CJ22YF5o.js')).AudioProvider(this.target, ctx);
+  }
+}
+
+class VideoProviderLoader {
+  name = "video";
+  target;
+  canPlay(src) {
+    if (!isVideoSrc(src)) return false;
+    return IS_SERVER || !isString(src.src) || src.type === "?" || canPlayVideoType(this.target, src.type);
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load video provider server-side");
+    }
+    return new (await Promise.resolve().then(function () { return provider$1; })).VideoProvider(this.target, ctx);
+  }
+}
+
+class HLSProviderLoader extends VideoProviderLoader {
+  static supported = isHLSSupported();
+  name = "hls";
+  canPlay(src) {
+    return HLSProviderLoader.supported && isHLSSrc(src);
+  }
+  async load(context) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load hls provider server-side");
+    }
+    return new (await import('./vidstack-8hvVfGIw.js')).HLSProvider(this.target, context);
+  }
+}
+
+let audioContext = null, gainNodes = [], elAudioSources = [];
+function getOrCreateAudioCtx() {
+  return audioContext ??= new AudioContext();
+}
+function createGainNode() {
+  const audioCtx = getOrCreateAudioCtx(), gainNode = audioCtx.createGain();
+  gainNode.connect(audioCtx.destination);
+  gainNodes.push(gainNode);
+  return gainNode;
+}
+function createElementSource(el, gainNode) {
+  const audioCtx = getOrCreateAudioCtx(), src = audioCtx.createMediaElementSource(el);
+  if (gainNode) {
+    src.connect(gainNode);
+  }
+  elAudioSources.push(src);
+  return src;
+}
+function destroyGainNode(node) {
+  const idx = gainNodes.indexOf(node);
+  if (idx !== -1) {
+    gainNodes.splice(idx, 1);
+    node.disconnect();
+    freeAudioCtxWhenAllResourcesFreed();
+  }
+}
+function destroyElementSource(src) {
+  const idx = elAudioSources.indexOf(src);
+  if (idx !== -1) {
+    elAudioSources.splice(idx, 1);
+    src.disconnect();
+    freeAudioCtxWhenAllResourcesFreed();
+  }
+}
+function freeAudioCtxWhenAllResourcesFreed() {
+  if (audioContext && gainNodes.length === 0 && elAudioSources.length === 0) {
+    audioContext.close().then(() => {
+      audioContext = null;
+    });
+  }
+}
+
+class AudioGain {
+  #media;
+  #onChange;
+  #gainNode = null;
+  #srcAudioNode = null;
+  get currentGain() {
+    return this.#gainNode?.gain?.value ?? null;
+  }
+  get supported() {
+    return true;
+  }
+  constructor(media, onChange) {
+    this.#media = media;
+    this.#onChange = onChange;
+  }
+  setGain(gain) {
+    const currGain = this.currentGain;
+    if (gain === this.currentGain) {
+      return;
+    }
+    if (gain === 1 && currGain !== 1) {
+      this.removeGain();
+      return;
+    }
+    if (!this.#gainNode) {
+      this.#gainNode = createGainNode();
+      if (this.#srcAudioNode) {
+        this.#srcAudioNode.connect(this.#gainNode);
+      }
+    }
+    if (!this.#srcAudioNode) {
+      this.#srcAudioNode = createElementSource(this.#media, this.#gainNode);
+    }
+    this.#gainNode.gain.value = gain;
+    this.#onChange(gain);
+  }
+  removeGain() {
+    if (!this.#gainNode) return;
+    if (this.#srcAudioNode) {
+      this.#srcAudioNode.connect(getOrCreateAudioCtx().destination);
+    }
+    this.#destroyGainNode();
+    this.#onChange(null);
+  }
+  destroy() {
+    this.#destroySrcNode();
+    this.#destroyGainNode();
+  }
+  #destroySrcNode() {
+    if (!this.#srcAudioNode) return;
+    try {
+      destroyElementSource(this.#srcAudioNode);
+    } catch (e) {
+    } finally {
+      this.#srcAudioNode = null;
+    }
+  }
+  #destroyGainNode() {
+    if (!this.#gainNode) return;
+    try {
+      destroyGainNode(this.#gainNode);
+    } catch (e) {
+    } finally {
+      this.#gainNode = null;
+    }
+  }
+}
+
+const PAGE_EVENTS = ["focus", "blur", "visibilitychange", "pageshow", "pagehide"];
+class PageVisibility {
+  #state = signal(determinePageState());
+  #visibility = signal(IS_SERVER ? "visible" : document.visibilityState);
+  #safariBeforeUnloadTimeout;
+  connect() {
+    const events = new EventsController(window), handlePageEvent = this.#handlePageEvent.bind(this);
+    for (const eventType of PAGE_EVENTS) {
+      events.add(eventType, handlePageEvent);
+    }
+    if (IS_SAFARI) {
+      events.add("beforeunload", (event) => {
+        this.#safariBeforeUnloadTimeout = setTimeout(() => {
+          if (!(event.defaultPrevented || event.returnValue.length > 0)) {
+            this.#state.set("hidden");
+            this.#visibility.set("hidden");
+          }
+        }, 0);
+      });
+    }
+  }
+  /**
+   * The current page state. Important to note we only account for a subset of page states, as
+   * the rest aren't valuable to the player at the moment.
+   *
+   * - **active:** A page is in the active state if it is visible and has input focus.
+   * - **passive:** A page is in the passive state if it is visible and does not have input focus.
+   * - **hidden:** A page is in the hidden state if it is not visible.
+   *
+   * @see https://developers.google.com/web/updates/2018/07/page-lifecycle-api#states
+   */
+  get pageState() {
+    return this.#state();
+  }
+  /**
+   * The current document visibility state.
+   *
+   * - **visible:** The page content may be at least partially visible. In practice, this means that
+   * the page is the foreground tab of a non-minimized window.
+   * - **hidden:** The page content is not visible to the user. In practice this means that the
+   * document is either a background tab or part of a minimized window, or the OS screen lock is
+   * active.
+   *
+   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState
+   */
+  get visibility() {
+    return this.#visibility();
+  }
+  #handlePageEvent(event) {
+    if (IS_SAFARI) window.clearTimeout(this.#safariBeforeUnloadTimeout);
+    if (event.type !== "blur" || this.#state() === "active") {
+      this.#state.set(determinePageState(event));
+      this.#visibility.set(document.visibilityState == "hidden" ? "hidden" : "visible");
+    }
+  }
+}
+function determinePageState(event) {
+  if (IS_SERVER) return "hidden";
+  if (event?.type === "blur" || document.visibilityState === "hidden") return "hidden";
+  if (document.hasFocus()) return "active";
+  return "passive";
+}
+
+class RAFLoop {
+  #id;
+  #callback;
+  constructor(callback) {
+    this.#callback = callback;
+  }
+  start() {
+    if (!isUndefined(this.#id)) return;
+    this.#loop();
+  }
+  stop() {
+    if (isNumber(this.#id)) window.cancelAnimationFrame(this.#id);
+    this.#id = void 0;
+  }
+  #loop() {
+    this.#id = window.requestAnimationFrame(() => {
+      if (isUndefined(this.#id)) return;
+      this.#callback();
+      this.#loop();
+    });
+  }
+}
+
+class HTMLMediaEvents {
+  #provider;
+  #ctx;
+  #waiting = false;
+  #attachedLoadStart = false;
+  #attachedCanPlay = false;
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #pageVisibility = new PageVisibility();
+  #events;
+  get #media() {
+    return this.#provider.media;
+  }
+  constructor(provider, ctx) {
+    this.#provider = provider;
+    this.#ctx = ctx;
+    this.#events = new EventsController(provider.media);
+    this.#attachInitialListeners();
+    this.#pageVisibility.connect();
+    effect(this.#attachTimeUpdate.bind(this));
+    onDispose(this.#onDispose.bind(this));
+  }
+  #onDispose() {
+    this.#attachedLoadStart = false;
+    this.#attachedCanPlay = false;
+    this.#timeRAF.stop();
+    this.#events.abort();
+    this.#devHandlers?.clear();
+  }
+  /**
+   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
+   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
+   * resolve that by retrieving time updates in a request animation frame loop.
+   */
+  #lastSeenTime = 0;
+  #seekedTo = -1;
+  #onAnimationFrame() {
+    const newTime = this.#media.currentTime;
+    const didStutter = IS_SAFARI && newTime - this.#seekedTo < 0.35;
+    if (!didStutter && this.#lastSeenTime !== newTime) {
+      this.#updateCurrentTime(newTime);
+      this.#lastSeenTime = newTime;
+    }
+  }
+  #attachInitialListeners() {
+    this.#attachEventListener("loadstart", this.#onLoadStart);
+    this.#attachEventListener("abort", this.#onAbort);
+    this.#attachEventListener("emptied", this.#onEmptied);
+    this.#attachEventListener("error", this.#onError);
+    this.#attachEventListener("volumechange", this.#onVolumeChange);
+  }
+  #attachLoadStartListeners() {
+    if (this.#attachedLoadStart) return;
+    this.#attachEventListener("loadeddata", this.#onLoadedData);
+    this.#attachEventListener("loadedmetadata", this.#onLoadedMetadata);
+    this.#attachEventListener("canplay", this.#onCanPlay);
+    this.#attachEventListener("canplaythrough", this.#onCanPlayThrough);
+    this.#attachEventListener("durationchange", this.#onDurationChange);
+    this.#attachEventListener("play", this.#onPlay);
+    this.#attachEventListener("progress", this.#onProgress);
+    this.#attachEventListener("stalled", this.#onStalled);
+    this.#attachEventListener("suspend", this.#onSuspend);
+    this.#attachEventListener("ratechange", this.#onRateChange);
+    this.#attachedLoadStart = true;
+  }
+  #attachCanPlayListeners() {
+    if (this.#attachedCanPlay) return;
+    this.#attachEventListener("pause", this.#onPause);
+    this.#attachEventListener("playing", this.#onPlaying);
+    this.#attachEventListener("seeked", this.#onSeeked);
+    this.#attachEventListener("seeking", this.#onSeeking);
+    this.#attachEventListener("ended", this.#onEnded);
+    this.#attachEventListener("waiting", this.#onWaiting);
+    this.#attachedCanPlay = true;
+  }
+  #devHandlers = void 0;
+  #handleDevEvent = void 0;
+  #attachEventListener(eventType, handler) {
+    this.#events.add(eventType, handler.bind(this));
+  }
+  #onDevEvent(event2) {
+    return;
+  }
+  #updateCurrentTime(time, trigger) {
+    const newTime = Math.min(time, this.#ctx.$state.seekableEnd());
+    this.#ctx.notify("time-change", newTime, trigger);
+  }
+  #onLoadStart(event2) {
+    if (this.#media.networkState === 3) {
+      this.#onAbort(event2);
+      return;
+    }
+    this.#attachLoadStartListeners();
+    this.#ctx.notify("load-start", void 0, event2);
+  }
+  #onAbort(event2) {
+    this.#ctx.notify("abort", void 0, event2);
+  }
+  #onEmptied() {
+    this.#ctx.notify("emptied", void 0, event);
+  }
+  #onLoadedData(event2) {
+    this.#ctx.notify("loaded-data", void 0, event2);
+  }
+  #onLoadedMetadata(event2) {
+    this.#lastSeenTime = 0;
+    this.#seekedTo = -1;
+    this.#attachCanPlayListeners();
+    this.#ctx.notify("loaded-metadata", void 0, event2);
+    if (IS_IOS || IS_SAFARI && isHLSSrc(this.#ctx.$state.source())) {
+      this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
+    }
+  }
+  #getCanPlayDetail() {
+    return {
+      provider: peek(this.#ctx.$provider),
+      duration: this.#media.duration,
+      buffered: this.#media.buffered,
+      seekable: this.#media.seekable
+    };
+  }
+  #onPlay(event2) {
+    if (!this.#ctx.$state.canPlay) return;
+    this.#ctx.notify("play", void 0, event2);
+  }
+  #onPause(event2) {
+    if (this.#media.readyState === 1 && !this.#waiting) return;
+    this.#waiting = false;
+    this.#timeRAF.stop();
+    this.#ctx.notify("pause", void 0, event2);
+  }
+  #onCanPlay(event2) {
+    this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
+  }
+  #onCanPlayThrough(event2) {
+    if (this.#ctx.$state.started()) return;
+    this.#ctx.notify("can-play-through", this.#getCanPlayDetail(), event2);
+  }
+  #onPlaying(event2) {
+    if (this.#media.paused) return;
+    this.#waiting = false;
+    this.#ctx.notify("playing", void 0, event2);
+    this.#timeRAF.start();
+  }
+  #onStalled(event2) {
+    this.#ctx.notify("stalled", void 0, event2);
+    if (this.#media.readyState < 3) {
+      this.#waiting = true;
+      this.#ctx.notify("waiting", void 0, event2);
+    }
+  }
+  #onWaiting(event2) {
+    if (this.#media.readyState < 3) {
+      this.#waiting = true;
+      this.#ctx.notify("waiting", void 0, event2);
+    }
+  }
+  #onEnded(event2) {
+    this.#timeRAF.stop();
+    this.#updateCurrentTime(this.#media.duration, event2);
+    this.#ctx.notify("end", void 0, event2);
+    if (this.#ctx.$state.loop()) {
+      const hasCustomControls = isNil(this.#media.controls);
+      if (hasCustomControls) this.#media.controls = false;
+    }
+  }
+  #attachTimeUpdate() {
+    const isPaused = this.#ctx.$state.paused(), isPageHidden = this.#pageVisibility.visibility === "hidden", shouldListenToTimeUpdates = isPaused || isPageHidden;
+    if (shouldListenToTimeUpdates) {
+      listenEvent(this.#media, "timeupdate", this.#onTimeUpdate.bind(this));
+    }
+  }
+  #onTimeUpdate(event2) {
+    this.#updateCurrentTime(this.#media.currentTime, event2);
+  }
+  #onDurationChange(event2) {
+    if (this.#ctx.$state.ended()) {
+      this.#updateCurrentTime(this.#media.duration, event2);
+    }
+    this.#ctx.notify("duration-change", this.#media.duration, event2);
+  }
+  #onVolumeChange(event2) {
+    const detail = {
+      volume: this.#media.volume,
+      muted: this.#media.muted
+    };
+    this.#ctx.notify("volume-change", detail, event2);
+  }
+  #onSeeked(event2) {
+    this.#seekedTo = this.#media.currentTime;
+    this.#updateCurrentTime(this.#media.currentTime, event2);
+    this.#ctx.notify("seeked", this.#media.currentTime, event2);
+    if (Math.trunc(this.#media.currentTime) === Math.trunc(this.#media.duration) && getNumberOfDecimalPlaces(this.#media.duration) > getNumberOfDecimalPlaces(this.#media.currentTime)) {
+      this.#updateCurrentTime(this.#media.duration, event2);
+      if (!this.#media.ended) {
+        this.#ctx.player.dispatch(
+          new DOMEvent("media-play-request", {
+            trigger: event2
+          })
+        );
+      }
+    }
+  }
+  #onSeeking(event2) {
+    this.#ctx.notify("seeking", this.#media.currentTime, event2);
+  }
+  #onProgress(event2) {
+    const detail = {
+      buffered: this.#media.buffered,
+      seekable: this.#media.seekable
+    };
+    this.#ctx.notify("progress", detail, event2);
+  }
+  #onSuspend(event2) {
+    this.#ctx.notify("suspend", void 0, event2);
+  }
+  #onRateChange(event2) {
+    this.#ctx.notify("rate-change", this.#media.playbackRate, event2);
+  }
+  #onError(event2) {
+    const error = this.#media.error;
+    if (!error) return;
+    const detail = {
+      message: error.message,
+      code: error.code,
+      mediaError: error
+    };
+    this.#ctx.notify("error", detail, event2);
+  }
+}
+
+class NativeAudioTracks {
+  #provider;
+  #ctx;
+  get #nativeTracks() {
+    return this.#provider.media.audioTracks;
+  }
+  constructor(provider, ctx) {
+    this.#provider = provider;
+    this.#ctx = ctx;
+    this.#nativeTracks.onaddtrack = this.#onAddNativeTrack.bind(this);
+    this.#nativeTracks.onremovetrack = this.#onRemoveNativeTrack.bind(this);
+    this.#nativeTracks.onchange = this.#onChangeNativeTrack.bind(this);
+    listenEvent(this.#ctx.audioTracks, "change", this.#onChangeTrack.bind(this));
+  }
+  #onAddNativeTrack(event) {
+    const nativeTrack = event.track;
+    if (nativeTrack.label === "") return;
+    const id = nativeTrack.id.toString() || `native-audio-${this.#ctx.audioTracks.length}`, audioTrack = {
+      id,
+      label: nativeTrack.label,
+      language: nativeTrack.language,
+      kind: nativeTrack.kind,
+      selected: false
+    };
+    this.#ctx.audioTracks[ListSymbol.add](audioTrack, event);
+    if (nativeTrack.enabled) audioTrack.selected = true;
+  }
+  #onRemoveNativeTrack(event) {
+    const track = this.#ctx.audioTracks.getById(event.track.id);
+    if (track) this.#ctx.audioTracks[ListSymbol.remove](track, event);
+  }
+  #onChangeNativeTrack(event) {
+    let enabledTrack = this.#getEnabledNativeTrack();
+    if (!enabledTrack) return;
+    const track = this.#ctx.audioTracks.getById(enabledTrack.id);
+    if (track) this.#ctx.audioTracks[ListSymbol.select](track, true, event);
+  }
+  #getEnabledNativeTrack() {
+    return Array.from(this.#nativeTracks).find((track) => track.enabled);
+  }
+  #onChangeTrack(event) {
+    const { current } = event.detail;
+    if (!current) return;
+    const track = this.#nativeTracks.getTrackById(current.id);
+    if (track) {
+      const prev = this.#getEnabledNativeTrack();
+      if (prev) prev.enabled = false;
+      track.enabled = true;
+    }
+  }
+}
+
+class HTMLMediaProvider {
+  constructor(media, ctx) {
+    this.media = media;
+    this.ctx = ctx;
+    this.audioGain = new AudioGain(media, (gain) => {
+      this.ctx.notify("audio-gain-change", gain);
+    });
+  }
+  scope = createScope();
+  currentSrc = null;
+  audioGain;
+  setup() {
+    new HTMLMediaEvents(this, this.ctx);
+    if ("audioTracks" in this.media) new NativeAudioTracks(this, this.ctx);
+    onDispose(() => {
+      this.audioGain.destroy();
+      this.media.srcObject = null;
+      this.media.removeAttribute("src");
+      for (const source of this.media.querySelectorAll("source")) source.remove();
+      this.media.load();
+    });
+  }
+  get type() {
+    return "";
+  }
+  setPlaybackRate(rate) {
+    this.media.playbackRate = rate;
+  }
+  async play() {
+    return this.media.play();
+  }
+  async pause() {
+    return this.media.pause();
+  }
+  setMuted(muted) {
+    this.media.muted = muted;
+  }
+  setVolume(volume) {
+    this.media.volume = volume;
+  }
+  setCurrentTime(time) {
+    this.media.currentTime = time;
+  }
+  setPlaysInline(inline) {
+    setAttribute(this.media, "playsinline", inline);
+  }
+  async loadSource({ src, type }, preload) {
+    this.media.preload = preload || "";
+    if (isMediaStream(src)) {
+      this.removeSource();
+      this.media.srcObject = src;
+    } else {
+      this.media.srcObject = null;
+      if (isString(src)) {
+        if (type !== "?") {
+          this.appendSource({ src, type });
+        } else {
+          this.removeSource();
+          this.media.src = this.#appendMediaFragment(src);
+        }
+      } else {
+        this.removeSource();
+        this.media.src = window.URL.createObjectURL(src);
+      }
+    }
+    this.media.load();
+    this.currentSrc = { src, type };
+  }
+  /**
+   * Append source so it works when requesting AirPlay since hls.js will remove it.
+   */
+  appendSource(src, defaultType) {
+    const prevSource = this.media.querySelector("source[data-vds]"), source = prevSource ?? document.createElement("source");
+    setAttribute(source, "src", this.#appendMediaFragment(src.src));
+    setAttribute(source, "type", src.type !== "?" ? src.type : defaultType);
+    setAttribute(source, "data-vds", "");
+    if (!prevSource) this.media.append(source);
+  }
+  removeSource() {
+    this.media.querySelector("source[data-vds]")?.remove();
+  }
+  #appendMediaFragment(src) {
+    const { clipStartTime, clipEndTime } = this.ctx.$state, startTime = clipStartTime(), endTime = clipEndTime();
+    if (startTime > 0 && endTime > 0) {
+      return `${src}#t=${startTime},${endTime}`;
+    } else if (startTime > 0) {
+      return `${src}#t=${startTime}`;
+    } else if (endTime > 0) {
+      return `${src}#t=0,${endTime}`;
+    }
+    return src;
+  }
+}
+
+class HTMLRemotePlaybackAdapter {
+  #media;
+  #ctx;
+  #state;
+  #supported = signal(false);
+  get supported() {
+    return this.#supported();
+  }
+  constructor(media, ctx) {
+    this.#media = media;
+    this.#ctx = ctx;
+    this.#setup();
+  }
+  #setup() {
+    if (IS_SERVER || !this.#media?.remote || !this.canPrompt) return;
+    this.#media.remote.watchAvailability((available) => {
+      this.#supported.set(available);
+    }).catch(() => {
+      this.#supported.set(false);
+    });
+    effect(this.#watchSupported.bind(this));
+  }
+  #watchSupported() {
+    if (!this.#supported()) return;
+    const events = ["connecting", "connect", "disconnect"], onStateChange = this.#onStateChange.bind(this);
+    onStateChange();
+    listenEvent(this.#media, "playing", onStateChange);
+    const remoteEvents = new EventsController(this.#media.remote);
+    for (const type of events) {
+      remoteEvents.add(type, onStateChange);
+    }
+  }
+  async prompt() {
+    if (!this.supported) throw Error("Not supported on this platform.");
+    if (this.type === "airplay" && this.#media.webkitShowPlaybackTargetPicker) {
+      return this.#media.webkitShowPlaybackTargetPicker();
+    }
+    return this.#media.remote.prompt();
+  }
+  #onStateChange(event) {
+    const state = this.#media.remote.state;
+    if (state === this.#state) return;
+    const detail = { type: this.type, state };
+    this.#ctx.notify("remote-playback-change", detail, event);
+    this.#state = state;
+  }
+}
+class HTMLAirPlayAdapter extends HTMLRemotePlaybackAdapter {
+  type = "airplay";
+  get canPrompt() {
+    return "WebKitPlaybackTargetAvailabilityEvent" in window;
+  }
+}
+
+class NativeHLSTextTracks {
+  #video;
+  #ctx;
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+    video.textTracks.onaddtrack = this.#onAddTrack.bind(this);
+    onDispose(this.#onDispose.bind(this));
+  }
+  #onAddTrack(event) {
+    const nativeTrack = event.track;
+    if (!nativeTrack || findTextTrackElement(this.#video, nativeTrack)) return;
+    const track = new TextTrack({
+      id: nativeTrack.id,
+      kind: nativeTrack.kind,
+      label: nativeTrack.label ?? "",
+      language: nativeTrack.language,
+      type: "vtt"
+    });
+    track[TextTrackSymbol.native] = { track: nativeTrack };
+    track[TextTrackSymbol.readyState] = 2;
+    track[TextTrackSymbol.nativeHLS] = true;
+    let lastIndex = 0;
+    const onCueChange = (event2) => {
+      if (!nativeTrack.cues) return;
+      for (let i = lastIndex; i < nativeTrack.cues.length; i++) {
+        track.addCue(nativeTrack.cues[i], event2);
+        lastIndex++;
+      }
+    };
+    onCueChange(event);
+    nativeTrack.oncuechange = onCueChange;
+    this.#ctx.textTracks.add(track, event);
+    track.setMode(nativeTrack.mode, event);
+  }
+  #onDispose() {
+    this.#video.textTracks.onaddtrack = null;
+    for (const track of this.#ctx.textTracks) {
+      const nativeTrack = track[TextTrackSymbol.native]?.track;
+      if (nativeTrack?.oncuechange) nativeTrack.oncuechange = null;
+    }
+  }
+}
+function findTextTrackElement(video, track) {
+  return Array.from(video.children).find((el) => el.track === track);
+}
+
+class VideoPictureInPicture {
+  #video;
+  #media;
+  constructor(video, media) {
+    this.#video = video;
+    this.#media = media;
+    new EventsController(video).add("enterpictureinpicture", this.#onEnter.bind(this)).add("leavepictureinpicture", this.#onExit.bind(this));
+  }
+  get active() {
+    return document.pictureInPictureElement === this.#video;
+  }
+  get supported() {
+    return canUsePictureInPicture(this.#video);
+  }
+  async enter() {
+    return this.#video.requestPictureInPicture();
+  }
+  exit() {
+    return document.exitPictureInPicture();
+  }
+  #onEnter(event) {
+    this.#onChange(true, event);
+  }
+  #onExit(event) {
+    this.#onChange(false, event);
+  }
+  #onChange = (active, event) => {
+    this.#media.notify("picture-in-picture-change", active, event);
+  };
+}
+
+class VideoPresentation {
+  #video;
+  #media;
+  #mode = "inline";
+  get mode() {
+    return this.#mode;
+  }
+  constructor(video, media) {
+    this.#video = video;
+    this.#media = media;
+    listenEvent(video, "webkitpresentationmodechanged", this.#onModeChange.bind(this));
+  }
+  get supported() {
+    return canUseVideoPresentation(this.#video);
+  }
+  async setPresentationMode(mode) {
+    if (this.#mode === mode) return;
+    this.#video.webkitSetPresentationMode(mode);
+  }
+  #onModeChange(event) {
+    const prevMode = this.#mode;
+    this.#mode = this.#video.webkitPresentationMode;
+    this.#media.player?.dispatch(
+      new DOMEvent("video-presentation-change", {
+        detail: this.#mode,
+        trigger: event
+      })
+    );
+    ["fullscreen", "picture-in-picture"].forEach((type) => {
+      if (this.#mode === type || prevMode === type) {
+        this.#media.notify(`${type}-change`, this.#mode === type, event);
+      }
+    });
+  }
+}
+class FullscreenPresentationAdapter {
+  #presentation;
+  get active() {
+    return this.#presentation.mode === "fullscreen";
+  }
+  get supported() {
+    return this.#presentation.supported;
+  }
+  constructor(presentation) {
+    this.#presentation = presentation;
+  }
+  async enter() {
+    this.#presentation.setPresentationMode("fullscreen");
+  }
+  async exit() {
+    this.#presentation.setPresentationMode("inline");
+  }
+}
+class PIPPresentationAdapter {
+  #presentation;
+  get active() {
+    return this.#presentation.mode === "picture-in-picture";
+  }
+  get supported() {
+    return this.#presentation.supported;
+  }
+  constructor(presentation) {
+    this.#presentation = presentation;
+  }
+  async enter() {
+    this.#presentation.setPresentationMode("picture-in-picture");
+  }
+  async exit() {
+    this.#presentation.setPresentationMode("inline");
+  }
+}
+
+class VideoProvider extends HTMLMediaProvider {
+  $$PROVIDER_TYPE = "VIDEO";
+  get type() {
+    return "video";
+  }
+  airPlay;
+  fullscreen;
+  pictureInPicture;
+  constructor(video, ctx) {
+    super(video, ctx);
+    scoped(() => {
+      this.airPlay = new HTMLAirPlayAdapter(video, ctx);
+      if (canUseVideoPresentation(video)) {
+        const presentation = new VideoPresentation(video, ctx);
+        this.fullscreen = new FullscreenPresentationAdapter(presentation);
+        this.pictureInPicture = new PIPPresentationAdapter(presentation);
+      } else if (canUsePictureInPicture(video)) {
+        this.pictureInPicture = new VideoPictureInPicture(video, ctx);
+      }
+    }, this.scope);
+  }
+  setup() {
+    super.setup();
+    if (canPlayHLSNatively(this.video)) {
+      new NativeHLSTextTracks(this.video, this.ctx);
+    }
+    this.ctx.textRenderers.attachVideo(this.video);
+    onDispose(() => {
+      this.ctx.textRenderers.attachVideo(null);
+    });
+    if (this.type === "video") this.ctx.notify("provider-setup", this);
+  }
+  /**
+   * The native HTML `<video>` element.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement}
+   */
+  get video() {
+    return this.media;
+  }
+}
+
+var provider$1 = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  VideoProvider: VideoProvider
+});
+
+function getLangName(langCode) {
+  try {
+    const displayNames = new Intl.DisplayNames(navigator.languages, { type: "language" });
+    const languageName = displayNames.of(langCode);
+    return languageName ?? null;
+  } catch (err) {
+    return null;
+  }
+}
+
+const toDOMEventType = (type) => `dash-${camelToKebabCase(type)}`;
+class DASHController {
+  #video;
+  #ctx;
+  #instance = null;
+  #callbacks = /* @__PURE__ */ new Set();
+  #stopLiveSync = null;
+  config = {};
+  get instance() {
+    return this.#instance;
+  }
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+  }
+  setup(ctor) {
+    this.#instance = ctor().create();
+    const dispatcher = this.#dispatchDASHEvent.bind(this);
+    for (const event of Object.values(ctor.events)) this.#instance.on(event, dispatcher);
+    this.#instance.on(ctor.events.ERROR, this.#onError.bind(this));
+    for (const callback of this.#callbacks) callback(this.#instance);
+    this.#ctx.player.dispatch("dash-instance", {
+      detail: this.#instance
+    });
+    this.#instance.initialize(this.#video, void 0, false);
+    this.#instance.updateSettings({
+      streaming: {
+        text: {
+          // Disabling text rendering by dash.
+          defaultEnabled: false,
+          dispatchForManualRendering: true
+        },
+        buffer: {
+          /// Enables buffer replacement when switching bitrates for faster switching.
+          fastSwitchEnabled: true
+        }
+      },
+      ...this.config
+    });
+    this.#instance.on(ctor.events.FRAGMENT_LOADING_STARTED, this.#onFragmentLoadStart.bind(this));
+    this.#instance.on(
+      ctor.events.FRAGMENT_LOADING_COMPLETED,
+      this.#onFragmentLoadComplete.bind(this)
+    );
+    this.#instance.on(ctor.events.MANIFEST_LOADED, this.#onManifestLoaded.bind(this));
+    this.#instance.on(ctor.events.QUALITY_CHANGE_RENDERED, this.#onQualityChange.bind(this));
+    this.#instance.on(ctor.events.TEXT_TRACKS_ADDED, this.#onTextTracksAdded.bind(this));
+    this.#instance.on(ctor.events.TRACK_CHANGE_RENDERED, this.#onTrackChange.bind(this));
+    this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
+    listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
+    listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
+    this.#stopLiveSync = effect(this.#liveSync.bind(this));
+  }
+  #createDOMEvent(event) {
+    return new DOMEvent(toDOMEventType(event.type), { detail: event });
+  }
+  #liveSync() {
+    if (!this.#ctx.$state.live()) return;
+    const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
+    raf.start();
+    return raf.stop.bind(raf);
+  }
+  #liveSyncPosition() {
+    if (!this.#instance) return;
+    const position = this.#instance.duration() - this.#instance.time();
+    this.#ctx.$state.liveSyncPosition.set(!isNaN(position) ? position : Infinity);
+  }
+  #dispatchDASHEvent(event) {
+    this.#ctx.player?.dispatch(this.#createDOMEvent(event));
+  }
+  #currentTrack = null;
+  #cueTracker = {};
+  #onTextFragmentLoaded(event) {
+    const native = this.#currentTrack?.[TextTrackSymbol.native], cues = (native?.track).cues;
+    if (!native || !cues) return;
+    const id = this.#currentTrack.id, startIndex = this.#cueTracker[id] ?? 0, trigger = this.#createDOMEvent(event);
+    for (let i = startIndex; i < cues.length; i++) {
+      const cue = cues[i];
+      if (!cue.positionAlign) cue.positionAlign = "auto";
+      this.#currentTrack.addCue(cue, trigger);
+    }
+    this.#cueTracker[id] = cues.length;
+  }
+  #onTextTracksAdded(event) {
+    if (!this.#instance) return;
+    const data = event.tracks, nativeTextTracks = [...this.#video.textTracks].filter((track) => "manualMode" in track), trigger = this.#createDOMEvent(event);
+    for (let i = 0; i < nativeTextTracks.length; i++) {
+      const textTrackInfo = data[i], nativeTextTrack = nativeTextTracks[i];
+      const id = `dash-${textTrackInfo.kind}-${i}`, track = new TextTrack({
+        id,
+        label: textTrackInfo?.label ?? textTrackInfo.labels.find((t) => t.text)?.text ?? (textTrackInfo?.lang && getLangName(textTrackInfo.lang)) ?? textTrackInfo?.lang ?? void 0,
+        language: textTrackInfo.lang ?? void 0,
+        kind: textTrackInfo.kind,
+        default: textTrackInfo.defaultTrack
+      });
+      track[TextTrackSymbol.native] = {
+        managed: true,
+        track: nativeTextTrack
+      };
+      track[TextTrackSymbol.readyState] = 2;
+      track[TextTrackSymbol.onModeChange] = () => {
+        if (!this.#instance) return;
+        if (track.mode === "showing") {
+          this.#instance.setTextTrack(i);
+          this.#currentTrack = track;
+        } else {
+          this.#instance.setTextTrack(-1);
+          this.#currentTrack = null;
+        }
+      };
+      this.#ctx.textTracks.add(track, trigger);
+    }
+  }
+  #onTrackChange(event) {
+    const { mediaType, newMediaInfo } = event;
+    if (mediaType === "audio") {
+      const track = this.#ctx.audioTracks.getById(`dash-audio-${newMediaInfo.index}`);
+      if (track) {
+        const trigger = this.#createDOMEvent(event);
+        this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
+      }
+    }
+  }
+  #onQualityChange(event) {
+    if (event.mediaType !== "video") return;
+    const quality = this.#ctx.qualities[event.newQuality];
+    if (quality) {
+      const trigger = this.#createDOMEvent(event);
+      this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+  }
+  #onManifestLoaded(event) {
+    if (this.#ctx.$state.canPlay() || !this.#instance) return;
+    const { type, mediaPresentationDuration } = event.data, trigger = this.#createDOMEvent(event);
+    this.#ctx.notify("stream-type-change", type !== "static" ? "live" : "on-demand", trigger);
+    this.#ctx.notify("duration-change", mediaPresentationDuration, trigger);
+    this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
+    const media = this.#instance.getVideoElement();
+    const videoQualities = this.#instance.getTracksForTypeFromManifest(
+      "video",
+      event.data
+    );
+    const supportedVideoMimeType = [...new Set(videoQualities.map((e) => e.mimeType))].find(
+      (type2) => type2 && canPlayVideoType(media, type2)
+    );
+    const videoQuality = videoQualities.filter(
+      (track) => supportedVideoMimeType === track.mimeType
+    )[0];
+    let audioTracks = this.#instance.getTracksForTypeFromManifest(
+      "audio",
+      event.data
+    );
+    const supportedAudioMimeType = [...new Set(audioTracks.map((e) => e.mimeType))].find(
+      (type2) => type2 && canPlayAudioType(media, type2)
+    );
+    audioTracks = audioTracks.filter((track) => supportedAudioMimeType === track.mimeType);
+    videoQuality.bitrateList.forEach((bitrate, index) => {
+      const quality = {
+        id: bitrate.id?.toString() ?? `dash-bitrate-${index}`,
+        width: bitrate.width ?? 0,
+        height: bitrate.height ?? 0,
+        bitrate: bitrate.bandwidth ?? 0,
+        codec: videoQuality.codec,
+        index
+      };
+      this.#ctx.qualities[ListSymbol.add](quality, trigger);
+    });
+    if (isNumber(videoQuality.index)) {
+      const quality = this.#ctx.qualities[videoQuality.index];
+      if (quality) this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+    audioTracks.forEach((audioTrack, index) => {
+      const matchingLabel = audioTrack.labels.find((label2) => {
+        return navigator.languages.some((language) => {
+          return label2.lang && language.toLowerCase().startsWith(label2.lang.toLowerCase());
+        });
+      });
+      const label = matchingLabel || audioTrack.labels[0];
+      const localTrack = {
+        id: `dash-audio-${audioTrack?.index}`,
+        label: label?.text ?? (audioTrack.lang && getLangName(audioTrack.lang)) ?? audioTrack.lang ?? "",
+        language: audioTrack.lang ?? "",
+        kind: "main",
+        mimeType: audioTrack.mimeType,
+        codec: audioTrack.codec,
+        index
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
+    });
+    media.dispatchEvent(new DOMEvent("canplay", { trigger }));
+  }
+  #onError(event) {
+    const { type: eventType, error: data } = event;
+    switch (data.code) {
+      case 27:
+        this.#onNetworkError(data);
+        break;
+      default:
+        this.#onFatalError(data);
+        break;
+    }
+  }
+  #onFragmentLoadStart() {
+    if (this.#retryLoadingTimer >= 0) this.#clearRetryTimer();
+  }
+  #onFragmentLoadComplete(event) {
+    const mediaType = event.mediaType;
+    if (mediaType === "text") {
+      requestAnimationFrame(this.#onTextFragmentLoaded.bind(this, event));
+    }
+  }
+  #retryLoadingTimer = -1;
+  #onNetworkError(error) {
+    this.#clearRetryTimer();
+    this.#instance?.play();
+    this.#retryLoadingTimer = window.setTimeout(() => {
+      this.#retryLoadingTimer = -1;
+      this.#onFatalError(error);
+    }, 5e3);
+  }
+  #clearRetryTimer() {
+    clearTimeout(this.#retryLoadingTimer);
+    this.#retryLoadingTimer = -1;
+  }
+  #onFatalError(error) {
+    this.#ctx.notify("error", {
+      message: error.message ?? "",
+      code: 1,
+      error
+    });
+  }
+  #enableAutoQuality() {
+    this.#switchAutoBitrate("video", true);
+    const { qualities } = this.#ctx;
+    this.#instance?.setQualityFor("video", qualities.selectedIndex, true);
+  }
+  #switchAutoBitrate(type, auto) {
+    this.#instance?.updateSettings({
+      streaming: { abr: { autoSwitchBitrate: { [type]: auto } } }
+    });
+  }
+  #onUserQualityChange() {
+    const { qualities } = this.#ctx;
+    if (!this.#instance || qualities.auto || !qualities.selected) return;
+    this.#switchAutoBitrate("video", false);
+    this.#instance.setQualityFor("video", qualities.selectedIndex, qualities.switch === "current");
+    if (IS_CHROME) {
+      this.#video.currentTime = this.#video.currentTime;
+    }
+  }
+  #onUserAudioChange() {
+    if (!this.#instance) return;
+    const { audioTracks } = this.#ctx, selectedTrack = this.#instance.getTracksFor("audio").find(
+      (track) => audioTracks.selected && audioTracks.selected.id === `dash-audio-${track.index}`
+    );
+    if (selectedTrack) this.#instance.setCurrentTrack(selectedTrack);
+  }
+  #reset() {
+    this.#clearRetryTimer();
+    this.#currentTrack = null;
+    this.#cueTracker = {};
+  }
+  onInstance(callback) {
+    this.#callbacks.add(callback);
+    return () => this.#callbacks.delete(callback);
+  }
+  loadSource(src) {
+    this.#reset();
+    if (!isString(src.src)) return;
+    this.#instance?.attachSource(src.src);
+  }
+  destroy() {
+    this.#reset();
+    this.#instance?.destroy();
+    this.#instance = null;
+    this.#stopLiveSync?.();
+    this.#stopLiveSync = null;
+  }
+}
+
+function coerceToError(error) {
+  return error instanceof Error ? error : Error(typeof error === "string" ? error : JSON.stringify(error));
+}
+function assert(condition, message) {
+  if (!condition) {
+    throw Error("Assertion failed.");
+  }
+}
+
+class DASHLibLoader {
+  #lib;
+  #ctx;
+  #callback;
+  constructor(lib, ctx, callback) {
+    this.#lib = lib;
+    this.#ctx = ctx;
+    this.#callback = callback;
+    this.#startLoading();
+  }
+  async #startLoading() {
+    const callbacks = {
+      onLoadStart: this.#onLoadStart.bind(this),
+      onLoaded: this.#onLoaded.bind(this),
+      onLoadError: this.#onLoadError.bind(this)
+    };
+    let ctor = await loadDASHScript(this.#lib, callbacks);
+    if (isUndefined(ctor) && !isString(this.#lib)) ctor = await importDASH(this.#lib, callbacks);
+    if (!ctor) return null;
+    if (!window.dashjs.supportsMediaSource()) {
+      const message = "[vidstack] `dash.js` is not supported in this environment";
+      this.#ctx.player.dispatch(new DOMEvent("dash-unsupported"));
+      this.#ctx.notify("error", { message, code: 4 });
+      return null;
+    }
+    return ctor;
+  }
+  #onLoadStart() {
+    this.#ctx.player.dispatch(new DOMEvent("dash-lib-load-start"));
+  }
+  #onLoaded(ctor) {
+    this.#ctx.player.dispatch(
+      new DOMEvent("dash-lib-loaded", {
+        detail: ctor
+      })
+    );
+    this.#callback(ctor);
+  }
+  #onLoadError(e) {
+    const error = coerceToError(e);
+    this.#ctx.player.dispatch(
+      new DOMEvent("dash-lib-load-error", {
+        detail: error
+      })
+    );
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 4,
+      error
+    });
+  }
+}
+async function importDASH(loader, callbacks = {}) {
+  if (isUndefined(loader)) return void 0;
+  callbacks.onLoadStart?.();
+  if (isDASHConstructor(loader)) {
+    callbacks.onLoaded?.(loader);
+    return loader;
+  }
+  if (isDASHNamespace(loader)) {
+    const ctor = loader.MediaPlayer;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  }
+  try {
+    const ctor = (await loader())?.default;
+    if (isDASHNamespace(ctor)) {
+      callbacks.onLoaded?.(ctor.MediaPlayer);
+      return ctor.MediaPlayer;
+    }
+    if (ctor) {
+      callbacks.onLoaded?.(ctor);
+    } else {
+      throw Error(
+        false ? "[vidstack] failed importing `dash.js`. Dynamic import returned invalid object." : ""
+      );
+    }
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+async function loadDASHScript(src, callbacks = {}) {
+  if (!isString(src)) return void 0;
+  callbacks.onLoadStart?.();
+  try {
+    await loadScript(src);
+    if (!isFunction(window.dashjs.MediaPlayer)) {
+      throw Error(
+        false ? "[vidstack] failed loading `dash.js`. Could not find a valid `Dash` constructor on window" : ""
+      );
+    }
+    const ctor = window.dashjs.MediaPlayer;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+function isDASHConstructor(value) {
+  return value && value.prototype && value.prototype !== Function;
+}
+function isDASHNamespace(value) {
+  return value && "MediaPlayer" in value;
+}
+
+const JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
+class DASHProvider extends VideoProvider {
+  $$PROVIDER_TYPE = "DASH";
+  #ctor = null;
+  #controller = new DASHController(this.video, this.ctx);
+  /**
+   * The `dash.js` constructor.
+   */
+  get ctor() {
+    return this.#ctor;
+  }
+  /**
+   * The current `dash.js` instance.
+   */
+  get instance() {
+    return this.#controller.instance;
+  }
+  /**
+   * Whether `dash.js` is supported in this environment.
+   */
+  static supported = isDASHSupported();
+  get type() {
+    return "dash";
+  }
+  get canLiveSync() {
+    return true;
+  }
+  #library = `${JS_DELIVR_CDN}/npm/dashjs@4.7.4/dist/dash${".all.min.js"}`;
+  /**
+   * The `dash.js` configuration object.
+   *
+   * @see {@link https://cdn.dashjs.org/latest/jsdoc/module-Settings.html}
+   */
+  get config() {
+    return this.#controller.config;
+  }
+  set config(config) {
+    this.#controller.config = config;
+  }
+  /**
+   * The `dash.js` constructor (supports dynamic imports) or a URL of where it can be found.
+   *
+   * @defaultValue `https://cdn.jsdelivr.net/npm/dashjs@4.7.4/dist/dash.all.min.js`
+   */
+  get library() {
+    return this.#library;
+  }
+  set library(library) {
+    this.#library = library;
+  }
+  preconnect() {
+    if (!isString(this.#library)) return;
+    preconnect(this.#library);
+  }
+  setup() {
+    super.setup();
+    new DASHLibLoader(this.#library, this.ctx, (ctor) => {
+      this.#ctor = ctor;
+      this.#controller.setup(ctor);
+      this.ctx.notify("provider-setup", this);
+      const src = peek(this.ctx.$state.source);
+      if (src) this.loadSource(src);
+    });
+  }
+  async loadSource(src, preload) {
+    if (!isString(src.src)) {
+      this.removeSource();
+      return;
+    }
+    this.media.preload = preload || "";
+    this.appendSource(src, "application/x-mpegurl");
+    this.#controller.loadSource(src);
+    this.currentSrc = src;
+  }
+  /**
+   * The given callback is invoked when a new `dash.js` instance is created and right before it's
+   * attached to media.
+   */
+  onInstance(callback) {
+    const instance = this.#controller.instance;
+    if (instance) callback(instance);
+    return this.#controller.onInstance(callback);
+  }
+  destroy() {
+    this.#controller.destroy();
+  }
+}
+
+var provider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  DASHProvider: DASHProvider
+});
+
+class DASHProviderLoader extends VideoProviderLoader {
+  static supported = isDASHSupported();
+  name = "dash";
+  canPlay(src) {
+    return DASHProviderLoader.supported && isDASHSrc(src);
+  }
+  async load(context) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load dash provider server-side");
+    }
+    return new (await Promise.resolve().then(function () { return provider; })).DASHProvider(this.target, context);
+  }
+}
+
+class VimeoProviderLoader {
+  name = "vimeo";
+  target;
+  preconnect() {
+    const connections = [
+      "https://i.vimeocdn.com",
+      "https://f.vimeocdn.com",
+      "https://fresnel.vimeocdn.com"
+    ];
+    for (const url of connections) {
+      preconnect(url);
+    }
+  }
+  canPlay(src) {
+    return isString(src.src) && src.type === "video/vimeo";
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load vimeo provider server-side");
+    }
+    return new (await import('./vidstack-DShF5mAU.js')).VimeoProvider(this.target, ctx);
+  }
+  async loadPoster(src, ctx, abort) {
+    const { resolveVimeoVideoId, getVimeoVideoInfo } = await import('./vidstack-krOAtKMi.js');
+    if (!isString(src.src)) return null;
+    const { videoId, hash } = resolveVimeoVideoId(src.src);
+    if (videoId) {
+      return getVimeoVideoInfo(videoId, abort, hash).then((info) => info ? info.poster : null);
+    }
+    return null;
+  }
+}
+
+class YouTubeProviderLoader {
+  name = "youtube";
+  target;
+  preconnect() {
+    const connections = [
+      // Botguard script.
+      "https://www.google.com",
+      // Posters.
+      "https://i.ytimg.com",
+      // Ads.
+      "https://googleads.g.doubleclick.net",
+      "https://static.doubleclick.net"
+    ];
+    for (const url of connections) {
+      preconnect(url);
+    }
+  }
+  canPlay(src) {
+    return isString(src.src) && src.type === "video/youtube";
+  }
+  mediaType() {
+    return "video";
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load youtube provider server-side");
+    }
+    return new (await import('./vidstack-DjW7_-Ze.js')).YouTubeProvider(this.target, ctx);
+  }
+  async loadPoster(src, ctx, abort) {
+    const { findYouTubePoster, resolveYouTubeVideoId } = await import('./vidstack-Zc3I7oOd.js');
+    const videoId = isString(src.src) && resolveYouTubeVideoId(src.src);
+    if (videoId) return findYouTubePoster(videoId, abort);
+    return null;
+  }
+}
+
+function padNumberWithZeroes(num, expectedLength) {
+  const str = String(num);
+  const actualLength = str.length;
+  const shouldPad = actualLength < expectedLength;
+  if (shouldPad) {
+    const padLength = expectedLength - actualLength;
+    const padding = `0`.repeat(padLength);
+    return `${padding}${num}`;
+  }
+  return str;
+}
+function parseTime(duration) {
+  const hours = Math.trunc(duration / 3600);
+  const minutes = Math.trunc(duration % 3600 / 60);
+  const seconds = Math.trunc(duration % 60);
+  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
+  return {
+    hours,
+    minutes,
+    seconds,
+    fraction
+  };
+}
+function formatTime(duration, { padHrs = null, padMins = null, showHrs = false, showMs = false } = {}) {
+  const { hours, minutes, seconds, fraction } = parseTime(duration), paddedHours = padHrs ? padNumberWithZeroes(hours, 2) : hours, paddedMinutes = padMins || isNull(padMins) && duration >= 3600 ? padNumberWithZeroes(minutes, 2) : minutes, paddedSeconds = padNumberWithZeroes(seconds, 2), paddedMs = showMs && fraction > 0 ? `.${String(fraction).replace(/^0?\./, "")}` : "", time = `${paddedMinutes}:${paddedSeconds}${paddedMs}`;
+  return hours > 0 || showHrs ? `${paddedHours}:${time}` : time;
+}
+function formatSpokenTime(duration) {
+  const spokenParts = [];
+  const { hours, minutes, seconds } = parseTime(duration);
+  if (hours > 0) {
+    spokenParts.push(`${hours} hour`);
+  }
+  if (minutes > 0) {
+    spokenParts.push(`${minutes} min`);
+  }
+  if (seconds > 0 || spokenParts.length === 0) {
+    spokenParts.push(`${seconds} sec`);
+  }
+  return spokenParts.join(" ");
+}
+
+const MEDIA_ATTRIBUTES = Symbol(0);
+const mediaAttributes = [
+  "autoPlay",
+  "canAirPlay",
+  "canFullscreen",
+  "canGoogleCast",
+  "canLoad",
+  "canLoadPoster",
+  "canPictureInPicture",
+  "canPlay",
+  "canSeek",
+  "ended",
+  "fullscreen",
+  "isAirPlayConnected",
+  "isGoogleCastConnected",
+  "live",
+  "liveEdge",
+  "loop",
+  "mediaType",
+  "muted",
+  "paused",
+  "pictureInPicture",
+  "playing",
+  "playsInline",
+  "remotePlaybackState",
+  "remotePlaybackType",
+  "seeking",
+  "started",
+  "streamType",
+  "viewType",
+  "waiting"
+];
+
+const mediaPlayerProps = {
+  artist: "",
+  artwork: null,
+  autoplay: false,
+  autoPlay: false,
+  clipStartTime: 0,
+  clipEndTime: 0,
+  controls: false,
+  currentTime: 0,
+  crossorigin: null,
+  crossOrigin: null,
+  duration: -1,
+  fullscreenOrientation: "landscape",
+  googleCast: {},
+  load: "visible",
+  posterLoad: "visible",
+  logLevel: "silent",
+  loop: false,
+  muted: false,
+  paused: true,
+  playsinline: false,
+  playsInline: false,
+  playbackRate: 1,
+  poster: "",
+  preload: "metadata",
+  preferNativeHLS: false,
+  src: "",
+  title: "",
+  controlsDelay: 2e3,
+  hideControlsOnMouseLeave: false,
+  viewType: "unknown",
+  streamType: "unknown",
+  volume: 1,
+  liveEdgeTolerance: 10,
+  minLiveDVRWindow: 60,
+  keyDisabled: false,
+  keyTarget: "player",
+  keyShortcuts: MEDIA_KEY_SHORTCUTS,
+  storage: null
+};
+
+class MediaLoadController extends MediaPlayerController {
+  #type;
+  #callback;
+  constructor(type, callback) {
+    super();
+    this.#type = type;
+    this.#callback = callback;
+  }
+  async onAttach(el) {
+    if (IS_SERVER) return;
+    const load = this.$props[this.#type]();
+    if (load === "eager") {
+      requestAnimationFrame(this.#callback);
+    } else if (load === "idle") {
+      waitIdlePeriod(this.#callback);
+    } else if (load === "visible") {
+      let dispose, observer = new IntersectionObserver((entries) => {
+        if (!this.scope) return;
+        if (entries[0].isIntersecting) {
+          dispose?.();
+          dispose = void 0;
+          this.#callback();
+        }
+      });
+      observer.observe(el);
+      dispose = onDispose(() => observer.disconnect());
+    }
+  }
+}
+
+class MediaPlayerDelegate {
+  #handle;
+  #media;
+  constructor(handle, media) {
+    this.#handle = handle;
+    this.#media = media;
+  }
+  notify(type, ...init) {
+    if (IS_SERVER) return;
+    this.#handle(
+      new DOMEvent(type, {
+        detail: init?.[0],
+        trigger: init?.[1]
+      })
+    );
+  }
+  async ready(info, trigger) {
+    if (IS_SERVER) return;
+    return untrack(async () => {
+      this.#media; const {
+        autoPlay,
+        canPlay,
+        started,
+        duration,
+        seekable,
+        buffered,
+        remotePlaybackInfo,
+        playsInline,
+        savedState,
+        source
+      } = this.#media.$state;
+      if (canPlay()) return;
+      const detail = {
+        duration: info?.duration ?? duration(),
+        seekable: info?.seekable ?? seekable(),
+        buffered: info?.buffered ?? buffered(),
+        provider: this.#media.$provider()
+      };
+      this.notify("can-play", detail, trigger);
+      tick();
+      let provider = this.#media.$provider(), { storage, qualities } = this.#media, { muted, volume, clipStartTime, playbackRate } = this.#media.$props;
+      await storage?.onLoad?.(source());
+      const savedPlaybackTime = savedState()?.currentTime, savedPausedState = savedState()?.paused, storageTime = await storage?.getTime(), startTime = savedPlaybackTime ?? storageTime ?? clipStartTime(), shouldAutoPlay = savedPausedState === false || savedPausedState !== true && !started() && autoPlay();
+      if (provider) {
+        provider.setVolume(await storage?.getVolume() ?? volume());
+        provider.setMuted(muted() || !!await storage?.getMuted());
+        const audioGain = await storage?.getAudioGain() ?? 1;
+        if (audioGain > 1) provider.audioGain?.setGain?.(audioGain);
+        provider.setPlaybackRate?.(await storage?.getPlaybackRate() ?? playbackRate());
+        provider.setPlaysInline?.(playsInline());
+        if (startTime > 0) provider.setCurrentTime(startTime);
+      }
+      const prefQuality = await storage?.getVideoQuality();
+      if (prefQuality && qualities.length) {
+        let currentQuality = null, currentScore = Infinity;
+        for (const quality of qualities) {
+          const score = Math.abs(prefQuality.width - quality.width) + Math.abs(prefQuality.height - quality.height) + (prefQuality.bitrate ? Math.abs(prefQuality.bitrate - (quality.bitrate ?? 0)) : 0);
+          if (score < currentScore) {
+            currentQuality = quality;
+            currentScore = score;
+          }
+        }
+        if (currentQuality) currentQuality.selected = true;
+      }
+      if (canPlay() && shouldAutoPlay) {
+        await this.#attemptAutoplay(trigger);
+      } else if (storageTime && storageTime > 0) {
+        this.notify("started", void 0, trigger);
+      }
+      remotePlaybackInfo.set(null);
+    });
+  }
+  async #attemptAutoplay(trigger) {
+    const {
+      player,
+      $state: { autoPlaying, muted }
+    } = this.#media;
+    autoPlaying.set(true);
+    const attemptEvent = new DOMEvent("auto-play-attempt", { trigger });
+    try {
+      await player.play(attemptEvent);
+    } catch (error) {
+    }
+  }
+}
+
+class Queue {
+  #queue = /* @__PURE__ */ new Map();
+  /**
+   * Queue the given `item` under the given `key` to be processed at a later time by calling
+   * `serve(key)`.
+   */
+  enqueue(key, item) {
+    this.#queue.set(key, item);
+  }
+  /**
+   * Process item in queue for the given `key`.
+   */
+  serve(key) {
+    const value = this.peek(key);
+    this.#queue.delete(key);
+    return value;
+  }
+  /**
+   * Peek at item in queue for the given `key`.
+   */
+  peek(key) {
+    return this.#queue.get(key);
+  }
+  /**
+   * Removes queued item under the given `key`.
+   */
+  delete(key) {
+    this.#queue.delete(key);
+  }
+  /**
+   * Clear all items in the queue.
+   */
+  clear() {
+    this.#queue.clear();
+  }
+}
+
+class RequestQueue {
+  #serving = false;
+  #pending = deferredPromise();
+  #queue = /* @__PURE__ */ new Map();
+  /**
+   * The number of callbacks that are currently in queue.
+   */
+  get size() {
+    return this.#queue.size;
+  }
+  /**
+   * Whether items in the queue are being served immediately, otherwise they're queued to
+   * be processed later.
+   */
+  get isServing() {
+    return this.#serving;
+  }
+  /**
+   * Waits for the queue to be flushed (ie: start serving).
+   */
+  async waitForFlush() {
+    if (this.#serving) return;
+    await this.#pending.promise;
+  }
+  /**
+   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
+   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
+   * then the callback will be invoked immediately.
+   *
+   * @param key - Uniquely identifies this callback so duplicates are ignored.
+   * @param callback - The function to call when this item in the queue is being served.
+   */
+  enqueue(key, callback) {
+    if (this.#serving) {
+      callback();
+      return;
+    }
+    this.#queue.delete(key);
+    this.#queue.set(key, callback);
+  }
+  /**
+   * Invokes the callback with the given `key` in the queue (if it exists).
+   */
+  serve(key) {
+    this.#queue.get(key)?.();
+    this.#queue.delete(key);
+  }
+  /**
+   * Flush all queued items and start serving future requests immediately until `stop()` is called.
+   */
+  start() {
+    this.#flush();
+    this.#serving = true;
+    if (this.#queue.size > 0) this.#flush();
+  }
+  /**
+   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
+   */
+  stop() {
+    this.#serving = false;
+  }
+  /**
+   * Stop serving requests, empty the request queue, and release any promises waiting for the
+   * queue to flush.
+   */
+  reset() {
+    this.stop();
+    this.#queue.clear();
+    this.#release();
+  }
+  #flush() {
+    for (const key of this.#queue.keys()) this.serve(key);
+    this.#release();
+  }
+  #release() {
+    this.#pending.resolve();
+    this.#pending = deferredPromise();
+  }
+}
+
+class MediaRequestManager extends MediaPlayerController {
+  #stateMgr;
+  #request;
+  #media;
+  controls;
+  #fullscreen;
+  #orientation;
+  #$provider;
+  #providerQueue = new RequestQueue();
+  constructor(stateMgr, request, media) {
+    super();
+    this.#stateMgr = stateMgr;
+    this.#request = request;
+    this.#media = media;
+    this.#$provider = media.$provider;
+    this.controls = new MediaControls();
+    this.#fullscreen = new FullscreenController();
+    this.#orientation = new ScreenOrientationController();
+  }
+  onAttach() {
+    this.listen("fullscreen-change", this.#onFullscreenChange.bind(this));
+  }
+  onConnect(el) {
+    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), events = new EventsController(el), handleRequest = this.#handleRequest.bind(this);
+    for (const name of names) {
+      if (name.startsWith("media-")) {
+        events.add(name, handleRequest);
+      }
+    }
+    this.#attachLoadPlayListener();
+    effect(this.#watchProvider.bind(this));
+    effect(this.#watchControlsDelayChange.bind(this));
+    effect(this.#watchAudioGainSupport.bind(this));
+    effect(this.#watchAirPlaySupport.bind(this));
+    effect(this.#watchGoogleCastSupport.bind(this));
+    effect(this.#watchFullscreenSupport.bind(this));
+    effect(this.#watchPiPSupport.bind(this));
+  }
+  onDestroy() {
+    try {
+      const destroyEvent = this.createEvent("destroy"), { pictureInPicture, fullscreen } = this.$state;
+      if (fullscreen()) this.exitFullscreen("prefer-media", destroyEvent);
+      if (pictureInPicture()) this.exitPictureInPicture(destroyEvent);
+    } catch (e) {
+    }
+    this.#providerQueue.reset();
+  }
+  #attachLoadPlayListener() {
+    const { load } = this.$props, { canLoad } = this.$state;
+    if (load() !== "play" || canLoad()) return;
+    const off = this.listen("media-play-request", (event) => {
+      this.#handleLoadPlayStrategy(event);
+      off();
+    });
+  }
+  #watchProvider() {
+    const provider = this.#$provider(), canPlay = this.$state.canPlay();
+    if (provider && canPlay) {
+      this.#providerQueue.start();
+    }
+    return () => {
+      this.#providerQueue.stop();
+    };
+  }
+  #handleRequest(event) {
+    event.stopPropagation();
+    if (event.defaultPrevented) return;
+    if (!this[event.type]) return;
+    if (peek(this.#$provider)) {
+      this[event.type](event);
+    } else {
+      this.#providerQueue.enqueue(event.type, () => {
+        if (peek(this.#$provider)) this[event.type](event);
+      });
+    }
+  }
+  async play(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, paused, autoPlaying } = this.$state;
+    if (this.#handleLoadPlayStrategy(trigger)) return;
+    if (!peek(paused)) return;
+    if (trigger) this.#request.queue.enqueue("media-play-request", trigger);
+    const isAutoPlaying = peek(autoPlaying);
+    try {
+      const provider = peek(this.#$provider);
+      throwIfNotReadyForPlayback(provider, peek(canPlay));
+      return await provider.play();
+    } catch (error) {
+      const errorEvent = this.createEvent("play-fail", {
+        detail: coerceToError(error),
+        trigger
+      });
+      errorEvent.autoPlay = isAutoPlaying;
+      this.#stateMgr.handle(errorEvent);
+      throw error;
+    }
+  }
+  #handleLoadPlayStrategy(trigger) {
+    const { load } = this.$props, { canLoad } = this.$state;
+    if (load() === "play" && !canLoad()) {
+      const event = this.createEvent("media-start-loading", { trigger });
+      this.dispatchEvent(event);
+      this.#providerQueue.enqueue("media-play-request", async () => {
+        try {
+          await this.play(event);
+        } catch (error) {
+        }
+      });
+      return true;
+    }
+    return false;
+  }
+  async pause(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, paused } = this.$state;
+    if (peek(paused)) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-pause-request", trigger);
+    }
+    try {
+      const provider = peek(this.#$provider);
+      throwIfNotReadyForPlayback(provider, peek(canPlay));
+      return await provider.pause();
+    } catch (error) {
+      this.#request.queue.delete("media-pause-request");
+      throw error;
+    }
+  }
+  setAudioGain(gain, trigger) {
+    const { audioGain, canSetAudioGain } = this.$state;
+    if (audioGain() === gain) return;
+    const provider = this.#$provider();
+    if (!provider?.audioGain || !canSetAudioGain()) {
+      throw Error("[vidstack] audio gain api not available");
+    }
+    if (trigger) {
+      this.#request.queue.enqueue("media-audio-gain-change-request", trigger);
+    }
+    provider.audioGain.setGain(gain);
+  }
+  seekToLiveEdge(trigger) {
+    if (IS_SERVER) return;
+    const { canPlay, live, liveEdge, canSeek, liveSyncPosition, seekableEnd, userBehindLiveEdge } = this.$state;
+    userBehindLiveEdge.set(false);
+    if (peek(() => !live() || liveEdge() || !canSeek())) return;
+    const provider = peek(this.#$provider);
+    throwIfNotReadyForPlayback(provider, peek(canPlay));
+    if (trigger) this.#request.queue.enqueue("media-seek-request", trigger);
+    const end = seekableEnd() - 2;
+    provider.setCurrentTime(Math.min(end, liveSyncPosition() ?? end));
+  }
+  #wasPIPActive = false;
+  async enterFullscreen(target = "prefer-media", trigger) {
+    if (IS_SERVER) return;
+    const adapter = this.#getFullscreenAdapter(target);
+    throwIfFullscreenNotSupported(target, adapter);
+    if (adapter.active) return;
+    if (peek(this.$state.pictureInPicture)) {
+      this.#wasPIPActive = true;
+      await this.exitPictureInPicture(trigger);
+    }
+    if (trigger) {
+      this.#request.queue.enqueue("media-enter-fullscreen-request", trigger);
+    }
+    return adapter.enter();
+  }
+  async exitFullscreen(target = "prefer-media", trigger) {
+    if (IS_SERVER) return;
+    const adapter = this.#getFullscreenAdapter(target);
+    throwIfFullscreenNotSupported(target, adapter);
+    if (!adapter.active) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-exit-fullscreen-request", trigger);
+    }
+    try {
+      const result = await adapter.exit();
+      if (this.#wasPIPActive && peek(this.$state.canPictureInPicture)) {
+        await this.enterPictureInPicture();
+      }
+      return result;
+    } finally {
+      this.#wasPIPActive = false;
+    }
+  }
+  #getFullscreenAdapter(target) {
+    const provider = peek(this.#$provider);
+    return target === "prefer-media" && this.#fullscreen.supported || target === "media" ? this.#fullscreen : provider?.fullscreen;
+  }
+  async enterPictureInPicture(trigger) {
+    if (IS_SERVER) return;
+    this.#throwIfPIPNotSupported();
+    if (this.$state.pictureInPicture()) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-enter-pip-request", trigger);
+    }
+    return await this.#$provider().pictureInPicture.enter();
+  }
+  async exitPictureInPicture(trigger) {
+    if (IS_SERVER) return;
+    this.#throwIfPIPNotSupported();
+    if (!this.$state.pictureInPicture()) return;
+    if (trigger) {
+      this.#request.queue.enqueue("media-exit-pip-request", trigger);
+    }
+    return await this.#$provider().pictureInPicture.exit();
+  }
+  #throwIfPIPNotSupported() {
+    if (this.$state.canPictureInPicture()) return;
+    throw Error(
+      "[vidstack] no pip support"
+    );
+  }
+  #watchControlsDelayChange() {
+    this.controls.defaultDelay = this.$props.controlsDelay();
+  }
+  #watchAudioGainSupport() {
+    const { canSetAudioGain } = this.$state, supported = !!this.#$provider()?.audioGain?.supported;
+    canSetAudioGain.set(supported);
+  }
+  #watchAirPlaySupport() {
+    const { canAirPlay } = this.$state, supported = !!this.#$provider()?.airPlay?.supported;
+    canAirPlay.set(supported);
+  }
+  #watchGoogleCastSupport() {
+    const { canGoogleCast, source } = this.$state, supported = IS_CHROME && !IS_IOS && canGoogleCastSrc(source());
+    canGoogleCast.set(supported);
+  }
+  #watchFullscreenSupport() {
+    const { canFullscreen } = this.$state, supported = this.#fullscreen.supported || !!this.#$provider()?.fullscreen?.supported;
+    canFullscreen.set(supported);
+  }
+  #watchPiPSupport() {
+    const { canPictureInPicture } = this.$state, supported = !!this.#$provider()?.pictureInPicture?.supported;
+    canPictureInPicture.set(supported);
+  }
+  async ["media-airplay-request"](event) {
+    try {
+      await this.requestAirPlay(event);
+    } catch (error) {
+    }
+  }
+  async requestAirPlay(trigger) {
+    try {
+      const adapter = this.#$provider()?.airPlay;
+      if (!adapter?.supported) {
+        throw Error(false ? "AirPlay adapter not available on provider." : "No AirPlay adapter.");
+      }
+      if (trigger) {
+        this.#request.queue.enqueue("media-airplay-request", trigger);
+      }
+      return await adapter.prompt();
+    } catch (error) {
+      this.#request.queue.delete("media-airplay-request");
+      throw error;
+    }
+  }
+  async ["media-google-cast-request"](event) {
+    try {
+      await this.requestGoogleCast(event);
+    } catch (error) {
+    }
+  }
+  #googleCastLoader;
+  async requestGoogleCast(trigger) {
+    try {
+      const { canGoogleCast } = this.$state;
+      if (!peek(canGoogleCast)) {
+        const error = Error(
+          false ? "Google Cast not available on this platform." : "Cast not available."
+        );
+        error.code = "CAST_NOT_AVAILABLE";
+        throw error;
+      }
+      preconnect("https://www.gstatic.com");
+      if (!this.#googleCastLoader) {
+        const $module = await import('./vidstack-BQRr1gez.js').then(function (n) { return n.loader; });
+        this.#googleCastLoader = new $module.GoogleCastLoader();
+      }
+      await this.#googleCastLoader.prompt(this.#media);
+      if (trigger) {
+        this.#request.queue.enqueue("media-google-cast-request", trigger);
+      }
+      const isConnecting = peek(this.$state.remotePlaybackState) !== "disconnected";
+      if (isConnecting) {
+        this.$state.savedState.set({
+          paused: peek(this.$state.paused),
+          currentTime: peek(this.$state.currentTime)
+        });
+      }
+      this.$state.remotePlaybackLoader.set(isConnecting ? this.#googleCastLoader : null);
+    } catch (error) {
+      this.#request.queue.delete("media-google-cast-request");
+      throw error;
+    }
+  }
+  ["media-clip-start-change-request"](event) {
+    const { clipStartTime } = this.$state;
+    clipStartTime.set(event.detail);
+  }
+  ["media-clip-end-change-request"](event) {
+    const { clipEndTime } = this.$state;
+    clipEndTime.set(event.detail);
+    this.dispatch("duration-change", {
+      detail: event.detail,
+      trigger: event
+    });
+  }
+  ["media-duration-change-request"](event) {
+    const { providedDuration, clipEndTime } = this.$state;
+    providedDuration.set(event.detail);
+    if (clipEndTime() <= 0) {
+      this.dispatch("duration-change", {
+        detail: event.detail,
+        trigger: event
+      });
+    }
+  }
+  ["media-audio-track-change-request"](event) {
+    const { logger, audioTracks } = this.#media;
+    if (audioTracks.readonly) {
+      return;
+    }
+    const index = event.detail, track = audioTracks[index];
+    if (track) {
+      const key = event.type;
+      this.#request.queue.enqueue(key, event);
+      track.selected = true;
+    }
+  }
+  async ["media-enter-fullscreen-request"](event) {
+    try {
+      await this.enterFullscreen(event.detail, event);
+    } catch (error) {
+      this.#onFullscreenError(error, event);
+    }
+  }
+  async ["media-exit-fullscreen-request"](event) {
+    try {
+      await this.exitFullscreen(event.detail, event);
+    } catch (error) {
+      this.#onFullscreenError(error, event);
+    }
+  }
+  async #onFullscreenChange(event) {
+    const lockType = peek(this.$props.fullscreenOrientation), isFullscreen = event.detail;
+    if (isUndefined(lockType) || lockType === "none" || !this.#orientation.supported) return;
+    if (isFullscreen) {
+      if (this.#orientation.locked) return;
+      this.dispatch("media-orientation-lock-request", {
+        detail: lockType,
+        trigger: event
+      });
+    } else if (this.#orientation.locked) {
+      this.dispatch("media-orientation-unlock-request", {
+        trigger: event
+      });
+    }
+  }
+  #onFullscreenError(error, request) {
+    this.#stateMgr.handle(
+      this.createEvent("fullscreen-error", {
+        detail: coerceToError(error)
+      })
+    );
+  }
+  async ["media-orientation-lock-request"](event) {
+    const key = event.type;
+    try {
+      this.#request.queue.enqueue(key, event);
+      await this.#orientation.lock(event.detail);
+    } catch (error) {
+      this.#request.queue.delete(key);
+    }
+  }
+  async ["media-orientation-unlock-request"](event) {
+    const key = event.type;
+    try {
+      this.#request.queue.enqueue(key, event);
+      await this.#orientation.unlock();
+    } catch (error) {
+      this.#request.queue.delete(key);
+    }
+  }
+  async ["media-enter-pip-request"](event) {
+    try {
+      await this.enterPictureInPicture(event);
+    } catch (error) {
+      this.#onPictureInPictureError(error, event);
+    }
+  }
+  async ["media-exit-pip-request"](event) {
+    try {
+      await this.exitPictureInPicture(event);
+    } catch (error) {
+      this.#onPictureInPictureError(error, event);
+    }
+  }
+  #onPictureInPictureError(error, request) {
+    this.#stateMgr.handle(
+      this.createEvent("picture-in-picture-error", {
+        detail: coerceToError(error)
+      })
+    );
+  }
+  ["media-live-edge-request"](event) {
+    const { live, liveEdge, canSeek } = this.$state;
+    if (!live() || liveEdge() || !canSeek()) return;
+    this.#request.queue.enqueue("media-seek-request", event);
+    try {
+      this.seekToLiveEdge();
+    } catch (error) {
+      this.#request.queue.delete("media-seek-request");
+    }
+  }
+  async ["media-loop-request"](event) {
+    try {
+      this.#request.looping = true;
+      this.#request.replaying = true;
+      await this.play(event);
+    } catch (error) {
+      this.#request.looping = false;
+    }
+  }
+  ["media-user-loop-change-request"](event) {
+    this.$state.userPrefersLoop.set(event.detail);
+  }
+  async ["media-pause-request"](event) {
+    if (this.$state.paused()) return;
+    try {
+      await this.pause(event);
+    } catch (error) {
+    }
+  }
+  async ["media-play-request"](event) {
+    if (!this.$state.paused()) return;
+    try {
+      await this.play(event);
+    } catch (e) {
+    }
+  }
+  ["media-rate-change-request"](event) {
+    const { playbackRate, canSetPlaybackRate } = this.$state;
+    if (playbackRate() === event.detail || !canSetPlaybackRate()) return;
+    const provider = this.#$provider();
+    if (!provider?.setPlaybackRate) return;
+    this.#request.queue.enqueue("media-rate-change-request", event);
+    provider.setPlaybackRate(event.detail);
+  }
+  ["media-audio-gain-change-request"](event) {
+    try {
+      this.setAudioGain(event.detail, event);
+    } catch (e) {
+    }
+  }
+  ["media-quality-change-request"](event) {
+    const { qualities, storage, logger } = this.#media;
+    if (qualities.readonly) {
+      return;
+    }
+    this.#request.queue.enqueue("media-quality-change-request", event);
+    const index = event.detail;
+    if (index < 0) {
+      qualities.autoSelect(event);
+      if (event.isOriginTrusted) storage?.setVideoQuality?.(null);
+    } else {
+      const quality = qualities[index];
+      if (quality) {
+        quality.selected = true;
+        if (event.isOriginTrusted) {
+          storage?.setVideoQuality?.({
+            id: quality.id,
+            width: quality.width,
+            height: quality.height,
+            bitrate: quality.bitrate
+          });
+        }
+      }
+    }
+  }
+  ["media-pause-controls-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.controls.pause(event);
+  }
+  ["media-resume-controls-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.controls.resume(event);
+  }
+  ["media-seek-request"](event) {
+    const { canSeek, ended, live, seekableEnd, userBehindLiveEdge } = this.$state, seekTime = event.detail;
+    if (ended()) this.#request.replaying = true;
+    const key = event.type;
+    this.#request.seeking = false;
+    this.#request.queue.delete(key);
+    const boundedTime = boundTime(seekTime, this.$state);
+    if (!Number.isFinite(boundedTime) || !canSeek()) return;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setCurrentTime(boundedTime);
+    if (live() && event.isOriginTrusted && Math.abs(seekableEnd() - boundedTime) >= 2) {
+      userBehindLiveEdge.set(true);
+    }
+  }
+  ["media-seeking-request"](event) {
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.$state.seeking.set(true);
+    this.#request.seeking = true;
+  }
+  ["media-start-loading"](event) {
+    if (this.$state.canLoad()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#stateMgr.handle(this.createEvent("can-load"));
+  }
+  ["media-poster-start-loading"](event) {
+    if (this.$state.canLoadPoster()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#stateMgr.handle(this.createEvent("can-load-poster"));
+  }
+  ["media-text-track-change-request"](event) {
+    const { index, mode } = event.detail, track = this.#media.textTracks[index];
+    if (track) {
+      const key = event.type;
+      this.#request.queue.enqueue(key, event);
+      track.setMode(mode, event);
+    }
+  }
+  ["media-mute-request"](event) {
+    if (this.$state.muted()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setMuted(true);
+  }
+  ["media-unmute-request"](event) {
+    const { muted, volume } = this.$state;
+    if (!muted()) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#media.$provider().setMuted(false);
+    if (volume() === 0) {
+      this.#request.queue.enqueue(key, event);
+      this.#$provider().setVolume(0.25);
+    }
+  }
+  ["media-volume-change-request"](event) {
+    const { muted, volume } = this.$state;
+    const newVolume = event.detail;
+    if (volume() === newVolume) return;
+    const key = event.type;
+    this.#request.queue.enqueue(key, event);
+    this.#$provider().setVolume(newVolume);
+    if (newVolume > 0 && muted()) {
+      this.#request.queue.enqueue(key, event);
+      this.#$provider().setMuted(false);
+    }
+  }
+  #logError(title, error, request) {
+    return;
+  }
+}
+function throwIfNotReadyForPlayback(provider, canPlay) {
+  if (provider && canPlay) return;
+  throw Error(
+    "[vidstack] media not ready"
+  );
+}
+function throwIfFullscreenNotSupported(target, fullscreen) {
+  if (fullscreen?.supported) return;
+  throw Error(
+    "[vidstack] no fullscreen support"
+  );
+}
+class MediaRequestContext {
+  seeking = false;
+  looping = false;
+  replaying = false;
+  queue = new Queue();
+}
+
+const TRACKED_EVENT = /* @__PURE__ */ new Set([
+  "auto-play",
+  "auto-play-fail",
+  "can-load",
+  "sources-change",
+  "source-change",
+  "load-start",
+  "abort",
+  "error",
+  "loaded-metadata",
+  "loaded-data",
+  "can-play",
+  "play",
+  "play-fail",
+  "pause",
+  "playing",
+  "seeking",
+  "seeked",
+  "waiting"
+]);
+
+class MediaStateManager extends MediaPlayerController {
+  #request;
+  #media;
+  #trackedEvents = /* @__PURE__ */ new Map();
+  #clipEnded = false;
+  #playedIntervals = [];
+  #playedInterval = [-1, -1];
+  #firingWaiting = false;
+  #waitingTrigger;
+  constructor(request, media) {
+    super();
+    this.#request = request;
+    this.#media = media;
+  }
+  onAttach(el) {
+    el.setAttribute("aria-busy", "true");
+    new EventsController(this).add("fullscreen-change", this["fullscreen-change"].bind(this)).add("fullscreen-error", this["fullscreen-error"].bind(this)).add("orientation-change", this["orientation-change"].bind(this));
+  }
+  onConnect(el) {
+    effect(this.#watchCanSetVolume.bind(this));
+    this.#addTextTrackListeners();
+    this.#addQualityListeners();
+    this.#addAudioTrackListeners();
+    this.#resumePlaybackOnConnect();
+    onDispose(this.#pausePlaybackOnDisconnect.bind(this));
+  }
+  onDestroy() {
+    const { audioTracks, qualities, textTracks } = this.#media;
+    audioTracks[ListSymbol.reset]();
+    qualities[ListSymbol.reset]();
+    textTracks[ListSymbol.reset]();
+    this.#stopWatchingQualityResize();
+  }
+  handle(event) {
+    if (!this.scope) return;
+    const type = event.type;
+    untrack(() => this[event.type]?.(event));
+    if (!IS_SERVER) {
+      if (TRACKED_EVENT.has(type)) this.#trackedEvents.set(type, event);
+      this.dispatch(event);
+    }
+  }
+  #isPlayingOnDisconnect = false;
+  #resumePlaybackOnConnect() {
+    if (!this.#isPlayingOnDisconnect) return;
+    requestAnimationFrame(() => {
+      if (!this.scope) return;
+      this.#media.remote.play(new DOMEvent("dom-connect"));
+    });
+    this.#isPlayingOnDisconnect = false;
+  }
+  #pausePlaybackOnDisconnect() {
+    if (this.#isPlayingOnDisconnect) return;
+    this.#isPlayingOnDisconnect = !this.$state.paused();
+    this.#media.$provider()?.pause();
+  }
+  #resetTracking() {
+    this.#stopWaiting();
+    this.#clipEnded = false;
+    this.#request.replaying = false;
+    this.#request.looping = false;
+    this.#firingWaiting = false;
+    this.#waitingTrigger = void 0;
+    this.#trackedEvents.clear();
+  }
+  #satisfyRequest(request, event) {
+    const requestEvent = this.#request.queue.serve(request);
+    if (!requestEvent) return;
+    event.request = requestEvent;
+    event.triggers.add(requestEvent);
+  }
+  #addTextTrackListeners() {
+    this.#onTextTracksChange();
+    this.#onTextTrackModeChange();
+    const textTracks = this.#media.textTracks;
+    new EventsController(textTracks).add("add", this.#onTextTracksChange.bind(this)).add("remove", this.#onTextTracksChange.bind(this)).add("mode-change", this.#onTextTrackModeChange.bind(this));
+  }
+  #addQualityListeners() {
+    const qualities = this.#media.qualities;
+    new EventsController(qualities).add("add", this.#onQualitiesChange.bind(this)).add("remove", this.#onQualitiesChange.bind(this)).add("change", this.#onQualityChange.bind(this)).add("auto-change", this.#onAutoQualityChange.bind(this)).add("readonly-change", this.#onCanSetQualityChange.bind(this));
+  }
+  #addAudioTrackListeners() {
+    const audioTracks = this.#media.audioTracks;
+    new EventsController(audioTracks).add("add", this.#onAudioTracksChange.bind(this)).add("remove", this.#onAudioTracksChange.bind(this)).add("change", this.#onAudioTrackChange.bind(this));
+  }
+  #onTextTracksChange(event) {
+    const { textTracks } = this.$state;
+    textTracks.set(this.#media.textTracks.toArray());
+    this.dispatch("text-tracks-change", {
+      detail: textTracks(),
+      trigger: event
+    });
+  }
+  #onTextTrackModeChange(event) {
+    if (event) this.#satisfyRequest("media-text-track-change-request", event);
+    const current = this.#media.textTracks.selected, { textTrack } = this.$state;
+    if (textTrack() !== current) {
+      textTrack.set(current);
+      this.dispatch("text-track-change", {
+        detail: current,
+        trigger: event
+      });
+    }
+  }
+  #onAudioTracksChange(event) {
+    const { audioTracks } = this.$state;
+    audioTracks.set(this.#media.audioTracks.toArray());
+    this.dispatch("audio-tracks-change", {
+      detail: audioTracks(),
+      trigger: event
+    });
+  }
+  #onAudioTrackChange(event) {
+    const { audioTrack } = this.$state;
+    audioTrack.set(this.#media.audioTracks.selected);
+    if (event) this.#satisfyRequest("media-audio-track-change-request", event);
+    this.dispatch("audio-track-change", {
+      detail: audioTrack(),
+      trigger: event
+    });
+  }
+  #onQualitiesChange(event) {
+    const { qualities } = this.$state;
+    qualities.set(this.#media.qualities.toArray());
+    this.dispatch("qualities-change", {
+      detail: qualities(),
+      trigger: event
+    });
+  }
+  #onQualityChange(event) {
+    const { quality } = this.$state;
+    quality.set(this.#media.qualities.selected);
+    if (event) this.#satisfyRequest("media-quality-change-request", event);
+    this.dispatch("quality-change", {
+      detail: quality(),
+      trigger: event
+    });
+  }
+  #onAutoQualityChange() {
+    const { qualities } = this.#media, isAuto = qualities.auto;
+    this.$state.autoQuality.set(isAuto);
+    if (!isAuto) this.#stopWatchingQualityResize();
+  }
+  #stopQualityResizeEffect = null;
+  #watchQualityResize() {
+    this.#stopWatchingQualityResize();
+    this.#stopQualityResizeEffect = effect(() => {
+      const { qualities } = this.#media, { mediaWidth, mediaHeight } = this.$state, w = mediaWidth(), h = mediaHeight();
+      if (w === 0 || h === 0) return;
+      let selectedQuality = null, minScore = Infinity;
+      for (const quality of qualities) {
+        const score = Math.abs(quality.width - w) + Math.abs(quality.height - h);
+        if (score < minScore) {
+          minScore = score;
+          selectedQuality = quality;
+        }
+      }
+      if (selectedQuality) {
+        qualities[ListSymbol.select](
+          selectedQuality,
+          true,
+          new DOMEvent("resize", { detail: { width: w, height: h } })
+        );
+      }
+    });
+  }
+  #stopWatchingQualityResize() {
+    this.#stopQualityResizeEffect?.();
+    this.#stopQualityResizeEffect = null;
+  }
+  #onCanSetQualityChange() {
+    this.$state.canSetQuality.set(!this.#media.qualities.readonly);
+  }
+  #watchCanSetVolume() {
+    const { canSetVolume, isGoogleCastConnected } = this.$state;
+    if (isGoogleCastConnected()) {
+      canSetVolume.set(false);
+      return;
+    }
+    canChangeVolume().then(canSetVolume.set);
+  }
+  ["provider-change"](event) {
+    const prevProvider = this.#media.$provider(), newProvider = event.detail;
+    if (prevProvider?.type === newProvider?.type) return;
+    prevProvider?.destroy?.();
+    prevProvider?.scope?.dispose();
+    this.#media.$provider.set(event.detail);
+    if (prevProvider && event.detail === null) {
+      this.#resetMediaState(event);
+    }
+  }
+  ["provider-loader-change"](event) {
+  }
+  ["auto-play"](event) {
+    this.$state.autoPlayError.set(null);
+  }
+  ["auto-play-fail"](event) {
+    this.$state.autoPlayError.set(event.detail);
+    this.#resetTracking();
+  }
+  ["can-load"](event) {
+    this.$state.canLoad.set(true);
+    this.#trackedEvents.set("can-load", event);
+    this.#media.textTracks[TextTrackSymbol.canLoad]();
+    this.#satisfyRequest("media-start-loading", event);
+  }
+  ["can-load-poster"](event) {
+    this.$state.canLoadPoster.set(true);
+    this.#trackedEvents.set("can-load-poster", event);
+    this.#satisfyRequest("media-poster-start-loading", event);
+  }
+  ["media-type-change"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const viewType = this.$state.viewType();
+    this.$state.mediaType.set(event.detail);
+    const providedViewType = this.$state.providedViewType(), currentViewType = providedViewType === "unknown" ? event.detail : providedViewType;
+    if (viewType !== currentViewType) {
+      if (IS_SERVER) {
+        this.$state.inferredViewType.set(currentViewType);
+      } else {
+        setTimeout(() => {
+          requestAnimationFrame(() => {
+            if (!this.scope) return;
+            this.$state.inferredViewType.set(event.detail);
+            this.dispatch("view-type-change", {
+              detail: currentViewType,
+              trigger: event
+            });
+          });
+        }, 0);
+      }
+    }
+  }
+  ["stream-type-change"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const { streamType, inferredStreamType } = this.$state;
+    inferredStreamType.set(event.detail);
+    event.detail = streamType();
+  }
+  ["rate-change"](event) {
+    const { storage } = this.#media, { canPlay } = this.$state;
+    this.$state.playbackRate.set(event.detail);
+    this.#satisfyRequest("media-rate-change-request", event);
+    if (canPlay()) {
+      storage?.setPlaybackRate?.(event.detail);
+    }
+  }
+  ["remote-playback-change"](event) {
+    const { remotePlaybackState, remotePlaybackType } = this.$state, { type, state } = event.detail, isConnected = state === "connected";
+    remotePlaybackType.set(type);
+    remotePlaybackState.set(state);
+    const key = type === "airplay" ? "media-airplay-request" : "media-google-cast-request";
+    if (isConnected) {
+      this.#satisfyRequest(key, event);
+    } else {
+      const requestEvent = this.#request.queue.peek(key);
+      if (requestEvent) {
+        event.request = requestEvent;
+        event.triggers.add(requestEvent);
+      }
+    }
+  }
+  ["sources-change"](event) {
+    const prevSources = this.$state.sources(), newSources = event.detail;
+    this.$state.sources.set(newSources);
+    this.#onSourceQualitiesChange(prevSources, newSources, event);
+  }
+  #onSourceQualitiesChange(prevSources, newSources, trigger) {
+    let { qualities } = this.#media, added = false, removed = false;
+    for (const prevSrc of prevSources) {
+      if (!isVideoQualitySrc(prevSrc)) continue;
+      const exists = newSources.some((s) => s.src === prevSrc.src);
+      if (!exists) {
+        const quality = qualities.getBySrc(prevSrc.src);
+        if (quality) {
+          qualities[ListSymbol.remove](quality, trigger);
+          removed = true;
+        }
+      }
+    }
+    if (removed && !qualities.length) {
+      this.$state.savedState.set(null);
+      qualities[ListSymbol.reset](trigger);
+    }
+    for (const src of newSources) {
+      if (!isVideoQualitySrc(src) || qualities.getBySrc(src.src)) continue;
+      const quality = {
+        id: src.id ?? src.height + "p",
+        bitrate: null,
+        codec: null,
+        ...src,
+        selected: false
+      };
+      qualities[ListSymbol.add](quality, trigger);
+      added = true;
+    }
+    if (added && !qualities[QualitySymbol.enableAuto]) {
+      this.#watchQualityResize();
+      qualities[QualitySymbol.enableAuto] = this.#watchQualityResize.bind(this);
+      qualities[QualitySymbol.setAuto](true, trigger);
+    }
+  }
+  ["source-change"](event) {
+    event.isQualityChange = event.originEvent?.type === "quality-change";
+    const source = event.detail;
+    this.#resetMediaState(event, event.isQualityChange);
+    this.#trackedEvents.set(event.type, event);
+    this.$state.source.set(source);
+    this.el?.setAttribute("aria-busy", "true");
+  }
+  #resetMediaState(event, isSourceQualityChange = false) {
+    const { audioTracks, qualities } = this.#media;
+    if (!isSourceQualityChange) {
+      this.#playedIntervals = [];
+      this.#playedInterval = [-1, -1];
+      audioTracks[ListSymbol.reset](event);
+      qualities[ListSymbol.reset](event);
+      softResetMediaState(this.$state, isSourceQualityChange);
+      this.#resetTracking();
+      return;
+    }
+    softResetMediaState(this.$state, isSourceQualityChange);
+    this.#resetTracking();
+  }
+  ["abort"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+    const canLoadEvent = this.#trackedEvents.get("can-load");
+    if (canLoadEvent && !event.triggers.hasType("can-load")) {
+      event.triggers.add(canLoadEvent);
+    }
+  }
+  ["load-start"](event) {
+    const sourceChangeEvent = this.#trackedEvents.get("source-change");
+    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);
+  }
+  ["error"](event) {
+    this.$state.error.set(event.detail);
+    const abortEvent = this.#trackedEvents.get("abort");
+    if (abortEvent) event.triggers.add(abortEvent);
+  }
+  ["loaded-metadata"](event) {
+    const loadStartEvent = this.#trackedEvents.get("load-start");
+    if (loadStartEvent) event.triggers.add(loadStartEvent);
+  }
+  ["loaded-data"](event) {
+    const loadStartEvent = this.#trackedEvents.get("load-start");
+    if (loadStartEvent) event.triggers.add(loadStartEvent);
+  }
+  ["can-play"](event) {
+    const loadedMetadata = this.#trackedEvents.get("loaded-metadata");
+    if (loadedMetadata) event.triggers.add(loadedMetadata);
+    this.#onCanPlayDetail(event.detail);
+    this.el?.setAttribute("aria-busy", "false");
+  }
+  ["can-play-through"](event) {
+    this.#onCanPlayDetail(event.detail);
+    const canPlay = this.#trackedEvents.get("can-play");
+    if (canPlay) event.triggers.add(canPlay);
+  }
+  #onCanPlayDetail(detail) {
+    const { seekable, buffered, intrinsicDuration, canPlay } = this.$state;
+    canPlay.set(true);
+    buffered.set(detail.buffered);
+    seekable.set(detail.seekable);
+    const seekableEnd = getTimeRangesEnd(detail.seekable) ?? Infinity;
+    intrinsicDuration.set(seekableEnd);
+  }
+  ["duration-change"](event) {
+    const { live, intrinsicDuration, providedDuration, clipEndTime, ended } = this.$state, time = event.detail;
+    if (!live()) {
+      const duration = !Number.isNaN(time) ? time : 0;
+      intrinsicDuration.set(duration);
+      if (ended()) this.#onEndPrecisionChange(event);
+    }
+    if (providedDuration() > 0 || clipEndTime() > 0) {
+      event.stopImmediatePropagation();
+    }
+  }
+  ["progress"](event) {
+    const { buffered, seekable } = this.$state, { buffered: newBuffered, seekable: newSeekable } = event.detail, newBufferedEnd = getTimeRangesEnd(newBuffered), hasBufferedLengthChanged = newBuffered.length !== buffered().length, hasBufferedEndChanged = newBufferedEnd !== getTimeRangesEnd(buffered()), newSeekableEnd = getTimeRangesEnd(newSeekable), hasSeekableLengthChanged = newSeekable.length !== seekable().length, hasSeekableEndChanged = newSeekableEnd !== getTimeRangesEnd(seekable());
+    if (hasBufferedLengthChanged || hasBufferedEndChanged) {
+      buffered.set(newBuffered);
+    }
+    if (hasSeekableLengthChanged || hasSeekableEndChanged) {
+      seekable.set(newSeekable);
+    }
+  }
+  ["play"](event) {
+    const {
+      paused,
+      autoPlayError,
+      ended,
+      autoPlaying,
+      playsInline,
+      pointer,
+      muted,
+      viewType,
+      live,
+      userBehindLiveEdge
+    } = this.$state;
+    this.#resetPlaybackIfNeeded();
+    if (!paused()) {
+      event.stopImmediatePropagation();
+      return;
+    }
+    event.autoPlay = autoPlaying();
+    const waitingEvent = this.#trackedEvents.get("waiting");
+    if (waitingEvent) event.triggers.add(waitingEvent);
+    this.#satisfyRequest("media-play-request", event);
+    this.#trackedEvents.set("play", event);
+    paused.set(false);
+    autoPlayError.set(null);
+    if (event.autoPlay) {
+      this.handle(
+        this.createEvent("auto-play", {
+          detail: { muted: muted() },
+          trigger: event
+        })
+      );
+      autoPlaying.set(false);
+    }
+    if (ended() || this.#request.replaying) {
+      this.#request.replaying = false;
+      ended.set(false);
+      this.handle(this.createEvent("replay", { trigger: event }));
+    }
+    if (!playsInline() && viewType() === "video" && pointer() === "coarse") {
+      this.#media.remote.enterFullscreen("prefer-media", event);
+    }
+    if (live() && !userBehindLiveEdge()) {
+      this.#media.remote.seekToLiveEdge(event);
+    }
+  }
+  #resetPlaybackIfNeeded(trigger) {
+    const provider = peek(this.#media.$provider);
+    if (!provider) return;
+    const { ended, seekableStart, clipEndTime, currentTime, realCurrentTime, duration } = this.$state;
+    const shouldReset = ended() || realCurrentTime() < seekableStart() || clipEndTime() > 0 && realCurrentTime() >= clipEndTime() || Math.abs(currentTime() - duration()) < 0.1;
+    if (shouldReset) {
+      this.dispatch("media-seek-request", {
+        detail: seekableStart(),
+        trigger
+      });
+    }
+    return shouldReset;
+  }
+  ["play-fail"](event) {
+    const { muted, autoPlaying } = this.$state;
+    const playEvent = this.#trackedEvents.get("play");
+    if (playEvent) event.triggers.add(playEvent);
+    this.#satisfyRequest("media-play-request", event);
+    const { paused, playing } = this.$state;
+    paused.set(true);
+    playing.set(false);
+    this.#resetTracking();
+    this.#trackedEvents.set("play-fail", event);
+    if (event.autoPlay) {
+      this.handle(
+        this.createEvent("auto-play-fail", {
+          detail: {
+            muted: muted(),
+            error: event.detail
+          },
+          trigger: event
+        })
+      );
+      autoPlaying.set(false);
+    }
+  }
+  ["playing"](event) {
+    const playEvent = this.#trackedEvents.get("play"), seekedEvent = this.#trackedEvents.get("seeked");
+    if (playEvent) event.triggers.add(playEvent);
+    else if (seekedEvent) event.triggers.add(seekedEvent);
+    setTimeout(() => this.#resetTracking(), 0);
+    const {
+      paused,
+      playing,
+      live,
+      liveSyncPosition,
+      seekableEnd,
+      started,
+      currentTime,
+      seeking,
+      ended
+    } = this.$state;
+    paused.set(false);
+    playing.set(true);
+    seeking.set(false);
+    ended.set(false);
+    if (this.#request.looping) {
+      this.#request.looping = false;
+      return;
+    }
+    if (live() && !started() && currentTime() === 0) {
+      const end = liveSyncPosition() ?? seekableEnd() - 2;
+      if (Number.isFinite(end)) this.#media.$provider().setCurrentTime(end);
+    }
+    this["started"](event);
+  }
+  ["started"](event) {
+    const { started } = this.$state;
+    if (!started()) {
+      started.set(true);
+      this.handle(this.createEvent("started", { trigger: event }));
+    }
+  }
+  ["pause"](event) {
+    if (!this.el?.isConnected) {
+      this.#isPlayingOnDisconnect = true;
+    }
+    this.#satisfyRequest("media-pause-request", event);
+    const seekedEvent = this.#trackedEvents.get("seeked");
+    if (seekedEvent) event.triggers.add(seekedEvent);
+    const { paused, playing } = this.$state;
+    paused.set(true);
+    playing.set(false);
+    if (this.#clipEnded) {
+      setTimeout(() => {
+        this.handle(this.createEvent("end", { trigger: event }));
+        this.#clipEnded = false;
+      }, 0);
+    }
+    this.#resetTracking();
+  }
+  ["time-change"](event) {
+    if (this.#request.looping) {
+      event.stopImmediatePropagation();
+      return;
+    }
+    let { waiting, played, clipEndTime, realCurrentTime, currentTime } = this.$state, newTime = event.detail, endTime = clipEndTime();
+    realCurrentTime.set(newTime);
+    this.#updatePlayed();
+    waiting.set(false);
+    for (const track of this.#media.textTracks) {
+      track[TextTrackSymbol.updateActiveCues](newTime, event);
+    }
+    if (endTime > 0 && newTime >= endTime) {
+      this.#clipEnded = true;
+      this.dispatch("media-pause-request", { trigger: event });
+    }
+    this.#saveTime();
+    this.dispatch("time-update", {
+      detail: { currentTime: currentTime(), played: played() },
+      trigger: event
+    });
+  }
+  #updatePlayed() {
+    const { currentTime, played, paused } = this.$state;
+    if (paused()) return;
+    this.#playedInterval = updateTimeIntervals(
+      this.#playedIntervals,
+      this.#playedInterval,
+      currentTime()
+    );
+    played.set(new TimeRange(this.#playedIntervals));
+  }
+  // Called to update time again incase duration precision has changed.
+  #onEndPrecisionChange(trigger) {
+    const { clipStartTime, clipEndTime, duration } = this.$state, isClipped = clipStartTime() > 0 || clipEndTime() > 0;
+    if (isClipped) return;
+    this.handle(
+      this.createEvent("time-change", {
+        detail: duration(),
+        trigger
+      })
+    );
+  }
+  #saveTime() {
+    const { storage } = this.#media, { canPlay, realCurrentTime } = this.$state;
+    if (canPlay()) {
+      storage?.setTime?.(realCurrentTime());
+    }
+  }
+  ["audio-gain-change"](event) {
+    const { storage } = this.#media, { canPlay, audioGain } = this.$state;
+    audioGain.set(event.detail);
+    this.#satisfyRequest("media-audio-gain-change-request", event);
+    if (canPlay()) storage?.setAudioGain?.(audioGain());
+  }
+  ["volume-change"](event) {
+    const { storage } = this.#media, { volume, muted, canPlay } = this.$state, detail = event.detail;
+    volume.set(detail.volume);
+    muted.set(detail.muted || detail.volume === 0);
+    this.#satisfyRequest("media-volume-change-request", event);
+    this.#satisfyRequest(detail.muted ? "media-mute-request" : "media-unmute-request", event);
+    if (canPlay()) {
+      storage?.setVolume?.(volume());
+      storage?.setMuted?.(muted());
+    }
+  }
+  ["seeking"] = functionThrottle(
+    (event) => {
+      const { seeking, realCurrentTime, paused } = this.$state;
+      seeking.set(true);
+      realCurrentTime.set(event.detail);
+      this.#satisfyRequest("media-seeking-request", event);
+      if (paused()) {
+        this.#waitingTrigger = event;
+        this.#fireWaiting();
+      }
+      this.#playedInterval = [-1, -1];
+    },
+    150,
+    { leading: true }
+  );
+  ["seeked"](event) {
+    const { seeking, currentTime, realCurrentTime, paused, seekableEnd, ended, live } = this.$state;
+    if (this.#request.seeking) {
+      seeking.set(true);
+      event.stopImmediatePropagation();
+    } else if (seeking()) {
+      const waitingEvent = this.#trackedEvents.get("waiting");
+      if (waitingEvent) event.triggers.add(waitingEvent);
+      const seekingEvent = this.#trackedEvents.get("seeking");
+      if (seekingEvent && !event.triggers.has(seekingEvent)) {
+        event.triggers.add(seekingEvent);
+      }
+      if (paused()) this.#stopWaiting();
+      seeking.set(false);
+      realCurrentTime.set(event.detail);
+      this.#satisfyRequest("media-seek-request", event);
+      const origin = event?.originEvent;
+      if (origin?.isTrusted && !(origin instanceof MessageEvent) && !/seek/.test(origin.type)) {
+        this["started"](event);
+      }
+    }
+    if (!live()) {
+      if (Math.floor(currentTime()) !== Math.floor(seekableEnd())) {
+        ended.set(false);
+      } else {
+        this.end(event);
+      }
+    }
+  }
+  ["waiting"](event) {
+    if (this.#firingWaiting || this.#request.seeking) return;
+    event.stopImmediatePropagation();
+    this.#waitingTrigger = event;
+    this.#fireWaiting();
+  }
+  #fireWaiting = functionDebounce(() => {
+    if (!this.#waitingTrigger) return;
+    this.#firingWaiting = true;
+    const { waiting, playing } = this.$state;
+    waiting.set(true);
+    playing.set(false);
+    const event = this.createEvent("waiting", { trigger: this.#waitingTrigger });
+    this.#trackedEvents.set("waiting", event);
+    this.dispatch(event);
+    this.#waitingTrigger = void 0;
+    this.#firingWaiting = false;
+  }, 300);
+  ["end"](event) {
+    const { loop, ended } = this.$state;
+    if (!loop() && ended()) return;
+    if (loop()) {
+      setTimeout(() => {
+        requestAnimationFrame(() => {
+          this.#resetPlaybackIfNeeded(event);
+          this.dispatch("media-loop-request", { trigger: event });
+        });
+      }, 10);
+      return;
+    }
+    setTimeout(() => this.#onEnded(event), 0);
+  }
+  #onEnded(event) {
+    const { storage } = this.#media, { paused, seeking, ended, duration } = this.$state;
+    this.#onEndPrecisionChange(event);
+    if (!paused()) {
+      this.dispatch("pause", { trigger: event });
+    }
+    if (seeking()) {
+      this.dispatch("seeked", {
+        detail: duration(),
+        trigger: event
+      });
+    }
+    ended.set(true);
+    this.#resetTracking();
+    storage?.setTime?.(duration(), true);
+    this.dispatch("ended", {
+      trigger: event
+    });
+  }
+  #stopWaiting() {
+    this.#fireWaiting.cancel();
+    this.$state.waiting.set(false);
+  }
+  ["fullscreen-change"](event) {
+    const isFullscreen = event.detail;
+    this.$state.fullscreen.set(isFullscreen);
+    this.#satisfyRequest(
+      isFullscreen ? "media-enter-fullscreen-request" : "media-exit-fullscreen-request",
+      event
+    );
+  }
+  ["fullscreen-error"](event) {
+    this.#satisfyRequest("media-enter-fullscreen-request", event);
+    this.#satisfyRequest("media-exit-fullscreen-request", event);
+  }
+  ["orientation-change"](event) {
+    const isLocked = event.detail.lock;
+    this.#satisfyRequest(
+      isLocked ? "media-orientation-lock-request" : "media-orientation-unlock-request",
+      event
+    );
+  }
+  ["picture-in-picture-change"](event) {
+    const isPiP = event.detail;
+    this.$state.pictureInPicture.set(isPiP);
+    this.#satisfyRequest(isPiP ? "media-enter-pip-request" : "media-exit-pip-request", event);
+  }
+  ["picture-in-picture-error"](event) {
+    this.#satisfyRequest("media-enter-pip-request", event);
+    this.#satisfyRequest("media-exit-pip-request", event);
+  }
+  ["title-change"](event) {
+    if (!event.trigger) return;
+    event.stopImmediatePropagation();
+    this.$state.inferredTitle.set(event.detail);
+  }
+  ["poster-change"](event) {
+    if (!event.trigger) return;
+    event.stopImmediatePropagation();
+    this.$state.inferredPoster.set(event.detail);
+  }
+}
+
+class MediaStateSync extends MediaPlayerController {
+  onSetup() {
+    this.#init();
+    if (IS_SERVER) return;
+    const effects = [
+      this.#watchMetadata,
+      this.#watchAutoplay,
+      this.#watchClipStartTime,
+      this.#watchClipEndTime,
+      this.#watchControls,
+      this.#watchCrossOrigin,
+      this.#watchDuration,
+      this.#watchLive,
+      this.#watchLiveEdge,
+      this.#watchLiveTolerance,
+      this.#watchLoop,
+      this.#watchPlaysInline,
+      this.#watchPoster,
+      this.#watchProvidedTypes,
+      this.#watchTitle
+    ];
+    for (const callback of effects) {
+      effect(callback.bind(this));
+    }
+  }
+  #init() {
+    const providedProps = {
+      duration: "providedDuration",
+      loop: "providedLoop",
+      poster: "providedPoster",
+      streamType: "providedStreamType",
+      title: "providedTitle",
+      viewType: "providedViewType"
+    };
+    const skip = /* @__PURE__ */ new Set([
+      "currentTime",
+      "paused",
+      "playbackRate",
+      "volume"
+    ]);
+    for (const prop of Object.keys(this.$props)) {
+      if (skip.has(prop)) continue;
+      this.$state[providedProps[prop] ?? prop]?.set(this.$props[prop]());
+    }
+    this.$state.muted.set(this.$props.muted() || this.$props.volume() === 0);
+  }
+  // Sync "provided" props with internal state. Provided props are used to differentiate from
+  // provider inferred values.
+  #watchProvidedTypes() {
+    const { viewType, streamType, title, poster, loop } = this.$props, $state = this.$state;
+    $state.providedPoster.set(poster());
+    $state.providedStreamType.set(streamType());
+    $state.providedViewType.set(viewType());
+    $state.providedTitle.set(title());
+    $state.providedLoop.set(loop());
+  }
+  #watchLogLevel() {
+    return;
+  }
+  #watchMetadata() {
+    const { artist, artwork } = this.$props;
+    this.$state.artist.set(artist());
+    this.$state.artwork.set(artwork());
+  }
+  #watchTitle() {
+    const { title } = this.$state;
+    this.dispatch("title-change", { detail: title() });
+  }
+  #watchAutoplay() {
+    const autoPlay = this.$props.autoPlay() || this.$props.autoplay();
+    this.$state.autoPlay.set(autoPlay);
+    this.dispatch("auto-play-change", { detail: autoPlay });
+  }
+  #watchLoop() {
+    const loop = this.$state.loop();
+    this.dispatch("loop-change", { detail: loop });
+  }
+  #watchControls() {
+    const controls = this.$props.controls();
+    this.$state.controls.set(controls);
+  }
+  #watchPoster() {
+    const { poster } = this.$state;
+    this.dispatch("poster-change", { detail: poster() });
+  }
+  #watchCrossOrigin() {
+    const crossOrigin = this.$props.crossOrigin() ?? this.$props.crossorigin(), value = crossOrigin === true ? "" : crossOrigin;
+    this.$state.crossOrigin.set(value);
+  }
+  #watchDuration() {
+    const { duration } = this.$props;
+    this.dispatch("media-duration-change-request", {
+      detail: duration()
+    });
+  }
+  #watchPlaysInline() {
+    const inline = this.$props.playsInline() || this.$props.playsinline();
+    this.$state.playsInline.set(inline);
+    this.dispatch("plays-inline-change", { detail: inline });
+  }
+  #watchClipStartTime() {
+    const { clipStartTime } = this.$props;
+    this.dispatch("media-clip-start-change-request", {
+      detail: clipStartTime()
+    });
+  }
+  #watchClipEndTime() {
+    const { clipEndTime } = this.$props;
+    this.dispatch("media-clip-end-change-request", {
+      detail: clipEndTime()
+    });
+  }
+  #watchLive() {
+    this.dispatch("live-change", { detail: this.$state.live() });
+  }
+  #watchLiveTolerance() {
+    this.$state.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());
+    this.$state.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());
+  }
+  #watchLiveEdge() {
+    this.dispatch("live-edge-change", { detail: this.$state.liveEdge() });
+  }
+}
+
+const actions = ["play", "pause", "seekforward", "seekbackward", "seekto"];
+class NavigatorMediaSession extends MediaPlayerController {
+  onConnect() {
+    effect(this.#onMetadataChange.bind(this));
+    effect(this.#onPlaybackStateChange.bind(this));
+    const handleAction = this.#handleAction.bind(this);
+    for (const action of actions) {
+      navigator.mediaSession.setActionHandler(action, handleAction);
+    }
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  #onDisconnect() {
+    for (const action of actions) {
+      navigator.mediaSession.setActionHandler(action, null);
+    }
+  }
+  #onMetadataChange() {
+    const { title, artist, artwork, poster } = this.$state;
+    navigator.mediaSession.metadata = new MediaMetadata({
+      title: title(),
+      artist: artist(),
+      artwork: artwork() ?? [{ src: poster() }]
+    });
+  }
+  #onPlaybackStateChange() {
+    const { canPlay, paused } = this.$state;
+    navigator.mediaSession.playbackState = !canPlay() ? "none" : paused() ? "paused" : "playing";
+  }
+  #handleAction(details) {
+    const trigger = new DOMEvent(`media-session-action`, { detail: details });
+    switch (details.action) {
+      case "play":
+        this.dispatch("media-play-request", { trigger });
+        break;
+      case "pause":
+        this.dispatch("media-pause-request", { trigger });
+        break;
+      case "seekto":
+      case "seekforward":
+      case "seekbackward":
+        this.dispatch("media-seek-request", {
+          detail: isNumber(details.seekTime) ? details.seekTime : this.$state.currentTime() + (details.seekOffset ?? (details.action === "seekforward" ? 10 : -10)),
+          trigger
+        });
+        break;
+    }
+  }
+}
+
+let $keyboard = signal(false);
+if (!IS_SERVER) {
+  listenEvent(document, "pointerdown", () => {
+    $keyboard.set(false);
+  });
+  listenEvent(document, "keydown", (e) => {
+    if (e.metaKey || e.altKey || e.ctrlKey) return;
+    $keyboard.set(true);
+  });
+}
+class FocusVisibleController extends ViewController {
+  #focused = signal(false);
+  onConnect(el) {
+    effect(() => {
+      const events = new EventsController(el);
+      if (!$keyboard()) {
+        this.#focused.set(false);
+        updateFocusAttr(el, false);
+        events.add("pointerenter", this.#onPointerEnter.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this));
+        return;
+      }
+      const active = document.activeElement === el;
+      this.#focused.set(active);
+      updateFocusAttr(el, active);
+      events.add("focus", this.#onFocus.bind(this)).add("blur", this.#onBlur.bind(this));
+    });
+  }
+  focused() {
+    return this.#focused();
+  }
+  #onFocus() {
+    this.#focused.set(true);
+    updateFocusAttr(this.el, true);
+  }
+  #onBlur() {
+    this.#focused.set(false);
+    updateFocusAttr(this.el, false);
+  }
+  #onPointerEnter() {
+    updateHoverAttr(this.el, true);
+  }
+  #onPointerLeave() {
+    updateHoverAttr(this.el, false);
+  }
+}
+function updateFocusAttr(el, isFocused) {
+  setAttribute(el, "data-focus", isFocused);
+  setAttribute(el, "data-hocus", isFocused);
+}
+function updateHoverAttr(el, isHovering) {
+  setAttribute(el, "data-hocus", isHovering);
+  setAttribute(el, "data-hover", isHovering);
+}
+
+class MediaPlayer extends Component {
+  static props = mediaPlayerProps;
+  static state = mediaState;
+  #media;
+  #stateMgr;
+  #requestMgr;
+  canPlayQueue = new RequestQueue();
+  remoteControl;
+  get #provider() {
+    return this.#media.$provider();
+  }
+  get #props() {
+    return this.$props;
+  }
+  constructor() {
+    super();
+    new MediaStateSync();
+    const context = {
+      player: this,
+      qualities: new VideoQualityList(),
+      audioTracks: new AudioTrackList(),
+      storage: null,
+      $provider: signal(null),
+      $providerSetup: signal(false),
+      $props: this.$props,
+      $state: this.$state
+    };
+    context.remote = this.remoteControl = new MediaRemoteControl(
+      void 0
+    );
+    context.remote.setPlayer(this);
+    context.textTracks = new TextTrackList();
+    context.textTracks[TextTrackSymbol.crossOrigin] = this.$state.crossOrigin;
+    context.textRenderers = new TextRenderers(context);
+    context.ariaKeys = {};
+    this.#media = context;
+    provideContext(mediaContext, context);
+    this.orientation = new ScreenOrientationController();
+    new FocusVisibleController();
+    new MediaKeyboardController(context);
+    const request = new MediaRequestContext();
+    this.#stateMgr = new MediaStateManager(request, context);
+    this.#requestMgr = new MediaRequestManager(this.#stateMgr, request, context);
+    context.delegate = new MediaPlayerDelegate(this.#stateMgr.handle.bind(this.#stateMgr), context);
+    context.notify = context.delegate.notify.bind(context.delegate);
+    if (typeof navigator !== "undefined" && "mediaSession" in navigator) {
+      new NavigatorMediaSession();
+    }
+    new MediaLoadController("load", this.startLoading.bind(this));
+    new MediaLoadController("posterLoad", this.startLoadingPoster.bind(this));
+  }
+  onSetup() {
+    this.#setupMediaAttributes();
+    effect(this.#watchCanPlay.bind(this));
+    effect(this.#watchMuted.bind(this));
+    effect(this.#watchPaused.bind(this));
+    effect(this.#watchVolume.bind(this));
+    effect(this.#watchCurrentTime.bind(this));
+    effect(this.#watchPlaysInline.bind(this));
+    effect(this.#watchPlaybackRate.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-player", "");
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "region");
+    effect(this.#watchStorage.bind(this));
+    if (IS_SERVER) this.#watchTitle();
+    else effect(this.#watchTitle.bind(this));
+    if (IS_SERVER) this.#watchOrientation();
+    else effect(this.#watchOrientation.bind(this));
+    listenEvent(el, "find-media-player", this.#onFindPlayer.bind(this));
+  }
+  onConnect(el) {
+    if (IS_IPHONE) setAttribute(el, "data-iphone", "");
+    const pointerQuery = window.matchMedia("(pointer: coarse)");
+    this.#onPointerChange(pointerQuery);
+    pointerQuery.onchange = this.#onPointerChange.bind(this);
+    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
+    resize.observe(el);
+    effect(this.#onResize.bind(this));
+    this.dispatch("media-player-connect", {
+      detail: this,
+      bubbles: true,
+      composed: true
+    });
+    onDispose(() => {
+      resize.disconnect();
+      pointerQuery.onchange = null;
+    });
+  }
+  onDestroy() {
+    this.#media.player = null;
+    this.canPlayQueue.reset();
+  }
+  #skipTitleUpdate = false;
+  #watchTitle() {
+    const el = this.$el, { title, live, viewType, providedTitle } = this.$state, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media", currentTitle = title();
+    setAttribute(
+      this.el,
+      "aria-label",
+      `${typeText} Player` + (currentTitle ? ` - ${currentTitle}` : "")
+    );
+    if (!IS_SERVER && el?.hasAttribute("title")) {
+      this.#skipTitleUpdate = true;
+      el?.removeAttribute("title");
+    }
+  }
+  #watchOrientation() {
+    const orientation = this.orientation.landscape ? "landscape" : "portrait";
+    this.$state.orientation.set(orientation);
+    setAttribute(this.el, "data-orientation", orientation);
+    this.#onResize();
+  }
+  #watchCanPlay() {
+    if (this.$state.canPlay() && this.#provider) this.canPlayQueue.start();
+    else this.canPlayQueue.stop();
+  }
+  #setupMediaAttributes() {
+    if (MediaPlayer[MEDIA_ATTRIBUTES]) {
+      this.setAttributes(MediaPlayer[MEDIA_ATTRIBUTES]);
+      return;
+    }
+    const $attrs = {
+      "data-load": function() {
+        return this.$props.load();
+      },
+      "data-captions": function() {
+        const track = this.$state.textTrack();
+        return !!track && isTrackCaptionKind(track);
+      },
+      "data-ios-controls": function() {
+        return this.$state.iOSControls();
+      },
+      "data-controls": function() {
+        return this.controls.showing;
+      },
+      "data-buffering": function() {
+        const { canLoad, canPlay, waiting } = this.$state;
+        return canLoad() && (!canPlay() || waiting());
+      },
+      "data-error": function() {
+        const { error } = this.$state;
+        return !!error();
+      },
+      "data-autoplay-error": function() {
+        const { autoPlayError } = this.$state;
+        return !!autoPlayError();
+      }
+    };
+    const alias = {
+      autoPlay: "autoplay",
+      canAirPlay: "can-airplay",
+      canPictureInPicture: "can-pip",
+      pictureInPicture: "pip",
+      playsInline: "playsinline",
+      remotePlaybackState: "remote-state",
+      remotePlaybackType: "remote-type",
+      isAirPlayConnected: "airplay",
+      isGoogleCastConnected: "google-cast"
+    };
+    for (const prop2 of mediaAttributes) {
+      const attrName = "data-" + (alias[prop2] ?? camelToKebabCase(prop2));
+      $attrs[attrName] = function() {
+        return this.$state[prop2]();
+      };
+    }
+    delete $attrs.title;
+    MediaPlayer[MEDIA_ATTRIBUTES] = $attrs;
+    this.setAttributes($attrs);
+  }
+  #onFindPlayer(event) {
+    event.detail(this);
+  }
+  #onResize() {
+    if (IS_SERVER || !this.el) return;
+    const width = this.el.clientWidth, height = this.el.clientHeight;
+    this.$state.width.set(width);
+    this.$state.height.set(height);
+    setStyle(this.el, "--player-width", width + "px");
+    setStyle(this.el, "--player-height", height + "px");
+  }
+  #onPointerChange(queryList) {
+    if (IS_SERVER) return;
+    const pointer = queryList.matches ? "coarse" : "fine";
+    setAttribute(this.el, "data-pointer", pointer);
+    this.$state.pointer.set(pointer);
+    this.#onResize();
+  }
+  /**
+   * The current media provider.
+   */
+  get provider() {
+    return this.#provider;
+  }
+  /**
+   * Media controls settings.
+   */
+  get controls() {
+    return this.#requestMgr.controls;
+  }
+  set controls(controls) {
+    this.#props.controls.set(controls);
+  }
+  /**
+   * Controls the screen orientation of the current browser window and dispatches orientation
+   * change events on the player.
+   */
+  orientation;
+  /**
+   * The title of the current media.
+   */
+  get title() {
+    return peek(this.$state.title);
+  }
+  set title(newTitle) {
+    if (this.#skipTitleUpdate) {
+      this.#skipTitleUpdate = false;
+      return;
+    }
+    this.#props.title.set(newTitle);
+  }
+  /**
+   * A list of all `VideoQuality` objects representing the set of available video renditions.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/video-quality}
+   */
+  get qualities() {
+    return this.#media.qualities;
+  }
+  /**
+   * A list of all `AudioTrack` objects representing the set of available audio tracks.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/audio-tracks}
+   */
+  get audioTracks() {
+    return this.#media.audioTracks;
+  }
+  /**
+   * A list of all `TextTrack` objects representing the set of available text tracks.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/text-tracks}
+   */
+  get textTracks() {
+    return this.#media.textTracks;
+  }
+  /**
+   * Contains text renderers which are responsible for loading, parsing, and rendering text
+   * tracks.
+   */
+  get textRenderers() {
+    return this.#media.textRenderers;
+  }
+  get duration() {
+    return this.$state.duration();
+  }
+  set duration(duration) {
+    this.#props.duration.set(duration);
+  }
+  get paused() {
+    return peek(this.$state.paused);
+  }
+  set paused(paused) {
+    this.#queuePausedUpdate(paused);
+  }
+  #watchPaused() {
+    this.#queuePausedUpdate(this.$props.paused());
+  }
+  #queuePausedUpdate(paused) {
+    if (paused) {
+      this.canPlayQueue.enqueue("paused", () => this.#requestMgr.pause());
+    } else this.canPlayQueue.enqueue("paused", () => this.#requestMgr.play());
+  }
+  get muted() {
+    return peek(this.$state.muted);
+  }
+  set muted(muted) {
+    this.#queueMutedUpdate(muted);
+  }
+  #watchMuted() {
+    this.#queueMutedUpdate(this.$props.muted());
+  }
+  #queueMutedUpdate(muted) {
+    this.canPlayQueue.enqueue("muted", () => {
+      if (this.#provider) this.#provider.setMuted(muted);
+    });
+  }
+  get currentTime() {
+    return peek(this.$state.currentTime);
+  }
+  set currentTime(time) {
+    this.#queueCurrentTimeUpdate(time);
+  }
+  #watchCurrentTime() {
+    this.#queueCurrentTimeUpdate(this.$props.currentTime());
+  }
+  #queueCurrentTimeUpdate(time) {
+    this.canPlayQueue.enqueue("currentTime", () => {
+      const { currentTime } = this.$state;
+      if (time === peek(currentTime)) return;
+      peek(() => {
+        if (!this.#provider) return;
+        const boundedTime = boundTime(time, this.$state);
+        if (Number.isFinite(boundedTime)) {
+          this.#provider.setCurrentTime(boundedTime);
+        }
+      });
+    });
+  }
+  get volume() {
+    return peek(this.$state.volume);
+  }
+  set volume(volume) {
+    this.#queueVolumeUpdate(volume);
+  }
+  #watchVolume() {
+    this.#queueVolumeUpdate(this.$props.volume());
+  }
+  #queueVolumeUpdate(volume) {
+    const clampedVolume = clampNumber(0, volume, 1);
+    this.canPlayQueue.enqueue("volume", () => {
+      if (this.#provider) this.#provider.setVolume(clampedVolume);
+    });
+  }
+  get playbackRate() {
+    return peek(this.$state.playbackRate);
+  }
+  set playbackRate(rate) {
+    this.#queuePlaybackRateUpdate(rate);
+  }
+  #watchPlaybackRate() {
+    this.#queuePlaybackRateUpdate(this.$props.playbackRate());
+  }
+  #queuePlaybackRateUpdate(rate) {
+    this.canPlayQueue.enqueue("rate", () => {
+      if (this.#provider) this.#provider.setPlaybackRate?.(rate);
+    });
+  }
+  #watchPlaysInline() {
+    this.#queuePlaysInlineUpdate(this.$props.playsInline());
+  }
+  #queuePlaysInlineUpdate(inline) {
+    this.canPlayQueue.enqueue("playsinline", () => {
+      if (this.#provider) this.#provider.setPlaysInline?.(inline);
+    });
+  }
+  #watchStorage() {
+    let storageValue = this.$props.storage(), storage = isString(storageValue) ? new LocalMediaStorage() : storageValue;
+    if (storage?.onChange) {
+      const { source } = this.$state, playerId = isString(storageValue) ? storageValue : this.el?.id, mediaId = computed(this.#computeMediaId.bind(this));
+      effect(() => storage.onChange(source(), mediaId(), playerId || void 0));
+    }
+    this.#media.storage = storage;
+    this.#media.textTracks.setStorage(storage);
+    onDispose(() => {
+      storage?.onDestroy?.();
+      this.#media.storage = null;
+      this.#media.textTracks.setStorage(null);
+    });
+  }
+  #computeMediaId() {
+    const { clipStartTime, clipEndTime } = this.$props, { source } = this.$state, src = source();
+    return src.src ? `${src.src}:${clipStartTime()}:${clipEndTime()}` : null;
+  }
+  /**
+   * Begins/resumes playback of the media. If this method is called programmatically before the
+   * user has interacted with the player, the promise may be rejected subject to the browser's
+   * autoplay policies. This method will throw if called before media is ready for playback.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play}
+   */
+  async play(trigger) {
+    return this.#requestMgr.play(trigger);
+  }
+  /**
+   * Pauses playback of the media. This method will throw if called before media is ready for
+   * playback.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause}
+   */
+  async pause(trigger) {
+    return this.#requestMgr.pause(trigger);
+  }
+  /**
+   * Attempts to display the player in fullscreen. The promise will resolve if successful, and
+   * reject if not. This method will throw if any fullscreen API is _not_ currently available.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/fullscreen}
+   */
+  async enterFullscreen(target, trigger) {
+    return this.#requestMgr.enterFullscreen(target, trigger);
+  }
+  /**
+   * Attempts to display the player inline by exiting fullscreen. This method will throw if any
+   * fullscreen API is _not_ currently available.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/fullscreen}
+   */
+  async exitFullscreen(target, trigger) {
+    return this.#requestMgr.exitFullscreen(target, trigger);
+  }
+  /**
+   * Attempts to display the player in picture-in-picture mode. This method will throw if PIP is
+   * not supported. This method will also return a `PictureInPictureWindow` if the current
+   * provider supports it.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
+   */
+  enterPictureInPicture(trigger) {
+    return this.#requestMgr.enterPictureInPicture(trigger);
+  }
+  /**
+   * Attempts to display the player in inline by exiting picture-in-picture mode. This method
+   * will throw if not supported.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
+   */
+  exitPictureInPicture(trigger) {
+    return this.#requestMgr.exitPictureInPicture(trigger);
+  }
+  /**
+   * Sets the current time to the live edge (i.e., `duration`). This is a no-op for non-live
+   * streams and will throw if called before media is ready for playback.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/live}
+   */
+  seekToLiveEdge(trigger) {
+    this.#requestMgr.seekToLiveEdge(trigger);
+  }
+  /**
+   * Called when media can begin loading. Calling this method will trigger the initial provider
+   * loading process. Calling it more than once has no effect.
+   *
+   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoading(trigger) {
+    this.#media.notify("can-load", void 0, trigger);
+  }
+  /**
+   * Called when the poster image can begin loading. Calling it more than once has no effect.
+   *
+   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
+   */
+  startLoadingPoster(trigger) {
+    this.#media.notify("can-load-poster", void 0, trigger);
+  }
+  /**
+   * Request Apple AirPlay picker to open.
+   */
+  requestAirPlay(trigger) {
+    return this.#requestMgr.requestAirPlay(trigger);
+  }
+  /**
+   * Request Google Cast device picker to open. The Google Cast framework will be loaded if it
+   * hasn't yet.
+   */
+  requestGoogleCast(trigger) {
+    return this.#requestMgr.requestGoogleCast(trigger);
+  }
+  /**
+   * Set the audio gain, amplifying volume and enabling a maximum volume above 100%.
+   *
+   * @see {@link https://vidstack.io/docs/player/api/audio-gain}
+   */
+  setAudioGain(gain, trigger) {
+    return this.#requestMgr.setAudioGain(gain, trigger);
+  }
+  destroy() {
+    super.destroy();
+    this.#media.remote.setPlayer(null);
+    this.dispatch("destroy");
+  }
+}
+const mediaplayer__proto = MediaPlayer.prototype;
+prop(mediaplayer__proto, "canPlayQueue");
+prop(mediaplayer__proto, "remoteControl");
+prop(mediaplayer__proto, "provider");
+prop(mediaplayer__proto, "controls");
+prop(mediaplayer__proto, "orientation");
+prop(mediaplayer__proto, "title");
+prop(mediaplayer__proto, "qualities");
+prop(mediaplayer__proto, "audioTracks");
+prop(mediaplayer__proto, "textTracks");
+prop(mediaplayer__proto, "textRenderers");
+prop(mediaplayer__proto, "duration");
+prop(mediaplayer__proto, "paused");
+prop(mediaplayer__proto, "muted");
+prop(mediaplayer__proto, "currentTime");
+prop(mediaplayer__proto, "volume");
+prop(mediaplayer__proto, "playbackRate");
+method(mediaplayer__proto, "play");
+method(mediaplayer__proto, "pause");
+method(mediaplayer__proto, "enterFullscreen");
+method(mediaplayer__proto, "exitFullscreen");
+method(mediaplayer__proto, "enterPictureInPicture");
+method(mediaplayer__proto, "exitPictureInPicture");
+method(mediaplayer__proto, "seekToLiveEdge");
+method(mediaplayer__proto, "startLoading");
+method(mediaplayer__proto, "startLoadingPoster");
+method(mediaplayer__proto, "requestAirPlay");
+method(mediaplayer__proto, "requestGoogleCast");
+method(mediaplayer__proto, "setAudioGain");
+
+function resolveStreamTypeFromDASHManifest(manifestSrc, requestInit) {
+  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
+    return /type="static"/.test(manifest) ? "on-demand" : "live";
+  });
+}
+function resolveStreamTypeFromHLSManifest(manifestSrc, requestInit) {
+  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
+    const renditionURI = resolveHLSRenditionURI(manifest);
+    if (renditionURI) {
+      return resolveStreamTypeFromHLSManifest(
+        /^https?:/.test(renditionURI) ? renditionURI : new URL(renditionURI, manifestSrc).href,
+        requestInit
+      );
+    }
+    const streamType = /EXT-X-PLAYLIST-TYPE:\s*VOD/.test(manifest) ? "on-demand" : "live";
+    if (streamType === "live" && resolveTargetDuration(manifest) >= 10 && (/#EXT-X-DVR-ENABLED:\s*true/.test(manifest) || manifest.includes("#EXT-X-DISCONTINUITY"))) {
+      return "live:dvr";
+    }
+    return streamType;
+  });
+}
+function resolveHLSRenditionURI(manifest) {
+  const matches = manifest.match(/#EXT-X-STREAM-INF:[^\n]+(\n[^\n]+)*/g);
+  return matches ? matches[0].split("\n")[1].trim() : null;
+}
+function resolveTargetDuration(manifest) {
+  const lines = manifest.split("\n");
+  for (const line of lines) {
+    if (line.startsWith("#EXT-X-TARGETDURATION")) {
+      const duration = parseFloat(line.split(":")[1]);
+      if (!isNaN(duration)) {
+        return duration;
+      }
+    }
+  }
+  return -1;
+}
+
+const sourceTypes = /* @__PURE__ */ new Map();
+class SourceSelection {
+  #initialize = false;
+  #loaders;
+  #domSources;
+  #media;
+  #loader;
+  constructor(domSources, media, loader, customLoaders = []) {
+    this.#domSources = domSources;
+    this.#media = media;
+    this.#loader = loader;
+    const DASH_LOADER = new DASHProviderLoader(), HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader(), YOUTUBE_LOADER = new YouTubeProviderLoader(), VIMEO_LOADER = new VimeoProviderLoader(), EMBED_LOADERS = [YOUTUBE_LOADER, VIMEO_LOADER];
+    this.#loaders = computed(() => {
+      const remoteLoader = media.$state.remotePlaybackLoader();
+      const loaders = media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, HLS_LOADER, ...EMBED_LOADERS, ...customLoaders] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, ...EMBED_LOADERS, ...customLoaders];
+      return remoteLoader ? [remoteLoader, ...loaders] : loaders;
+    });
+    const { $state } = media;
+    $state.sources.set(normalizeSrc(media.$props.src()));
+    for (const src of $state.sources()) {
+      const loader2 = this.#loaders().find((loader3) => loader3.canPlay(src));
+      if (!loader2) continue;
+      const mediaType = loader2.mediaType(src);
+      media.$state.source.set(src);
+      media.$state.mediaType.set(mediaType);
+      media.$state.inferredViewType.set(mediaType);
+      this.#loader.set(loader2);
+      this.#initialize = true;
+      break;
+    }
+  }
+  connect() {
+    const loader = this.#loader();
+    if (this.#initialize) {
+      this.#notifySourceChange(this.#media.$state.source(), loader);
+      this.#notifyLoaderChange(loader);
+      this.#initialize = false;
+    }
+    effect(this.#onSourcesChange.bind(this));
+    effect(this.#onSourceChange.bind(this));
+    effect(this.#onSetup.bind(this));
+    effect(this.#onLoadSource.bind(this));
+    effect(this.#onLoadPoster.bind(this));
+  }
+  #onSourcesChange() {
+    this.#media.notify("sources-change", [
+      ...normalizeSrc(this.#media.$props.src()),
+      ...this.#domSources()
+    ]);
+  }
+  #onSourceChange() {
+    const { $state } = this.#media;
+    const sources = $state.sources(), currentSource = peek($state.source), newSource = this.#findNewSource(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;
+    if (noMatch) {
+      const { crossOrigin } = $state, credentials = getRequestCredentials(crossOrigin()), abort = new AbortController();
+      Promise.all(
+        sources.map(
+          (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
+            method: "HEAD",
+            credentials,
+            signal: abort.signal
+          }).then((res) => {
+            source.type = res.headers.get("content-type") || "??";
+            sourceTypes.set(source.src, source.type);
+            return source;
+          }).catch(() => source) : source
+        )
+      ).then((sources2) => {
+        if (abort.signal.aborted) return;
+        const newSource2 = this.#findNewSource(peek($state.source), sources2);
+        tick();
+        if (!newSource2.src) {
+          this.#media.notify("error", {
+            message: "Failed to load resource.",
+            code: 4
+          });
+        }
+      });
+      return () => abort.abort();
+    }
+    tick();
+  }
+  #findNewSource(currentSource, sources) {
+    let newSource = { src: "", type: "" }, newLoader = null, triggerEvent = new DOMEvent("sources-change", { detail: { sources } }), loaders = this.#loaders(), { started, paused, currentTime, quality, savedState } = this.#media.$state;
+    for (const src of sources) {
+      const loader = loaders.find((loader2) => loader2.canPlay(src));
+      if (loader) {
+        newSource = src;
+        newLoader = loader;
+        break;
+      }
+    }
+    if (isVideoQualitySrc(newSource)) {
+      const currentQuality = quality(), sourceQuality = sources.find((s) => s.src === currentQuality?.src);
+      if (peek(started)) {
+        savedState.set({
+          paused: peek(paused),
+          currentTime: peek(currentTime)
+        });
+      } else {
+        savedState.set(null);
+      }
+      if (sourceQuality) {
+        newSource = sourceQuality;
+        triggerEvent = new DOMEvent("quality-change", {
+          detail: { quality: currentQuality }
+        });
+      }
+    }
+    if (!isSameSrc(currentSource, newSource)) {
+      this.#notifySourceChange(newSource, newLoader, triggerEvent);
+    }
+    if (newLoader !== peek(this.#loader)) {
+      this.#notifyLoaderChange(newLoader, triggerEvent);
+    }
+    return newSource;
+  }
+  #notifySourceChange(src, loader, trigger) {
+    this.#media.notify("source-change", src, trigger);
+    this.#media.notify("media-type-change", loader?.mediaType(src) || "unknown", trigger);
+  }
+  #notifyLoaderChange(loader, trigger) {
+    this.#media.$providerSetup.set(false);
+    this.#media.notify("provider-change", null, trigger);
+    loader && peek(() => loader.preconnect?.(this.#media));
+    this.#loader.set(loader);
+    this.#media.notify("provider-loader-change", loader, trigger);
+  }
+  #onSetup() {
+    const provider = this.#media.$provider();
+    if (!provider || peek(this.#media.$providerSetup)) return;
+    if (this.#media.$state.canLoad()) {
+      scoped(() => provider.setup(), provider.scope);
+      this.#media.$providerSetup.set(true);
+      return;
+    }
+    peek(() => provider.preconnect?.());
+  }
+  #onLoadSource() {
+    if (!this.#media.$providerSetup()) return;
+    const provider = this.#media.$provider(), source = this.#media.$state.source(), crossOrigin = peek(this.#media.$state.crossOrigin), preferNativeHLS = peek(this.#media.$props.preferNativeHLS);
+    if (isSameSrc(provider?.currentSrc, source)) {
+      return;
+    }
+    if (this.#media.$state.canLoad()) {
+      const abort = new AbortController();
+      if (isHLSSrc(source)) {
+        if (preferNativeHLS || !isHLSSupported()) {
+          resolveStreamTypeFromHLSManifest(source.src, {
+            credentials: getRequestCredentials(crossOrigin),
+            signal: abort.signal
+          }).then((streamType) => {
+            this.#media.notify("stream-type-change", streamType);
+          }).catch(noop);
+        }
+      } else if (isDASHSrc(source)) {
+        resolveStreamTypeFromDASHManifest(source.src, {
+          credentials: getRequestCredentials(crossOrigin),
+          signal: abort.signal
+        }).then((streamType) => {
+          this.#media.notify("stream-type-change", streamType);
+        }).catch(noop);
+      } else {
+        this.#media.notify("stream-type-change", "on-demand");
+      }
+      peek(() => {
+        const preload = peek(this.#media.$state.preload);
+        return provider?.loadSource(source, preload).catch((error) => {
+        });
+      });
+      return () => abort.abort();
+    }
+    try {
+      isString(source.src) && preconnect(new URL(source.src).origin);
+    } catch (error) {
+    }
+  }
+  #onLoadPoster() {
+    const loader = this.#loader(), { providedPoster, source, canLoadPoster } = this.#media.$state;
+    if (!loader || !loader.loadPoster || !source() || !canLoadPoster() || providedPoster()) return;
+    const abort = new AbortController(), trigger = new DOMEvent("source-change", { detail: source });
+    loader.loadPoster(source(), this.#media, abort).then((url) => {
+      this.#media.notify("poster-change", url || "", trigger);
+    }).catch(() => {
+      this.#media.notify("poster-change", "", trigger);
+    });
+    return () => {
+      abort.abort();
+    };
+  }
+}
+function normalizeSrc(src) {
+  return (isArray(src) ? src : [src]).map((src2) => {
+    if (isString(src2)) {
+      return { src: src2, type: inferType(src2) };
+    } else {
+      return { ...src2, type: inferType(src2.src, src2.type) };
+    }
+  });
+}
+function inferType(src, type) {
+  if (isString(type) && type.length) {
+    return type;
+  } else if (isString(src) && sourceTypes.has(src)) {
+    return sourceTypes.get(src);
+  } else if (!type && isHLSSrc({ src, type: "" })) {
+    return "application/x-mpegurl";
+  } else if (!type && isDASHSrc({ src, type: "" })) {
+    return "application/dash+xml";
+  } else if (!isString(src) || src.startsWith("blob:")) {
+    return "video/object";
+  } else if (src.includes("youtube") || src.includes("youtu.be")) {
+    return "video/youtube";
+  } else if (src.includes("vimeo") && !src.includes("progressive_redirect") && !src.includes(".m3u8")) {
+    return "video/vimeo";
+  }
+  return "?";
+}
+function isSameSrc(a, b) {
+  return a?.src === b?.src && a?.type === b?.type;
+}
+
+class Tracks {
+  #domTracks;
+  #media;
+  #prevTracks = [];
+  constructor(domTracks, media) {
+    this.#domTracks = domTracks;
+    this.#media = media;
+    effect(this.#onTracksChange.bind(this));
+  }
+  #onTracksChange() {
+    const newTracks = this.#domTracks();
+    for (const oldTrack of this.#prevTracks) {
+      if (!newTracks.some((t) => t.id === oldTrack.id)) {
+        const track = oldTrack.id && this.#media.textTracks.getById(oldTrack.id);
+        if (track) this.#media.textTracks.remove(track);
+      }
+    }
+    for (const newTrack of newTracks) {
+      const id = newTrack.id || TextTrack.createId(newTrack);
+      if (!this.#media.textTracks.getById(id)) {
+        newTrack.id = id;
+        this.#media.textTracks.add(newTrack);
+      }
+    }
+    this.#prevTracks = newTracks;
+  }
+}
+
+class MediaProvider extends Component {
+  static props = {
+    loaders: []
+  };
+  static state = new State({
+    loader: null
+  });
+  #media;
+  #sources;
+  #domSources = signal([]);
+  #domTracks = signal([]);
+  #loader = null;
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#sources = new SourceSelection(
+      this.#domSources,
+      this.#media,
+      this.$state.loader,
+      this.$props.loaders()
+    );
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-provider", "");
+  }
+  onConnect(el) {
+    this.#sources.connect();
+    new Tracks(this.#domTracks, this.#media);
+    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
+    resize.observe(el);
+    const mutations = new MutationObserver(this.#onMutation.bind(this));
+    mutations.observe(el, { attributes: true, childList: true });
+    this.#onResize();
+    this.#onMutation();
+    onDispose(() => {
+      resize.disconnect();
+      mutations.disconnect();
+    });
+  }
+  #loadRafId = -1;
+  load(target) {
+    target?.setAttribute("aria-hidden", "true");
+    window.cancelAnimationFrame(this.#loadRafId);
+    this.#loadRafId = requestAnimationFrame(() => this.#runLoader(target));
+    onDispose(() => {
+      window.cancelAnimationFrame(this.#loadRafId);
+    });
+  }
+  #runLoader(target) {
+    if (!this.scope) return;
+    const loader = this.$state.loader(), { $provider } = this.#media;
+    if (this.#loader === loader && loader?.target === target && peek($provider)) return;
+    this.#destroyProvider();
+    this.#loader = loader;
+    if (loader) loader.target = target || null;
+    if (!loader || !target) return;
+    loader.load(this.#media).then((provider) => {
+      if (!this.scope) return;
+      if (peek(this.$state.loader) !== loader) return;
+      this.#media.notify("provider-change", provider);
+    });
+  }
+  onDestroy() {
+    this.#loader = null;
+    this.#destroyProvider();
+  }
+  #destroyProvider() {
+    this.#media?.notify("provider-change", null);
+  }
+  #onResize() {
+    if (!this.el) return;
+    const { player, $state } = this.#media, width = this.el.offsetWidth, height = this.el.offsetHeight;
+    if (!player) return;
+    $state.mediaWidth.set(width);
+    $state.mediaHeight.set(height);
+    if (player.el) {
+      setStyle(player.el, "--media-width", width + "px");
+      setStyle(player.el, "--media-height", height + "px");
+    }
+  }
+  #onMutation() {
+    const sources = [], tracks = [], children = this.el.children;
+    for (const el of children) {
+      if (el.hasAttribute("data-vds")) continue;
+      if (el instanceof HTMLSourceElement) {
+        const src = {
+          id: el.id,
+          src: el.src,
+          type: el.type
+        };
+        for (const prop of ["id", "src", "width", "height", "bitrate", "codec"]) {
+          const value = el.getAttribute(`data-${prop}`);
+          if (isString(value)) src[prop] = /id|src|codec/.test(prop) ? value : Number(value);
+        }
+        sources.push(src);
+      } else if (el instanceof HTMLTrackElement) {
+        const track = {
+          src: el.src,
+          kind: el.track.kind,
+          language: el.srclang,
+          label: el.label,
+          default: el.default,
+          type: el.getAttribute("data-type")
+        };
+        tracks.push({
+          id: el.id || TextTrack.createId(track),
+          ...track
+        });
+      }
+    }
+    this.#domSources.set(sources);
+    this.#domTracks.set(tracks);
+    tick();
+  }
+}
+const mediaprovider__proto = MediaProvider.prototype;
+method(mediaprovider__proto, "load");
+
+class MediaAnnouncer extends Component {
+  static props = {
+    translations: null
+  };
+  static state = new State({
+    label: null,
+    busy: false
+  });
+  #media;
+  #initializing = false;
+  onSetup() {
+    this.#media = useMediaContext();
+  }
+  onAttach(el) {
+    el.style.display = "contents";
+  }
+  onConnect(el) {
+    el.setAttribute("data-media-announcer", "");
+    setAttributeIfEmpty(el, "role", "status");
+    setAttributeIfEmpty(el, "aria-live", "polite");
+    const { busy } = this.$state;
+    this.setAttributes({
+      "aria-busy": () => busy() ? "true" : null
+    });
+    this.#initializing = true;
+    effect(this.#watchPaused.bind(this));
+    effect(this.#watchVolume.bind(this));
+    effect(this.#watchCaptions.bind(this));
+    effect(this.#watchFullscreen.bind(this));
+    effect(this.#watchPiP.bind(this));
+    effect(this.#watchSeeking.bind(this));
+    effect(this.#watchLabel.bind(this));
+    tick();
+    this.#initializing = false;
+  }
+  #watchPaused() {
+    const { paused } = this.#media.$state;
+    this.#setLabel(!paused() ? "Play" : "Pause");
+  }
+  #watchFullscreen() {
+    const { fullscreen } = this.#media.$state;
+    this.#setLabel(fullscreen() ? "Enter Fullscreen" : "Exit Fullscreen");
+  }
+  #watchPiP() {
+    const { pictureInPicture } = this.#media.$state;
+    this.#setLabel(pictureInPicture() ? "Enter PiP" : "Exit PiP");
+  }
+  #watchCaptions() {
+    const { textTrack } = this.#media.$state;
+    this.#setLabel(textTrack() ? "Closed-Captions On" : "Closed-Captions Off");
+  }
+  #watchVolume() {
+    const { muted, volume, audioGain } = this.#media.$state;
+    this.#setLabel(
+      muted() || volume() === 0 ? "Mute" : `${Math.round(volume() * (audioGain() ?? 1) * 100)}% ${this.#translate("Volume")}`
+    );
+  }
+  #startedSeekingAt = -1;
+  #seekTimer = -1;
+  #watchSeeking() {
+    const { seeking, currentTime } = this.#media.$state, isSeeking = seeking();
+    if (this.#startedSeekingAt > 0) {
+      window.clearTimeout(this.#seekTimer);
+      this.#seekTimer = window.setTimeout(() => {
+        if (!this.scope) return;
+        const newTime = peek(currentTime), seconds = Math.abs(newTime - this.#startedSeekingAt);
+        if (seconds >= 1) {
+          const isForward = newTime >= this.#startedSeekingAt, spokenTime = formatSpokenTime(seconds);
+          this.#setLabel(
+            `${this.#translate(isForward ? "Seek Forward" : "Seek Backward")} ${spokenTime}`
+          );
+        }
+        this.#startedSeekingAt = -1;
+        this.#seekTimer = -1;
+      }, 300);
+    } else if (isSeeking) {
+      this.#startedSeekingAt = peek(currentTime);
+    }
+  }
+  #translate(word) {
+    const { translations } = this.$props;
+    return translations?.()?.[word || ""] ?? word;
+  }
+  #watchLabel() {
+    const { label, busy } = this.$state, $label = this.#translate(label());
+    if (this.#initializing) return;
+    busy.set(true);
+    const id = window.setTimeout(() => void busy.set(false), 150);
+    this.el && setAttribute(this.el, "aria-label", $label);
+    if (isString($label)) {
+      this.dispatch("change", { detail: $label });
+    }
+    return () => window.clearTimeout(id);
+  }
+  #setLabel(word) {
+    const { label } = this.$state;
+    label.set(word);
+  }
+}
+
+class Controls extends Component {
+  static props = {
+    hideDelay: 2e3,
+    hideOnMouseLeave: false
+  };
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    effect(this.#watchProps.bind(this));
+  }
+  onAttach(el) {
+    const { pictureInPicture, fullscreen } = this.#media.$state;
+    setStyle(el, "pointer-events", "none");
+    setAttributeIfEmpty(el, "role", "group");
+    this.setAttributes({
+      "data-visible": this.#isShowing.bind(this),
+      "data-fullscreen": fullscreen,
+      "data-pip": pictureInPicture
+    });
+    effect(() => {
+      this.dispatch("change", { detail: this.#isShowing() });
+    });
+    effect(this.#hideControls.bind(this));
+    effect(() => {
+      const isFullscreen = fullscreen();
+      for (const side of ["top", "right", "bottom", "left"]) {
+        setStyle(el, `padding-${side}`, isFullscreen && `env(safe-area-inset-${side})`);
+      }
+    });
+  }
+  #hideControls() {
+    if (!this.el) return;
+    const { nativeControls } = this.#media.$state, isHidden = nativeControls();
+    setAttribute(this.el, "aria-hidden", isHidden ? "true" : null);
+    setStyle(this.el, "display", isHidden ? "none" : null);
+  }
+  #watchProps() {
+    const { controls } = this.#media.player, { hideDelay, hideOnMouseLeave } = this.$props;
+    controls.defaultDelay = hideDelay() === 2e3 ? this.#media.$props.controlsDelay() : hideDelay();
+    controls.hideOnMouseLeave = hideOnMouseLeave();
+  }
+  #isShowing() {
+    const { controlsVisible } = this.#media.$state;
+    return controlsVisible();
+  }
+}
+
+class ControlsGroup extends Component {
+  onAttach(el) {
+    if (!el.style.pointerEvents) setStyle(el, "pointer-events", "auto");
+  }
+}
+
+class Popper extends ViewController {
+  #delegate;
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+    effect(this.#watchTrigger.bind(this));
+  }
+  onDestroy() {
+    this.#stopAnimationEndListener?.();
+    this.#stopAnimationEndListener = null;
+  }
+  #watchTrigger() {
+    const trigger = this.#delegate.trigger();
+    if (!trigger) {
+      this.hide();
+      return;
+    }
+    const show = this.show.bind(this), hide = this.hide.bind(this);
+    this.#delegate.listen(trigger, show, hide);
+  }
+  #showTimerId = -1;
+  #hideRafId = -1;
+  #stopAnimationEndListener = null;
+  show(trigger) {
+    this.#cancelShowing();
+    window.cancelAnimationFrame(this.#hideRafId);
+    this.#hideRafId = -1;
+    this.#stopAnimationEndListener?.();
+    this.#stopAnimationEndListener = null;
+    this.#showTimerId = window.setTimeout(() => {
+      this.#showTimerId = -1;
+      const content = this.#delegate.content();
+      if (content) content.style.removeProperty("display");
+      peek(() => this.#delegate.onChange(true, trigger));
+    }, this.#delegate.showDelay?.() ?? 0);
+  }
+  hide(trigger) {
+    this.#cancelShowing();
+    peek(() => this.#delegate.onChange(false, trigger));
+    this.#hideRafId = requestAnimationFrame(() => {
+      this.#cancelShowing();
+      this.#hideRafId = -1;
+      const content = this.#delegate.content();
+      if (content) {
+        const onHide = () => {
+          content.style.display = "none";
+          this.#stopAnimationEndListener = null;
+        };
+        const isAnimated = hasAnimation(content);
+        if (isAnimated) {
+          this.#stopAnimationEndListener?.();
+          const stop = listenEvent(content, "animationend", onHide, { once: true });
+          this.#stopAnimationEndListener = stop;
+        } else {
+          onHide();
+        }
+      }
+    });
+  }
+  #cancelShowing() {
+    window.clearTimeout(this.#showTimerId);
+    this.#showTimerId = -1;
+  }
+}
+
+const tooltipContext = createContext();
+
+let id = 0;
+class Tooltip extends Component {
+  static props = {
+    showDelay: 700
+  };
+  #id = `media-tooltip-${++id}`;
+  #trigger = signal(null);
+  #content = signal(null);
+  #showing = signal(false);
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { showDelay } = this.$props;
+    new Popper({
+      trigger: this.#trigger,
+      content: this.#content,
+      showDelay,
+      listen(trigger, show, hide) {
+        effect(() => {
+          if ($keyboard()) listenEvent(trigger, "focus", show);
+          listenEvent(trigger, "blur", hide);
+        });
+        new EventsController(trigger).add("touchstart", (e) => e.preventDefault(), { passive: false }).add("mouseenter", show).add("mouseleave", hide);
+      },
+      onChange: this.#onShowingChange.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  onSetup() {
+    provideContext(tooltipContext, {
+      trigger: this.#trigger,
+      content: this.#content,
+      showing: this.#showing,
+      attachTrigger: this.#attachTrigger.bind(this),
+      detachTrigger: this.#detachTrigger.bind(this),
+      attachContent: this.#attachContent.bind(this),
+      detachContent: this.#detachContent.bind(this)
+    });
+  }
+  #attachTrigger(el) {
+    this.#trigger.set(el);
+    let tooltipName = el.getAttribute("data-media-tooltip");
+    if (tooltipName) {
+      this.el?.setAttribute(`data-media-${tooltipName}-tooltip`, "");
+    }
+    setAttribute(el, "data-describedby", this.#id);
+  }
+  #detachTrigger(el) {
+    el.removeAttribute("data-describedby");
+    el.removeAttribute("aria-describedby");
+    this.#trigger.set(null);
+  }
+  #attachContent(el) {
+    el.setAttribute("id", this.#id);
+    el.style.display = "none";
+    setAttributeIfEmpty(el, "role", "tooltip");
+    this.#content.set(el);
+  }
+  #detachContent(el) {
+    el.removeAttribute("id");
+    el.removeAttribute("role");
+    this.#content.set(null);
+  }
+  #onShowingChange(isShowing) {
+    const trigger = this.#trigger(), content = this.#content();
+    if (trigger) {
+      setAttribute(trigger, "aria-describedby", isShowing ? this.#id : null);
+    }
+    for (const el of [this.el, trigger, content]) {
+      el && setAttribute(el, "data-visible", isShowing);
+    }
+    this.#showing.set(isShowing);
+  }
+}
+
+class TooltipTrigger extends Component {
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onConnect(el) {
+    onDispose(
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        this.#attach();
+        const tooltip = useContext(tooltipContext);
+        onDispose(() => {
+          const button = this.#getButton();
+          button && tooltip.detachTrigger(button);
+        });
+      })
+    );
+  }
+  #attach() {
+    const button = this.#getButton(), tooltip = useContext(tooltipContext);
+    button && tooltip.attachTrigger(button);
+  }
+  #getButton() {
+    const candidate = this.el.firstElementChild;
+    return candidate?.localName === "button" || candidate?.getAttribute("role") === "button" ? candidate : this.el;
+  }
+}
+
+class TooltipContent extends Component {
+  static props = {
+    placement: "top center",
+    offset: 0,
+    alignOffset: 0
+  };
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { placement } = this.$props;
+    this.setAttributes({
+      "data-placement": placement
+    });
+  }
+  onAttach(el) {
+    this.#attach(el);
+    Object.assign(el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+  }
+  onConnect(el) {
+    this.#attach(el);
+    const tooltip = useContext(tooltipContext);
+    onDispose(() => tooltip.detachContent(el));
+    onDispose(
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        effect(this.#watchPlacement.bind(this));
+      })
+    );
+  }
+  #attach(el) {
+    const tooltip = useContext(tooltipContext);
+    tooltip.attachContent(el);
+  }
+  #watchPlacement() {
+    const { showing } = useContext(tooltipContext);
+    if (!showing()) return;
+    const { placement, offset: mainOffset, alignOffset } = this.$props;
+    return autoPlacement(this.el, this.#getTrigger(), placement(), {
+      offsetVarName: "media-tooltip",
+      xOffset: alignOffset(),
+      yOffset: mainOffset()
+    });
+  }
+  #getTrigger() {
+    return useContext(tooltipContext).trigger();
+  }
+}
+
+class ToggleButtonController extends ViewController {
+  static props = {
+    disabled: false
+  };
+  #delegate;
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+    new FocusVisibleController();
+    if (delegate.keyShortcut) {
+      new ARIAKeyShortcuts(delegate.keyShortcut);
+    }
+  }
+  onSetup() {
+    const { disabled } = this.$props;
+    this.setAttributes({
+      "data-pressed": this.#delegate.isPresssed,
+      "aria-pressed": this.#isARIAPressed.bind(this),
+      "aria-disabled": () => disabled() ? "true" : null
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+  }
+  onConnect(el) {
+    const events = onPress(el, this.#onMaybePress.bind(this));
+    for (const type of ["click", "touchstart"]) {
+      events.add(type, this.#onInteraction.bind(this), {
+        passive: true
+      });
+    }
+  }
+  #isARIAPressed() {
+    return ariaBool$1(this.#delegate.isPresssed());
+  }
+  #onPressed(event) {
+    if (isWriteSignal(this.#delegate.isPresssed)) {
+      this.#delegate.isPresssed.set((p) => !p);
+    }
+  }
+  #onMaybePress(event) {
+    const disabled = this.$props.disabled() || this.el.hasAttribute("data-disabled");
+    if (disabled) {
+      event.preventDefault();
+      event.stopImmediatePropagation();
+      return;
+    }
+    event.preventDefault();
+    (this.#delegate.onPress ?? this.#onPressed).call(this, event);
+  }
+  #onInteraction(event) {
+    if (this.$props.disabled()) {
+      event.preventDefault();
+      event.stopImmediatePropagation();
+    }
+  }
+}
+
+class ToggleButton extends Component {
+  static props = {
+    disabled: false,
+    defaultPressed: false
+  };
+  #pressed = signal(false);
+  /**
+   * Whether the toggle is currently in a `pressed` state.
+   */
+  get pressed() {
+    return this.#pressed();
+  }
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#pressed
+    });
+  }
+}
+const togglebutton__proto = ToggleButton.prototype;
+prop(togglebutton__proto, "pressed");
+
+function ariaBool(value) {
+  return value ? "true" : "false";
+}
+function $ariaBool(signal) {
+  return () => ariaBool(signal());
+}
+
+class AirPlayButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { canAirPlay, isAirPlayConnected } = this.#media.$state;
+    this.setAttributes({
+      "data-active": isAirPlayConnected,
+      "data-supported": canAirPlay,
+      "data-state": this.#getState.bind(this),
+      "aria-hidden": $ariaBool(() => !canAirPlay())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "airplay");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    remote.requestAirPlay(event);
+  }
+  #isPressed() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "airplay" && remotePlaybackState() !== "disconnected";
+  }
+  #getState() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "airplay" && remotePlaybackState();
+  }
+  #getDefaultLabel() {
+    const { remotePlaybackState } = this.#media.$state;
+    return `AirPlay ${remotePlaybackState()}`;
+  }
+}
+
+class GoogleCastButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { canGoogleCast, isGoogleCastConnected } = this.#media.$state;
+    this.setAttributes({
+      "data-active": isGoogleCastConnected,
+      "data-supported": canGoogleCast,
+      "data-state": this.#getState.bind(this),
+      "aria-hidden": $ariaBool(() => !canGoogleCast())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "google-cast");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    remote.requestGoogleCast(event);
+  }
+  #isPressed() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "google-cast" && remotePlaybackState() !== "disconnected";
+  }
+  #getState() {
+    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
+    return remotePlaybackType() === "google-cast" && remotePlaybackState();
+  }
+  #getDefaultLabel() {
+    const { remotePlaybackState } = this.#media.$state;
+    return `Google Cast ${remotePlaybackState()}`;
+  }
+}
+
+class PlayButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "togglePaused",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { paused, ended } = this.#media.$state;
+    this.setAttributes({
+      "data-paused": paused,
+      "data-ended": ended
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "play");
+    setARIALabel(el, "Play");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.pause(event) : remote.play(event);
+  }
+  #isPressed() {
+    const { paused } = this.#media.$state;
+    return !paused();
+  }
+}
+
+class CaptionButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleCaptions",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "data-active": this.#isPressed.bind(this),
+      "data-supported": () => !this.#isHidden(),
+      "aria-hidden": $ariaBool(this.#isHidden.bind(this))
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "caption");
+    setARIALabel(el, "Captions");
+  }
+  #onPress(event) {
+    this.#media.remote.toggleCaptions(event);
+  }
+  #isPressed() {
+    const { textTrack } = this.#media.$state, track = textTrack();
+    return !!track && isTrackCaptionKind(track);
+  }
+  #isHidden() {
+    const { hasCaptions } = this.#media.$state;
+    return !hasCaptions();
+  }
+}
+
+class FullscreenButton extends Component {
+  static props = {
+    ...ToggleButtonController.props,
+    target: "prefer-media"
+  };
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleFullscreen",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { fullscreen } = this.#media.$state, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      "data-active": fullscreen,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "fullscreen");
+    setARIALabel(el, "Fullscreen");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote, target = this.$props.target();
+    this.#isPressed() ? remote.exitFullscreen(target, event) : remote.enterFullscreen(target, event);
+  }
+  #isPressed() {
+    const { fullscreen } = this.#media.$state;
+    return fullscreen();
+  }
+  #isSupported() {
+    const { canFullscreen } = this.#media.$state;
+    return canFullscreen();
+  }
+}
+
+class MuteButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "toggleMuted",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "data-muted": this.#isPressed.bind(this),
+      "data-state": this.#getState.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-mute-button", "");
+    el.setAttribute("data-media-tooltip", "mute");
+    setARIALabel(el, "Mute");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.unmute(event) : remote.mute(event);
+  }
+  #isPressed() {
+    const { muted, volume } = this.#media.$state;
+    return muted() || volume() === 0;
+  }
+  #getState() {
+    const { muted, volume } = this.#media.$state, $volume = volume();
+    if (muted() || $volume === 0) return "muted";
+    else if ($volume >= 0.5) return "high";
+    else if ($volume < 0.5) return "low";
+  }
+}
+
+class PIPButton extends Component {
+  static props = ToggleButtonController.props;
+  #media;
+  constructor() {
+    super();
+    new ToggleButtonController({
+      isPresssed: this.#isPressed.bind(this),
+      keyShortcut: "togglePictureInPicture",
+      onPress: this.#onPress.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { pictureInPicture } = this.#media.$state, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      "data-active": pictureInPicture,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-tooltip", "pip");
+    setARIALabel(el, "PiP");
+  }
+  #onPress(event) {
+    const remote = this.#media.remote;
+    this.#isPressed() ? remote.exitPictureInPicture(event) : remote.enterPictureInPicture(event);
+  }
+  #isPressed() {
+    const { pictureInPicture } = this.#media.$state;
+    return pictureInPicture();
+  }
+  #isSupported() {
+    const { canPictureInPicture } = this.#media.$state;
+    return canPictureInPicture();
+  }
+}
+
+class SeekButton extends Component {
+  static props = {
+    disabled: false,
+    seconds: 30
+  };
+  #media;
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { seeking } = this.#media.$state, { seconds } = this.$props, isSupported = this.#isSupported.bind(this);
+    this.setAttributes({
+      seconds,
+      "data-seeking": seeking,
+      "data-supported": isSupported,
+      "aria-hidden": $ariaBool(() => !isSupported())
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+    el.setAttribute("data-media-tooltip", "seek");
+    setARIALabel(el, this.#getDefaultLabel.bind(this));
+  }
+  onConnect(el) {
+    onPress(el, this.#onPress.bind(this));
+  }
+  #isSupported() {
+    const { canSeek } = this.#media.$state;
+    return canSeek();
+  }
+  #getDefaultLabel() {
+    const { seconds } = this.$props;
+    return `Seek ${seconds() > 0 ? "forward" : "backward"} ${seconds()} seconds`;
+  }
+  #onPress(event) {
+    const { seconds, disabled } = this.$props;
+    if (disabled()) return;
+    const { currentTime } = this.#media.$state, seekTo = currentTime() + seconds();
+    this.#media.remote.seek(seekTo, event);
+  }
+}
+
+class LiveButton extends Component {
+  static props = {
+    disabled: false
+  };
+  #media;
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const { disabled } = this.$props, { live, liveEdge } = this.#media.$state, isHidden = () => !live();
+    this.setAttributes({
+      "data-edge": liveEdge,
+      "data-hidden": isHidden,
+      "aria-disabled": $ariaBool(() => disabled() || liveEdge()),
+      "aria-hidden": $ariaBool(isHidden)
+    });
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "role", "button");
+    setAttributeIfEmpty(el, "type", "button");
+    el.setAttribute("data-media-tooltip", "live");
+  }
+  onConnect(el) {
+    onPress(el, this.#onPress.bind(this));
+  }
+  #onPress(event) {
+    const { disabled } = this.$props, { liveEdge } = this.#media.$state;
+    if (disabled() || liveEdge()) return;
+    this.#media.remote.seekToLiveEdge(event);
+  }
+}
+
+const sliderState = new State({
+  min: 0,
+  max: 100,
+  value: 0,
+  step: 1,
+  pointerValue: 0,
+  focused: false,
+  dragging: false,
+  pointing: false,
+  hidden: false,
+  get active() {
+    return this.dragging || this.focused || this.pointing;
+  },
+  get fillRate() {
+    return calcRate(this.min, this.max, this.value);
+  },
+  get fillPercent() {
+    return this.fillRate * 100;
+  },
+  get pointerRate() {
+    return calcRate(this.min, this.max, this.pointerValue);
+  },
+  get pointerPercent() {
+    return this.pointerRate * 100;
+  }
+});
+function calcRate(min, max, value) {
+  const range = max - min, offset = value - min;
+  return range > 0 ? offset / range : 0;
+}
+
+class IntersectionObserverController extends ViewController {
+  #init;
+  #observer;
+  constructor(init) {
+    super();
+    this.#init = init;
+  }
+  onConnect(el) {
+    this.#observer = new IntersectionObserver((entries) => {
+      this.#init.callback?.(entries, this.#observer);
+    }, this.#init);
+    this.#observer.observe(el);
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  /**
+   * Disconnect any active intersection observers.
+   */
+  #onDisconnect() {
+    this.#observer?.disconnect();
+    this.#observer = void 0;
+  }
+}
+
+const sliderContext = createContext();
+const sliderObserverContext = createContext();
+
+function getClampedValue(min, max, value, step) {
+  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
+}
+function getValueFromRate(min, max, rate, step) {
+  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * Math.round(stepRatio);
+  return min + steps;
+}
+
+const SliderKeyDirection = {
+  Left: -1,
+  ArrowLeft: -1,
+  Up: 1,
+  ArrowUp: 1,
+  Right: 1,
+  ArrowRight: 1,
+  Down: -1,
+  ArrowDown: -1
+};
+class SliderEventsController extends ViewController {
+  #delegate;
+  #media;
+  #observer;
+  constructor(delegate, media) {
+    super();
+    this.#delegate = delegate;
+    this.#media = media;
+  }
+  onSetup() {
+    if (hasProvidedContext(sliderObserverContext)) {
+      this.#observer = useContext(sliderObserverContext);
+    }
+  }
+  onConnect(el) {
+    effect(this.#attachEventListeners.bind(this, el));
+    effect(this.#attachPointerListeners.bind(this, el));
+    if (this.#delegate.swipeGesture) effect(this.#watchSwipeGesture.bind(this));
+  }
+  #watchSwipeGesture() {
+    const { pointer } = this.#media.$state;
+    if (pointer() !== "coarse" || !this.#delegate.swipeGesture()) {
+      this.#provider = null;
+      return;
+    }
+    this.#provider = this.#media.player.el?.querySelector(
+      "media-provider,[data-media-provider]"
+    );
+    if (!this.#provider) return;
+    new EventsController(this.#provider).add("touchstart", this.#onTouchStart.bind(this), {
+      passive: true
+    }).add("touchmove", this.#onTouchMove.bind(this), { passive: false });
+  }
+  #provider = null;
+  #touch = null;
+  #touchStartValue = null;
+  #onTouchStart(event) {
+    this.#touch = event.touches[0];
+  }
+  #onTouchMove(event) {
+    if (isNull(this.#touch) || isTouchPinchEvent(event)) return;
+    const touch = event.touches[0], xDiff = touch.clientX - this.#touch.clientX, yDiff = touch.clientY - this.#touch.clientY, isDragging = this.$state.dragging();
+    if (!isDragging && Math.abs(yDiff) > 5) {
+      return;
+    }
+    if (isDragging) return;
+    event.preventDefault();
+    if (Math.abs(xDiff) > 20) {
+      this.#touch = touch;
+      this.#touchStartValue = this.$state.value();
+      this.#onStartDragging(this.#touchStartValue, event);
+    }
+  }
+  #attachEventListeners(el) {
+    const { hidden } = this.$props;
+    listenEvent(el, "focus", this.#onFocus.bind(this));
+    if (hidden() || this.#delegate.isDisabled()) return;
+    new EventsController(el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("pointerenter", this.#onPointerEnter.bind(this)).add("pointermove", this.#onPointerMove.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this)).add("pointerdown", this.#onPointerDown.bind(this));
+  }
+  #attachPointerListeners(el) {
+    if (this.#delegate.isDisabled() || !this.$state.dragging()) return;
+    new EventsController(document).add("pointerup", this.#onDocumentPointerUp.bind(this), { capture: true }).add("pointermove", this.#onDocumentPointerMove.bind(this)).add("touchmove", this.#onDocumentTouchMove.bind(this), {
+      passive: false
+    });
+  }
+  #onFocus() {
+    this.#updatePointerValue(this.$state.value());
+  }
+  #updateValue(newValue, trigger) {
+    const { value, min, max, dragging } = this.$state;
+    const clampedValue = Math.max(min(), Math.min(newValue, max()));
+    value.set(clampedValue);
+    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
+    this.dispatch(event);
+    this.#delegate.onValueChange?.(event);
+    if (dragging()) {
+      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
+      this.dispatch(event2);
+      this.#delegate.onDragValueChange?.(event2);
+    }
+  }
+  #updatePointerValue(value, trigger) {
+    const { pointerValue, dragging } = this.$state;
+    pointerValue.set(value);
+    this.dispatch("pointer-value-change", { detail: value, trigger });
+    if (dragging()) {
+      this.#updateValue(value, trigger);
+    }
+  }
+  #getPointerValue(event) {
+    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$state;
+    if (this.$props.orientation() === "vertical") {
+      const { bottom: trackBottom, height: trackHeight } = rect;
+      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
+    } else {
+      if (this.#touch && isNumber(this.#touchStartValue)) {
+        const { width } = this.#provider.getBoundingClientRect(), rate = (event.clientX - this.#touch.clientX) / width, range = max() - min(), diff = range * Math.abs(rate);
+        thumbPositionRate = (rate < 0 ? this.#touchStartValue - diff : this.#touchStartValue + diff) / range;
+      } else {
+        const { left: trackLeft, width: trackWidth } = rect;
+        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
+      }
+    }
+    return Math.max(
+      min(),
+      Math.min(
+        max(),
+        this.#delegate.roundValue(
+          getValueFromRate(min(), max(), thumbPositionRate, this.#delegate.getStep())
+        )
+      )
+    );
+  }
+  #onPointerEnter(event) {
+    this.$state.pointing.set(true);
+  }
+  #onPointerMove(event) {
+    const { dragging } = this.$state;
+    if (dragging()) return;
+    this.#updatePointerValue(this.#getPointerValue(event), event);
+  }
+  #onPointerLeave(event) {
+    this.$state.pointing.set(false);
+  }
+  #onPointerDown(event) {
+    if (event.button !== 0) return;
+    const value = this.#getPointerValue(event);
+    this.#onStartDragging(value, event);
+    this.#updatePointerValue(value, event);
+  }
+  #onStartDragging(value, trigger) {
+    const { dragging } = this.$state;
+    if (dragging()) return;
+    dragging.set(true);
+    this.#media.remote.pauseControls(trigger);
+    const event = this.createEvent("drag-start", { detail: value, trigger });
+    this.dispatch(event);
+    this.#delegate.onDragStart?.(event);
+    this.#observer?.onDragStart?.();
+  }
+  #onStopDragging(value, trigger) {
+    const { dragging } = this.$state;
+    if (!dragging()) return;
+    dragging.set(false);
+    this.#media.remote.resumeControls(trigger);
+    const event = this.createEvent("drag-end", { detail: value, trigger });
+    this.dispatch(event);
+    this.#delegate.onDragEnd?.(event);
+    this.#touch = null;
+    this.#touchStartValue = null;
+    this.#observer?.onDragEnd?.();
+  }
+  // -------------------------------------------------------------------------------------------
+  // Keyboard Events
+  // -------------------------------------------------------------------------------------------
+  #lastDownKey;
+  #repeatedKeys = false;
+  #onKeyDown(event) {
+    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);
+    if (!isValidKey) return;
+    const { key } = event, jumpValue = this.#calcJumpValue(event);
+    if (!isNull(jumpValue)) {
+      this.#updatePointerValue(jumpValue, event);
+      this.#updateValue(jumpValue, event);
+      return;
+    }
+    const newValue = this.#calcNewKeyValue(event);
+    if (!this.#repeatedKeys) {
+      this.#repeatedKeys = key === this.#lastDownKey;
+      if (!this.$state.dragging() && this.#repeatedKeys) {
+        this.#onStartDragging(newValue, event);
+      }
+    }
+    this.#updatePointerValue(newValue, event);
+    this.#lastDownKey = key;
+  }
+  #onKeyUp(event) {
+    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);
+    if (!isValidKey || !isNull(this.#calcJumpValue(event))) return;
+    const newValue = this.#repeatedKeys ? this.$state.pointerValue() : this.#calcNewKeyValue(event);
+    this.#updateValue(newValue, event);
+    this.#onStopDragging(newValue, event);
+    this.#lastDownKey = "";
+    this.#repeatedKeys = false;
+  }
+  #calcJumpValue(event) {
+    let key = event.key, { min, max } = this.$state;
+    if (key === "Home" || key === "PageUp") {
+      return min();
+    } else if (key === "End" || key === "PageDown") {
+      return max();
+    } else if (!event.metaKey && /^[0-9]$/.test(key)) {
+      return (max() - min()) / 10 * Number(key);
+    }
+    return null;
+  }
+  #calcNewKeyValue(event) {
+    const { key, shiftKey } = event;
+    event.preventDefault();
+    event.stopPropagation();
+    const { shiftKeyMultiplier } = this.$props;
+    const { min, max, value, pointerValue } = this.$state, step = this.#delegate.getStep(), keyStep = this.#delegate.getKeyStep();
+    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, currentValue = this.#repeatedKeys ? pointerValue() : this.#delegate.getValue?.() ?? value(), steps = (currentValue + diff) / step;
+    return Math.max(min(), Math.min(max(), Number((step * steps).toFixed(3))));
+  }
+  // -------------------------------------------------------------------------------------------
+  // Document (Pointer Events)
+  // -------------------------------------------------------------------------------------------
+  #onDocumentPointerUp(event) {
+    if (event.button !== 0) return;
+    event.preventDefault();
+    event.stopImmediatePropagation();
+    const value = this.#getPointerValue(event);
+    this.#updatePointerValue(value, event);
+    this.#onStopDragging(value, event);
+  }
+  #onDocumentTouchMove(event) {
+    event.preventDefault();
+  }
+  #onDocumentPointerMove = functionThrottle(
+    (event) => {
+      this.#updatePointerValue(this.#getPointerValue(event), event);
+    },
+    20,
+    { leading: true }
+  );
+}
+
+const sliderValueFormatContext = createContext(() => ({}));
+
+class SliderController extends ViewController {
+  static props = {
+    hidden: false,
+    disabled: false,
+    step: 1,
+    keyStep: 1,
+    orientation: "horizontal",
+    shiftKeyMultiplier: 5
+  };
+  #media;
+  #delegate;
+  #isVisible = signal(true);
+  #isIntersecting = signal(true);
+  constructor(delegate) {
+    super();
+    this.#delegate = delegate;
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const focus = new FocusVisibleController();
+    focus.attach(this);
+    this.$state.focused = focus.focused.bind(focus);
+    if (!hasProvidedContext(sliderValueFormatContext)) {
+      provideContext(sliderValueFormatContext, {
+        default: "value"
+      });
+    }
+    provideContext(sliderContext, {
+      orientation: this.$props.orientation,
+      disabled: this.#delegate.isDisabled,
+      preview: signal(null)
+    });
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchStep.bind(this));
+    effect(this.#watchDisabled.bind(this));
+    this.#setupAttrs();
+    new SliderEventsController(this.#delegate, this.#media).attach(this);
+    new IntersectionObserverController({
+      callback: this.#onIntersectionChange.bind(this)
+    }).attach(this);
+  }
+  onAttach(el) {
+    setAttributeIfEmpty(el, "role", "slider");
+    setAttributeIfEmpty(el, "tabindex", "0");
+    setAttributeIfEmpty(el, "autocomplete", "off");
+    if (IS_SERVER) this.#watchCSSVars();
+    else effect(this.#watchCSSVars.bind(this));
+  }
+  onConnect(el) {
+    onDispose(observeVisibility(el, this.#isVisible.set));
+    effect(this.#watchHidden.bind(this));
+  }
+  #onIntersectionChange(entries) {
+    this.#isIntersecting.set(entries[0].isIntersecting);
+  }
+  // -------------------------------------------------------------------------------------------
+  // Watch
+  // -------------------------------------------------------------------------------------------
+  #watchHidden() {
+    const { hidden } = this.$props;
+    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting.bind(this));
+  }
+  #watchValue() {
+    const { dragging, value, min, max } = this.$state;
+    if (peek(dragging)) return;
+    value.set(getClampedValue(min(), max(), value(), this.#delegate.getStep()));
+  }
+  #watchStep() {
+    this.$state.step.set(this.#delegate.getStep());
+  }
+  #watchDisabled() {
+    if (!this.#delegate.isDisabled()) return;
+    const { dragging, pointing } = this.$state;
+    dragging.set(false);
+    pointing.set(false);
+  }
+  // -------------------------------------------------------------------------------------------
+  // ARIA
+  // -------------------------------------------------------------------------------------------
+  #getARIADisabled() {
+    return ariaBool$1(this.#delegate.isDisabled());
+  }
+  // -------------------------------------------------------------------------------------------
+  // Attributes
+  // -------------------------------------------------------------------------------------------
+  #setupAttrs() {
+    const { orientation } = this.$props, { dragging, active, pointing } = this.$state;
+    this.setAttributes({
+      "data-dragging": dragging,
+      "data-pointing": pointing,
+      "data-active": active,
+      "aria-disabled": this.#getARIADisabled.bind(this),
+      "aria-valuemin": this.#delegate.aria.valueMin ?? this.$state.min,
+      "aria-valuemax": this.#delegate.aria.valueMax ?? this.$state.max,
+      "aria-valuenow": this.#delegate.aria.valueNow,
+      "aria-valuetext": this.#delegate.aria.valueText,
+      "aria-orientation": orientation
+    });
+  }
+  #watchCSSVars() {
+    const { fillPercent, pointerPercent } = this.$state;
+    this.#updateSliderVars(round(fillPercent(), 3), round(pointerPercent(), 3));
+  }
+  #updateSliderVars = animationFrameThrottle((fillPercent, pointerPercent) => {
+    this.el?.style.setProperty("--slider-fill", fillPercent + "%");
+    this.el?.style.setProperty("--slider-pointer", pointerPercent + "%");
+  });
+}
+
+class Slider extends Component {
+  static props = {
+    ...SliderController.props,
+    min: 0,
+    max: 100,
+    value: 0
+  };
+  static state = sliderState;
+  constructor() {
+    super();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.$props.disabled,
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      }
+    });
+  }
+  onSetup() {
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchMinMax.bind(this));
+  }
+  // -------------------------------------------------------------------------------------------
+  // Props
+  // -------------------------------------------------------------------------------------------
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const { value, max } = this.$state;
+    return round(value() / max() * 100, 2) + "%";
+  }
+  // -------------------------------------------------------------------------------------------
+  // Watch
+  // -------------------------------------------------------------------------------------------
+  #watchValue() {
+    const { value } = this.$props;
+    this.$state.value.set(value());
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+}
+
+const cache = /* @__PURE__ */ new Map(), pending = /* @__PURE__ */ new Map();
+class ThumbnailsLoader {
+  #media;
+  #src;
+  #crossOrigin;
+  $images = signal([]);
+  static create(src, crossOrigin) {
+    const media = useMediaContext();
+    return new ThumbnailsLoader(src, crossOrigin, media);
+  }
+  constructor(src, crossOrigin, media) {
+    this.#src = src;
+    this.#crossOrigin = crossOrigin;
+    this.#media = media;
+    effect(this.#onLoadCues.bind(this));
+  }
+  #onLoadCues() {
+    const { canLoad } = this.#media.$state;
+    if (!canLoad()) return;
+    const src = this.#src();
+    if (!src) return;
+    if (isString(src) && cache.has(src)) {
+      const cues = cache.get(src);
+      cache.delete(src);
+      cache.set(src, cues);
+      if (cache.size > 99) {
+        const firstKey = cache.keys().next().value;
+        cache.delete(firstKey);
+      }
+      this.$images.set(cache.get(src));
+    } else if (isString(src)) {
+      const crossOrigin = this.#crossOrigin(), currentKey = src + "::" + crossOrigin;
+      if (!pending.has(currentKey)) {
+        const promise = new Promise(async (resolve, reject) => {
+          try {
+            const response = await fetch(src, {
+              credentials: getRequestCredentials(crossOrigin)
+            }), isJSON = response.headers.get("content-type") === "application/json";
+            if (isJSON) {
+              const json = await response.json();
+              if (isArray(json)) {
+                if (json[0] && "text" in json[0]) {
+                  resolve(this.#processVTTCues(json));
+                } else {
+                  for (let i = 0; i < json.length; i++) {
+                    const image = json[i];
+                    assert(isObject(image), false);
+                    assert(
+                      "url" in image && isString(image.url),
+                      false
+                    );
+                    assert(
+                      "startTime" in image && isNumber(image.startTime),
+                      false
+                    );
+                  }
+                  resolve(json);
+                }
+              } else {
+                resolve(this.#processStoryboard(json));
+              }
+              return;
+            }
+            import('media-captions').then(async ({ parseResponse }) => {
+              try {
+                const { cues } = await parseResponse(response);
+                resolve(this.#processVTTCues(cues));
+              } catch (e) {
+                reject(e);
+              }
+            });
+          } catch (e) {
+            reject(e);
+          }
+        }).then((images) => {
+          cache.set(currentKey, images);
+          return images;
+        }).catch((error) => {
+          this.#onError(src, error);
+        }).finally(() => {
+          if (isString(currentKey)) pending.delete(currentKey);
+        });
+        pending.set(currentKey, promise);
+      }
+      pending.get(currentKey)?.then((images) => {
+        this.$images.set(images || []);
+      });
+    } else if (isArray(src)) {
+      try {
+        this.$images.set(this.#processImages(src));
+      } catch (error) {
+        this.#onError(src, error);
+      }
+    } else {
+      try {
+        this.$images.set(this.#processStoryboard(src));
+      } catch (error) {
+        this.#onError(src, error);
+      }
+    }
+    return () => {
+      this.$images.set([]);
+    };
+  }
+  #processImages(images) {
+    const baseURL = this.#resolveBaseUrl();
+    return images.map((img, i) => {
+      assert(
+        img.url && isString(img.url));
+      assert(
+        "startTime" in img && isNumber(img.startTime));
+      return {
+        ...img,
+        url: isString(img.url) ? this.#resolveURL(img.url, baseURL) : img.url
+      };
+    });
+  }
+  #processStoryboard(board) {
+    assert(isString(board.url));
+    assert(isArray(board.tiles) && board.tiles?.length);
+    const url = new URL(board.url), images = [];
+    const tileWidth = "tile_width" in board ? board.tile_width : board.tileWidth, tileHeight = "tile_height" in board ? board.tile_height : board.tileHeight;
+    for (const tile of board.tiles) {
+      images.push({
+        url,
+        startTime: "start" in tile ? tile.start : tile.startTime,
+        width: tileWidth,
+        height: tileHeight,
+        coords: { x: tile.x, y: tile.y }
+      });
+    }
+    return images;
+  }
+  #processVTTCues(cues) {
+    for (let i = 0; i < cues.length; i++) {
+      const cue = cues[i];
+      assert(
+        "startTime" in cue && isNumber(cue.startTime));
+      assert(
+        "text" in cue && isString(cue.text));
+    }
+    const images = [], baseURL = this.#resolveBaseUrl();
+    for (const cue of cues) {
+      const [url, hash] = cue.text.split("#"), data = this.#resolveData(hash);
+      images.push({
+        url: this.#resolveURL(url, baseURL),
+        startTime: cue.startTime,
+        endTime: cue.endTime,
+        width: data?.w,
+        height: data?.h,
+        coords: data && isNumber(data.x) && isNumber(data.y) ? { x: data.x, y: data.y } : void 0
+      });
+    }
+    return images;
+  }
+  #resolveBaseUrl() {
+    let baseURL = peek(this.#src);
+    if (!isString(baseURL) || !/^https?:/.test(baseURL)) {
+      return location.href;
+    }
+    return baseURL;
+  }
+  #resolveURL(src, baseURL) {
+    return /^https?:/.test(src) ? new URL(src) : new URL(src, baseURL);
+  }
+  #resolveData(hash) {
+    if (!hash) return {};
+    const [hashProps, values] = hash.split("="), hashValues = values?.split(","), data = {};
+    if (!hashProps || !hashValues) {
+      return null;
+    }
+    for (let i = 0; i < hashProps.length; i++) {
+      const value = +hashValues[i];
+      if (!isNaN(value)) data[hashProps[i]] = value;
+    }
+    return data;
+  }
+  #onError(src, error) {
+    return;
+  }
+}
+
+class Thumbnail extends Component {
+  static props = {
+    src: null,
+    time: 0,
+    crossOrigin: null
+  };
+  static state = new State({
+    src: "",
+    img: null,
+    thumbnails: [],
+    activeThumbnail: null,
+    crossOrigin: null,
+    loading: false,
+    error: null,
+    hidden: false
+  });
+  media;
+  #loader;
+  #styleResets = [];
+  onSetup() {
+    this.media = useMediaContext();
+    this.#loader = ThumbnailsLoader.create(this.$props.src, this.$state.crossOrigin);
+    this.#watchCrossOrigin();
+    this.setAttributes({
+      "data-loading": this.#isLoading.bind(this),
+      "data-error": this.#hasError.bind(this),
+      "data-hidden": this.$state.hidden,
+      "aria-hidden": $ariaBool(this.$state.hidden)
+    });
+  }
+  onConnect(el) {
+    effect(this.#watchImg.bind(this));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#onLoadStart.bind(this));
+    effect(this.#onFindActiveThumbnail.bind(this));
+    effect(this.#resize.bind(this));
+  }
+  #watchImg() {
+    const img = this.$state.img();
+    if (!img) return;
+    new EventsController(img).add("load", this.#onLoaded.bind(this)).add("error", this.#onError.bind(this));
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
+  }
+  #onLoadStart() {
+    const { src, loading, error } = this.$state;
+    if (src()) {
+      loading.set(true);
+      error.set(null);
+    }
+    return () => {
+      this.#resetStyles();
+      loading.set(false);
+      error.set(null);
+    };
+  }
+  #onLoaded() {
+    const { loading, error } = this.$state;
+    this.#resize();
+    loading.set(false);
+    error.set(null);
+  }
+  #onError(event) {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(event);
+  }
+  #isLoading() {
+    const { loading, hidden } = this.$state;
+    return !hidden() && loading();
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error());
+  }
+  #watchHidden() {
+    const { hidden } = this.$state, { duration } = this.media.$state, images = this.#loader.$images();
+    hidden.set(this.#hasError() || !Number.isFinite(duration()) || images.length === 0);
+  }
+  getTime() {
+    return this.$props.time();
+  }
+  #onFindActiveThumbnail() {
+    let images = this.#loader.$images();
+    if (!images.length) return;
+    let time = this.getTime(), { src, activeThumbnail } = this.$state, activeIndex = -1, activeImage = null;
+    for (let i = images.length - 1; i >= 0; i--) {
+      const image = images[i];
+      if (time >= image.startTime && (!image.endTime || time < image.endTime)) {
+        activeIndex = i;
+        break;
+      }
+    }
+    if (images[activeIndex]) {
+      activeImage = images[activeIndex];
+    }
+    activeThumbnail.set(activeImage);
+    src.set(activeImage?.url.href || "");
+  }
+  #resize() {
+    if (!this.scope || this.$state.hidden()) return;
+    const rootEl = this.el, imgEl = this.$state.img(), thumbnail = this.$state.activeThumbnail();
+    if (!imgEl || !thumbnail || !rootEl) return;
+    let width = thumbnail.width ?? imgEl.naturalWidth, height = thumbnail?.height ?? imgEl.naturalHeight, {
+      maxWidth,
+      maxHeight,
+      minWidth,
+      minHeight,
+      width: elWidth,
+      height: elHeight
+    } = getComputedStyle(this.el);
+    if (minWidth === "100%") minWidth = parseFloat(elWidth) + "";
+    if (minHeight === "100%") minHeight = parseFloat(elHeight) + "";
+    let minRatio = Math.max(parseInt(minWidth) / width, parseInt(minHeight) / height), maxRatio = Math.min(
+      Math.max(parseInt(minWidth), parseInt(maxWidth)) / width,
+      Math.max(parseInt(minHeight), parseInt(maxHeight)) / height
+    ), scale = !isNaN(maxRatio) && maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
+    this.#style(rootEl, "--thumbnail-width", `${width * scale}px`);
+    this.#style(rootEl, "--thumbnail-height", `${height * scale}px`);
+    this.#style(rootEl, "--thumbnail-aspect-ratio", String(round(width / height, 5)));
+    this.#style(imgEl, "width", `${imgEl.naturalWidth * scale}px`);
+    this.#style(imgEl, "height", `${imgEl.naturalHeight * scale}px`);
+    this.#style(
+      imgEl,
+      "transform",
+      thumbnail.coords ? `translate(-${thumbnail.coords.x * scale}px, -${thumbnail.coords.y * scale}px)` : ""
+    );
+    this.#style(imgEl, "max-width", "none");
+  }
+  #style(el, name, value) {
+    el.style.setProperty(name, value);
+    this.#styleResets.push(() => el.style.removeProperty(name));
+  }
+  #resetStyles() {
+    for (const reset of this.#styleResets) reset();
+    this.#styleResets = [];
+  }
+}
+
+class SliderThumbnail extends Thumbnail {
+  #slider;
+  onAttach(el) {
+    this.#slider = useState(Slider.state);
+  }
+  getTime() {
+    const { duration, clipStartTime } = this.media.$state;
+    return clipStartTime() + this.#slider.pointerRate() * duration();
+  }
+}
+
+class SliderVideo extends Component {
+  static props = {
+    src: null,
+    crossOrigin: null
+  };
+  static state = new State({
+    video: null,
+    src: null,
+    crossOrigin: null,
+    canPlay: false,
+    error: null,
+    hidden: false
+  });
+  #media;
+  #slider;
+  get video() {
+    return this.$state.video();
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#slider = useState(Slider.state);
+    this.#watchCrossOrigin();
+    this.setAttributes({
+      "data-loading": this.#isLoading.bind(this),
+      "data-hidden": this.$state.hidden,
+      "data-error": this.#hasError.bind(this),
+      "aria-hidden": $ariaBool(this.$state.hidden)
+    });
+  }
+  onAttach(el) {
+    effect(this.#watchVideo.bind(this));
+    effect(this.#watchSrc.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#onSrcChange.bind(this));
+    effect(this.#onUpdateTime.bind(this));
+  }
+  #watchVideo() {
+    const video = this.$state.video();
+    if (!video) return;
+    if (video.readyState >= 2) this.#onCanPlay();
+    new EventsController(video).add("canplay", this.#onCanPlay.bind(this)).add("error", this.#onError.bind(this));
+  }
+  #watchSrc() {
+    const { src } = this.$state, { canLoad } = this.#media.$state;
+    src.set(canLoad() ? this.$props.src() : null);
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
+  }
+  #isLoading() {
+    const { canPlay, hidden } = this.$state;
+    return !canPlay() && !hidden();
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error);
+  }
+  #watchHidden() {
+    const { src, hidden } = this.$state, { canLoad, duration } = this.#media.$state;
+    hidden.set(canLoad() && (!src() || this.#hasError() || !Number.isFinite(duration())));
+  }
+  #onSrcChange() {
+    const { src, canPlay, error } = this.$state;
+    src();
+    canPlay.set(false);
+    error.set(null);
+  }
+  #onCanPlay(event) {
+    const { canPlay, error } = this.$state;
+    canPlay.set(true);
+    error.set(null);
+    this.dispatch("can-play", { trigger: event });
+  }
+  #onError(event) {
+    const { canPlay, error } = this.$state;
+    canPlay.set(false);
+    error.set(event);
+    this.dispatch("error", { trigger: event });
+  }
+  #onUpdateTime() {
+    const { video, canPlay } = this.$state, { duration } = this.#media.$state, { pointerRate } = this.#slider, media = video(), canUpdate = canPlay() && media && Number.isFinite(duration()) && Number.isFinite(pointerRate());
+    if (canUpdate) {
+      media.currentTime = pointerRate() * duration();
+    }
+  }
+}
+const slidervideo__proto = SliderVideo.prototype;
+prop(slidervideo__proto, "video");
+
+class SliderValue extends Component {
+  static props = {
+    type: "pointer",
+    format: null,
+    showHours: false,
+    showMs: false,
+    padHours: null,
+    padMinutes: null,
+    decimalPlaces: 2
+  };
+  #format;
+  #text;
+  #slider;
+  onSetup() {
+    this.#slider = useState(Slider.state);
+    this.#format = useContext(sliderValueFormatContext);
+    this.#text = computed(this.getValueText.bind(this));
+  }
+  /**
+   * Returns the current value formatted as text based on prop settings.
+   */
+  getValueText() {
+    const {
+      type,
+      format: $format,
+      decimalPlaces,
+      padHours,
+      padMinutes,
+      showHours,
+      showMs
+    } = this.$props, { value: sliderValue, pointerValue, min, max } = this.#slider, format = $format?.() ?? this.#format.default;
+    const value = type() === "current" ? sliderValue() : pointerValue();
+    if (format === "percent") {
+      const range = max() - min();
+      const percent = value / range * 100;
+      return (this.#format.percent ?? round)(percent, decimalPlaces()) + "%";
+    } else if (format === "time") {
+      return (this.#format.time ?? formatTime)(value, {
+        padHrs: padHours(),
+        padMins: padMinutes(),
+        showHrs: showHours(),
+        showMs: showMs()
+      });
+    } else {
+      return (this.#format.value?.(value) ?? value.toFixed(2)) + "";
+    }
+  }
+}
+const slidervalue__proto = SliderValue.prototype;
+method(slidervalue__proto, "getValueText");
+
+class SliderPreview extends Component {
+  static props = {
+    offset: 0,
+    noClamp: false
+  };
+  #slider;
+  onSetup() {
+    this.#slider = useContext(sliderContext);
+    const { active } = useState(Slider.state);
+    this.setAttributes({
+      "data-visible": active
+    });
+  }
+  onAttach(el) {
+    Object.assign(el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+  }
+  onConnect(el) {
+    const { preview } = this.#slider;
+    preview.set(el);
+    onDispose(() => preview.set(null));
+    effect(this.#updatePlacement.bind(this));
+    const resize = new ResizeObserver(this.#updatePlacement.bind(this));
+    resize.observe(el);
+    onDispose(() => resize.disconnect());
+  }
+  #updatePlacement = animationFrameThrottle(() => {
+    const { disabled, orientation } = this.#slider;
+    if (disabled()) return;
+    const el = this.el, { offset, noClamp } = this.$props;
+    if (!el) return;
+    updateSliderPreviewPlacement(el, {
+      clamp: !noClamp(),
+      offset: offset(),
+      orientation: orientation()
+    });
+  });
+}
+function updateSliderPreviewPlacement(el, {
+  clamp,
+  offset,
+  orientation
+}) {
+  const computedStyle = getComputedStyle(el), width = parseFloat(computedStyle.width), height = parseFloat(computedStyle.height), styles = {
+    top: null,
+    right: null,
+    bottom: null,
+    left: null
+  };
+  styles[orientation === "horizontal" ? "bottom" : "left"] = `calc(100% + var(--media-slider-preview-offset, ${offset}px))`;
+  if (orientation === "horizontal") {
+    const widthHalf = width / 2;
+    if (!clamp) {
+      styles.left = `calc(var(--slider-pointer) - ${widthHalf}px)`;
+    } else {
+      const leftClamp = `max(0px, calc(var(--slider-pointer) - ${widthHalf}px))`, rightClamp = `calc(100% - ${width}px)`;
+      styles.left = `min(${leftClamp}, ${rightClamp})`;
+    }
+  } else {
+    const heightHalf = height / 2;
+    if (!clamp) {
+      styles.bottom = `calc(var(--slider-pointer) - ${heightHalf}px)`;
+    } else {
+      const topClamp = `max(${heightHalf}px, calc(var(--slider-pointer) - ${heightHalf}px))`, bottomClamp = `calc(100% - ${height}px)`;
+      styles.bottom = `min(${topClamp}, ${bottomClamp})`;
+    }
+  }
+  Object.assign(el.style, styles);
+}
+
+class VolumeSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    keyStep: 5,
+    shiftKeyMultiplier: 2
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    const { audioGain } = this.#media.$state;
+    provideContext(sliderValueFormatContext, {
+      default: "percent",
+      value(value) {
+        return (value * (audioGain() ?? 1)).toFixed(2);
+      },
+      percent(value) {
+        return Math.round(value * (audioGain() ?? 1));
+      }
+    });
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueMax: this.#getARIAValueMax.bind(this),
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchVolume.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-volume-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Volume");
+    const { canSetVolume } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetVolume,
+      "aria-hidden": $ariaBool(() => !canSetVolume())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state, { audioGain } = this.#media.$state;
+    return Math.round(value() * (audioGain() ?? 1));
+  }
+  #getARIAValueText() {
+    const { value, max } = this.$state, { audioGain } = this.#media.$state;
+    return round(value() / max() * (audioGain() ?? 1) * 100, 2) + "%";
+  }
+  #getARIAValueMax() {
+    const { audioGain } = this.#media.$state;
+    return this.$state.max() * (audioGain() ?? 1);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetVolume } = this.#media.$state;
+    return disabled() || !canSetVolume();
+  }
+  #watchVolume() {
+    const { muted, volume } = this.#media.$state;
+    const newValue = muted() ? 0 : volume() * 100;
+    this.$state.value.set(newValue);
+    this.dispatch("value-change", { detail: newValue });
+  }
+  #throttleVolumeChange = functionThrottle(this.#onVolumeChange.bind(this), 25);
+  #onVolumeChange(event) {
+    if (!event.trigger) return;
+    const mediaVolume = round(event.detail / 100, 3);
+    this.#media.remote.changeVolume(mediaVolume, event);
+  }
+  #onValueChange(event) {
+    this.#throttleVolumeChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttleVolumeChange(event);
+  }
+}
+
+class AudioGainSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 25,
+    keyStep: 25,
+    shiftKeyMultiplier: 2,
+    min: 0,
+    max: 300
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(sliderValueFormatContext, {
+      default: "percent",
+      percent: (_, decimalPlaces) => {
+        return round(this.$state.value(), decimalPlaces) + "%";
+      }
+    });
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMinMax.bind(this));
+    effect(this.#watchAudioGain.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-audio-gain-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Audio Boost");
+    const { canSetAudioGain } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetAudioGain,
+      "aria-hidden": $ariaBool(() => !canSetAudioGain())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const { value } = this.$state;
+    return value() + "%";
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+  #watchAudioGain() {
+    const { audioGain } = this.#media.$state, value = ((audioGain() ?? 1) - 1) * 100;
+    this.$state.value.set(value);
+    this.dispatch("value-change", { detail: value });
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetAudioGain } = this.#media.$state;
+    return disabled() || !canSetAudioGain();
+  }
+  #onAudioGainChange(event) {
+    if (!event.trigger) return;
+    const gain = round(1 + event.detail / 100, 2);
+    this.#media.remote.changeAudioGain(gain, event);
+  }
+  #onValueChange(event) {
+    this.#onAudioGainChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#onAudioGainChange(event);
+  }
+}
+
+class SpeedSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 0.25,
+    keyStep: 0.25,
+    shiftKeyMultiplier: 2,
+    min: 0,
+    max: 2
+  };
+  static state = sliderState;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: this.#roundValue,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMinMax.bind(this));
+    effect(this.#watchPlaybackRate.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-speed-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Speed");
+    const { canSetPlaybackRate } = this.#media.$state;
+    this.setAttributes({
+      "data-supported": canSetPlaybackRate,
+      "aria-hidden": $ariaBool(() => !canSetPlaybackRate())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return value();
+  }
+  #getARIAValueText() {
+    const { value } = this.$state;
+    return value() + "x";
+  }
+  #watchMinMax() {
+    const { min, max } = this.$props;
+    this.$state.min.set(min());
+    this.$state.max.set(max());
+  }
+  #watchPlaybackRate() {
+    const { playbackRate } = this.#media.$state;
+    const newValue = playbackRate();
+    this.$state.value.set(newValue);
+    this.dispatch("value-change", { detail: newValue });
+  }
+  #roundValue(value) {
+    return round(value, 2);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetPlaybackRate } = this.#media.$state;
+    return disabled() || !canSetPlaybackRate();
+  }
+  #throttledSpeedChange = functionThrottle(this.#onPlaybackRateChange.bind(this), 25);
+  #onPlaybackRateChange(event) {
+    if (!event.trigger) return;
+    const rate = event.detail;
+    this.#media.remote.changePlaybackRate(rate, event);
+  }
+  #onValueChange(event) {
+    this.#throttledSpeedChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttledSpeedChange(event);
+  }
+}
+
+class QualitySlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 1,
+    keyStep: 1,
+    shiftKeyMultiplier: 1
+  };
+  static state = sliderState;
+  #media;
+  #sortedQualities = computed(() => {
+    const { qualities } = this.#media.$state;
+    return sortVideoQualities(qualities());
+  });
+  onSetup() {
+    this.#media = useMediaContext();
+    new SliderController({
+      getStep: this.$props.step,
+      getKeyStep: this.$props.keyStep,
+      roundValue: Math.round,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    }).attach(this);
+    effect(this.#watchMax.bind(this));
+    effect(this.#watchQuality.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-quality-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Video Quality");
+    const { qualities, canSetQuality } = this.#media.$state, $supported = computed(() => canSetQuality() && qualities().length > 0);
+    this.setAttributes({
+      "data-supported": $supported,
+      "aria-hidden": $ariaBool(() => !$supported())
+    });
+  }
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return value();
+  }
+  #getARIAValueText() {
+    const { quality } = this.#media.$state;
+    if (!quality()) return "";
+    const { height, bitrate } = quality(), bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null;
+    return height ? `${height}p${bitrateText ? ` (${bitrateText})` : ""}` : "Auto";
+  }
+  #watchMax() {
+    const $qualities = this.#sortedQualities();
+    this.$state.max.set(Math.max(0, $qualities.length - 1));
+  }
+  #watchQuality() {
+    let { quality } = this.#media.$state, $qualities = this.#sortedQualities(), value = Math.max(0, $qualities.indexOf(quality()));
+    this.$state.value.set(value);
+    this.dispatch("value-change", { detail: value });
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSetQuality, qualities } = this.#media.$state;
+    return disabled() || qualities().length <= 1 || !canSetQuality();
+  }
+  #throttledQualityChange = functionThrottle(this.#onQualityChange.bind(this), 25);
+  #onQualityChange(event) {
+    if (!event.trigger) return;
+    const { qualities } = this.#media, quality = peek(this.#sortedQualities)[event.detail];
+    this.#media.remote.changeQuality(qualities.indexOf(quality), event);
+  }
+  #onValueChange(event) {
+    this.#throttledQualityChange(event);
+  }
+  #onDragValueChange(event) {
+    this.#throttledQualityChange(event);
+  }
+}
+
+class TimeSlider extends Component {
+  static props = {
+    ...SliderController.props,
+    step: 0.1,
+    keyStep: 5,
+    shiftKeyMultiplier: 2,
+    pauseWhileDragging: false,
+    noSwipeGesture: false,
+    seekingRequestThrottle: 100
+  };
+  static state = sliderState;
+  #media;
+  #dispatchSeeking;
+  #chapter = signal(null);
+  constructor() {
+    super();
+    const { noSwipeGesture } = this.$props;
+    new SliderController({
+      swipeGesture: () => !noSwipeGesture(),
+      getValue: this.#getValue.bind(this),
+      getStep: this.#getStep.bind(this),
+      getKeyStep: this.#getKeyStep.bind(this),
+      roundValue: this.#roundValue,
+      isDisabled: this.#isDisabled.bind(this),
+      aria: {
+        valueNow: this.#getARIAValueNow.bind(this),
+        valueText: this.#getARIAValueText.bind(this)
+      },
+      onDragStart: this.#onDragStart.bind(this),
+      onDragValueChange: this.#onDragValueChange.bind(this),
+      onDragEnd: this.#onDragEnd.bind(this),
+      onValueChange: this.#onValueChange.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(sliderValueFormatContext, {
+      default: "time",
+      value: this.#formatValue.bind(this),
+      time: this.#formatTime.bind(this)
+    });
+    this.setAttributes({
+      "data-chapters": this.#hasChapters.bind(this)
+    });
+    this.setStyles({
+      "--slider-progress": this.#calcBufferedPercent.bind(this)
+    });
+    effect(this.#watchCurrentTime.bind(this));
+    effect(this.#watchSeekingThrottle.bind(this));
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-time-slider", "");
+    setAttributeIfEmpty(el, "aria-label", "Seek");
+  }
+  onConnect(el) {
+    effect(this.#watchPreviewing.bind(this));
+    watchActiveTextTrack(this.#media.textTracks, "chapters", this.#chapter.set);
+  }
+  #calcBufferedPercent() {
+    const { bufferedEnd, duration } = this.#media.$state;
+    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + "%";
+  }
+  #hasChapters() {
+    const { duration } = this.#media.$state;
+    return this.#chapter()?.cues.length && Number.isFinite(duration()) && duration() > 0;
+  }
+  #watchSeekingThrottle() {
+    this.#dispatchSeeking = functionThrottle(
+      this.#seeking.bind(this),
+      this.$props.seekingRequestThrottle()
+    );
+  }
+  #watchCurrentTime() {
+    if (this.$state.hidden()) return;
+    const { value, dragging } = this.$state, newValue = this.#getValue();
+    if (!peek(dragging)) {
+      value.set(newValue);
+      this.dispatch("value-change", { detail: newValue });
+    }
+  }
+  #watchPreviewing() {
+    const player = this.#media.player.el, { preview } = useContext(sliderContext);
+    player && preview() && setAttribute(player, "data-preview", this.$state.active());
+  }
+  #seeking(time, event) {
+    this.#media.remote.seeking(time, event);
+  }
+  #seek(time, percent, event) {
+    this.#dispatchSeeking.cancel();
+    const { live } = this.#media.$state;
+    if (live() && percent >= 99) {
+      this.#media.remote.seekToLiveEdge(event);
+      return;
+    }
+    this.#media.remote.seek(time, event);
+  }
+  #playingBeforeDragStart = false;
+  #onDragStart(event) {
+    const { pauseWhileDragging } = this.$props;
+    if (pauseWhileDragging()) {
+      const { paused } = this.#media.$state;
+      this.#playingBeforeDragStart = !paused();
+      this.#media.remote.pause(event);
+    }
+  }
+  #onDragValueChange(event) {
+    this.#dispatchSeeking(this.#percentToTime(event.detail), event);
+  }
+  #onDragEnd(event) {
+    const { seeking } = this.#media.$state;
+    if (!peek(seeking)) this.#seeking(this.#percentToTime(event.detail), event);
+    const percent = event.detail;
+    this.#seek(this.#percentToTime(percent), percent, event);
+    const { pauseWhileDragging } = this.$props;
+    if (pauseWhileDragging() && this.#playingBeforeDragStart) {
+      this.#media.remote.play(event);
+      this.#playingBeforeDragStart = false;
+    }
+  }
+  #onValueChange(event) {
+    const { dragging } = this.$state;
+    if (dragging() || !event.trigger) return;
+    this.#onDragEnd(event);
+  }
+  // -------------------------------------------------------------------------------------------
+  // Props
+  // -------------------------------------------------------------------------------------------
+  #getValue() {
+    const { currentTime } = this.#media.$state;
+    return this.#timeToPercent(currentTime());
+  }
+  #getStep() {
+    const value = this.$props.step() / this.#media.$state.duration() * 100;
+    return Number.isFinite(value) ? value : 1;
+  }
+  #getKeyStep() {
+    const value = this.$props.keyStep() / this.#media.$state.duration() * 100;
+    return Number.isFinite(value) ? value : 1;
+  }
+  #roundValue(value) {
+    return round(value, 3);
+  }
+  #isDisabled() {
+    const { disabled } = this.$props, { canSeek } = this.#media.$state;
+    return disabled() || !canSeek();
+  }
+  // -------------------------------------------------------------------------------------------
+  // ARIA
+  // -------------------------------------------------------------------------------------------
+  #getARIAValueNow() {
+    const { value } = this.$state;
+    return Math.round(value());
+  }
+  #getARIAValueText() {
+    const time = this.#percentToTime(this.$state.value()), { duration } = this.#media.$state;
+    return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : "live";
+  }
+  // -------------------------------------------------------------------------------------------
+  // Format
+  // -------------------------------------------------------------------------------------------
+  #percentToTime(percent) {
+    const { duration } = this.#media.$state;
+    return round(percent / 100 * duration(), 5);
+  }
+  #timeToPercent(time) {
+    const { liveEdge, duration } = this.#media.$state, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));
+    return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
+  }
+  #formatValue(percent) {
+    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state;
+    return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : "LIVE";
+  }
+  #formatTime(percent, options) {
+    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state, value = live() ? time - duration() : time;
+    return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(Math.abs(value), options)}` : "LIVE";
+  }
+}
+
+class SliderChapters extends Component {
+  static props = {
+    disabled: false
+  };
+  #media;
+  #sliderState;
+  #updateScope;
+  #titleRef = null;
+  #refs = [];
+  #$track = signal(null);
+  #$cues = signal([]);
+  #activeIndex = signal(-1);
+  #activePointerIndex = signal(-1);
+  #bufferedIndex = 0;
+  get cues() {
+    return this.#$cues();
+  }
+  get activeCue() {
+    return this.#$cues()[this.#activeIndex()] || null;
+  }
+  get activePointerCue() {
+    return this.#$cues()[this.#activePointerIndex()] || null;
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#sliderState = useState(TimeSlider.state);
+  }
+  onAttach(el) {
+    watchActiveTextTrack(this.#media.textTracks, "chapters", this.#setTrack.bind(this));
+    effect(this.#watchSource.bind(this));
+  }
+  onConnect() {
+    onDispose(() => this.#reset.bind(this));
+  }
+  onDestroy() {
+    this.#setTrack(null);
+  }
+  setRefs(refs) {
+    this.#refs = refs;
+    this.#updateScope?.dispose();
+    if (this.#refs.length === 1) {
+      const el = this.#refs[0];
+      el.style.width = "100%";
+      el.style.setProperty("--chapter-fill", "var(--slider-fill)");
+      el.style.setProperty("--chapter-progress", "var(--slider-progress)");
+    } else if (this.#refs.length > 0) {
+      scoped(() => this.#watch(), this.#updateScope = createScope());
+    }
+  }
+  #setTrack(track) {
+    if (peek(this.#$track) === track) return;
+    this.#reset();
+    this.#$track.set(track);
+  }
+  #reset() {
+    this.#refs = [];
+    this.#$cues.set([]);
+    this.#activeIndex.set(-1);
+    this.#activePointerIndex.set(-1);
+    this.#bufferedIndex = 0;
+    this.#updateScope?.dispose();
+  }
+  #watch() {
+    if (!this.#refs.length) return;
+    effect(this.#watchUpdates.bind(this));
+  }
+  #watchUpdates() {
+    const { hidden } = this.#sliderState;
+    if (hidden()) return;
+    effect(this.#watchContainerWidths.bind(this));
+    effect(this.#watchFillPercent.bind(this));
+    effect(this.#watchPointerPercent.bind(this));
+    effect(this.#watchBufferedPercent.bind(this));
+  }
+  #watchContainerWidths() {
+    const cues = this.#$cues();
+    if (!cues.length) return;
+    let cue, { seekableStart, seekableEnd } = this.#media.$state, startTime = seekableStart(), endTime = seekableEnd() || cues[cues.length - 1].endTime, duration = endTime - startTime, remainingWidth = 100;
+    for (let i = 0; i < cues.length; i++) {
+      cue = cues[i];
+      if (this.#refs[i]) {
+        const width = i === cues.length - 1 ? remainingWidth : round((cue.endTime - Math.max(startTime, cue.startTime)) / duration * 100, 3);
+        this.#refs[i].style.width = width + "%";
+        remainingWidth -= width;
+      }
+    }
+  }
+  #watchFillPercent() {
+    let { liveEdge, seekableStart, seekableEnd } = this.#media.$state, { fillPercent, value } = this.#sliderState, cues = this.#$cues(), isLiveEdge = liveEdge(), prevActiveIndex = peek(this.#activeIndex), currentChapter = cues[prevActiveIndex];
+    let currentActiveIndex = isLiveEdge ? this.#$cues.length - 1 : this.#findActiveChapterIndex(
+      currentChapter ? currentChapter.startTime / seekableEnd() * 100 <= peek(value) ? prevActiveIndex : 0 : 0,
+      fillPercent()
+    );
+    if (isLiveEdge || !currentChapter) {
+      this.#updateFillPercents(0, cues.length, 100);
+    } else if (currentActiveIndex > prevActiveIndex) {
+      this.#updateFillPercents(prevActiveIndex, currentActiveIndex, 100);
+    } else if (currentActiveIndex < prevActiveIndex) {
+      this.#updateFillPercents(currentActiveIndex + 1, prevActiveIndex + 1, 0);
+    }
+    const percent = isLiveEdge ? 100 : this.#calcPercent(
+      cues[currentActiveIndex],
+      fillPercent(),
+      seekableStart(),
+      this.#getEndTime(cues)
+    );
+    this.#updateFillPercent(this.#refs[currentActiveIndex], percent);
+    this.#activeIndex.set(currentActiveIndex);
+  }
+  #watchPointerPercent() {
+    let { pointing, pointerPercent } = this.#sliderState;
+    if (!pointing()) {
+      this.#activePointerIndex.set(-1);
+      return;
+    }
+    const activeIndex = this.#findActiveChapterIndex(0, pointerPercent());
+    this.#activePointerIndex.set(activeIndex);
+  }
+  #updateFillPercents(start, end, percent) {
+    for (let i = start; i < end; i++) this.#updateFillPercent(this.#refs[i], percent);
+  }
+  #updateFillPercent(ref, percent) {
+    if (!ref) return;
+    ref.style.setProperty("--chapter-fill", percent + "%");
+    setAttribute(ref, "data-active", percent > 0 && percent < 100);
+    setAttribute(ref, "data-ended", percent === 100);
+  }
+  #findActiveChapterIndex(startIndex, percent) {
+    let chapterPercent = 0, cues = this.#$cues();
+    if (percent === 0) return 0;
+    else if (percent === 100) return cues.length - 1;
+    let { seekableStart } = this.#media.$state, startTime = seekableStart(), endTime = this.#getEndTime(cues);
+    for (let i = startIndex; i < cues.length; i++) {
+      chapterPercent = this.#calcPercent(cues[i], percent, startTime, endTime);
+      if (chapterPercent >= 0 && chapterPercent < 100) return i;
+    }
+    return 0;
+  }
+  #watchBufferedPercent() {
+    this.#updateBufferedPercent(this.#bufferedPercent());
+  }
+  #updateBufferedPercent = animationFrameThrottle((bufferedPercent) => {
+    let percent, cues = this.#$cues(), { seekableStart } = this.#media.$state, startTime = seekableStart(), endTime = this.#getEndTime(cues);
+    for (let i = this.#bufferedIndex; i < this.#refs.length; i++) {
+      percent = this.#calcPercent(cues[i], bufferedPercent, startTime, endTime);
+      this.#refs[i]?.style.setProperty("--chapter-progress", percent + "%");
+      if (percent < 100) {
+        this.#bufferedIndex = i;
+        break;
+      }
+    }
+  });
+  #bufferedPercent = computed(this.#calcMediaBufferedPercent.bind(this));
+  #calcMediaBufferedPercent() {
+    const { bufferedEnd, duration } = this.#media.$state;
+    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1), 3) * 100;
+  }
+  #getEndTime(cues) {
+    const { seekableEnd } = this.#media.$state, endTime = seekableEnd();
+    return Number.isFinite(endTime) ? endTime : cues[cues.length - 1]?.endTime || 0;
+  }
+  #calcPercent(cue, percent, startTime, endTime) {
+    if (!cue) return 0;
+    const cues = this.#$cues();
+    if (cues.length === 0) return 0;
+    const duration = endTime - startTime, cueStartTime = Math.max(0, cue.startTime - startTime), cueEndTime = Math.min(endTime, cue.endTime) - startTime;
+    const startRatio = cueStartTime / duration, startPercent = startRatio * 100, endPercent = Math.min(1, startRatio + (cueEndTime - cueStartTime) / duration) * 100;
+    return Math.max(
+      0,
+      round(
+        percent >= endPercent ? 100 : (percent - startPercent) / (endPercent - startPercent) * 100,
+        3
+      )
+    );
+  }
+  #fillGaps(cues) {
+    let chapters = [], { seekableStart, seekableEnd, duration } = this.#media.$state, startTime = seekableStart(), endTime = seekableEnd();
+    cues = cues.filter((cue) => cue.startTime <= endTime && cue.endTime >= startTime);
+    const firstCue = cues[0];
+    if (firstCue && firstCue.startTime > startTime) {
+      chapters.push(new window.VTTCue(startTime, firstCue.startTime, ""));
+    }
+    for (let i = 0; i < cues.length - 1; i++) {
+      const currentCue = cues[i], nextCue = cues[i + 1];
+      chapters.push(currentCue);
+      if (nextCue) {
+        const timeDiff = nextCue.startTime - currentCue.endTime;
+        if (timeDiff > 0) {
+          chapters.push(new window.VTTCue(currentCue.endTime, currentCue.endTime + timeDiff, ""));
+        }
+      }
+    }
+    const lastCue = cues[cues.length - 1];
+    if (lastCue) {
+      chapters.push(lastCue);
+      const endTime2 = duration();
+      if (endTime2 >= 0 && endTime2 - lastCue.endTime > 1) {
+        chapters.push(new window.VTTCue(lastCue.endTime, duration(), ""));
+      }
+    }
+    return chapters;
+  }
+  #watchSource() {
+    const { source } = this.#media.$state;
+    source();
+    this.#onTrackChange();
+  }
+  #onTrackChange() {
+    if (!this.scope) return;
+    const { disabled } = this.$props;
+    if (disabled()) {
+      this.#$cues.set([]);
+      this.#activeIndex.set(0);
+      this.#bufferedIndex = 0;
+      return;
+    }
+    const track = this.#$track();
+    if (track) {
+      const onCuesChange = this.#onCuesChange.bind(this);
+      onCuesChange();
+      new EventsController(track).add("add-cue", onCuesChange).add("remove-cue", onCuesChange);
+      effect(this.#watchMediaDuration.bind(this));
+    }
+    this.#titleRef = this.#findChapterTitleRef();
+    if (this.#titleRef) effect(this.#onChapterTitleChange.bind(this));
+    return () => {
+      if (this.#titleRef) {
+        this.#titleRef.textContent = "";
+        this.#titleRef = null;
+      }
+    };
+  }
+  #watchMediaDuration() {
+    this.#media.$state.duration();
+    this.#onCuesChange();
+  }
+  #onCuesChange = functionDebounce(
+    () => {
+      const track = peek(this.#$track);
+      if (!this.scope || !track || !track.cues.length) return;
+      this.#$cues.set(this.#fillGaps(track.cues));
+      this.#activeIndex.set(0);
+      this.#bufferedIndex = 0;
+    },
+    150,
+    true
+  );
+  #onChapterTitleChange() {
+    const cue = this.activePointerCue || this.activeCue;
+    if (this.#titleRef) this.#titleRef.textContent = cue?.text || "";
+  }
+  #findParentSlider() {
+    let node = this.el;
+    while (node && node.getAttribute("role") !== "slider") {
+      node = node.parentElement;
+    }
+    return node;
+  }
+  #findChapterTitleRef() {
+    const slider = this.#findParentSlider();
+    return slider ? slider.querySelector('[data-part="chapter-title"]') : null;
+  }
+}
+const sliderchapters__proto = SliderChapters.prototype;
+prop(sliderchapters__proto, "cues");
+prop(sliderchapters__proto, "activeCue");
+prop(sliderchapters__proto, "activePointerCue");
+method(sliderchapters__proto, "setRefs");
+
+const menuContext = createContext();
+
+function scrollIntoView(el, options) {
+  const scrolls = r(el, options);
+  for (const { el: el2, top, left } of scrolls) {
+    el2.scroll({ top, left, behavior: options.behavior });
+  }
+}
+function scrollIntoCenter(el, options = {}) {
+  scrollIntoView(el, {
+    scrollMode: "if-needed",
+    block: "center",
+    inline: "center",
+    ...options
+  });
+}
+
+const FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
+  "a[href]",
+  "[tabindex]",
+  "input",
+  "select",
+  "button"
+].map((selector) => `${selector}:not([aria-hidden='true'])`).join(",");
+const VALID_KEYS = /* @__PURE__ */ new Set([
+  "Escape",
+  "Tab",
+  "ArrowUp",
+  "ArrowDown",
+  "Home",
+  "PageUp",
+  "End",
+  "PageDown",
+  "Enter",
+  " "
+]);
+class MenuFocusController {
+  #index = -1;
+  #el = null;
+  #elements = [];
+  #delegate;
+  get items() {
+    return this.#elements;
+  }
+  constructor(delegate) {
+    this.#delegate = delegate;
+  }
+  attachMenu(el) {
+    listenEvent(el, "focus", this.#onFocus.bind(this));
+    this.#el = el;
+    onDispose(() => {
+      this.#el = null;
+    });
+  }
+  listen() {
+    if (!this.#el) return;
+    this.update();
+    new EventsController(this.#el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this));
+    onDispose(() => {
+      this.#index = -1;
+      this.#elements = [];
+    });
+  }
+  update() {
+    this.#index = 0;
+    this.#elements = this.#getFocusableElements();
+  }
+  scroll(index = this.#findActiveIndex()) {
+    const element = this.#elements[index];
+    if (element) {
+      requestAnimationFrame(() => {
+        requestAnimationFrame(() => {
+          scrollIntoCenter(element, {
+            behavior: "smooth",
+            boundary: (el) => {
+              return !el.hasAttribute("data-root");
+            }
+          });
+        });
+      });
+    }
+  }
+  focusActive(scroll = true) {
+    const index = this.#findActiveIndex();
+    this.#focusAt(index >= 0 ? index : 0, scroll);
+  }
+  #focusAt(index, scroll = true) {
+    this.#index = index;
+    if (this.#elements[index]) {
+      this.#elements[index].focus({ preventScroll: true });
+      if (scroll) this.scroll(index);
+    } else {
+      this.#el?.focus({ preventScroll: true });
+    }
+  }
+  #findActiveIndex() {
+    return this.#elements.findIndex(
+      (el) => document.activeElement === el || el.getAttribute("role") === "menuitemradio" && el.getAttribute("aria-checked") === "true"
+    );
+  }
+  #onFocus() {
+    if (this.#index >= 0) return;
+    this.update();
+    this.focusActive();
+  }
+  #validateKeyEvent(event) {
+    const el = event.target;
+    if (wasEnterKeyPressed(event) && el instanceof Element) {
+      const role = el.getAttribute("role");
+      return !/a|input|select|button/.test(el.localName) && !role;
+    }
+    return VALID_KEYS.has(event.key);
+  }
+  #onKeyUp(event) {
+    if (!this.#validateKeyEvent(event)) return;
+    event.stopPropagation();
+    event.preventDefault();
+  }
+  #onKeyDown(event) {
+    if (!this.#validateKeyEvent(event)) return;
+    event.stopPropagation();
+    event.preventDefault();
+    switch (event.key) {
+      case "Escape":
+        this.#delegate.closeMenu(event);
+        break;
+      case "Tab":
+        this.#focusAt(this.#nextIndex(event.shiftKey ? -1 : 1));
+        break;
+      case "ArrowUp":
+        this.#focusAt(this.#nextIndex(-1));
+        break;
+      case "ArrowDown":
+        this.#focusAt(this.#nextIndex(1));
+        break;
+      case "Home":
+      case "PageUp":
+        this.#focusAt(0);
+        break;
+      case "End":
+      case "PageDown":
+        this.#focusAt(this.#elements.length - 1);
+        break;
+    }
+  }
+  #nextIndex(delta) {
+    let index = this.#index;
+    do {
+      index = (index + delta + this.#elements.length) % this.#elements.length;
+    } while (this.#elements[index]?.offsetParent === null);
+    return index;
+  }
+  #getFocusableElements() {
+    if (!this.#el) return [];
+    const focusableElements = this.#el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
+    const is = (node) => {
+      return node.getAttribute("role") === "menu";
+    };
+    for (const el of focusableElements) {
+      if (isHTMLElement(el) && el.offsetParent !== null && // does not have display: none
+      isElementParent(this.#el, el, is)) {
+        elements.push(el);
+      }
+    }
+    return elements;
+  }
+}
+
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __decorateClass = (decorators, target, key, kind) => {
+  var result = __getOwnPropDesc(target, key) ;
+  for (var i = decorators.length - 1, decorator; i >= 0; i--)
+    if (decorator = decorators[i])
+      result = (decorator(target, key, result) ) || result;
+  if (result) __defProp(target, key, result);
+  return result;
+};
+let idCount = 0;
+class Menu extends Component {
+  static props = {
+    showDelay: 0
+  };
+  #media;
+  #menuId;
+  #menuButtonId;
+  #expanded = signal(false);
+  #disabled = signal(false);
+  #trigger = signal(null);
+  #content = signal(null);
+  #parentMenu;
+  #submenus = /* @__PURE__ */ new Set();
+  #menuObserver = null;
+  #popper;
+  #focus;
+  #isSliderActive = false;
+  #isTriggerDisabled = signal(false);
+  #transitionCallbacks = /* @__PURE__ */ new Set();
+  get triggerElement() {
+    return this.#trigger();
+  }
+  get contentElement() {
+    return this.#content();
+  }
+  get isSubmenu() {
+    return !!this.#parentMenu;
+  }
+  constructor() {
+    super();
+    const { showDelay } = this.$props;
+    this.#popper = new Popper({
+      trigger: this.#trigger,
+      content: this.#content,
+      showDelay,
+      listen: (trigger, show, hide) => {
+        onPress(trigger, (event) => {
+          if (this.#expanded()) hide(event);
+          else show(event);
+        });
+        const closeTarget = this.#getCloseTarget();
+        if (closeTarget) {
+          onPress(closeTarget, (event) => {
+            event.stopPropagation();
+            hide(event);
+          });
+        }
+      },
+      onChange: this.#onExpandedChange.bind(this)
+    });
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    const currentIdCount = ++idCount;
+    this.#menuId = `media-menu-${currentIdCount}`;
+    this.#menuButtonId = `media-menu-button-${currentIdCount}`;
+    this.#focus = new MenuFocusController({
+      closeMenu: this.close.bind(this)
+    });
+    if (hasProvidedContext(menuContext)) {
+      this.#parentMenu = useContext(menuContext);
+    }
+    this.#observeSliders();
+    this.setAttributes({
+      "data-open": this.#expanded,
+      "data-root": !this.isSubmenu,
+      "data-submenu": this.isSubmenu,
+      "data-disabled": this.#isDisabled.bind(this)
+    });
+    provideContext(menuContext, {
+      button: this.#trigger,
+      content: this.#content,
+      expanded: this.#expanded,
+      hint: signal(""),
+      submenu: !!this.#parentMenu,
+      disable: this.#disable.bind(this),
+      attachMenuButton: this.#attachMenuButton.bind(this),
+      attachMenuItems: this.#attachMenuItems.bind(this),
+      attachObserver: this.#attachObserver.bind(this),
+      disableMenuButton: this.#disableMenuButton.bind(this),
+      addSubmenu: this.#addSubmenu.bind(this),
+      onTransitionEvent: (callback) => {
+        this.#transitionCallbacks.add(callback);
+        onDispose(() => {
+          this.#transitionCallbacks.delete(callback);
+        });
+      }
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  onConnect(el) {
+    effect(this.#watchExpanded.bind(this));
+    if (this.isSubmenu) {
+      this.#parentMenu?.addSubmenu(this);
+    }
+  }
+  onDestroy() {
+    this.#trigger.set(null);
+    this.#content.set(null);
+    this.#menuObserver = null;
+    this.#transitionCallbacks.clear();
+  }
+  #observeSliders() {
+    let sliderActiveTimer = -1, parentSliderObserver = hasProvidedContext(sliderObserverContext) ? useContext(sliderObserverContext) : null;
+    provideContext(sliderObserverContext, {
+      onDragStart: () => {
+        parentSliderObserver?.onDragStart?.();
+        window.clearTimeout(sliderActiveTimer);
+        sliderActiveTimer = -1;
+        this.#isSliderActive = true;
+      },
+      onDragEnd: () => {
+        parentSliderObserver?.onDragEnd?.();
+        sliderActiveTimer = window.setTimeout(() => {
+          this.#isSliderActive = false;
+          sliderActiveTimer = -1;
+        }, 300);
+      }
+    });
+  }
+  #watchExpanded() {
+    const expanded = this.#isExpanded();
+    if (!this.isSubmenu) this.#onResize();
+    this.#updateMenuItemsHidden(expanded);
+    if (!expanded) return;
+    effect(() => {
+      const { height } = this.#media.$state, content = this.#content();
+      content && setStyle(content, "--player-height", height() + "px");
+    });
+    this.#focus.listen();
+    this.listen("pointerup", this.#onPointerUp.bind(this));
+    listenEvent(window, "pointerup", this.#onWindowPointerUp.bind(this));
+  }
+  #attachMenuButton(button) {
+    const el = button.el, isMenuItem = this.isSubmenu, isARIADisabled = $ariaBool(this.#isDisabled.bind(this));
+    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
+    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
+    setAttribute(el, "id", this.#menuButtonId);
+    setAttribute(el, "aria-haspopup", "menu");
+    setAttribute(el, "aria-expanded", "false");
+    setAttribute(el, "data-root", !this.isSubmenu);
+    setAttribute(el, "data-submenu", this.isSubmenu);
+    const watchAttrs = () => {
+      setAttribute(el, "data-open", this.#expanded());
+      setAttribute(el, "aria-disabled", isARIADisabled());
+    };
+    if (IS_SERVER) watchAttrs();
+    else effect(watchAttrs);
+    this.#trigger.set(el);
+    onDispose(() => {
+      this.#trigger.set(null);
+    });
+  }
+  #attachMenuItems(items) {
+    const el = items.el;
+    el.style.setProperty("display", "none");
+    setAttribute(el, "id", this.#menuId);
+    setAttributeIfEmpty(el, "role", "menu");
+    setAttributeIfEmpty(el, "tabindex", "-1");
+    setAttribute(el, "data-root", !this.isSubmenu);
+    setAttribute(el, "data-submenu", this.isSubmenu);
+    this.#content.set(el);
+    onDispose(() => this.#content.set(null));
+    const watchAttrs = () => setAttribute(el, "data-open", this.#expanded());
+    if (IS_SERVER) watchAttrs();
+    else effect(watchAttrs);
+    this.#focus.attachMenu(el);
+    this.#updateMenuItemsHidden(false);
+    const onTransition = this.#onResizeTransition.bind(this);
+    if (!this.isSubmenu) {
+      items.listen("transitionstart", onTransition);
+      items.listen("transitionend", onTransition);
+      items.listen("animationend", this.#onResize);
+      items.listen("vds-menu-resize", this.#onResize);
+    } else {
+      this.#parentMenu?.onTransitionEvent(onTransition);
+    }
+  }
+  #attachObserver(observer) {
+    this.#menuObserver = observer;
+  }
+  #updateMenuItemsHidden(expanded) {
+    const content = peek(this.#content);
+    if (content) setAttribute(content, "aria-hidden", ariaBool$1(!expanded));
+  }
+  #disableMenuButton(disabled) {
+    this.#isTriggerDisabled.set(disabled);
+  }
+  #wasKeyboardExpand = false;
+  #onExpandedChange(isExpanded, event) {
+    this.#wasKeyboardExpand = isKeyboardEvent(event);
+    event?.stopPropagation();
+    if (this.#expanded() === isExpanded) return;
+    if (this.#isDisabled()) {
+      if (isExpanded) this.#popper.hide(event);
+      return;
+    }
+    this.el?.dispatchEvent(
+      new Event("vds-menu-resize", {
+        bubbles: true,
+        composed: true
+      })
+    );
+    const trigger = this.#trigger(), content = this.#content();
+    if (trigger) {
+      setAttribute(trigger, "aria-controls", isExpanded && this.#menuId);
+      setAttribute(trigger, "aria-expanded", ariaBool$1(isExpanded));
+    }
+    if (content) setAttribute(content, "aria-labelledby", isExpanded && this.#menuButtonId);
+    this.#expanded.set(isExpanded);
+    this.#toggleMediaControls(event);
+    tick();
+    if (this.#wasKeyboardExpand) {
+      if (isExpanded) content?.focus();
+      else trigger?.focus();
+      for (const el of [this.el, content]) {
+        el && el.setAttribute("data-keyboard", "");
+      }
+    } else {
+      for (const el of [this.el, content]) {
+        el && el.removeAttribute("data-keyboard");
+      }
+    }
+    this.dispatch(isExpanded ? "open" : "close", { trigger: event });
+    if (isExpanded) {
+      if (!this.isSubmenu && this.#media.activeMenu !== this) {
+        this.#media.activeMenu?.close(event);
+        this.#media.activeMenu = this;
+      }
+      this.#menuObserver?.onOpen?.(event);
+    } else {
+      if (this.isSubmenu) {
+        for (const el of this.#submenus) el.close(event);
+      } else {
+        this.#media.activeMenu = null;
+      }
+      this.#menuObserver?.onClose?.(event);
+    }
+    if (isExpanded) {
+      requestAnimationFrame(this.#updateFocus.bind(this));
+    }
+  }
+  #updateFocus() {
+    if (this.#isTransitionActive || this.#isSubmenuOpen) return;
+    this.#focus.update();
+    requestAnimationFrame(() => {
+      if (this.#wasKeyboardExpand) {
+        this.#focus.focusActive();
+      } else {
+        this.#focus.scroll();
+      }
+    });
+  }
+  #isExpanded() {
+    return !this.#isDisabled() && this.#expanded();
+  }
+  #isDisabled() {
+    return this.#disabled() || this.#isTriggerDisabled();
+  }
+  #disable(disabled) {
+    this.#disabled.set(disabled);
+  }
+  #onPointerUp(event) {
+    const content = this.#content();
+    if (this.#isSliderActive || content && isEventInside(content, event)) {
+      return;
+    }
+    event.stopPropagation();
+  }
+  #onWindowPointerUp(event) {
+    const content = this.#content();
+    if (this.#isSliderActive || content && isEventInside(content, event)) {
+      return;
+    }
+    this.close(event);
+  }
+  #getCloseTarget() {
+    const target = this.el?.querySelector('[data-part="close-target"]');
+    return this.el && target && isElementParent(this.el, target, (node) => node.getAttribute("role") === "menu") ? target : null;
+  }
+  #toggleMediaControls(trigger) {
+    if (this.isSubmenu) return;
+    if (this.#expanded()) this.#media.remote.pauseControls(trigger);
+    else this.#media.remote.resumeControls(trigger);
+  }
+  #addSubmenu(menu) {
+    this.#submenus.add(menu);
+    new EventsController(menu).add("open", this.#onSubmenuOpenBind).add("close", this.#onSubmenuCloseBind);
+    onDispose(this.#removeSubmenuBind);
+  }
+  #removeSubmenuBind = this.#removeSubmenu.bind(this);
+  #removeSubmenu(menu) {
+    this.#submenus.delete(menu);
+  }
+  #isSubmenuOpen = false;
+  #onSubmenuOpenBind = this.#onSubmenuOpen.bind(this);
+  #onSubmenuOpen(event) {
+    this.#isSubmenuOpen = true;
+    const content = this.#content();
+    if (this.isSubmenu) {
+      this.triggerElement?.setAttribute("aria-hidden", "true");
+    }
+    for (const target of this.#submenus) {
+      if (target !== event.target) {
+        for (const el of [target.el, target.triggerElement]) {
+          el?.setAttribute("aria-hidden", "true");
+        }
+      }
+    }
+    if (content) {
+      const el = event.target.el;
+      for (const child of content.children) {
+        if (child.contains(el)) {
+          child.setAttribute("data-open", "");
+        } else if (child !== el) {
+          child.setAttribute("data-hidden", "");
+        }
+      }
+    }
+  }
+  #onSubmenuCloseBind = this.#onSubmenuClose.bind(this);
+  #onSubmenuClose(event) {
+    this.#isSubmenuOpen = false;
+    const content = this.#content();
+    if (this.isSubmenu) {
+      this.triggerElement?.setAttribute("aria-hidden", "false");
+    }
+    for (const target of this.#submenus) {
+      for (const el of [target.el, target.triggerElement]) {
+        el?.setAttribute("aria-hidden", "false");
+      }
+    }
+    if (content) {
+      for (const child of content.children) {
+        child.removeAttribute("data-open");
+        child.removeAttribute("data-hidden");
+      }
+    }
+  }
+  #onResize = animationFrameThrottle(() => {
+    const content = peek(this.#content);
+    if (!content || IS_SERVER) return;
+    let height = 0, styles = getComputedStyle(content), children = [...content.children];
+    for (const prop2 of ["paddingTop", "paddingBottom", "borderTopWidth", "borderBottomWidth"]) {
+      height += parseFloat(styles[prop2]) || 0;
+    }
+    for (const child of children) {
+      if (isHTMLElement(child) && child.style.display === "contents") {
+        children.push(...child.children);
+      } else if (child.nodeType === 3) {
+        height += parseFloat(getComputedStyle(child).fontSize);
+      } else if (isHTMLElement(child)) {
+        if (!isElementVisible(child)) continue;
+        const style = getComputedStyle(child);
+        height += child.offsetHeight + (parseFloat(style.marginTop) || 0) + (parseFloat(style.marginBottom) || 0);
+      }
+    }
+    setStyle(content, "--menu-height", height + "px");
+  });
+  #isTransitionActive = false;
+  #onResizeTransition(event) {
+    const content = this.#content();
+    if (content && event.propertyName === "height") {
+      this.#isTransitionActive = event.type === "transitionstart";
+      setAttribute(content, "data-transition", this.#isTransitionActive ? "height" : null);
+      if (this.#expanded()) this.#updateFocus();
+    }
+    for (const callback of this.#transitionCallbacks) callback(event);
+  }
+  open(trigger) {
+    if (peek(this.#expanded)) return;
+    this.#popper.show(trigger);
+    tick();
+  }
+  close(trigger) {
+    if (!peek(this.#expanded)) return;
+    this.#popper.hide(trigger);
+    tick();
+  }
+}
+__decorateClass([
+  prop
+], Menu.prototype, "triggerElement");
+__decorateClass([
+  prop
+], Menu.prototype, "contentElement");
+__decorateClass([
+  prop
+], Menu.prototype, "isSubmenu");
+__decorateClass([
+  method
+], Menu.prototype, "open");
+__decorateClass([
+  method
+], Menu.prototype, "close");
+
+class MenuButton extends Component {
+  static props = {
+    disabled: false
+  };
+  #menu;
+  #hintEl = signal(null);
+  get expanded() {
+    return this.#menu?.expanded() ?? false;
+  }
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.#menu = useContext(menuContext);
+  }
+  onAttach(el) {
+    this.#menu.attachMenuButton(this);
+    effect(this.#watchDisabled.bind(this));
+    setAttributeIfEmpty(el, "type", "button");
+  }
+  onConnect(el) {
+    effect(this.#watchHintEl.bind(this));
+    this.#onMutation();
+    const mutations = new MutationObserver(this.#onMutation.bind(this));
+    mutations.observe(el, { attributeFilter: ["data-part"], childList: true, subtree: true });
+    onDispose(() => mutations.disconnect());
+    onPress(el, (trigger) => {
+      this.dispatch("select", { trigger });
+    });
+  }
+  #watchDisabled() {
+    this.#menu.disableMenuButton(this.$props.disabled());
+  }
+  #watchHintEl() {
+    const el = this.#hintEl();
+    if (!el) return;
+    effect(() => {
+      const text = this.#menu.hint();
+      if (text) el.textContent = text;
+    });
+  }
+  #onMutation() {
+    const hintEl = this.el?.querySelector('[data-part="hint"]');
+    this.#hintEl.set(hintEl ?? null);
+  }
+}
+const menubutton__proto = MenuButton.prototype;
+prop(menubutton__proto, "expanded");
+
+class MenuItem extends MenuButton {
+}
+
+class MenuPortal extends Component {
+  static props = {
+    container: null,
+    disabled: false
+  };
+  #target = null;
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    provideContext(menuPortalContext, {
+      attach: this.#attachElement.bind(this)
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("display", "contents");
+  }
+  // Need this so connect scope is defined.
+  onConnect(el) {
+  }
+  onDestroy() {
+    this.#target?.remove();
+    this.#target = null;
+  }
+  #attachElement(el) {
+    this.#portal(false);
+    this.#target = el;
+    requestScopedAnimationFrame(() => {
+      requestScopedAnimationFrame(() => {
+        if (!this.connectScope) return;
+        effect(this.#watchDisabled.bind(this));
+      });
+    });
+  }
+  #watchDisabled() {
+    const { fullscreen } = this.#media.$state, { disabled } = this.$props;
+    this.#portal(disabled() === "fullscreen" ? !fullscreen() : !disabled());
+  }
+  #portal(shouldPortal) {
+    if (!this.#target) return;
+    let container = this.#getContainer(this.$props.container());
+    if (!container) return;
+    const isPortalled = this.#target.parentElement === container;
+    setAttribute(this.#target, "data-portal", shouldPortal);
+    if (shouldPortal) {
+      if (!isPortalled) {
+        this.#target.remove();
+        container.append(this.#target);
+      }
+    } else if (isPortalled && this.#target.parentElement === container) {
+      this.#target.remove();
+      this.el?.append(this.#target);
+    }
+  }
+  #getContainer(selector) {
+    if (isHTMLElement(selector)) return selector;
+    return selector ? document.querySelector(selector) : document.body;
+  }
+}
+const menuPortalContext = createContext();
+
+class MenuItems extends Component {
+  static props = {
+    placement: null,
+    offset: 0,
+    alignOffset: 0
+  };
+  #menu;
+  constructor() {
+    super();
+    new FocusVisibleController();
+    const { placement } = this.$props;
+    this.setAttributes({
+      "data-placement": placement
+    });
+  }
+  onAttach(el) {
+    this.#menu = useContext(menuContext);
+    this.#menu.attachMenuItems(this);
+    if (hasProvidedContext(menuPortalContext)) {
+      const portal = useContext(menuPortalContext);
+      if (portal) {
+        provideContext(menuPortalContext, null);
+        portal.attach(el);
+        onDispose(() => portal.attach(null));
+      }
+    }
+  }
+  onConnect(el) {
+    effect(this.#watchPlacement.bind(this));
+  }
+  #watchPlacement() {
+    const { expanded } = this.#menu;
+    if (!this.el || !expanded()) return;
+    const placement = this.$props.placement();
+    if (!placement) return;
+    Object.assign(this.el.style, {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      width: "max-content"
+    });
+    const { offset: mainOffset, alignOffset } = this.$props;
+    onDispose(
+      autoPlacement(this.el, this.#getButton(), placement, {
+        offsetVarName: "media-menu",
+        xOffset: alignOffset(),
+        yOffset: mainOffset()
+      })
+    );
+    onDispose(this.#hide.bind(this));
+  }
+  #hide() {
+    if (!this.el) return;
+    this.el.removeAttribute("style");
+    this.el.style.display = "none";
+  }
+  #getButton() {
+    return this.#menu.button();
+  }
+}
+
+const radioControllerContext = createContext();
+
+class RadioGroupController extends ViewController {
+  #group = /* @__PURE__ */ new Set();
+  #value = signal("");
+  #controller = null;
+  onValueChange;
+  get values() {
+    return Array.from(this.#group).map((radio) => radio.value());
+  }
+  get value() {
+    return this.#value();
+  }
+  set value(value) {
+    this.#onChange(value);
+  }
+  onSetup() {
+    provideContext(radioControllerContext, {
+      add: this.#addRadio.bind(this),
+      remove: this.#removeRadio.bind(this)
+    });
+  }
+  onAttach(el) {
+    const isMenuItem = hasProvidedContext(menuContext);
+    if (!isMenuItem) setAttributeIfEmpty(el, "role", "radiogroup");
+    this.setAttributes({ value: this.#value });
+  }
+  onDestroy() {
+    this.#group.clear();
+  }
+  #addRadio(radio) {
+    if (this.#group.has(radio)) return;
+    this.#group.add(radio);
+    radio.onCheck = this.#onChangeBind;
+    radio.check(radio.value() === this.#value());
+  }
+  #removeRadio(radio) {
+    radio.onCheck = null;
+    this.#group.delete(radio);
+  }
+  #onChangeBind = this.#onChange.bind(this);
+  #onChange(newValue, trigger) {
+    const currentValue = peek(this.#value);
+    if (!newValue || newValue === currentValue) return;
+    const currentRadio = this.#findRadio(currentValue), newRadio = this.#findRadio(newValue);
+    currentRadio?.check(false, trigger);
+    newRadio?.check(true, trigger);
+    this.#value.set(newValue);
+    this.onValueChange?.(newValue, trigger);
+  }
+  #findRadio(newValue) {
+    for (const radio of this.#group) {
+      if (newValue === peek(radio.value)) return radio;
+    }
+    return null;
+  }
+}
+
+class RadioGroup extends Component {
+  static props = {
+    value: ""
+  };
+  #controller;
+  /**
+   * A list of radio values that belong this group.
+   */
+  get values() {
+    return this.#controller.values;
+  }
+  /**
+   * The radio value that is checked in this group.
+   */
+  get value() {
+    return this.#controller.value;
+  }
+  set value(newValue) {
+    this.#controller.value = newValue;
+  }
+  constructor() {
+    super();
+    this.#controller = new RadioGroupController();
+    this.#controller.onValueChange = this.#onValueChange.bind(this);
+  }
+  onSetup() {
+    if (IS_SERVER) this.#watchValue();
+    else effect(this.#watchValue.bind(this));
+  }
+  #watchValue() {
+    this.#controller.value = this.$props.value();
+  }
+  #onValueChange(value, trigger) {
+    const event = this.createEvent("change", { detail: value, trigger });
+    this.dispatch(event);
+  }
+}
+const radiogroup__proto = RadioGroup.prototype;
+prop(radiogroup__proto, "values");
+prop(radiogroup__proto, "value");
+
+class Radio extends Component {
+  static props = {
+    value: ""
+  };
+  #checked = signal(false);
+  #controller = {
+    value: this.$props.value,
+    check: this.#check.bind(this),
+    onCheck: null
+  };
+  /**
+   * Whether this radio is currently checked.
+   */
+  get checked() {
+    return this.#checked();
+  }
+  constructor() {
+    super();
+    new FocusVisibleController();
+  }
+  onSetup() {
+    this.setAttributes({
+      value: this.$props.value,
+      "data-checked": this.#checked,
+      "aria-checked": $ariaBool(this.#checked)
+    });
+  }
+  onAttach(el) {
+    const isMenuItem = hasProvidedContext(menuContext);
+    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
+    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitemradio" : "radio");
+    effect(this.#watchValue.bind(this));
+  }
+  onConnect(el) {
+    this.#addToGroup();
+    onPress(el, this.#onPress.bind(this));
+    onDispose(this.#onDisconnect.bind(this));
+  }
+  #onDisconnect() {
+    scoped(() => {
+      const group = useContext(radioControllerContext);
+      group.remove(this.#controller);
+    }, this.connectScope);
+  }
+  #addToGroup() {
+    const group = useContext(radioControllerContext);
+    group.add(this.#controller);
+  }
+  #watchValue() {
+    const { value } = this.$props, newValue = value();
+    if (peek(this.#checked)) {
+      this.#controller.onCheck?.(newValue);
+    }
+  }
+  #onPress(event) {
+    if (peek(this.#checked)) return;
+    this.#onChange(true, event);
+    this.#onSelect(event);
+    this.#controller.onCheck?.(peek(this.$props.value), event);
+  }
+  #check(value, trigger) {
+    if (peek(this.#checked) === value) return;
+    this.#onChange(value, trigger);
+  }
+  #onChange(value, trigger) {
+    this.#checked.set(value);
+    this.dispatch("change", { detail: value, trigger });
+  }
+  #onSelect(trigger) {
+    this.dispatch("select", { trigger });
+  }
+}
+const radio__proto = Radio.prototype;
+prop(radio__proto, "checked");
+
+class Gesture extends Component {
+  static props = {
+    disabled: false,
+    event: void 0,
+    action: void 0
+  };
+  #media;
+  #provider = null;
+  onSetup() {
+    this.#media = useMediaContext();
+    const { event, action } = this.$props;
+    this.setAttributes({
+      event,
+      action
+    });
+  }
+  onAttach(el) {
+    el.setAttribute("data-media-gesture", "");
+    el.style.setProperty("pointer-events", "none");
+  }
+  onConnect(el) {
+    this.#provider = this.#media.player.el?.querySelector(
+      "[data-media-provider]"
+    );
+    effect(this.#attachListener.bind(this));
+  }
+  #attachListener() {
+    let eventType = this.$props.event(), disabled = this.$props.disabled();
+    if (!this.#provider || !eventType || disabled) return;
+    if (/^dbl/.test(eventType)) {
+      eventType = eventType.split(/^dbl/)[1];
+    }
+    if (eventType === "pointerup" || eventType === "pointerdown") {
+      const pointer = this.#media.$state.pointer();
+      if (pointer === "coarse") {
+        eventType = eventType === "pointerup" ? "touchend" : "touchstart";
+      }
+    }
+    listenEvent(
+      this.#provider,
+      eventType,
+      this.#acceptEvent.bind(this),
+      { passive: false }
+    );
+  }
+  #presses = 0;
+  #pressTimerId = -1;
+  #acceptEvent(event) {
+    if (this.$props.disabled() || isPointerEvent(event) && (event.button !== 0 || this.#media.activeMenu) || isTouchEvent(event) && this.#media.activeMenu || isTouchPinchEvent(event) || !this.#inBounds(event)) {
+      return;
+    }
+    event.MEDIA_GESTURE = true;
+    event.preventDefault();
+    const eventType = peek(this.$props.event), isDblEvent = eventType?.startsWith("dbl");
+    if (!isDblEvent) {
+      if (this.#presses === 0) {
+        setTimeout(() => {
+          if (this.#presses === 1) this.#handleEvent(event);
+        }, 250);
+      }
+    } else if (this.#presses === 1) {
+      queueMicrotask(() => this.#handleEvent(event));
+      clearTimeout(this.#pressTimerId);
+      this.#presses = 0;
+      return;
+    }
+    if (this.#presses === 0) {
+      this.#pressTimerId = window.setTimeout(() => {
+        this.#presses = 0;
+      }, 275);
+    }
+    this.#presses++;
+  }
+  #handleEvent(event) {
+    this.el.setAttribute("data-triggered", "");
+    requestAnimationFrame(() => {
+      if (this.#isTopLayer()) {
+        this.#performAction(peek(this.$props.action), event);
+      }
+      requestAnimationFrame(() => {
+        this.el.removeAttribute("data-triggered");
+      });
+    });
+  }
+  /** Validate event occurred in gesture bounds. */
+  #inBounds(event) {
+    if (!this.el) return false;
+    if (isPointerEvent(event) || isMouseEvent(event) || isTouchEvent(event)) {
+      const touch = isTouchEvent(event) ? event.changedTouches[0] ?? event.touches[0] : void 0;
+      const clientX = touch?.clientX ?? event.clientX;
+      const clientY = touch?.clientY ?? event.clientY;
+      const rect = this.el.getBoundingClientRect();
+      const inBounds = clientY >= rect.top && clientY <= rect.bottom && clientX >= rect.left && clientX <= rect.right;
+      return event.type.includes("leave") ? !inBounds : inBounds;
+    }
+    return true;
+  }
+  /** Validate gesture has the highest z-index in this triggered group. */
+  #isTopLayer() {
+    const gestures = this.#media.player.el.querySelectorAll(
+      "[data-media-gesture][data-triggered]"
+    );
+    return Array.from(gestures).sort(
+      (a, b) => +getComputedStyle(b).zIndex - +getComputedStyle(a).zIndex
+    )[0] === this.el;
+  }
+  #performAction(action, trigger) {
+    if (!action) return;
+    const willTriggerEvent = new DOMEvent("will-trigger", {
+      detail: action,
+      cancelable: true,
+      trigger
+    });
+    this.dispatchEvent(willTriggerEvent);
+    if (willTriggerEvent.defaultPrevented) return;
+    const [method, value] = action.replace(/:([a-z])/, "-$1").split(":");
+    if (action.includes(":fullscreen")) {
+      this.#media.remote.toggleFullscreen("prefer-media", trigger);
+    } else if (action.includes("seek:")) {
+      this.#media.remote.seek(peek(this.#media.$state.currentTime) + (+value || 0), trigger);
+    } else {
+      this.#media.remote[kebabToCamelCase(method)](trigger);
+    }
+    this.dispatch("trigger", {
+      detail: action,
+      trigger
+    });
+  }
+}
+
+class CaptionsTextRenderer {
+  priority = 10;
+  #track = null;
+  #renderer;
+  #events;
+  constructor(renderer) {
+    this.#renderer = renderer;
+  }
+  attach() {
+  }
+  canRender() {
+    return true;
+  }
+  detach() {
+    this.#events?.abort();
+    this.#events = void 0;
+    this.#renderer.reset();
+    this.#track = null;
+  }
+  changeTrack(track) {
+    if (!track || this.#track === track) return;
+    this.#events?.abort();
+    this.#events = new EventsController(track);
+    if (track.readyState < 2) {
+      this.#renderer.reset();
+      this.#events.add("load", () => this.#changeTrack(track), { once: true });
+    } else {
+      this.#changeTrack(track);
+    }
+    this.#events.add("add-cue", (event) => {
+      this.#renderer.addCue(event.detail);
+    }).add("remove-cue", (event) => {
+      this.#renderer.removeCue(event.detail);
+    });
+    this.#track = track;
+  }
+  #changeTrack(track) {
+    this.#renderer.changeTrack({
+      cues: [...track.cues],
+      regions: [...track.regions]
+    });
+  }
+}
+
+class Captions extends Component {
+  static props = {
+    textDir: "ltr",
+    exampleText: "Captions look like this."
+  };
+  #media;
+  static lib = signal(null);
+  onSetup() {
+    this.#media = useMediaContext();
+    this.setAttributes({
+      "aria-hidden": $ariaBool(this.#isHidden.bind(this))
+    });
+  }
+  onAttach(el) {
+    el.style.setProperty("pointer-events", "none");
+  }
+  onConnect(el) {
+    if (!Captions.lib()) {
+      import('media-captions').then((lib) => Captions.lib.set(lib));
+    }
+    effect(this.#watchViewType.bind(this));
+  }
+  #isHidden() {
+    const { textTrack, remotePlaybackState, iOSControls } = this.#media.$state, track = textTrack();
+    return iOSControls() || remotePlaybackState() === "connected" || !track || !isTrackCaptionKind(track);
+  }
+  #watchViewType() {
+    if (!Captions.lib()) return;
+    const { viewType } = this.#media.$state;
+    if (viewType() === "audio") {
+      return this.#setupAudioView();
+    } else {
+      return this.#setupVideoView();
+    }
+  }
+  #setupAudioView() {
+    effect(this.#onTrackChange.bind(this));
+    this.#listenToFontStyleChanges(null);
+    return () => {
+      this.el.textContent = "";
+    };
+  }
+  #onTrackChange() {
+    if (this.#isHidden()) return;
+    this.#onCueChange();
+    const { textTrack } = this.#media.$state;
+    listenEvent(textTrack(), "cue-change", this.#onCueChange.bind(this));
+    effect(this.#onUpdateTimedNodes.bind(this));
+  }
+  #onCueChange() {
+    this.el.textContent = "";
+    if (this.#hideExampleTimer >= 0) {
+      this.#removeExample();
+    }
+    const { realCurrentTime, textTrack } = this.#media.$state, { renderVTTCueString } = Captions.lib(), time = peek(realCurrentTime), activeCues = peek(textTrack).activeCues;
+    for (const cue of activeCues) {
+      const displayEl = this.#createCueDisplayElement(), cueEl = this.#createCueElement();
+      cueEl.innerHTML = renderVTTCueString(cue, time);
+      displayEl.append(cueEl);
+      this.el.append(cueEl);
+    }
+  }
+  #onUpdateTimedNodes() {
+    const { realCurrentTime } = this.#media.$state, { updateTimedVTTCueNodes } = Captions.lib();
+    updateTimedVTTCueNodes(this.el, realCurrentTime());
+  }
+  #setupVideoView() {
+    const { CaptionsRenderer } = Captions.lib(), renderer = new CaptionsRenderer(this.el), textRenderer = new CaptionsTextRenderer(renderer);
+    this.#media.textRenderers.add(textRenderer);
+    effect(this.#watchTextDirection.bind(this, renderer));
+    effect(this.#watchMediaTime.bind(this, renderer));
+    this.#listenToFontStyleChanges(renderer);
+    return () => {
+      this.el.textContent = "";
+      this.#media.textRenderers.remove(textRenderer);
+      renderer.destroy();
+    };
+  }
+  #watchTextDirection(renderer) {
+    renderer.dir = this.$props.textDir();
+  }
+  #watchMediaTime(renderer) {
+    if (this.#isHidden()) return;
+    const { realCurrentTime, textTrack } = this.#media.$state;
+    renderer.currentTime = realCurrentTime();
+    if (this.#hideExampleTimer >= 0 && textTrack()?.activeCues[0]) {
+      this.#removeExample();
+    }
+  }
+  #listenToFontStyleChanges(renderer) {
+    const player = this.#media.player;
+    if (!player) return;
+    const onChange = this.#onFontStyleChange.bind(this, renderer);
+    listenEvent(player, "vds-font-change", onChange);
+  }
+  #onFontStyleChange(renderer) {
+    if (this.#hideExampleTimer >= 0) {
+      this.#hideExample();
+      return;
+    }
+    const { textTrack } = this.#media.$state;
+    if (!textTrack()?.activeCues[0]) {
+      this.#showExample();
+    } else {
+      renderer?.update(true);
+    }
+  }
+  #showExample() {
+    const display = this.#createCueDisplayElement();
+    setAttribute(display, "data-example", "");
+    const cue = this.#createCueElement();
+    setAttribute(cue, "data-example", "");
+    cue.textContent = this.$props.exampleText();
+    display?.append(cue);
+    this.el?.append(display);
+    this.el?.setAttribute("data-example", "");
+    this.#hideExample();
+  }
+  #hideExampleTimer = -1;
+  #hideExample() {
+    window.clearTimeout(this.#hideExampleTimer);
+    this.#hideExampleTimer = window.setTimeout(this.#removeExample.bind(this), 2500);
+  }
+  #removeExample() {
+    this.el?.removeAttribute("data-example");
+    if (this.el?.querySelector("[data-example]")) this.el.textContent = "";
+    this.#hideExampleTimer = -1;
+  }
+  #createCueDisplayElement() {
+    const el = document.createElement("div");
+    setAttribute(el, "data-part", "cue-display");
+    return el;
+  }
+  #createCueElement() {
+    const el = document.createElement("div");
+    setAttribute(el, "data-part", "cue");
+    return el;
+  }
+}
+
+class Poster extends Component {
+  static props = {
+    src: null,
+    alt: null,
+    crossOrigin: null
+  };
+  static state = new State({
+    img: null,
+    src: null,
+    alt: null,
+    crossOrigin: null,
+    loading: true,
+    error: null,
+    hidden: false
+  });
+  #media;
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#watchSrc();
+    this.#watchAlt();
+    this.#watchCrossOrigin();
+    this.#watchHidden();
+  }
+  onAttach(el) {
+    el.style.setProperty("pointer-events", "none");
+    effect(this.#watchImg.bind(this));
+    effect(this.#watchSrc.bind(this));
+    effect(this.#watchAlt.bind(this));
+    effect(this.#watchCrossOrigin.bind(this));
+    effect(this.#watchHidden.bind(this));
+    const { started } = this.#media.$state;
+    this.setAttributes({
+      "data-visible": () => !started() && !this.$state.hidden(),
+      "data-loading": this.#isLoading.bind(this),
+      "data-error": this.#hasError.bind(this),
+      "data-hidden": this.$state.hidden
+    });
+  }
+  onConnect(el) {
+    effect(this.#onPreconnect.bind(this));
+    effect(this.#onLoadStart.bind(this));
+  }
+  #hasError() {
+    const { error } = this.$state;
+    return !isNull(error());
+  }
+  #onPreconnect() {
+    const { canLoadPoster, poster } = this.#media.$state;
+    if (!canLoadPoster() && poster()) preconnect(poster(), "preconnect");
+  }
+  #watchHidden() {
+    const { src } = this.$props, { poster, nativeControls } = this.#media.$state;
+    this.el && setAttribute(this.el, "display", nativeControls() ? "none" : null);
+    this.$state.hidden.set(this.#hasError() || !(src() || poster()) || nativeControls());
+  }
+  #isLoading() {
+    const { loading, hidden } = this.$state;
+    return !hidden() && loading();
+  }
+  #watchImg() {
+    const img = this.$state.img();
+    if (!img) return;
+    new EventsController(img).add("load", this.#onLoad.bind(this)).add("error", this.#onError.bind(this));
+    if (img.complete) this.#onLoad();
+  }
+  #prevSrc = "";
+  #watchSrc() {
+    const { poster: defaultPoster } = this.#media.$props, { canLoadPoster, providedPoster, inferredPoster } = this.#media.$state;
+    const src = this.$props.src() || "", poster = src || defaultPoster() || inferredPoster();
+    if (this.#prevSrc === providedPoster()) {
+      providedPoster.set(src);
+    }
+    this.$state.src.set(canLoadPoster() && poster.length ? poster : null);
+    this.#prevSrc = src;
+  }
+  #watchAlt() {
+    const { src } = this.$props, { alt } = this.$state, { poster } = this.#media.$state;
+    alt.set(src() || poster() ? this.$props.alt() : null);
+  }
+  #watchCrossOrigin() {
+    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin, poster: src } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
+    crossOriginState.set(
+      /ytimg\.com|vimeo/.test(src() || "") ? null : crossOrigin === true ? "anonymous" : crossOrigin
+    );
+  }
+  #onLoadStart() {
+    const { loading, error } = this.$state, { canLoadPoster, poster } = this.#media.$state;
+    loading.set(canLoadPoster() && !!poster());
+    error.set(null);
+  }
+  #onLoad() {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(null);
+  }
+  #onError(event) {
+    const { loading, error } = this.$state;
+    loading.set(false);
+    error.set(event);
+  }
+}
+
+class Time extends Component {
+  static props = {
+    type: "current",
+    showHours: false,
+    padHours: null,
+    padMinutes: null,
+    remainder: false,
+    toggle: false,
+    hidden: false
+  };
+  static state = new State({
+    timeText: "",
+    hidden: false
+  });
+  #media;
+  #invert = signal(null);
+  #isVisible = signal(true);
+  #isIntersecting = signal(true);
+  onSetup() {
+    this.#media = useMediaContext();
+    this.#watchTime();
+    const { type } = this.$props;
+    this.setAttributes({
+      "data-type": type,
+      "data-remainder": this.#shouldInvert.bind(this)
+    });
+    new IntersectionObserverController({
+      callback: this.#onIntersectionChange.bind(this)
+    }).attach(this);
+  }
+  onAttach(el) {
+    if (!el.hasAttribute("role")) effect(this.#watchRole.bind(this));
+    effect(this.#watchTime.bind(this));
+  }
+  onConnect(el) {
+    onDispose(observeVisibility(el, this.#isVisible.set));
+    effect(this.#watchHidden.bind(this));
+    effect(this.#watchToggle.bind(this));
+  }
+  #onIntersectionChange(entries) {
+    this.#isIntersecting.set(entries[0].isIntersecting);
+  }
+  #watchHidden() {
+    const { hidden } = this.$props;
+    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting());
+  }
+  #watchToggle() {
+    if (!this.$props.toggle()) {
+      this.#invert.set(null);
+      return;
+    }
+    if (this.el) {
+      onPress(this.el, this.#onToggle.bind(this));
+    }
+  }
+  #watchTime() {
+    const { hidden, timeText } = this.$state, { duration } = this.#media.$state;
+    if (hidden()) return;
+    const { type, padHours, padMinutes, showHours } = this.$props, seconds = this.#getSeconds(type()), $duration = duration(), shouldInvert = this.#shouldInvert();
+    if (!Number.isFinite(seconds + $duration)) {
+      timeText.set("LIVE");
+      return;
+    }
+    const time = shouldInvert ? Math.max(0, $duration - seconds) : seconds, formattedTime = formatTime(time, {
+      padHrs: padHours(),
+      padMins: padMinutes(),
+      showHrs: showHours()
+    });
+    timeText.set((shouldInvert ? "-" : "") + formattedTime);
+  }
+  #watchRole() {
+    if (!this.el) return;
+    const { toggle } = this.$props;
+    setAttribute(this.el, "role", toggle() ? "timer" : null);
+    setAttribute(this.el, "tabindex", toggle() ? 0 : null);
+  }
+  #getSeconds(type) {
+    const { bufferedEnd, duration, currentTime } = this.#media.$state;
+    switch (type) {
+      case "buffered":
+        return bufferedEnd();
+      case "duration":
+        return duration();
+      default:
+        return currentTime();
+    }
+  }
+  #shouldInvert() {
+    return this.$props.remainder() && this.#invert() !== false;
+  }
+  #onToggle(event) {
+    event.preventDefault();
+    if (this.#invert() === null) {
+      this.#invert.set(!this.$props.remainder());
+      return;
+    }
+    this.#invert.set((v) => !v);
+  }
+}
+
+class MediaPlayerInstance extends MediaPlayer {
+}
+class MediaProviderInstance extends MediaProvider {
+}
+class MediaAnnouncerInstance extends MediaAnnouncer {
+}
+class ControlsInstance extends Controls {
+}
+class ControlsGroupInstance extends ControlsGroup {
+}
+class ToggleButtonInstance extends ToggleButton {
+}
+class CaptionButtonInstance extends CaptionButton {
+}
+class FullscreenButtonInstance extends FullscreenButton {
+}
+class LiveButtonInstance extends LiveButton {
+}
+class MuteButtonInstance extends MuteButton {
+}
+class PIPButtonInstance extends PIPButton {
+}
+class PlayButtonInstance extends PlayButton {
+}
+class AirPlayButtonInstance extends AirPlayButton {
+}
+class GoogleCastButtonInstance extends GoogleCastButton {
+}
+class SeekButtonInstance extends SeekButton {
+}
+class TooltipInstance extends Tooltip {
+}
+class TooltipTriggerInstance extends TooltipTrigger {
+}
+class TooltipContentInstance extends TooltipContent {
+}
+class SliderInstance extends Slider {
+}
+class TimeSliderInstance extends TimeSlider {
+}
+class VolumeSliderInstance extends VolumeSlider {
+}
+class AudioGainSliderInstance extends AudioGainSlider {
+}
+class SpeedSliderInstance extends SpeedSlider {
+}
+class QualitySliderInstance extends QualitySlider {
+}
+class SliderThumbnailInstance extends SliderThumbnail {
+}
+class SliderValueInstance extends SliderValue {
+}
+class SliderVideoInstance extends SliderVideo {
+}
+class SliderPreviewInstance extends SliderPreview {
+}
+class SliderChaptersInstance extends SliderChapters {
+}
+class MenuInstance extends Menu {
+}
+class MenuButtonInstance extends MenuButton {
+}
+class MenuItemsInstance extends MenuItems {
+}
+class MenuItemInstance extends MenuItem {
+}
+class MenuPortalInstance extends MenuPortal {
+}
+class RadioGroupInstance extends RadioGroup {
+}
+class RadioInstance extends Radio {
+}
+class CaptionsInstance extends Captions {
+}
+class GestureInstance extends Gesture {
+}
+class PosterInstance extends Poster {
+}
+class ThumbnailInstance extends Thumbnail {
+}
+class TimeInstance extends Time {
+}
+
+const Slot = React.forwardRef((props, forwardedRef) => {
+  const { children, ...slotProps } = props;
+  const childrenArray = React.Children.toArray(children);
+  const slottable = childrenArray.find(isSlottable);
+  if (slottable) {
+    const newElement = slottable.props.children;
+    const newChildren = childrenArray.map((child) => {
+      if (child === slottable) {
+        if (React.Children.count(newElement) > 1) return React.Children.only(null);
+        return React.isValidElement(newElement) ? newElement.props.children : null;
+      } else {
+        return child;
+      }
+    });
+    return /* @__PURE__ */ React.createElement(SlotClone, { ...slotProps, ref: forwardedRef }, React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null);
+  }
+  return /* @__PURE__ */ React.createElement(SlotClone, { ...slotProps, ref: forwardedRef }, children);
+});
+Slot.displayName = "Slot";
+const SlotClone = React.forwardRef((props, forwardedRef) => {
+  const { children, ...slotProps } = props;
+  if (React.isValidElement(children)) {
+    return React.cloneElement(children, {
+      ...mergeProps(slotProps, children.props),
+      ref: forwardedRef ? composeRefs(forwardedRef, children.ref) : children.ref
+    });
+  }
+  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
+});
+SlotClone.displayName = "SlotClone";
+const Slottable = ({ children }) => {
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
+};
+function isSlottable(child) {
+  return React.isValidElement(child) && child.type === Slottable;
+}
+function mergeProps(slotProps, childProps) {
+  const overrideProps = { ...childProps };
+  for (const propName in childProps) {
+    const slotPropValue = slotProps[propName];
+    const childPropValue = childProps[propName];
+    const isHandler = /^on[A-Z]/.test(propName);
+    if (isHandler) {
+      if (slotPropValue && childPropValue) {
+        overrideProps[propName] = (...args) => {
+          childPropValue(...args);
+          slotPropValue(...args);
+        };
+      } else if (slotPropValue) {
+        overrideProps[propName] = slotPropValue;
+      }
+    } else if (propName === "style") {
+      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
+    } else if (propName === "className") {
+      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
+    }
+  }
+  return { ...slotProps, ...overrideProps };
+}
+
+const NODES = ["button", "div", "span", "img", "video", "audio"];
+const Primitive = NODES.reduce((primitives, node) => {
+  const Node = React.forwardRef((props, forwardedRef) => {
+    const { asChild, ...primitiveProps } = props;
+    const Comp = asChild ? Slot : node;
+    return /* @__PURE__ */ React.createElement(Comp, { ...primitiveProps, ref: forwardedRef });
+  });
+  Node.displayName = `Primitive.${node}`;
+  return { ...primitives, [node]: Node };
+}, {});
+
+function isRemotionProvider(provider) {
+  return provider?.$$PROVIDER_TYPE === "REMOTION";
+}
+function isRemotionSrc(src) {
+  return src?.type === "video/remotion";
+}
+
+const sliderStateRecord = SliderInstance.state.record, initialSliderStore = Object.keys(sliderStateRecord).reduce(
+  (store, prop) => ({
+    ...store,
+    [prop]() {
+      return sliderStateRecord[prop];
+    }
+  }),
+  {}
+);
+function useSliderState(prop, ref) {
+  const $state = useStateContext(sliderState);
+  return useSignal((ref?.current?.$state || $state || initialSliderStore)[prop]);
+}
+function useSliderStore(ref) {
+  const $state = useStateContext(sliderState);
+  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialSliderStore);
+}
+
+const mediaStateRecord = MediaPlayerInstance.state.record, initialMediaStore = Object.keys(mediaStateRecord).reduce(
+  (store, prop) => ({
+    ...store,
+    [prop]() {
+      return mediaStateRecord[prop];
+    }
+  }),
+  {}
+);
+function useMediaState(prop, ref) {
+  const $state = useStateContext(mediaState);
+  return useSignal((ref?.current?.$state || $state || initialMediaStore)[prop]);
+}
+function useMediaStore(ref) {
+  const $state = useStateContext(mediaState);
+  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialMediaStore);
+}
+
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLAirPlayAdapter, HTMLMediaProvider, IS_CHROME, IS_IOS, IS_SERVER, List, ListSymbol, LiveButtonInstance, LocalMediaStorage, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaPlayerInstance, MediaProviderInstance, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, Primitive, QualitySliderInstance, QualitySymbol, RAFLoop, RadioGroupController, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrack, TextTrackList, TextTrackSymbol, ThumbnailInstance, ThumbnailsLoader, TimeInstance, TimeRange, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProvider, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, appendParamsToURL, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, coerceToError, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHLSSupported, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isRemotionProvider, isRemotionSrc, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, loadScript, mediaContext, mediaState, menuContext, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, preconnect, sliderState, softResetMediaState, sortVideoQualities, updateSliderPreviewPlacement, updateTimeIntervals, useMediaContext, useMediaState, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange };
diff --git a/prod/chunks/vidstack-BZdaxU0-.js b/prod/chunks/vidstack-BZdaxU0-.js
new file mode 100644
index 0000000000000000000000000000000000000000..bd736f5714f8d5c3ebc5e2411af7304f14373eae
--- /dev/null
+++ b/prod/chunks/vidstack-BZdaxU0-.js
@@ -0,0 +1,663 @@
+"use client"
+
+import * as React from 'react';
+import { useReactContext, createReactComponent, composeRefs, useSignal, noop, useStateContext, signal, effect, isString } from './vidstack-CNjv_Zem.js';
+import { mediaContext, Primitive, AirPlayButtonInstance, PlayButtonInstance, CaptionButtonInstance, FullscreenButtonInstance, MuteButtonInstance, PIPButtonInstance, SeekButtonInstance, LiveButtonInstance, SliderValueInstance, useSliderState, SliderInstance, SliderPreviewInstance, VolumeSliderInstance, IS_SERVER, ThumbnailInstance, TimeSliderInstance, SliderChaptersInstance, SliderThumbnailInstance, SliderVideoInstance, mediaState, RadioGroupInstance, RadioInstance, useMediaState, MenuInstance, MenuButtonInstance, MenuItemsInstance, MenuItemInstance, GestureInstance, TimeInstance, isTrackCaptionKind } from './vidstack-3ABKqYU9.js';
+import { createPortal } from 'react-dom';
+
+function useMediaContext() {
+  return useReactContext(mediaContext);
+}
+
+const AirPlayButtonBridge = createReactComponent(AirPlayButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const AirPlayButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(AirPlayButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+AirPlayButton.displayName = "AirPlayButton";
+
+const PlayButtonBridge = createReactComponent(PlayButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const PlayButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PlayButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+PlayButton.displayName = "PlayButton";
+
+const CaptionButtonBridge = createReactComponent(CaptionButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const CaptionButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(CaptionButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+CaptionButton.displayName = "CaptionButton";
+
+const FullscreenButtonBridge = createReactComponent(FullscreenButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const FullscreenButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(FullscreenButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+FullscreenButton.displayName = "FullscreenButton";
+
+const MuteButtonBridge = createReactComponent(MuteButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const MuteButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(MuteButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+MuteButton.displayName = "MuteButton";
+
+const PIPButtonBridge = createReactComponent(PIPButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const PIPButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PIPButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+PIPButton.displayName = "PIPButton";
+
+const SeekButtonBridge = createReactComponent(SeekButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const SeekButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SeekButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+SeekButton.displayName = "SeekButton";
+
+const LiveButtonBridge = createReactComponent(LiveButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const LiveButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(LiveButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+LiveButton.displayName = "LiveButton";
+
+const sliderCallbacks = [
+  "onDragStart",
+  "onDragEnd",
+  "onDragValueChange",
+  "onValueChange",
+  "onPointerValueChange"
+];
+
+const SliderValueBridge = createReactComponent(SliderValueInstance);
+
+const SliderBridge = createReactComponent(SliderInstance, {
+  events: sliderCallbacks
+});
+const Root$5 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(SliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+});
+Root$5.displayName = "Slider";
+const Thumb = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Thumb.displayName = "SliderThumb";
+const Track = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Track.displayName = "SliderTrack";
+const TrackFill = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+TrackFill.displayName = "SliderTrackFill";
+const PreviewBridge = createReactComponent(SliderPreviewInstance);
+const Preview = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PreviewBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Preview.displayName = "SliderPreview";
+const Value = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(SliderValueBridge, { ...props }, (props2, instance) => {
+    const $text = useSignal(() => instance.getValueText(), instance);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props2, ref: forwardRef }, $text, children);
+  });
+});
+Value.displayName = "SliderValue";
+const Steps = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const $min = useSliderState("min"), $max = useSliderState("max"), $step = useSliderState("step"), steps = ($max - $min) / $step;
+  return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, Array.from({ length: Math.floor(steps) + 1 }).map((_, step) => children(step)));
+});
+Steps.displayName = "SliderSteps";
+
+var slider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$5,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value
+});
+
+const VolumeSliderBridge = createReactComponent(VolumeSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$4 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(VolumeSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$4.displayName = "VolumeSlider";
+
+var volumeSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$4,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value
+});
+
+function createVTTCue(startTime = 0, endTime = 0, text = "") {
+  if (IS_SERVER) {
+    return {
+      startTime,
+      endTime,
+      text,
+      addEventListener: noop,
+      removeEventListener: noop,
+      dispatchEvent: noop
+    };
+  }
+  return new window.VTTCue(startTime, endTime, text);
+}
+function appendParamsToURL(baseUrl, params) {
+  const url = new URL(baseUrl);
+  for (const key of Object.keys(params)) {
+    url.searchParams.set(key, params[key] + "");
+  }
+  return url.toString();
+}
+
+const ThumbnailBridge = createReactComponent(ThumbnailInstance);
+const Root$3 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ThumbnailBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Root$3.displayName = "Thumbnail";
+const Img = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const { src, img, crossOrigin } = useStateContext(ThumbnailInstance.state), $src = useSignal(src), $crossOrigin = useSignal(crossOrigin);
+  return /* @__PURE__ */ React.createElement(
+    Primitive.img,
+    {
+      crossOrigin: $crossOrigin,
+      ...props,
+      src: $src || void 0,
+      ref: composeRefs(img.set, forwardRef)
+    },
+    children
+  );
+});
+Img.displayName = "ThumbnailImg";
+
+var thumbnail = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Img: Img,
+  Root: Root$3
+});
+
+const TimeSliderContext = React.createContext({
+  $chapters: signal(null)
+});
+TimeSliderContext.displayName = "TimeSliderContext";
+const TimeSliderBridge = createReactComponent(TimeSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$2 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    const $chapters = React.useMemo(() => signal(null), []);
+    return /* @__PURE__ */ React.createElement(TimeSliderContext.Provider, { value: { $chapters } }, /* @__PURE__ */ React.createElement(TimeSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children)));
+  }
+);
+Root$2.displayName = "TimeSlider";
+const SliderChaptersBridge = createReactComponent(SliderChaptersInstance);
+const Chapters = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SliderChaptersBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      /* @__PURE__ */ React.createElement(ChapterTracks, { instance }, children)
+    ));
+  }
+);
+Chapters.displayName = "SliderChapters";
+function ChapterTracks({ instance, children }) {
+  const $cues = useSignal(() => instance.cues, instance), refs = React.useRef([]), emptyCue = React.useRef(), { $chapters } = React.useContext(TimeSliderContext);
+  if (!emptyCue.current) {
+    emptyCue.current = createVTTCue();
+  }
+  React.useEffect(() => {
+    $chapters.set(instance);
+    return () => void $chapters.set(null);
+  }, [instance]);
+  React.useEffect(() => {
+    instance.setRefs(refs.current);
+  }, [$cues]);
+  return children($cues.length ? $cues : [emptyCue.current], (el) => {
+    if (!el) {
+      refs.current.length = 0;
+      return;
+    }
+    refs.current.push(el);
+  });
+}
+ChapterTracks.displayName = "SliderChapterTracks";
+const ChapterTitle = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    const { $chapters } = React.useContext(TimeSliderContext), [title, setTitle] = React.useState();
+    React.useEffect(() => {
+      return effect(() => {
+        const chapters = $chapters(), cue = chapters?.activePointerCue || chapters?.activeCue;
+        setTitle(cue?.text || "");
+      });
+    }, []);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, title, children);
+  }
+);
+ChapterTitle.displayName = "SliderChapterTitle";
+const Progress = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Progress.displayName = "SliderProgress";
+const SliderThumbnailBridge = createReactComponent(SliderThumbnailInstance);
+const ThumbnailRoot = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SliderThumbnailBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2, ref: composeRefs(props2.ref, forwardRef) }, children));
+  }
+);
+ThumbnailRoot.displayName = "SliderThumbnail";
+const Thumbnail = {
+  Root: ThumbnailRoot,
+  Img: Img
+};
+const VideoBridge = createReactComponent(SliderVideoInstance, {
+  events: ["onCanPlay", "onError"]
+});
+const Video = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(VideoBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+      VideoProvider,
+      {
+        ...props2,
+        instance,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Video.displayName = "SliderVideo";
+const VideoProvider = React.forwardRef(
+  ({ instance, children, ...props }, forwardRef) => {
+    const { canLoad } = useStateContext(mediaState), { src, video, crossOrigin } = instance.$state, $src = useSignal(src), $canLoad = useSignal(canLoad), $crossOrigin = useSignal(crossOrigin);
+    return /* @__PURE__ */ React.createElement(
+      Primitive.video,
+      {
+        style: { maxWidth: "unset" },
+        ...props,
+        src: $src || void 0,
+        muted: true,
+        playsInline: true,
+        preload: $canLoad ? "auto" : "none",
+        crossOrigin: $crossOrigin || void 0,
+        ref: composeRefs(video.set, forwardRef)
+      },
+      children
+    );
+  }
+);
+VideoProvider.displayName = "SliderVideoProvider";
+
+var timeSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  ChapterTitle: ChapterTitle,
+  Chapters: Chapters,
+  Preview: Preview,
+  Progress: Progress,
+  Root: Root$2,
+  Steps: Steps,
+  Thumb: Thumb,
+  Thumbnail: Thumbnail,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value,
+  Video: Video
+});
+
+const RadioGroupBridge = createReactComponent(RadioGroupInstance, {
+  events: ["onChange"]
+});
+const Root$1 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(RadioGroupBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$1.displayName = "RadioGroup";
+const ItemBridge$1 = createReactComponent(RadioInstance, {
+  events: ["onChange", "onSelect"]
+});
+const Item$1 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemBridge$1, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Item$1.displayName = "RadioItem";
+
+var radioGroup = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Item: Item$1,
+  Root: Root$1
+});
+
+const MenuBridge = createReactComponent(MenuInstance, {
+  events: ["onOpen", "onClose"],
+  domEventsRegex: /^onMedia/
+});
+const Root = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(MenuBridge, { ...props, ref: forwardRef }, (props2, instance) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      style: { display: !instance.isSubmenu ? "contents" : void 0, ...props2.style }
+    },
+    children
+  ));
+});
+Root.displayName = "Menu";
+const ButtonBridge = createReactComponent(MenuButtonInstance, {
+  events: ["onSelect"]
+});
+const Button = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(ButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Button.displayName = "MenuButton";
+const Portal = React.forwardRef(
+  ({ container = null, disabled = false, children, ...props }, forwardRef) => {
+    let fullscreen = useMediaState("fullscreen"), shouldPortal = disabled === "fullscreen" ? !fullscreen : !disabled;
+    const target = React.useMemo(() => {
+      if (IS_SERVER) return null;
+      const node = isString(container) ? document.querySelector(container) : container;
+      return node ?? document.body;
+    }, [container]);
+    return !target || !shouldPortal ? children : createPortal(
+      /* @__PURE__ */ React.createElement(
+        Primitive.div,
+        {
+          ...props,
+          style: { display: "contents", ...props.style },
+          ref: forwardRef
+        },
+        children
+      ),
+      target
+    );
+  }
+);
+Portal.displayName = "MenuPortal";
+const ItemsBridge = createReactComponent(MenuItemsInstance);
+const Items = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemsBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Items.displayName = "MenuItems";
+const ItemBridge = createReactComponent(MenuItemInstance);
+const Item = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Item.displayName = "MenuItem";
+
+var menu = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Button: Button,
+  Content: Items,
+  Item: Item,
+  Items: Items,
+  Portal: Portal,
+  Radio: Item$1,
+  RadioGroup: Root$1,
+  Root: Root
+});
+
+const GestureBridge = createReactComponent(GestureInstance, {
+  events: ["onWillTrigger", "onTrigger"]
+});
+const Gesture = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(GestureBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Gesture.displayName = "Gesture";
+
+const TimeBridge = createReactComponent(TimeInstance);
+const Time = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(TimeBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+    TimeText,
+    {
+      ...props2,
+      instance,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Time.displayName = "Time";
+const TimeText = React.forwardRef(
+  ({ instance, children, ...props }, forwardRef) => {
+    const { timeText } = instance.$state, $timeText = useSignal(timeText);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, $timeText, children);
+  }
+);
+TimeText.displayName = "TimeText";
+
+function useMediaPlayer() {
+  const context = useMediaContext();
+  return context?.player || null;
+}
+
+function useAudioOptions() {
+  const media = useMediaContext(), { audioTracks, audioTrack } = media.$state, $audioTracks = useSignal(audioTracks);
+  useSignal(audioTrack);
+  return React.useMemo(() => {
+    const options = $audioTracks.map((track) => ({
+      track,
+      label: track.label,
+      value: getTrackValue$1(track),
+      get selected() {
+        return audioTrack() === track;
+      },
+      select(trigger) {
+        const index = audioTracks().indexOf(track);
+        if (index >= 0) media.remote.changeAudioTrack(index, trigger);
+      }
+    }));
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return options.length <= 1;
+      }
+    });
+    Object.defineProperty(options, "selectedTrack", {
+      get() {
+        return audioTrack();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const track = audioTrack();
+        return track ? getTrackValue$1(track) : void 0;
+      }
+    });
+    return options;
+  }, [$audioTracks]);
+}
+function getTrackValue$1(track) {
+  return track.label.toLowerCase();
+}
+
+function useCaptionOptions({ off = true } = {}) {
+  const media = useMediaContext(), { textTracks, textTrack } = media.$state, $textTracks = useSignal(textTracks);
+  useSignal(textTrack);
+  return React.useMemo(() => {
+    const captionTracks = $textTracks.filter(isTrackCaptionKind), options = captionTracks.map((track) => ({
+      track,
+      label: track.label,
+      value: getTrackValue(track),
+      get selected() {
+        return textTrack() === track;
+      },
+      select(trigger) {
+        const index = textTracks().indexOf(track);
+        if (index >= 0) media.remote.changeTextTrackMode(index, "showing", trigger);
+      }
+    }));
+    if (off) {
+      options.unshift({
+        track: null,
+        label: isString(off) ? off : "Off",
+        value: "off",
+        get selected() {
+          return !textTrack();
+        },
+        select(trigger) {
+          media.remote.toggleCaptions(trigger);
+        }
+      });
+    }
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !captionTracks.length;
+      }
+    });
+    Object.defineProperty(options, "selectedTrack", {
+      get() {
+        return textTrack();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const track = textTrack();
+        return track ? getTrackValue(track) : "off";
+      }
+    });
+    return options;
+  }, [$textTracks]);
+}
+function getTrackValue(track) {
+  return track.id + ":" + track.kind + "-" + track.label.toLowerCase();
+}
+
+export { AirPlayButton, Button, CaptionButton, ChapterTitle, Chapters, FullscreenButton, Gesture, Img, Item$1 as Item, Items, LiveButton, MuteButton, PIPButton, PlayButton, Portal, Preview, Progress, Root$3 as Root, Root$2 as Root$1, Root as Root$2, Root$1 as Root$3, Root$4, Root$5, SeekButton, Steps, Thumb, Thumbnail, Time, Track, TrackFill, Value, appendParamsToURL, menu, radioGroup, slider, sliderCallbacks, thumbnail, timeSlider, useAudioOptions, useCaptionOptions, useMediaContext, useMediaPlayer, volumeSlider };
diff --git a/prod/chunks/vidstack-CC0Rsbn0.js b/prod/chunks/vidstack-Bg-Oi9JY.js
similarity index 97%
rename from prod/chunks/vidstack-CC0Rsbn0.js
rename to prod/chunks/vidstack-Bg-Oi9JY.js
index 5b828d723b9dc7d4d0106590ebecf5232cdb50a6..c865c4d8c7252603f646f6dc0f0fbe22211a80f4 100644
--- a/prod/chunks/vidstack-CC0Rsbn0.js
+++ b/prod/chunks/vidstack-Bg-Oi9JY.js
@@ -1,7 +1,7 @@
 "use client"
 
 import { scoped } from './vidstack-CNjv_Zem.js';
-import { HTMLMediaProvider, HTMLAirPlayAdapter } from './vidstack-D6dKrFOZ.js';
+import { HTMLMediaProvider, HTMLAirPlayAdapter } from './vidstack-3ABKqYU9.js';
 import 'react';
 import '@floating-ui/dom';
 
diff --git a/prod/chunks/vidstack-glsH_65p.js b/prod/chunks/vidstack-Bn2GzgdE.js
similarity index 99%
rename from prod/chunks/vidstack-glsH_65p.js
rename to prod/chunks/vidstack-Bn2GzgdE.js
index f763def837efb43286040c0a59b28b309c6d96e4..872fee8164e7694678da501991ed7c198d489882 100644
--- a/prod/chunks/vidstack-glsH_65p.js
+++ b/prod/chunks/vidstack-Bn2GzgdE.js
@@ -1,8 +1,8 @@
 "use client"
 
 import * as React from 'react';
-import { RadioGroupController, useMediaContext, menuContext, MediaRemoteControl, MediaPlayerInstance, sortVideoQualities } from './vidstack-D6dKrFOZ.js';
-import { useMediaContext as useMediaContext$1 } from './vidstack-DP0Brh65.js';
+import { RadioGroupController, useMediaContext, menuContext, MediaRemoteControl, MediaPlayerInstance, sortVideoQualities } from './vidstack-CwFL6mmL.js';
+import { useMediaContext as useMediaContext$1 } from './vidstack-BKi5uu_j.js';
 import { prop, method, Component, hasProvidedContext, useContext, effect, useSignal, isString } from './vidstack-CNjv_Zem.js';
 
 const DEFAULT_PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
diff --git a/prod/chunks/vidstack-BnZ6XdXq.js b/prod/chunks/vidstack-BnZ6XdXq.js
new file mode 100644
index 0000000000000000000000000000000000000000..e0b9dc1048bd1ec641fcb1d648ad653dc276cd20
--- /dev/null
+++ b/prod/chunks/vidstack-BnZ6XdXq.js
@@ -0,0 +1,159 @@
+"use client"
+
+import { IS_CHROME, IS_IOS, canGoogleCastSrc, IS_SERVER, loadScript } from './vidstack-3ABKqYU9.js';
+import { listenEvent, peek } from './vidstack-CNjv_Zem.js';
+
+function getCastFrameworkURL() {
+  return "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";
+}
+function hasLoadedCastFramework() {
+  return !!window.cast?.framework;
+}
+function isCastAvailable() {
+  return !!window.chrome?.cast?.isAvailable;
+}
+function isCastConnected() {
+  return getCastContext().getCastState() === cast.framework.CastState.CONNECTED;
+}
+function getCastContext() {
+  return window.cast.framework.CastContext.getInstance();
+}
+function getCastSession() {
+  return getCastContext().getCurrentSession();
+}
+function getCastSessionMedia() {
+  return getCastSession()?.getSessionObj().media[0];
+}
+function hasActiveCastSession(src) {
+  const contentId = getCastSessionMedia()?.media.contentId;
+  return contentId === src?.src;
+}
+function getDefaultCastOptions() {
+  return {
+    language: "en-US",
+    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
+    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
+    resumeSavedSession: true,
+    androidReceiverCompatible: true
+  };
+}
+function getCastErrorMessage(code) {
+  const defaultMessage = `Google Cast Error Code: ${code}`;
+  return defaultMessage;
+}
+function listenCastContextEvent(type, handler) {
+  return listenEvent(getCastContext(), type, handler);
+}
+
+class GoogleCastLoader {
+  name = "google-cast";
+  target;
+  #player;
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
+   */
+  get cast() {
+    return getCastContext();
+  }
+  mediaType() {
+    return "video";
+  }
+  canPlay(src) {
+    return IS_CHROME && !IS_IOS && canGoogleCastSrc(src);
+  }
+  async prompt(ctx) {
+    let loadEvent, openEvent, errorEvent;
+    try {
+      loadEvent = await this.#loadCastFramework(ctx);
+      if (!this.#player) {
+        this.#player = new cast.framework.RemotePlayer();
+        new cast.framework.RemotePlayerController(this.#player);
+      }
+      openEvent = ctx.player.createEvent("google-cast-prompt-open", {
+        trigger: loadEvent
+      });
+      ctx.player.dispatchEvent(openEvent);
+      this.#notifyRemoteStateChange(ctx, "connecting", openEvent);
+      await this.#showPrompt(peek(ctx.$props.googleCast));
+      ctx.$state.remotePlaybackInfo.set({
+        deviceName: getCastSession()?.getCastDevice().friendlyName
+      });
+      if (isCastConnected()) this.#notifyRemoteStateChange(ctx, "connected", openEvent);
+    } catch (code) {
+      const error = code instanceof Error ? code : this.#createError(
+        (code + "").toUpperCase(),
+        "Prompt failed."
+      );
+      errorEvent = ctx.player.createEvent("google-cast-prompt-error", {
+        detail: error,
+        trigger: openEvent ?? loadEvent,
+        cancelable: true
+      });
+      ctx.player.dispatch(errorEvent);
+      this.#notifyRemoteStateChange(
+        ctx,
+        isCastConnected() ? "connected" : "disconnected",
+        errorEvent
+      );
+      throw error;
+    } finally {
+      ctx.player.dispatch("google-cast-prompt-close", {
+        trigger: errorEvent ?? openEvent ?? loadEvent
+      });
+    }
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load google cast provider server-side");
+    }
+    if (!this.#player) {
+      throw Error("[vidstack] google cast player was not initialized");
+    }
+    return new (await import('./vidstack-CoI7qZrr.js')).GoogleCastProvider(this.#player, ctx);
+  }
+  async #loadCastFramework(ctx) {
+    if (hasLoadedCastFramework()) return;
+    const loadStartEvent = ctx.player.createEvent("google-cast-load-start");
+    ctx.player.dispatch(loadStartEvent);
+    await loadScript(getCastFrameworkURL());
+    await customElements.whenDefined("google-cast-launcher");
+    const loadedEvent = ctx.player.createEvent("google-cast-loaded", { trigger: loadStartEvent });
+    ctx.player.dispatch(loadedEvent);
+    if (!isCastAvailable()) {
+      throw this.#createError("CAST_NOT_AVAILABLE", "Google Cast not available on this platform.");
+    }
+    return loadedEvent;
+  }
+  async #showPrompt(options) {
+    this.#setOptions(options);
+    const errorCode = await this.cast.requestSession();
+    if (errorCode) {
+      throw this.#createError(
+        errorCode.toUpperCase(),
+        getCastErrorMessage(errorCode)
+      );
+    }
+  }
+  #setOptions(options) {
+    this.cast?.setOptions({
+      ...getDefaultCastOptions(),
+      ...options
+    });
+  }
+  #notifyRemoteStateChange(ctx, state, trigger) {
+    const detail = { type: "google-cast", state };
+    ctx.notify("remote-playback-change", detail, trigger);
+  }
+  #createError(code, message) {
+    const error = Error(message);
+    error.code = code;
+    return error;
+  }
+}
+
+var loader = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  GoogleCastLoader: GoogleCastLoader
+});
+
+export { getCastContext, getCastErrorMessage, getCastSession, getCastSessionMedia, hasActiveCastSession, listenCastContextEvent, loader };
diff --git a/prod/chunks/vidstack-MVSQZ19X.js b/prod/chunks/vidstack-BsS3T00D.js
similarity index 99%
rename from prod/chunks/vidstack-MVSQZ19X.js
rename to prod/chunks/vidstack-BsS3T00D.js
index bebf85f26cae67094255219f6cbbf7c5543e5bca..aeeefbfcf60e3580e8683a92814a0f0fb42a27b9 100644
--- a/prod/chunks/vidstack-MVSQZ19X.js
+++ b/prod/chunks/vidstack-BsS3T00D.js
@@ -4,7 +4,7 @@ import * as React from 'react';
 import { createDisposalBin, listenEvent, createScope, signal, peek, effect, tick, isFunction, useSignal, deferredPromise } from './vidstack-CNjv_Zem.js';
 import { Internals } from 'remotion';
 import { RemotionLayoutEngine, REMOTION_PROVIDER_ID, RemotionContextProvider, ErrorBoundary } from '../player/vidstack-remotion.js';
-import { isRemotionSrc, TimeRange } from './vidstack-D6dKrFOZ.js';
+import { isRemotionSrc, TimeRange } from './vidstack-CwFL6mmL.js';
 import { NoReactInternals } from 'remotion/no-react';
 import './vidstack-CV12ZH4Z.js';
 import '@floating-ui/dom';
diff --git a/prod/chunks/vidstack-CBvGixcr.js b/prod/chunks/vidstack-CBvGixcr.js
new file mode 100644
index 0000000000000000000000000000000000000000..e5afc875d66b112854a434456c4bacf2b9b65f9d
--- /dev/null
+++ b/prod/chunks/vidstack-CBvGixcr.js
@@ -0,0 +1,386 @@
+"use client"
+
+import { peek, listenEvent, effect, DOMEvent, isString, camelToKebabCase, isUndefined, isFunction } from './vidstack-CNjv_Zem.js';
+import { QualitySymbol, RAFLoop, TextTrack, TextTrackSymbol, ListSymbol, IS_CHROME, coerceToError, loadScript, VideoProvider, isHLSSupported, preconnect } from './vidstack-3ABKqYU9.js';
+import 'react';
+import '@floating-ui/dom';
+
+const toDOMEventType = (type) => camelToKebabCase(type);
+class HLSController {
+  #video;
+  #ctx;
+  #instance = null;
+  #stopLiveSync = null;
+  config = {};
+  #callbacks = /* @__PURE__ */ new Set();
+  get instance() {
+    return this.#instance;
+  }
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+  }
+  setup(ctor) {
+    const { streamType } = this.#ctx.$state;
+    const isLive = peek(streamType).includes("live"), isLiveLowLatency = peek(streamType).includes("ll-");
+    this.#instance = new ctor({
+      lowLatencyMode: isLiveLowLatency,
+      backBufferLength: isLiveLowLatency ? 4 : isLive ? 8 : void 0,
+      renderTextTracksNatively: false,
+      ...this.config
+    });
+    const dispatcher = this.#dispatchHLSEvent.bind(this);
+    for (const event of Object.values(ctor.Events)) this.#instance.on(event, dispatcher);
+    this.#instance.on(ctor.Events.ERROR, this.#onError.bind(this));
+    for (const callback of this.#callbacks) callback(this.#instance);
+    this.#ctx.player.dispatch("hls-instance", {
+      detail: this.#instance
+    });
+    this.#instance.attachMedia(this.#video);
+    this.#instance.on(ctor.Events.AUDIO_TRACK_SWITCHED, this.#onAudioSwitch.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_SWITCHED, this.#onLevelSwitched.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_LOADED, this.#onLevelLoaded.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_UPDATED, this.#onLevelUpdated.bind(this));
+    this.#instance.on(ctor.Events.NON_NATIVE_TEXT_TRACKS_FOUND, this.#onTracksFound.bind(this));
+    this.#instance.on(ctor.Events.CUES_PARSED, this.#onCuesParsed.bind(this));
+    this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
+    listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
+    listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
+    this.#stopLiveSync = effect(this.#liveSync.bind(this));
+  }
+  #createDOMEvent(type, data) {
+    return new DOMEvent(toDOMEventType(type), { detail: data });
+  }
+  #liveSync() {
+    if (!this.#ctx.$state.live()) return;
+    const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
+    raf.start();
+    return raf.stop.bind(raf);
+  }
+  #liveSyncPosition() {
+    this.#ctx.$state.liveSyncPosition.set(this.#instance?.liveSyncPosition ?? Infinity);
+  }
+  #dispatchHLSEvent(type, data) {
+    this.#ctx.player?.dispatch(this.#createDOMEvent(type, data));
+  }
+  #onTracksFound(eventType, data) {
+    const event = this.#createDOMEvent(eventType, data);
+    let currentTrack = -1;
+    for (let i = 0; i < data.tracks.length; i++) {
+      const nonNativeTrack = data.tracks[i], init = nonNativeTrack.subtitleTrack ?? nonNativeTrack.closedCaptions, track = new TextTrack({
+        id: `hls-${nonNativeTrack.kind}-${i}`,
+        src: init?.url,
+        label: nonNativeTrack.label,
+        language: init?.lang,
+        kind: nonNativeTrack.kind,
+        default: nonNativeTrack.default
+      });
+      track[TextTrackSymbol.readyState] = 2;
+      track[TextTrackSymbol.onModeChange] = () => {
+        if (track.mode === "showing") {
+          this.#instance.subtitleTrack = i;
+          currentTrack = i;
+        } else if (currentTrack === i) {
+          this.#instance.subtitleTrack = -1;
+          currentTrack = -1;
+        }
+      };
+      this.#ctx.textTracks.add(track, event);
+    }
+  }
+  #onCuesParsed(eventType, data) {
+    const index = this.#instance?.subtitleTrack, track = this.#ctx.textTracks.getById(`hls-${data.type}-${index}`);
+    if (!track) return;
+    const event = this.#createDOMEvent(eventType, data);
+    for (const cue of data.cues) {
+      cue.positionAlign = "auto";
+      track.addCue(cue, event);
+    }
+  }
+  #onAudioSwitch(eventType, data) {
+    const track = this.#ctx.audioTracks[data.id];
+    if (track) {
+      const trigger = this.#createDOMEvent(eventType, data);
+      this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
+    }
+  }
+  #onLevelSwitched(eventType, data) {
+    const quality = this.#ctx.qualities[data.level];
+    if (quality) {
+      const trigger = this.#createDOMEvent(eventType, data);
+      this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+  }
+  #onLevelUpdated(eventType, data) {
+    if (data.details.totalduration > 0) {
+      this.#ctx.$state.inferredLiveDVRWindow.set(data.details.totalduration);
+    }
+  }
+  #onLevelLoaded(eventType, data) {
+    if (this.#ctx.$state.canPlay()) return;
+    const { type, live, totalduration: duration, targetduration } = data.details, trigger = this.#createDOMEvent(eventType, data);
+    this.#ctx.notify(
+      "stream-type-change",
+      live ? type === "EVENT" && Number.isFinite(duration) && targetduration >= 10 ? "live:dvr" : "live" : "on-demand",
+      trigger
+    );
+    this.#ctx.notify("duration-change", duration, trigger);
+    const media = this.#instance.media;
+    if (this.#instance.currentLevel === -1) {
+      this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
+    }
+    for (const remoteTrack of this.#instance.audioTracks) {
+      const localTrack = {
+        id: remoteTrack.id.toString(),
+        label: remoteTrack.name,
+        language: remoteTrack.lang || "",
+        kind: "main"
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
+    }
+    for (const level of this.#instance.levels) {
+      const videoQuality = {
+        id: level.id?.toString() ?? level.height + "p",
+        width: level.width,
+        height: level.height,
+        codec: level.codecSet,
+        bitrate: level.bitrate
+      };
+      this.#ctx.qualities[ListSymbol.add](videoQuality, trigger);
+    }
+    media.dispatchEvent(new DOMEvent("canplay", { trigger }));
+  }
+  #onError(eventType, data) {
+    if (data.fatal) {
+      switch (data.type) {
+        case "mediaError":
+          this.#instance?.recoverMediaError();
+          break;
+        default:
+          this.#onFatalError(data.error);
+          break;
+      }
+    }
+  }
+  #onFatalError(error) {
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 1,
+      error
+    });
+  }
+  #enableAutoQuality() {
+    if (this.#instance) this.#instance.currentLevel = -1;
+  }
+  #onUserQualityChange() {
+    const { qualities } = this.#ctx;
+    if (!this.#instance || qualities.auto) return;
+    this.#instance[qualities.switch + "Level"] = qualities.selectedIndex;
+    if (IS_CHROME) {
+      this.#video.currentTime = this.#video.currentTime;
+    }
+  }
+  #onUserAudioChange() {
+    const { audioTracks } = this.#ctx;
+    if (this.#instance && this.#instance.audioTrack !== audioTracks.selectedIndex) {
+      this.#instance.audioTrack = audioTracks.selectedIndex;
+    }
+  }
+  onInstance(callback) {
+    this.#callbacks.add(callback);
+    return () => this.#callbacks.delete(callback);
+  }
+  loadSource(src) {
+    if (!isString(src.src)) return;
+    this.#instance?.loadSource(src.src);
+  }
+  destroy() {
+    this.#instance?.destroy();
+    this.#instance = null;
+    this.#stopLiveSync?.();
+    this.#stopLiveSync = null;
+  }
+}
+
+class HLSLibLoader {
+  #lib;
+  #ctx;
+  #callback;
+  constructor(lib, ctx, callback) {
+    this.#lib = lib;
+    this.#ctx = ctx;
+    this.#callback = callback;
+    this.#startLoading();
+  }
+  async #startLoading() {
+    const callbacks = {
+      onLoadStart: this.#onLoadStart.bind(this),
+      onLoaded: this.#onLoaded.bind(this),
+      onLoadError: this.#onLoadError.bind(this)
+    };
+    let ctor = await loadHLSScript(this.#lib, callbacks);
+    if (isUndefined(ctor) && !isString(this.#lib)) ctor = await importHLS(this.#lib, callbacks);
+    if (!ctor) return null;
+    if (!ctor.isSupported()) {
+      const message = "[vidstack] `hls.js` is not supported in this environment";
+      this.#ctx.player.dispatch(new DOMEvent("hls-unsupported"));
+      this.#ctx.notify("error", { message, code: 4 });
+      return null;
+    }
+    return ctor;
+  }
+  #onLoadStart() {
+    this.#ctx.player.dispatch(new DOMEvent("hls-lib-load-start"));
+  }
+  #onLoaded(ctor) {
+    this.#ctx.player.dispatch(
+      new DOMEvent("hls-lib-loaded", {
+        detail: ctor
+      })
+    );
+    this.#callback(ctor);
+  }
+  #onLoadError(e) {
+    const error = coerceToError(e);
+    this.#ctx.player.dispatch(
+      new DOMEvent("hls-lib-load-error", {
+        detail: error
+      })
+    );
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 4,
+      error
+    });
+  }
+}
+async function importHLS(loader, callbacks = {}) {
+  if (isUndefined(loader)) return void 0;
+  callbacks.onLoadStart?.();
+  if (loader.prototype && loader.prototype !== Function) {
+    callbacks.onLoaded?.(loader);
+    return loader;
+  }
+  try {
+    const ctor = (await loader())?.default;
+    if (ctor && !!ctor.isSupported) {
+      callbacks.onLoaded?.(ctor);
+    } else {
+      throw Error(
+        false ? "[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
+      );
+    }
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+async function loadHLSScript(src, callbacks = {}) {
+  if (!isString(src)) return void 0;
+  callbacks.onLoadStart?.();
+  try {
+    await loadScript(src);
+    if (!isFunction(window.Hls)) {
+      throw Error(
+        false ? "[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window" : ""
+      );
+    }
+    const ctor = window.Hls;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+
+const JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
+class HLSProvider extends VideoProvider {
+  $$PROVIDER_TYPE = "HLS";
+  #ctor = null;
+  #controller = new HLSController(this.video, this.ctx);
+  /**
+   * The `hls.js` constructor.
+   */
+  get ctor() {
+    return this.#ctor;
+  }
+  /**
+   * The current `hls.js` instance.
+   */
+  get instance() {
+    return this.#controller.instance;
+  }
+  /**
+   * Whether `hls.js` is supported in this environment.
+   */
+  static supported = isHLSSupported();
+  get type() {
+    return "hls";
+  }
+  get canLiveSync() {
+    return true;
+  }
+  #library = `${JS_DELIVR_CDN}/npm/hls.js@^1.5.0/dist/hls${".min.js"}`;
+  /**
+   * The `hls.js` configuration object.
+   *
+   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#fine-tuning}
+   */
+  get config() {
+    return this.#controller.config;
+  }
+  set config(config) {
+    this.#controller.config = config;
+  }
+  /**
+   * The `hls.js` constructor (supports dynamic imports) or a URL of where it can be found.
+   *
+   * @defaultValue `https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.min.js`
+   */
+  get library() {
+    return this.#library;
+  }
+  set library(library) {
+    this.#library = library;
+  }
+  preconnect() {
+    if (!isString(this.#library)) return;
+    preconnect(this.#library);
+  }
+  setup() {
+    super.setup();
+    new HLSLibLoader(this.#library, this.ctx, (ctor) => {
+      this.#ctor = ctor;
+      this.#controller.setup(ctor);
+      this.ctx.notify("provider-setup", this);
+      const src = peek(this.ctx.$state.source);
+      if (src) this.loadSource(src);
+    });
+  }
+  async loadSource(src, preload) {
+    if (!isString(src.src)) {
+      this.removeSource();
+      return;
+    }
+    this.media.preload = preload || "";
+    this.appendSource(src, "application/x-mpegurl");
+    this.#controller.loadSource(src);
+    this.currentSrc = src;
+  }
+  /**
+   * The given callback is invoked when a new `hls.js` instance is created and right before it's
+   * attached to media.
+   */
+  onInstance(callback) {
+    const instance = this.#controller.instance;
+    if (instance) callback(instance);
+    return this.#controller.onInstance(callback);
+  }
+  destroy() {
+    this.#controller.destroy();
+  }
+}
+
+export { HLSProvider };
diff --git a/prod/chunks/vidstack-CI9AxZNe.js b/prod/chunks/vidstack-CI9AxZNe.js
new file mode 100644
index 0000000000000000000000000000000000000000..68d166759b7e630d2bb66a81744a70e4ea98de4a
--- /dev/null
+++ b/prod/chunks/vidstack-CI9AxZNe.js
@@ -0,0 +1,189 @@
+"use client"
+
+import * as React from 'react';
+import { RadioGroupController, useMediaContext, menuContext, MediaRemoteControl, MediaPlayerInstance, sortVideoQualities } from './vidstack-BY07IoHR.js';
+import { useMediaContext as useMediaContext$1 } from './vidstack-CtKPQRKk.js';
+import { prop, method, Component, hasProvidedContext, useContext, effect, useSignal, isString } from './vidstack-CNjv_Zem.js';
+
+const DEFAULT_PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
+class SpeedRadioGroup extends Component {
+  static props = {
+    normalLabel: "Normal",
+    rates: DEFAULT_PLAYBACK_RATES
+  };
+  #media;
+  #menu;
+  #controller;
+  get value() {
+    return this.#controller.value;
+  }
+  get disabled() {
+    const { rates } = this.$props, { canSetPlaybackRate } = this.#media.$state;
+    return !canSetPlaybackRate() || rates().length === 0;
+  }
+  constructor() {
+    super();
+    this.#controller = new RadioGroupController();
+    this.#controller.onValueChange = this.#onValueChange.bind(this);
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    if (hasProvidedContext(menuContext)) {
+      this.#menu = useContext(menuContext);
+    }
+  }
+  onConnect(el) {
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchHintText.bind(this));
+    effect(this.#watchControllerDisabled.bind(this));
+  }
+  getOptions() {
+    const { rates, normalLabel } = this.$props;
+    return rates().map((rate) => ({
+      label: rate === 1 ? normalLabel : rate + "\xD7",
+      value: rate.toString()
+    }));
+  }
+  #watchValue() {
+    this.#controller.value = this.#getValue();
+  }
+  #watchHintText() {
+    const { normalLabel } = this.$props, { playbackRate } = this.#media.$state, rate = playbackRate();
+    this.#menu?.hint.set(rate === 1 ? normalLabel() : rate + "\xD7");
+  }
+  #watchControllerDisabled() {
+    this.#menu?.disable(this.disabled);
+  }
+  #getValue() {
+    const { playbackRate } = this.#media.$state;
+    return playbackRate().toString();
+  }
+  #onValueChange(value, trigger) {
+    if (this.disabled) return;
+    const rate = +value;
+    this.#media.remote.changePlaybackRate(rate, trigger);
+    this.dispatch("change", { detail: rate, trigger });
+  }
+}
+const speedradiogroup__proto = SpeedRadioGroup.prototype;
+prop(speedradiogroup__proto, "value");
+prop(speedradiogroup__proto, "disabled");
+method(speedradiogroup__proto, "getOptions");
+
+function useMediaRemote(target) {
+  const media = useMediaContext$1(), remote = React.useRef();
+  if (!remote.current) {
+    remote.current = new MediaRemoteControl();
+  }
+  React.useEffect(() => {
+    const ref = target && "current" in target ? target.current : target, isPlayerRef = ref instanceof MediaPlayerInstance, player = isPlayerRef ? ref : media?.player;
+    remote.current.setPlayer(player ?? null);
+    remote.current.setTarget(ref ?? null);
+  }, [media, target && "current" in target ? target.current : target]);
+  return remote.current;
+}
+
+function useVideoQualityOptions({
+  auto = true,
+  sort = "descending"
+} = {}) {
+  const media = useMediaContext$1(), { qualities, quality, autoQuality, canSetQuality } = media.$state, $qualities = useSignal(qualities);
+  useSignal(quality);
+  useSignal(autoQuality);
+  useSignal(canSetQuality);
+  return React.useMemo(() => {
+    const sortedQualities = sortVideoQualities($qualities, sort === "descending"), options = sortedQualities.map((q) => {
+      return {
+        quality: q,
+        label: q.height + "p",
+        value: getQualityValue(q),
+        bitrateText: q.bitrate && q.bitrate > 0 ? `${(q.bitrate / 1e6).toFixed(2)} Mbps` : null,
+        get selected() {
+          return q === quality();
+        },
+        get autoSelected() {
+          return autoQuality();
+        },
+        select(trigger) {
+          const index = qualities().indexOf(q);
+          if (index >= 0) media.remote.changeQuality(index, trigger);
+        }
+      };
+    });
+    if (auto) {
+      options.unshift({
+        quality: null,
+        label: isString(auto) ? auto : "Auto",
+        value: "auto",
+        bitrateText: null,
+        get selected() {
+          return autoQuality();
+        },
+        get autoSelected() {
+          return autoQuality();
+        },
+        select(trigger) {
+          media.remote.requestAutoQuality(trigger);
+        }
+      });
+    }
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !canSetQuality() || $qualities.length <= 1;
+      }
+    });
+    Object.defineProperty(options, "selectedQuality", {
+      get() {
+        return quality();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const $quality = quality();
+        return !autoQuality() && $quality ? getQualityValue($quality) : "auto";
+      }
+    });
+    return options;
+  }, [$qualities, sort]);
+}
+function getQualityValue(quality) {
+  return quality.height + "_" + quality.bitrate;
+}
+
+function usePlaybackRateOptions({
+  rates = DEFAULT_PLAYBACK_RATES,
+  normalLabel = "Normal"
+} = {}) {
+  const media = useMediaContext$1(), { playbackRate, canSetPlaybackRate } = media.$state;
+  useSignal(playbackRate);
+  useSignal(canSetPlaybackRate);
+  return React.useMemo(() => {
+    const options = rates.map((opt) => {
+      const label = typeof opt === "number" ? opt === 1 && normalLabel ? normalLabel : opt + "x" : opt.label, rate = typeof opt === "number" ? opt : opt.rate;
+      return {
+        label,
+        value: rate.toString(),
+        rate,
+        get selected() {
+          return playbackRate() === rate;
+        },
+        select(trigger) {
+          media.remote.changePlaybackRate(rate, trigger);
+        }
+      };
+    });
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !canSetPlaybackRate() || !options.length;
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        return playbackRate().toString();
+      }
+    });
+    return options;
+  }, [rates]);
+}
+
+export { DEFAULT_PLAYBACK_RATES, useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions };
diff --git a/prod/chunks/vidstack-CJ22YF5o.js b/prod/chunks/vidstack-CJ22YF5o.js
new file mode 100644
index 0000000000000000000000000000000000000000..fe640ee708e6e69ceee42c7343777084ecb43cb9
--- /dev/null
+++ b/prod/chunks/vidstack-CJ22YF5o.js
@@ -0,0 +1,34 @@
+"use client"
+
+import { scoped } from './vidstack-CNjv_Zem.js';
+import { HTMLMediaProvider, HTMLAirPlayAdapter } from './vidstack-BY07IoHR.js';
+import 'react';
+import '@floating-ui/dom';
+
+class AudioProvider extends HTMLMediaProvider {
+  $$PROVIDER_TYPE = "AUDIO";
+  get type() {
+    return "audio";
+  }
+  airPlay;
+  constructor(audio, ctx) {
+    super(audio, ctx);
+    scoped(() => {
+      this.airPlay = new HTMLAirPlayAdapter(this.media, ctx);
+    }, this.scope);
+  }
+  setup() {
+    super.setup();
+    if (this.type === "audio") this.ctx.notify("provider-setup", this);
+  }
+  /**
+   * The native HTML `<audio>` element.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement}
+   */
+  get audio() {
+    return this.media;
+  }
+}
+
+export { AudioProvider };
diff --git a/prod/chunks/vidstack-CZ_a5B97.js b/prod/chunks/vidstack-CZ_a5B97.js
new file mode 100644
index 0000000000000000000000000000000000000000..30226e5d9107ec20ed21b6198163ea73b65d1143
--- /dev/null
+++ b/prod/chunks/vidstack-CZ_a5B97.js
@@ -0,0 +1,287 @@
+"use client"
+
+import { createScope, signal, effect, isString, deferredPromise, isObject, isNumber, isBoolean } from './vidstack-CNjv_Zem.js';
+import { preconnect, TimeRange } from './vidstack-CwFL6mmL.js';
+import { EmbedProvider } from './vidstack-CzDPuCjO.js';
+import { resolveYouTubeVideoId } from './vidstack-Zc3I7oOd.js';
+import 'react';
+import '@floating-ui/dom';
+
+const YouTubePlayerState = {
+  Unstarted: -1,
+  Ended: 0,
+  Playing: 1,
+  Paused: 2,
+  Buffering: 3,
+  Cued: 5
+};
+
+class YouTubeProvider extends EmbedProvider {
+  $$PROVIDER_TYPE = "YOUTUBE";
+  scope = createScope();
+  #ctx;
+  #videoId = signal("");
+  #state = -1;
+  #currentSrc = null;
+  #seekingTimer = -1;
+  #invalidPlay = false;
+  #promises = /* @__PURE__ */ new Map();
+  constructor(iframe, ctx) {
+    super(iframe);
+    this.#ctx = ctx;
+  }
+  /**
+   * Sets the player's interface language. The parameter value is an ISO 639-1 two-letter
+   * language code or a fully specified locale. For example, fr and fr-ca are both valid values.
+   * Other language input codes, such as IETF language tags (BCP 47) might also be handled properly.
+   *
+   * The interface language is used for tooltips in the player and also affects the default caption
+   * track. Note that YouTube might select a different caption track language for a particular
+   * user based on the user's individual language preferences and the availability of caption tracks.
+   *
+   * @defaultValue 'en'
+   */
+  language = "en";
+  color = "red";
+  /**
+   * Whether cookies should be enabled on the embed. This is turned off by default to be
+   * GDPR-compliant.
+   *
+   * @defaultValue `false`
+   */
+  cookies = false;
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  get type() {
+    return "youtube";
+  }
+  get videoId() {
+    return this.#videoId();
+  }
+  preconnect() {
+    preconnect(this.getOrigin());
+  }
+  setup() {
+    super.setup();
+    effect(this.#watchVideoId.bind(this));
+    this.#ctx.notify("provider-setup", this);
+  }
+  destroy() {
+    this.#reset();
+    const message = "provider destroyed";
+    for (const promises of this.#promises.values()) {
+      for (const { reject } of promises) reject(message);
+    }
+    this.#promises.clear();
+  }
+  async play() {
+    return this.#remote("playVideo");
+  }
+  #playFail(message) {
+    this.#getPromise("playVideo")?.reject(message);
+  }
+  async pause() {
+    return this.#remote("pauseVideo");
+  }
+  #pauseFail(message) {
+    this.#getPromise("pauseVideo")?.reject(message);
+  }
+  setMuted(muted) {
+    if (muted) this.#remote("mute");
+    else this.#remote("unMute");
+  }
+  setCurrentTime(time) {
+    this.#remote("seekTo", time);
+    this.#ctx.notify("seeking", time);
+  }
+  setVolume(volume) {
+    this.#remote("setVolume", volume * 100);
+  }
+  setPlaybackRate(rate) {
+    this.#remote("setPlaybackRate", rate);
+  }
+  async loadSource(src) {
+    if (!isString(src.src)) {
+      this.#currentSrc = null;
+      this.#videoId.set("");
+      return;
+    }
+    const videoId = resolveYouTubeVideoId(src.src);
+    this.#videoId.set(videoId ?? "");
+    this.#currentSrc = src;
+  }
+  getOrigin() {
+    return !this.cookies ? "https://www.youtube-nocookie.com" : "https://www.youtube.com";
+  }
+  #watchVideoId() {
+    this.#reset();
+    const videoId = this.#videoId();
+    if (!videoId) {
+      this.src.set("");
+      return;
+    }
+    this.src.set(`${this.getOrigin()}/embed/${videoId}`);
+    this.#ctx.notify("load-start");
+  }
+  buildParams() {
+    const { keyDisabled } = this.#ctx.$props, { muted, playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
+    return {
+      autoplay: 0,
+      cc_lang_pref: this.language,
+      cc_load_policy: showControls ? 1 : void 0,
+      color: this.color,
+      controls: showControls ? 1 : 0,
+      disablekb: !showControls || keyDisabled() ? 1 : 0,
+      enablejsapi: 1,
+      fs: 1,
+      hl: this.language,
+      iv_load_policy: showControls ? 1 : 3,
+      mute: muted() ? 1 : 0,
+      playsinline: playsInline() ? 1 : 0
+    };
+  }
+  #remote(command, arg) {
+    let promise = deferredPromise(), promises = this.#promises.get(command);
+    if (!promises) this.#promises.set(command, promises = []);
+    promises.push(promise);
+    this.postMessage({
+      event: "command",
+      func: command,
+      args: arg ? [arg] : void 0
+    });
+    return promise.promise;
+  }
+  onLoad() {
+    window.setTimeout(() => this.postMessage({ event: "listening" }), 100);
+  }
+  #onReady(trigger) {
+    this.#ctx.notify("loaded-metadata");
+    this.#ctx.notify("loaded-data");
+    this.#ctx.delegate.ready(void 0, trigger);
+  }
+  #onPause(trigger) {
+    this.#getPromise("pauseVideo")?.resolve();
+    this.#ctx.notify("pause", void 0, trigger);
+  }
+  #onTimeUpdate(time, trigger) {
+    const { duration, realCurrentTime } = this.#ctx.$state, hasEnded = this.#state === YouTubePlayerState.Ended, boundTime = hasEnded ? duration() : time;
+    this.#ctx.notify("time-change", boundTime, trigger);
+    if (!hasEnded && Math.abs(boundTime - realCurrentTime()) > 1) {
+      this.#ctx.notify("seeking", boundTime, trigger);
+    }
+  }
+  #onProgress(buffered, seekable, trigger) {
+    const detail = {
+      buffered: new TimeRange(0, buffered),
+      seekable
+    };
+    this.#ctx.notify("progress", detail, trigger);
+    const { seeking, realCurrentTime } = this.#ctx.$state;
+    if (seeking() && buffered > realCurrentTime()) {
+      this.#onSeeked(trigger);
+    }
+  }
+  #onSeeked(trigger) {
+    const { paused, realCurrentTime } = this.#ctx.$state;
+    window.clearTimeout(this.#seekingTimer);
+    this.#seekingTimer = window.setTimeout(
+      () => {
+        this.#ctx.notify("seeked", realCurrentTime(), trigger);
+        this.#seekingTimer = -1;
+      },
+      paused() ? 100 : 0
+    );
+  }
+  #onEnded(trigger) {
+    const { seeking } = this.#ctx.$state;
+    if (seeking()) this.#onSeeked(trigger);
+    this.#ctx.notify("pause", void 0, trigger);
+    this.#ctx.notify("end", void 0, trigger);
+  }
+  #onStateChange(state, trigger) {
+    const { paused, seeking } = this.#ctx.$state, isPlaying = state === YouTubePlayerState.Playing, isBuffering = state === YouTubePlayerState.Buffering, isPendingPlay = this.#isPending("playVideo"), isPlay = paused() && (isBuffering || isPlaying);
+    if (isBuffering) this.#ctx.notify("waiting", void 0, trigger);
+    if (seeking() && isPlaying) {
+      this.#onSeeked(trigger);
+    }
+    if (this.#invalidPlay && isPlaying) {
+      this.pause();
+      this.#invalidPlay = false;
+      this.setMuted(this.#ctx.$state.muted());
+      return;
+    }
+    if (!isPendingPlay && isPlay) {
+      this.#invalidPlay = true;
+      this.setMuted(true);
+      return;
+    }
+    if (isPlay) {
+      this.#getPromise("playVideo")?.resolve();
+      this.#ctx.notify("play", void 0, trigger);
+    }
+    switch (state) {
+      case YouTubePlayerState.Cued:
+        this.#onReady(trigger);
+        break;
+      case YouTubePlayerState.Playing:
+        this.#ctx.notify("playing", void 0, trigger);
+        break;
+      case YouTubePlayerState.Paused:
+        this.#onPause(trigger);
+        break;
+      case YouTubePlayerState.Ended:
+        this.#onEnded(trigger);
+        break;
+    }
+    this.#state = state;
+  }
+  onMessage({ info }, event) {
+    if (!info) return;
+    const { title, intrinsicDuration, playbackRate } = this.#ctx.$state;
+    if (isObject(info.videoData) && info.videoData.title !== title()) {
+      this.#ctx.notify("title-change", info.videoData.title, event);
+    }
+    if (isNumber(info.duration) && info.duration !== intrinsicDuration()) {
+      if (isNumber(info.videoLoadedFraction)) {
+        const buffered = info.progressState?.loaded ?? info.videoLoadedFraction * info.duration, seekable = new TimeRange(0, info.duration);
+        this.#onProgress(buffered, seekable, event);
+      }
+      this.#ctx.notify("duration-change", info.duration, event);
+    }
+    if (isNumber(info.playbackRate) && info.playbackRate !== playbackRate()) {
+      this.#ctx.notify("rate-change", info.playbackRate, event);
+    }
+    if (info.progressState) {
+      const { current, seekableStart, seekableEnd, loaded, duration } = info.progressState;
+      this.#onTimeUpdate(current, event);
+      this.#onProgress(loaded, new TimeRange(seekableStart, seekableEnd), event);
+      if (duration !== intrinsicDuration()) {
+        this.#ctx.notify("duration-change", duration, event);
+      }
+    }
+    if (isNumber(info.volume) && isBoolean(info.muted) && !this.#invalidPlay) {
+      const detail = {
+        muted: info.muted,
+        volume: info.volume / 100
+      };
+      this.#ctx.notify("volume-change", detail, event);
+    }
+    if (isNumber(info.playerState) && info.playerState !== this.#state) {
+      this.#onStateChange(info.playerState, event);
+    }
+  }
+  #reset() {
+    this.#state = -1;
+    this.#seekingTimer = -1;
+    this.#invalidPlay = false;
+  }
+  #getPromise(command) {
+    return this.#promises.get(command)?.shift();
+  }
+  #isPending(command) {
+    return Boolean(this.#promises.get(command)?.length);
+  }
+}
+
+export { YouTubeProvider };
diff --git a/prod/chunks/vidstack-CeHFQcBJ.js b/prod/chunks/vidstack-CeHFQcBJ.js
new file mode 100644
index 0000000000000000000000000000000000000000..2fcaf7d01d7a0e555dd03d0ff399d4ca4d3b3535
--- /dev/null
+++ b/prod/chunks/vidstack-CeHFQcBJ.js
@@ -0,0 +1,375 @@
+"use client"
+
+import * as React from 'react';
+import { createReactComponent, composeRefs, listenEvent, useReactScope, scoped, signal, computed, effect, EventsController, useSignal } from './vidstack-CNjv_Zem.js';
+import { Primitive, MediaAnnouncerInstance, ControlsInstance, ControlsGroupInstance, TooltipInstance, TooltipTriggerInstance, TooltipContentInstance, GoogleCastButtonInstance, QualitySliderInstance, AudioGainSliderInstance, SpeedSliderInstance, useMediaState, watchActiveTextTrack, CaptionsInstance, formatTime, formatSpokenTime } from './vidstack-BY07IoHR.js';
+import { sliderCallbacks, Preview, Steps, Thumb, Track as Track$1, TrackFill as TrackFill$1, Value, useMediaContext } from './vidstack-CtKPQRKk.js';
+
+const MediaAnnouncerBridge = createReactComponent(MediaAnnouncerInstance, {
+  events: ["onChange"]
+});
+const MediaAnnouncer = React.forwardRef(
+  ({ style, children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(MediaAnnouncerBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        style: { display: "contents", ...style },
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+MediaAnnouncer.displayName = "MediaAnnouncer";
+
+const ControlsBridge = createReactComponent(ControlsInstance);
+const Root$5 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ControlsBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Root$5.displayName = "Controls";
+const ControlsGroupBridge = createReactComponent(ControlsGroupInstance);
+const Group = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ControlsGroupBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Group.displayName = "ControlsGroup";
+
+var controls = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Group: Group,
+  Root: Root$5
+});
+
+const TooltipBridge = createReactComponent(TooltipInstance);
+function Root$4({ children, ...props }) {
+  return /* @__PURE__ */ React.createElement(TooltipBridge, { ...props }, children);
+}
+Root$4.displayName = "Tooltip";
+const TriggerBridge = createReactComponent(TooltipTriggerInstance);
+const Trigger = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(TriggerBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Trigger.displayName = "TooltipTrigger";
+const ContentBridge = createReactComponent(TooltipContentInstance);
+const Content = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(ContentBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Content.displayName = "TooltipContent";
+
+var tooltip = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Content: Content,
+  Root: Root$4,
+  Trigger: Trigger
+});
+
+const GoogleCastButtonBridge = createReactComponent(GoogleCastButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const GoogleCastButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(GoogleCastButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+GoogleCastButton.displayName = "GoogleCastButton";
+
+const QualitySliderBridge = createReactComponent(QualitySliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$3 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(QualitySliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$3.displayName = "QualitySlider";
+
+var qualitySlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$3,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const AudioGainSliderBridge = createReactComponent(AudioGainSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$2 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(AudioGainSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$2.displayName = "AudioGainSlider";
+
+var audioGainSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$2,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const SpeedSliderBridge = createReactComponent(SpeedSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$1 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SpeedSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$1.displayName = "SpeedSlider";
+
+var speedSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$1,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const Title = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const $title = useMediaState("title");
+  return /* @__PURE__ */ React.createElement(Primitive.span, { ...props, ref: forwardRef }, $title, children);
+});
+Title.displayName = "Title";
+
+function useActiveTextCues(track) {
+  const [activeCues, setActiveCues] = React.useState([]);
+  React.useEffect(() => {
+    if (!track) {
+      setActiveCues([]);
+      return;
+    }
+    function onCuesChange() {
+      if (track) setActiveCues(track.activeCues);
+    }
+    onCuesChange();
+    return listenEvent(track, "cue-change", onCuesChange);
+  }, [track]);
+  return activeCues;
+}
+
+function useActiveTextTrack(kind) {
+  const media = useMediaContext(), [track, setTrack] = React.useState(null);
+  React.useEffect(() => {
+    return watchActiveTextTrack(media.textTracks, kind, setTrack);
+  }, [kind]);
+  return track;
+}
+
+function useChapterTitle() {
+  const $track = useActiveTextTrack("chapters"), $cues = useActiveTextCues($track);
+  return $cues[0]?.text || "";
+}
+
+const ChapterTitle = React.forwardRef(
+  ({ defaultText = "", children, ...props }, forwardRef) => {
+    const $chapterTitle = useChapterTitle();
+    return /* @__PURE__ */ React.createElement(Primitive.span, { ...props, ref: forwardRef }, $chapterTitle || defaultText, children);
+  }
+);
+ChapterTitle.displayName = "ChapterTitle";
+
+const CaptionsBridge = createReactComponent(CaptionsInstance);
+const Captions = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(CaptionsBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Captions.displayName = "Captions";
+
+const Root = React.forwardRef(
+  ({ size = 96, children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(
+      "svg",
+      {
+        width: size,
+        height: size,
+        fill: "none",
+        viewBox: "0 0 120 120",
+        "aria-hidden": "true",
+        "data-part": "root",
+        ...props,
+        ref: forwardRef
+      },
+      children
+    );
+  }
+);
+const Track = React.forwardRef(
+  ({ width = 8, children, ...props }, ref) => /* @__PURE__ */ React.createElement(
+    "circle",
+    {
+      cx: "60",
+      cy: "60",
+      r: "54",
+      stroke: "currentColor",
+      strokeWidth: width,
+      "data-part": "track",
+      ...props,
+      ref
+    },
+    children
+  )
+);
+const TrackFill = React.forwardRef(
+  ({ width = 8, fillPercent = 50, children, ...props }, ref) => /* @__PURE__ */ React.createElement(
+    "circle",
+    {
+      cx: "60",
+      cy: "60",
+      r: "54",
+      stroke: "currentColor",
+      pathLength: "100",
+      strokeWidth: width,
+      strokeDasharray: 100,
+      strokeDashoffset: 100 - fillPercent,
+      "data-part": "track-fill",
+      ...props,
+      ref
+    },
+    children
+  )
+);
+
+var spinner = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Root: Root,
+  Track: Track,
+  TrackFill: TrackFill
+});
+
+function createSignal(initialValue, deps = []) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(() => signal(initialValue), scope), [scope, ...deps]);
+}
+function createComputed(compute, deps = []) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(() => computed(compute), scope), [scope, ...deps]);
+}
+function createEffect(compute, deps = []) {
+  const scope = useReactScope();
+  React.useEffect(() => scoped(() => effect(compute), scope), [scope, ...deps]);
+}
+function useScoped(compute) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(compute, scope), [scope]);
+}
+
+function useTextCues(track) {
+  const [cues, setCues] = React.useState([]);
+  React.useEffect(() => {
+    if (!track) return;
+    function onCuesChange() {
+      if (track) setCues([...track.cues]);
+    }
+    const events = new EventsController(track).add("add-cue", onCuesChange).add("remove-cue", onCuesChange);
+    onCuesChange();
+    return () => {
+      setCues([]);
+      events.abort();
+    };
+  }, [track]);
+  return cues;
+}
+
+function useChapterOptions() {
+  const media = useMediaContext(), track = useActiveTextTrack("chapters"), cues = useTextCues(track), $startTime = useSignal(media.$state.seekableStart), $endTime = useSignal(media.$state.seekableEnd);
+  useActiveTextCues(track);
+  return React.useMemo(() => {
+    const options = track ? cues.filter((cue) => cue.startTime <= $endTime && cue.endTime >= $startTime).map((cue, i) => {
+      let currentRef = null, stopProgressEffect;
+      return {
+        cue,
+        label: cue.text,
+        value: i.toString(),
+        startTimeText: formatTime(Math.max(0, cue.startTime - $startTime)),
+        durationText: formatSpokenTime(
+          Math.min($endTime, cue.endTime) - Math.max($startTime, cue.startTime)
+        ),
+        get selected() {
+          return cue === track.activeCues[0];
+        },
+        setProgressVar(ref) {
+          if (!ref || cue !== track.activeCues[0]) {
+            stopProgressEffect?.();
+            stopProgressEffect = void 0;
+            ref?.style.setProperty("--progress", "0%");
+            currentRef = null;
+            return;
+          }
+          if (currentRef === ref) return;
+          currentRef = ref;
+          stopProgressEffect?.();
+          stopProgressEffect = effect(() => {
+            const { realCurrentTime } = media.$state, time = realCurrentTime(), cueStartTime = Math.max($startTime, cue.startTime), duration = Math.min($endTime, cue.endTime) - cueStartTime, progress = Math.max(0, time - cueStartTime) / duration * 100;
+            ref.style.setProperty("--progress", progress.toFixed(3) + "%");
+          });
+        },
+        select(trigger) {
+          media.remote.seek(cue.startTime - $startTime, trigger);
+        }
+      };
+    }) : [];
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const index = options.findIndex((option) => option.selected);
+        return (index >= 0 ? index : 0).toString();
+      }
+    });
+    return options;
+  }, [cues, $startTime, $endTime]);
+}
+
+export { Captions, ChapterTitle, Content, GoogleCastButton, Group, MediaAnnouncer, Root$4 as Root, Root$2 as Root$1, Root$3 as Root$2, Root$1 as Root$3, Root$5 as Root$4, Root as Root$5, Title, Track, TrackFill, Trigger, audioGainSlider, controls, createComputed, createEffect, createSignal, qualitySlider, speedSlider, spinner, tooltip, useActiveTextCues, useActiveTextTrack, useChapterOptions, useChapterTitle, useScoped, useTextCues };
diff --git a/prod/chunks/vidstack-B6KLIr71.js b/prod/chunks/vidstack-CfyCSud2.js
similarity index 99%
rename from prod/chunks/vidstack-B6KLIr71.js
rename to prod/chunks/vidstack-CfyCSud2.js
index cf0713dfc6d8855b0acebcb4568489fe7d4e1e00..a93f1b0dd1140b469c3f16d9bb02c67921a9c56e 100644
--- a/prod/chunks/vidstack-B6KLIr71.js
+++ b/prod/chunks/vidstack-CfyCSud2.js
@@ -2,10 +2,10 @@
 
 import * as React from 'react';
 import { useSignal, isBoolean, composeRefs, uppercaseFirstChar, isUndefined, isString, signal, camelToKebabCase, onDispose, scoped, keysOf, effect, isArray, isKeyboardClick, listenEvent, toggleClass, useContext } from './vidstack-CNjv_Zem.js';
-import { createComputed, createSignal, MediaAnnouncer, Root, Trigger, Content, GoogleCastButton, Captions, useChapterOptions, Root$1 as Root$5, Root$2 as Root$6, Root$3 as Root$7, useScoped, Root$4 as Root$a, Group, useChapterTitle, createEffect, useActiveTextTrack, ChapterTitle as ChapterTitle$1, Title, Root$5 as Root$b, Track as Track$1, TrackFill as TrackFill$1 } from './vidstack-BDYuUZKb.js';
-import { useColorSchemePreference, useActive, useResizeObserver, useLayoutName, useTransitionActive } from './vidstack-D6LPqXyU.js';
-import { useMediaContext, MuteButton, PlayButton, CaptionButton, PIPButton, FullscreenButton, SeekButton, AirPlayButton, LiveButton, appendParamsToURL, Items, Root$3 as Root$1, Item, Root as Root$2, Img, Root$2 as Root$3, Button, Portal, Track, TrackFill, Thumb, Steps, useMediaPlayer, Root$5 as Root$4, useAudioOptions, useCaptionOptions, Root$4 as Root$8, Preview, Value, Root$1 as Root$9, Chapters, Progress, Thumbnail, ChapterTitle, Time, Gesture } from './vidstack-DP0Brh65.js';
-import { useMediaState, isTrackCaptionKind, getDownloadFile, isRemotionSrc, IS_SERVER, useMediaContext as useMediaContext$1, sortVideoQualities, Primitive, mediaContext } from './vidstack-D6dKrFOZ.js';
+import { createComputed, createSignal, MediaAnnouncer, Root, Trigger, Content, GoogleCastButton, Captions, useChapterOptions, Root$1 as Root$5, Root$2 as Root$6, Root$3 as Root$7, useScoped, Root$4 as Root$a, Group, useChapterTitle, createEffect, useActiveTextTrack, ChapterTitle as ChapterTitle$1, Title, Root$5 as Root$b, Track as Track$1, TrackFill as TrackFill$1 } from './vidstack-VGRmv787.js';
+import { useColorSchemePreference, useActive, useResizeObserver, useLayoutName, useTransitionActive } from './vidstack-VjvZ5CCo.js';
+import { useMediaContext, MuteButton, PlayButton, CaptionButton, PIPButton, FullscreenButton, SeekButton, AirPlayButton, LiveButton, appendParamsToURL, Items, Root$3 as Root$1, Item, Root as Root$2, Img, Root$2 as Root$3, Button, Portal, Track, TrackFill, Thumb, Steps, useMediaPlayer, Root$5 as Root$4, useAudioOptions, useCaptionOptions, Root$4 as Root$8, Preview, Value, Root$1 as Root$9, Chapters, Progress, Thumbnail, ChapterTitle, Time, Gesture } from './vidstack-BZdaxU0-.js';
+import { useMediaState, isTrackCaptionKind, getDownloadFile, isRemotionSrc, IS_SERVER, useMediaContext as useMediaContext$1, sortVideoQualities, Primitive, mediaContext } from './vidstack-3ABKqYU9.js';
 import { flushSync } from 'react-dom';
 import { RemotionThumbnail, RemotionSliderThumbnail } from './vidstack-CV12ZH4Z.js';
 
diff --git a/prod/chunks/vidstack-D6LPqXyU.js b/prod/chunks/vidstack-CiVrFBoK.js
similarity index 98%
rename from prod/chunks/vidstack-D6LPqXyU.js
rename to prod/chunks/vidstack-CiVrFBoK.js
index d0360541d04c862c514aedbc5a5de5d95069cbb6..8869c56897357708fee4f754cbf910f3d907eee3 100644
--- a/prod/chunks/vidstack-D6LPqXyU.js
+++ b/prod/chunks/vidstack-CiVrFBoK.js
@@ -2,7 +2,7 @@
 
 import * as React from 'react';
 import { animationFrameThrottle, EventsController, listenEvent, effect } from './vidstack-CNjv_Zem.js';
-import { useMediaPlayer } from './vidstack-DP0Brh65.js';
+import { useMediaPlayer } from './vidstack-CtKPQRKk.js';
 
 function useClassName(el, className) {
   React.useEffect(() => {
diff --git a/prod/chunks/vidstack-CkTe59Wi.js b/prod/chunks/vidstack-CkTe59Wi.js
new file mode 100644
index 0000000000000000000000000000000000000000..0f511348c6d3bb144375d0cad3ecf399438a373c
--- /dev/null
+++ b/prod/chunks/vidstack-CkTe59Wi.js
@@ -0,0 +1,490 @@
+"use client"
+
+import * as React from 'react';
+import { createDisposalBin, listenEvent, createScope, signal, peek, effect, tick, isFunction, useSignal, deferredPromise } from './vidstack-CNjv_Zem.js';
+import { Internals } from 'remotion';
+import { RemotionLayoutEngine, REMOTION_PROVIDER_ID, RemotionContextProvider, ErrorBoundary } from '../player/vidstack-remotion.js';
+import { isRemotionSrc, TimeRange } from './vidstack-BY07IoHR.js';
+import { NoReactInternals } from 'remotion/no-react';
+import './vidstack-CV12ZH4Z.js';
+import '@floating-ui/dom';
+
+class RemotionPlaybackEngine {
+  #src;
+  #onFrameChange;
+  #onEnd;
+  #disposal = createDisposalBin();
+  #frame = 0;
+  #framesAdvanced = 0;
+  #playbackRate = 1;
+  #playing = false;
+  #rafId = -1;
+  #timerId = -1;
+  #startedAt = 0;
+  #isRunningInBackground = false;
+  get frame() {
+    return this.#frame;
+  }
+  set frame(frame) {
+    this.#frame = frame;
+    this.#onFrameChange(frame);
+  }
+  constructor(src, onFrameChange, onEnd) {
+    this.#src = src;
+    this.#onFrameChange = onFrameChange;
+    this.#onEnd = onEnd;
+    this.#frame = src.initialFrame ?? 0;
+    this.#disposal.add(
+      listenEvent(document, "visibilitychange", this.#onVisibilityChange.bind(this))
+    );
+  }
+  play() {
+    this.#framesAdvanced = 0;
+    this.#playing = true;
+    this.#startedAt = performance.now();
+    this.#tick();
+  }
+  stop() {
+    this.#playing = false;
+    if (this.#rafId >= 0) {
+      cancelAnimationFrame(this.#rafId);
+      this.#rafId = -1;
+    }
+    if (this.#timerId >= 0) {
+      clearTimeout(this.#timerId);
+      this.#timerId = -1;
+    }
+  }
+  setPlaybackRate(rate) {
+    this.#playbackRate = rate;
+  }
+  destroy() {
+    this.#disposal.empty();
+    this.stop();
+  }
+  #update() {
+    const { nextFrame, framesToAdvance, ended } = this.#calculateNextFrame();
+    this.#framesAdvanced += framesToAdvance;
+    if (nextFrame !== this.#frame) {
+      this.#onFrameChange(nextFrame);
+      this.#frame = nextFrame;
+    }
+    if (ended) {
+      this.#frame = this.#src.outFrame;
+      this.stop();
+      this.#onEnd();
+    }
+  }
+  #tick = () => {
+    this.#update();
+    if (this.#playing) {
+      this.#queueNextFrame(this.#tick);
+    }
+  };
+  #queueNextFrame(callback) {
+    if (this.#isRunningInBackground) {
+      this.#timerId = window.setTimeout(callback, 1e3 / this.#src.fps);
+    } else {
+      this.#rafId = requestAnimationFrame(callback);
+    }
+  }
+  #calculateNextFrame() {
+    const round = this.#playbackRate < 0 ? Math.ceil : Math.floor, time = performance.now() - this.#startedAt, framesToAdvance = round(time * this.#playbackRate / (1e3 / this.#src.fps)) - this.#framesAdvanced, nextFrame = framesToAdvance + this.#frame, isCurrentFrameOutOfBounds = this.#frame > this.#src.outFrame || this.#frame < this.#src.inFrame, isNextFrameOutOfBounds = nextFrame > this.#src.outFrame || nextFrame < this.#src.inFrame, ended = isNextFrameOutOfBounds && !isCurrentFrameOutOfBounds;
+    if (this.#playbackRate > 0 && !ended) {
+      if (isNextFrameOutOfBounds) {
+        return {
+          nextFrame: this.#src.inFrame,
+          framesToAdvance,
+          ended
+        };
+      }
+      return { nextFrame, framesToAdvance, ended };
+    }
+    if (isNextFrameOutOfBounds) {
+      return {
+        nextFrame: this.#src.outFrame,
+        framesToAdvance,
+        ended
+      };
+    }
+    return { nextFrame, framesToAdvance, ended };
+  }
+  #onVisibilityChange() {
+    this.#isRunningInBackground = document.visibilityState === "hidden";
+    if (this.#playing) {
+      this.stop();
+      this.play();
+    }
+  }
+}
+
+NoReactInternals.validateFps;
+NoReactInternals.validateDimension;
+NoReactInternals.validateDurationInFrames;
+
+class RemotionProvider {
+  $$PROVIDER_TYPE = "REMOTION";
+  scope = createScope();
+  #src = signal(null);
+  #setup = false;
+  #loadStart = false;
+  #audio = null;
+  #waiting = signal(false);
+  #waitingPromise = null;
+  #mediaTags = signal([]);
+  #mediaElements = signal([]);
+  #bufferingElements = /* @__PURE__ */ new Set();
+  #timeline = null;
+  #frame = signal({ [REMOTION_PROVIDER_ID]: 0 });
+  #layoutEngine = new RemotionLayoutEngine();
+  #playbackEngine = null;
+  #container;
+  #ctx;
+  #setTimeline;
+  #setMediaVolume = {
+    setMediaMuted: this.setMuted.bind(this),
+    setMediaVolume: this.setVolume.bind(this)
+  };
+  get type() {
+    return "remotion";
+  }
+  get currentSrc() {
+    return peek(this.#src);
+  }
+  get frame() {
+    return this.#frame();
+  }
+  constructor(container, ctx) {
+    this.#container = container;
+    this.#ctx = ctx;
+    this.#setTimeline = {
+      setFrame: this.#setFrame.bind(this),
+      setPlaying: this.#setPlaying.bind(this)
+    };
+    this.#layoutEngine.setContainer(container);
+  }
+  setup() {
+    effect(this.#watchWaiting.bind(this));
+    effect(this.#watchMediaTags.bind(this));
+    effect(this.#watchMediaElements.bind(this));
+  }
+  #watchMediaTags() {
+    this.#mediaTags();
+    this.#discoverMediaElements();
+  }
+  #discoverMediaElements() {
+    const elements = [...this.#container.querySelectorAll("audio,video")];
+    this.#mediaElements.set(elements);
+  }
+  #watchMediaElements() {
+    const elements = this.#mediaElements();
+    for (const tag of elements) {
+      const onWait = this.#onWaitFor.bind(this, tag), onStopWaiting = this.#onStopWaitingFor.bind(this, tag);
+      if (tag.currentSrc && tag.readyState < 4) {
+        this.#onWaitFor(tag);
+        listenEvent(tag, "canplay", onStopWaiting);
+      }
+      listenEvent(tag, "waiting", onWait);
+      listenEvent(tag, "playing", onStopWaiting);
+    }
+    for (const el of this.#bufferingElements) {
+      if (!elements.includes(el)) this.#onStopWaitingFor(el);
+    }
+  }
+  #onFrameChange(frame) {
+    const { inFrame, fps } = this.#src(), { seeking } = this.#ctx.$state, time = Math.max(0, frame - inFrame) / fps;
+    this.#frame.set((record) => ({
+      ...record,
+      [REMOTION_PROVIDER_ID]: frame
+    }));
+    this.#ctx.notify("time-change", time);
+    if (seeking()) {
+      tick();
+      this.#ctx.notify("seeked", time);
+    }
+  }
+  #onFrameEnd() {
+    this.pause();
+    this.#ctx.notify("end");
+  }
+  async play() {
+    const { ended } = this.#ctx.$state;
+    if (peek(ended)) {
+      this.#setFrame({ [REMOTION_PROVIDER_ID]: 0 });
+    }
+    try {
+      const mediaElements = peek(this.#mediaElements);
+      if (mediaElements.length) {
+        await Promise.all(mediaElements.map((media) => media.play()));
+      }
+      this.#ctx.notify("play");
+      tick();
+      if (this.#waitingPromise) {
+        this.#ctx.notify("waiting");
+        return this.#waitingPromise.promise;
+      } else {
+        this.#playbackEngine?.play();
+        this.#ctx.notify("playing");
+      }
+    } catch (error) {
+      throw error;
+    }
+  }
+  async pause() {
+    this.#ctx.$state;
+    this.#playbackEngine?.stop();
+    this.#ctx.notify("pause");
+  }
+  setMuted(value) {
+    if (!this.#ctx) return;
+    const { muted, volume } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.setMuted(value(muted()));
+      return;
+    }
+    this.#ctx.notify("volume-change", {
+      volume: peek(volume),
+      muted: value
+    });
+  }
+  setCurrentTime(time) {
+    const { fps } = this.#src(), frame = time * fps;
+    this.#ctx.notify("seeking", time);
+    this.#setFrame({ [REMOTION_PROVIDER_ID]: frame });
+  }
+  setVolume(value) {
+    if (!this.#ctx) return;
+    const { volume, muted } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.setVolume(value(volume()));
+      return;
+    }
+    this.#ctx.notify("volume-change", {
+      volume: value,
+      muted: peek(muted)
+    });
+  }
+  setPlaybackRate(rate) {
+    if (isFunction(rate)) {
+      const { playbackRate } = this.#ctx.$state;
+      this.setPlaybackRate(rate(peek(playbackRate)));
+      return;
+    }
+    this.#playbackEngine?.setPlaybackRate(rate);
+    this.#ctx.notify("rate-change", rate);
+  }
+  async loadSource(src) {
+    if (!isRemotionSrc(src)) return;
+    const onUserError = src.onError, resolvedSrc = {
+      compositionWidth: 1920,
+      compositionHeight: 1080,
+      fps: 30,
+      initialFrame: 0,
+      inFrame: 0,
+      outFrame: src.durationInFrames,
+      numberOfSharedAudioTags: 5,
+      inputProps: {},
+      ...src,
+      onError: (error) => {
+        this.pause();
+        this.#ctx.notify("error", {
+          message: error.message,
+          code: 1
+        });
+        onUserError?.(error);
+      }
+    };
+    this.#src.set(resolvedSrc);
+    for (const prop of Object.keys(resolvedSrc)) {
+      src[prop] = resolvedSrc[prop];
+    }
+    this.changeSrc(resolvedSrc);
+  }
+  destroy() {
+    this.changeSrc(null);
+  }
+  changeSrc(src) {
+    this.#playbackEngine?.destroy();
+    this.#waiting.set(false);
+    this.#waitingPromise?.reject("src changed");
+    this.#waitingPromise = null;
+    this.#audio = null;
+    this.#timeline = null;
+    this.#playbackEngine = null;
+    this.#mediaTags.set([]);
+    this.#bufferingElements.clear();
+    this.#frame.set({ [REMOTION_PROVIDER_ID]: 0 });
+    this.#layoutEngine.setSrc(src);
+    if (src) {
+      this.#timeline = this.#createTimelineContextValue();
+      this.#playbackEngine = new RemotionPlaybackEngine(
+        src,
+        this.#onFrameChange.bind(this),
+        this.#onFrameEnd.bind(this)
+      );
+    }
+  }
+  render = () => {
+    const $src = useSignal(this.#src);
+    if (!$src) {
+      throw Error(
+        "[vidstack] no src"
+      );
+    }
+    React.useEffect(() => {
+      if (!isRemotionSrc($src)) return;
+      const rafId = requestAnimationFrame(() => {
+        if (!this.#setup) {
+          this.#ctx.notify("provider-setup", this);
+          this.#setup = true;
+        }
+        if (!this.#loadStart) {
+          this.#ctx.notify("load-start");
+          this.#loadStart = true;
+        }
+        this.#discoverMediaElements();
+        tick();
+        if (!this.#waiting()) this.#ready($src);
+      });
+      return () => {
+        cancelAnimationFrame(rafId);
+        this.#loadStart = false;
+      };
+    }, [$src]);
+    const Component = Internals.useLazyComponent({
+      component: $src.src
+    });
+    const { $state } = this.#ctx, $volume = useSignal($state.volume), $isMuted = useSignal($state.muted);
+    const mediaVolume = React.useMemo(() => {
+      const { muted, volume } = this.#ctx.$state;
+      return { mediaMuted: muted(), mediaVolume: volume() };
+    }, [$isMuted, $volume]);
+    return /* @__PURE__ */ React.createElement(
+      RemotionContextProvider,
+      {
+        src: $src,
+        component: Component,
+        timeline: this.#timeline,
+        mediaVolume,
+        setMediaVolume: this.#setMediaVolume
+      },
+      /* @__PURE__ */ React.createElement(Internals.Timeline.SetTimelineContext.Provider, { value: this.#setTimeline }, React.createElement(this.renderVideo, { src: $src }))
+    );
+  };
+  renderVideo = ({ src }) => {
+    const video = Internals.useVideo(), Video = video ? video.component : null, audioContext = React.useContext(Internals.SharedAudioContext);
+    const { $state } = this.#ctx;
+    useSignal(this.#frame);
+    useSignal($state.playing);
+    useSignal($state.playbackRate);
+    React.useEffect(() => {
+      this.#audio = audioContext;
+      return () => {
+        this.#audio = null;
+      };
+    }, [audioContext]);
+    const LoadingContent = React.useMemo(() => src.renderLoading?.(), [src]);
+    const Content = Video ? /* @__PURE__ */ React.createElement(ErrorBoundary, { fallback: src.errorFallback, onError: src.onError }, /* @__PURE__ */ React.createElement(Internals.ClipComposition, null, /* @__PURE__ */ React.createElement(Video, { ...video?.props, ...src.inputProps }))) : null;
+    return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: LoadingContent }, Content);
+  };
+  #ready(src) {
+    if (!src) return;
+    const { outFrame, inFrame, fps } = src, duration = (outFrame - inFrame) / fps;
+    this.#ctx.notify("loaded-metadata");
+    this.#ctx.notify("loaded-data");
+    this.#ctx.delegate.ready({
+      duration,
+      seekable: new TimeRange(0, duration),
+      buffered: new TimeRange(0, duration)
+    });
+    if (src.initialFrame) {
+      this.#setFrame({
+        [REMOTION_PROVIDER_ID]: src.initialFrame
+      });
+    }
+  }
+  #onWaitFor(el) {
+    this.#bufferingElements.add(el);
+    this.#waiting.set(true);
+    if (!this.#waitingPromise) {
+      this.#waitingPromise = deferredPromise();
+    }
+  }
+  #onStopWaitingFor(el) {
+    this.#bufferingElements.delete(el);
+    if (this.#bufferingElements.size) return;
+    this.#waiting.set(false);
+    this.#waitingPromise?.resolve();
+    this.#waitingPromise = null;
+    const { canPlay } = this.#ctx.$state;
+    if (!peek(canPlay)) {
+      this.#ready(peek(this.#src));
+    }
+  }
+  #watchWaiting() {
+    this.#waiting();
+    const { paused } = this.#ctx.$state;
+    if (peek(paused)) return;
+    if (this.#waiting()) {
+      this.#playbackEngine?.stop();
+      this.#ctx.notify("waiting");
+    } else {
+      this.#playbackEngine?.play();
+      this.#ctx.notify("playing");
+    }
+  }
+  #setFrame(value) {
+    if (isFunction(value)) {
+      this.#setFrame(value(this.#frame()));
+      return;
+    }
+    this.#frame.set((record) => ({ ...record, ...value }));
+    const nextFrame = value[REMOTION_PROVIDER_ID];
+    if (this.#playbackEngine && this.#playbackEngine.frame !== nextFrame) {
+      this.#playbackEngine.frame = nextFrame;
+    }
+  }
+  #setPlaying(value) {
+    const { playing } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.#setPlaying(value(playing()));
+      return;
+    }
+    if (value) {
+      this.play();
+    } else if (!value) {
+      this.pause();
+    }
+  }
+  #createTimelineContextValue() {
+    const { playing, playbackRate } = this.#ctx.$state, frame = this.#frame, mediaTags = this.#mediaTags, setPlaybackRate = this.setPlaybackRate.bind(this);
+    return {
+      rootId: REMOTION_PROVIDER_ID,
+      get frame() {
+        return frame();
+      },
+      get playing() {
+        return playing();
+      },
+      get playbackRate() {
+        return playbackRate();
+      },
+      imperativePlaying: {
+        get current() {
+          return playing();
+        }
+      },
+      setPlaybackRate,
+      audioAndVideoTags: {
+        get current() {
+          return mediaTags();
+        },
+        set current(tags) {
+          mediaTags.set(tags);
+        }
+      }
+    };
+  }
+}
+
+export { RemotionProvider };
diff --git a/prod/chunks/vidstack-Cn4BWI0O.js b/prod/chunks/vidstack-Cn4BWI0O.js
new file mode 100644
index 0000000000000000000000000000000000000000..92b491853a9bfa736d9336a094aed0755db89f29
--- /dev/null
+++ b/prod/chunks/vidstack-Cn4BWI0O.js
@@ -0,0 +1,1371 @@
+"use client"
+
+import * as React from 'react';
+import { useSignal, isBoolean, composeRefs, uppercaseFirstChar, isUndefined, isString, signal, camelToKebabCase, onDispose, scoped, keysOf, effect, isArray, isKeyboardClick, listenEvent, toggleClass, useContext } from './vidstack-CNjv_Zem.js';
+import { createComputed, createSignal, MediaAnnouncer, Root, Trigger, Content, GoogleCastButton, Captions, useChapterOptions, Root$1 as Root$5, Root$2 as Root$6, Root$3 as Root$7, useScoped, Root$4 as Root$a, Group, useChapterTitle, createEffect, useActiveTextTrack, ChapterTitle as ChapterTitle$1, Title, Root$5 as Root$b, Track as Track$1, TrackFill as TrackFill$1 } from './vidstack-CeHFQcBJ.js';
+import { useColorSchemePreference, useActive, useResizeObserver, useLayoutName, useTransitionActive } from './vidstack-CiVrFBoK.js';
+import { useMediaContext, MuteButton, PlayButton, CaptionButton, PIPButton, FullscreenButton, SeekButton, AirPlayButton, LiveButton, appendParamsToURL, Items, Root$3 as Root$1, Item, Root as Root$2, Img, Root$2 as Root$3, Button, Portal, Track, TrackFill, Thumb, Steps, useMediaPlayer, Root$5 as Root$4, useAudioOptions, useCaptionOptions, Root$4 as Root$8, Preview, Value, Root$1 as Root$9, Chapters, Progress, Thumbnail, ChapterTitle, Time, Gesture } from './vidstack-CtKPQRKk.js';
+import { useMediaState, isTrackCaptionKind, getDownloadFile, isRemotionSrc, IS_SERVER, useMediaContext as useMediaContext$1, sortVideoQualities, Primitive, mediaContext } from './vidstack-BY07IoHR.js';
+import { flushSync } from 'react-dom';
+import { RemotionThumbnail, RemotionSliderThumbnail } from './vidstack-CV12ZH4Z.js';
+
+const DefaultLayoutContext = React.createContext({});
+DefaultLayoutContext.displayName = "DefaultLayoutContext";
+function useDefaultLayoutContext() {
+  return React.useContext(DefaultLayoutContext);
+}
+function useDefaultLayoutWord(word) {
+  const { translations } = useDefaultLayoutContext();
+  return i18n(translations, word);
+}
+function i18n(translations, word) {
+  return translations?.[word] ?? word;
+}
+
+function useColorSchemeClass(colorScheme) {
+  const systemColorPreference = useColorSchemePreference();
+  if (colorScheme === "default") {
+    return null;
+  } else if (colorScheme === "system") {
+    return systemColorPreference;
+  } else {
+    return colorScheme;
+  }
+}
+
+function createDefaultMediaLayout({
+  type,
+  smLayoutWhen,
+  renderLayout
+}) {
+  const Layout = React.forwardRef(
+    ({
+      children,
+      className,
+      disableTimeSlider = false,
+      hideQualityBitrate = false,
+      icons,
+      colorScheme = "system",
+      download = null,
+      menuContainer = null,
+      menuGroup = "bottom",
+      noAudioGain = false,
+      audioGains = { min: 0, max: 300, step: 25 },
+      noGestures = false,
+      noKeyboardAnimations = false,
+      noModal = false,
+      noScrubGesture,
+      playbackRates = { min: 0, max: 2, step: 0.25 },
+      seekStep = 10,
+      showMenuDelay,
+      showTooltipDelay = 700,
+      sliderChaptersMinWidth = 325,
+      slots,
+      smallLayoutWhen = smLayoutWhen,
+      thumbnails = null,
+      translations,
+      ...props
+    }, forwardRef) => {
+      const media = useMediaContext(), $load = useSignal(media.$props.load), $canLoad = useMediaState("canLoad"), $viewType = useMediaState("viewType"), $streamType = useMediaState("streamType"), $smallWhen = createComputed(() => {
+        return isBoolean(smallLayoutWhen) ? smallLayoutWhen : smallLayoutWhen(media.player.state);
+      }, [smallLayoutWhen]), userPrefersAnnouncements = createSignal(true), userPrefersKeyboardAnimations = createSignal(true), isMatch = $viewType === type, isSmallLayout = $smallWhen(), isForcedLayout = isBoolean(smallLayoutWhen), isLoadLayout = $load === "play" && !$canLoad, canRender = $canLoad || isForcedLayout || isLoadLayout, colorSchemeClass = useColorSchemeClass(colorScheme), layoutEl = createSignal(null);
+      useSignal($smallWhen);
+      return /* @__PURE__ */ React.createElement(
+        "div",
+        {
+          ...props,
+          className: `vds-${type}-layout` + (colorSchemeClass ? ` ${colorSchemeClass}` : "") + (className ? ` ${className}` : ""),
+          "data-match": isMatch ? "" : null,
+          "data-sm": isSmallLayout ? "" : null,
+          "data-lg": !isSmallLayout ? "" : null,
+          "data-size": isSmallLayout ? "sm" : "lg",
+          "data-no-scrub-gesture": noScrubGesture ? "" : null,
+          ref: composeRefs(layoutEl.set, forwardRef)
+        },
+        canRender && isMatch ? /* @__PURE__ */ React.createElement(
+          DefaultLayoutContext.Provider,
+          {
+            value: {
+              disableTimeSlider,
+              hideQualityBitrate,
+              icons,
+              colorScheme,
+              download,
+              isSmallLayout,
+              menuContainer,
+              menuGroup,
+              noAudioGain,
+              audioGains,
+              layoutEl,
+              noGestures,
+              noKeyboardAnimations,
+              noModal,
+              noScrubGesture,
+              showMenuDelay,
+              showTooltipDelay,
+              sliderChaptersMinWidth,
+              slots,
+              seekStep,
+              playbackRates,
+              thumbnails,
+              translations,
+              userPrefersAnnouncements,
+              userPrefersKeyboardAnimations
+            }
+          },
+          renderLayout({ streamType: $streamType, isSmallLayout, isLoadLayout }),
+          children
+        ) : null
+      );
+    }
+  );
+  Layout.displayName = "DefaultMediaLayout";
+  return Layout;
+}
+
+function useDefaultAudioLayoutSlots() {
+  return React.useContext(DefaultLayoutContext).slots;
+}
+function useDefaultVideoLayoutSlots() {
+  return React.useContext(DefaultLayoutContext).slots;
+}
+function slot(slots, name, defaultValue) {
+  const slot2 = slots?.[name], capitalizedName = uppercaseFirstChar(name);
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slots?.[`before${capitalizedName}`], isUndefined(slot2) ? defaultValue : slot2, slots?.[`after${capitalizedName}`]);
+}
+
+function DefaultAnnouncer() {
+  const { userPrefersAnnouncements, translations } = useDefaultLayoutContext(), $userPrefersAnnouncements = useSignal(userPrefersAnnouncements);
+  if (!$userPrefersAnnouncements) return null;
+  return /* @__PURE__ */ React.createElement(MediaAnnouncer, { translations });
+}
+DefaultAnnouncer.displayName = "DefaultAnnouncer";
+
+function DefaultTooltip({ content, placement, children }) {
+  const { showTooltipDelay } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root, { showDelay: showTooltipDelay }, /* @__PURE__ */ React.createElement(Trigger, { asChild: true }, children), /* @__PURE__ */ React.createElement(Content, { className: "vds-tooltip-content", placement }, content));
+}
+DefaultTooltip.displayName = "DefaultTooltip";
+
+function DefaultPlayButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), playText = useDefaultLayoutWord("Play"), pauseText = useDefaultLayoutWord("Pause"), $paused = useMediaState("paused"), $ended = useMediaState("ended");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $paused ? playText : pauseText, placement: tooltip }, /* @__PURE__ */ React.createElement(PlayButton, { className: "vds-play-button vds-button", "aria-label": playText }, $ended ? /* @__PURE__ */ React.createElement(Icons.PlayButton.Replay, { className: "vds-icon" }) : $paused ? /* @__PURE__ */ React.createElement(Icons.PlayButton.Play, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.PlayButton.Pause, { className: "vds-icon" })));
+}
+DefaultPlayButton.displayName = "DefaultPlayButton";
+const DefaultMuteButton = React.forwardRef(
+  ({ tooltip }, forwardRef) => {
+    const { icons: Icons } = useDefaultLayoutContext(), muteText = useDefaultLayoutWord("Mute"), unmuteText = useDefaultLayoutWord("Unmute"), $muted = useMediaState("muted"), $volume = useMediaState("volume");
+    return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $muted ? unmuteText : muteText, placement: tooltip }, /* @__PURE__ */ React.createElement(MuteButton, { className: "vds-mute-button vds-button", "aria-label": muteText, ref: forwardRef }, $muted || $volume == 0 ? /* @__PURE__ */ React.createElement(Icons.MuteButton.Mute, { className: "vds-icon" }) : $volume < 0.5 ? /* @__PURE__ */ React.createElement(Icons.MuteButton.VolumeLow, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.MuteButton.VolumeHigh, { className: "vds-icon" })));
+  }
+);
+DefaultMuteButton.displayName = "DefaultMuteButton";
+function DefaultCaptionButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), captionsText = useDefaultLayoutWord("Captions"), onText = useDefaultLayoutWord("Closed-Captions On"), offText = useDefaultLayoutWord("Closed-Captions Off"), $track = useMediaState("textTrack"), isOn = $track && isTrackCaptionKind($track);
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: isOn ? onText : offText, placement: tooltip }, /* @__PURE__ */ React.createElement(CaptionButton, { className: "vds-caption-button vds-button", "aria-label": captionsText }, isOn ? /* @__PURE__ */ React.createElement(Icons.CaptionButton.On, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.CaptionButton.Off, { className: "vds-icon" })));
+}
+DefaultCaptionButton.displayName = "DefaultCaptionButton";
+function DefaultPIPButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), pipText = useDefaultLayoutWord("PiP"), enterText = useDefaultLayoutWord("Enter PiP"), exitText = useDefaultLayoutWord("Exit PiP"), $pip = useMediaState("pictureInPicture");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $pip ? exitText : enterText, placement: tooltip }, /* @__PURE__ */ React.createElement(PIPButton, { className: "vds-pip-button vds-button", "aria-label": pipText }, $pip ? /* @__PURE__ */ React.createElement(Icons.PIPButton.Exit, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.PIPButton.Enter, { className: "vds-icon" })));
+}
+DefaultPIPButton.displayName = "DefaultPIPButton";
+function DefaultFullscreenButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), fullscreenText = useDefaultLayoutWord("Fullscreen"), enterText = useDefaultLayoutWord("Enter Fullscreen"), exitText = useDefaultLayoutWord("Exit Fullscreen"), $fullscreen = useMediaState("fullscreen");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $fullscreen ? exitText : enterText, placement: tooltip }, /* @__PURE__ */ React.createElement(FullscreenButton, { className: "vds-fullscreen-button vds-button", "aria-label": fullscreenText }, $fullscreen ? /* @__PURE__ */ React.createElement(Icons.FullscreenButton.Exit, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.FullscreenButton.Enter, { className: "vds-icon" })));
+}
+DefaultFullscreenButton.displayName = "DefaultFullscreenButton";
+function DefaultSeekButton({
+  backward,
+  tooltip
+}) {
+  const { icons: Icons, seekStep } = useDefaultLayoutContext(), seekForwardText = useDefaultLayoutWord("Seek Forward"), seekBackwardText = useDefaultLayoutWord("Seek Backward"), seconds = (backward ? -1 : 1) * seekStep, label = seconds >= 0 ? seekForwardText : seekBackwardText;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: label, placement: tooltip }, /* @__PURE__ */ React.createElement(SeekButton, { className: "vds-seek-button vds-button", seconds, "aria-label": label }, seconds >= 0 ? /* @__PURE__ */ React.createElement(Icons.SeekButton.Forward, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.SeekButton.Backward, { className: "vds-icon" })));
+}
+DefaultSeekButton.displayName = "DefaultSeekButton";
+function DefaultAirPlayButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), airPlayText = useDefaultLayoutWord("AirPlay"), $state = useMediaState("remotePlaybackState"), stateText = useDefaultLayoutWord(uppercaseFirstChar($state)), label = `${airPlayText} ${stateText}`, Icon = ($state === "connecting" ? Icons.AirPlayButton.Connecting : $state === "connected" ? Icons.AirPlayButton.Connected : null) ?? Icons.AirPlayButton.Default;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: airPlayText, placement: tooltip }, /* @__PURE__ */ React.createElement(AirPlayButton, { className: "vds-airplay-button vds-button", "aria-label": label }, /* @__PURE__ */ React.createElement(Icon, { className: "vds-icon" })));
+}
+DefaultAirPlayButton.displayName = "DefaultAirPlayButton";
+function DefaultGoogleCastButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), googleCastText = useDefaultLayoutWord("Google Cast"), $state = useMediaState("remotePlaybackState"), stateText = useDefaultLayoutWord(uppercaseFirstChar($state)), label = `${googleCastText} ${stateText}`, Icon = ($state === "connecting" ? Icons.GoogleCastButton.Connecting : $state === "connected" ? Icons.GoogleCastButton.Connected : null) ?? Icons.GoogleCastButton.Default;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: googleCastText, placement: tooltip }, /* @__PURE__ */ React.createElement(GoogleCastButton, { className: "vds-google-cast-button vds-button", "aria-label": label }, /* @__PURE__ */ React.createElement(Icon, { className: "vds-icon" })));
+}
+DefaultGoogleCastButton.displayName = "DefaultGoogleCastButton";
+function DefaultLiveButton() {
+  const $live = useMediaState("live"), label = useDefaultLayoutWord("Skip To Live"), liveText = useDefaultLayoutWord("LIVE");
+  return $live ? /* @__PURE__ */ React.createElement(LiveButton, { className: "vds-live-button", "aria-label": label }, /* @__PURE__ */ React.createElement("span", { className: "vds-live-button-text" }, liveText)) : null;
+}
+DefaultLiveButton.displayName = "DefaultLiveButton";
+function DefaultDownloadButton() {
+  const { download, icons: Icons } = useDefaultLayoutContext(), $src = useMediaState("source"), $title = useMediaState("title"), file = getDownloadFile({
+    title: $title,
+    src: $src,
+    download
+  }), downloadText = useDefaultLayoutWord("Download");
+  return isString(file?.url) ? /* @__PURE__ */ React.createElement(DefaultTooltip, { content: downloadText, placement: "top" }, /* @__PURE__ */ React.createElement(
+    "a",
+    {
+      role: "button",
+      className: "vds-download-button vds-button",
+      "aria-label": downloadText,
+      href: appendParamsToURL(file.url, { download: file.name }),
+      download: file.name,
+      target: "_blank"
+    },
+    Icons.DownloadButton ? /* @__PURE__ */ React.createElement(Icons.DownloadButton.Default, { className: "vds-icon" }) : null
+  )) : null;
+}
+DefaultDownloadButton.displayName = "DefaultDownloadButton";
+
+function DefaultCaptions() {
+  const exampleText = useDefaultLayoutWord("Captions look like this");
+  return /* @__PURE__ */ React.createElement(Captions, { className: "vds-captions", exampleText });
+}
+DefaultCaptions.displayName = "DefaultCaptions";
+
+function DefaultControlsSpacer() {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-controls-spacer" });
+}
+DefaultControlsSpacer.displayName = "DefaultControlsSpacer";
+
+function useParentDialogEl() {
+  const { layoutEl } = useDefaultLayoutContext(), $layoutEl = useSignal(layoutEl);
+  return React.useMemo(() => $layoutEl?.closest("dialog"), [$layoutEl]);
+}
+
+function DefaultChaptersMenu({ tooltip, placement, portalClass = "" }) {
+  const {
+    showMenuDelay,
+    noModal,
+    isSmallLayout,
+    icons: Icons,
+    menuGroup,
+    menuContainer,
+    colorScheme
+  } = useDefaultLayoutContext(), chaptersText = useDefaultLayoutWord("Chapters"), options = useChapterOptions(), disabled = !options.length, { thumbnails } = useDefaultLayoutContext(), $src = useMediaState("currentSrc"), $viewType = useMediaState("viewType"), $offset = !isSmallLayout && menuGroup === "bottom" && $viewType === "video" ? 26 : 0, $RemotionThumbnail = useSignal(RemotionThumbnail), colorSchemeClass = useColorSchemeClass(colorScheme), [isOpen, setIsOpen] = React.useState(false), dialogEl = useParentDialogEl();
+  if (disabled) return null;
+  function onOpen() {
+    flushSync(() => {
+      setIsOpen(true);
+    });
+  }
+  function onClose() {
+    setIsOpen(false);
+  }
+  const Content = /* @__PURE__ */ React.createElement(
+    Items,
+    {
+      className: "vds-chapters-menu-items vds-menu-items",
+      placement,
+      offset: $offset
+    },
+    isOpen ? /* @__PURE__ */ React.createElement(
+      Root$1,
+      {
+        className: "vds-chapters-radio-group vds-radio-group",
+        value: options.selectedValue,
+        "data-thumbnails": thumbnails ? "" : null
+      },
+      options.map(
+        ({ cue, label, value, startTimeText, durationText, select, setProgressVar }) => /* @__PURE__ */ React.createElement(
+          Item,
+          {
+            className: "vds-chapter-radio vds-radio",
+            value,
+            key: value,
+            onSelect: select,
+            ref: setProgressVar
+          },
+          thumbnails ? /* @__PURE__ */ React.createElement(Root$2, { src: thumbnails, className: "vds-thumbnail", time: cue.startTime }, /* @__PURE__ */ React.createElement(Img, null)) : $RemotionThumbnail && isRemotionSrc($src) ? /* @__PURE__ */ React.createElement($RemotionThumbnail, { className: "vds-thumbnail", frame: cue.startTime * $src.fps }) : null,
+          /* @__PURE__ */ React.createElement("div", { className: "vds-chapter-radio-content" }, /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-label" }, label), /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-start-time" }, startTimeText), /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-duration" }, durationText))
+        )
+      )
+    ) : null
+  );
+  return /* @__PURE__ */ React.createElement(
+    Root$3,
+    {
+      className: "vds-chapters-menu vds-menu",
+      showDelay: showMenuDelay,
+      onOpen,
+      onClose
+    },
+    /* @__PURE__ */ React.createElement(DefaultTooltip, { content: chaptersText, placement: tooltip }, /* @__PURE__ */ React.createElement(
+      Button,
+      {
+        className: "vds-menu-button vds-button",
+        disabled,
+        "aria-label": chaptersText
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.Chapters, { className: "vds-icon" })
+    )),
+    noModal || !isSmallLayout ? Content : /* @__PURE__ */ React.createElement(
+      Portal,
+      {
+        container: menuContainer ?? dialogEl,
+        className: portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : ""),
+        disabled: "fullscreen",
+        "data-sm": isSmallLayout ? "" : null,
+        "data-lg": !isSmallLayout ? "" : null,
+        "data-size": isSmallLayout ? "sm" : "lg"
+      },
+      Content
+    )
+  );
+}
+DefaultChaptersMenu.displayName = "DefaultChaptersMenu";
+
+const FONT_COLOR_OPTION = {
+  type: "color"
+};
+const FONT_FAMILY_OPTION = {
+  type: "radio",
+  values: {
+    "Monospaced Serif": "mono-serif",
+    "Proportional Serif": "pro-serif",
+    "Monospaced Sans-Serif": "mono-sans",
+    "Proportional Sans-Serif": "pro-sans",
+    Casual: "casual",
+    Cursive: "cursive",
+    "Small Capitals": "capitals"
+  }
+};
+const FONT_SIZE_OPTION = {
+  type: "slider",
+  min: 0,
+  max: 400,
+  step: 25,
+  upIcon: null,
+  downIcon: null
+};
+const FONT_OPACITY_OPTION = {
+  type: "slider",
+  min: 0,
+  max: 100,
+  step: 5,
+  upIcon: null,
+  downIcon: null
+};
+const FONT_TEXT_SHADOW_OPTION = {
+  type: "radio",
+  values: ["None", "Drop Shadow", "Raised", "Depressed", "Outline"]
+};
+const FONT_DEFAULTS = {
+  fontFamily: "pro-sans",
+  fontSize: "100%",
+  textColor: "#ffffff",
+  textOpacity: "100%",
+  textShadow: "none",
+  textBg: "#000000",
+  textBgOpacity: "100%",
+  displayBg: "#000000",
+  displayBgOpacity: "0%"
+};
+const FONT_SIGNALS = Object.keys(FONT_DEFAULTS).reduce(
+  (prev, type) => ({
+    ...prev,
+    [type]: signal(FONT_DEFAULTS[type])
+  }),
+  {}
+);
+if (!IS_SERVER) {
+  for (const type of Object.keys(FONT_SIGNALS)) {
+    const value = localStorage.getItem(`vds-player:${camelToKebabCase(type)}`);
+    if (isString(value)) FONT_SIGNALS[type].set(value);
+  }
+}
+function onFontReset() {
+  for (const type of Object.keys(FONT_SIGNALS)) {
+    const defaultValue = FONT_DEFAULTS[type];
+    FONT_SIGNALS[type].set(defaultValue);
+  }
+}
+
+function hexToRgb(hex) {
+  const { style } = new Option();
+  style.color = hex;
+  return style.color.match(/\((.*?)\)/)[1].replace(/,/g, " ");
+}
+
+let isWatchingVars = false, players = /* @__PURE__ */ new Set();
+function updateFontCssVars() {
+  if (IS_SERVER) return;
+  const { player } = useMediaContext$1();
+  players.add(player);
+  onDispose(() => players.delete(player));
+  if (!isWatchingVars) {
+    scoped(() => {
+      for (const type of keysOf(FONT_SIGNALS)) {
+        const $value = FONT_SIGNALS[type], defaultValue = FONT_DEFAULTS[type], varName = `--media-user-${camelToKebabCase(type)}`, storageKey = `vds-player:${camelToKebabCase(type)}`;
+        effect(() => {
+          const value = $value(), isDefaultVarValue = value === defaultValue, varValue = !isDefaultVarValue ? getCssVarValue(player, type, value) : null;
+          for (const player2 of players) {
+            player2.el?.style.setProperty(varName, varValue);
+          }
+          if (isDefaultVarValue) {
+            localStorage.removeItem(storageKey);
+          } else {
+            localStorage.setItem(storageKey, value);
+          }
+        });
+      }
+    }, null);
+    isWatchingVars = true;
+  }
+}
+function getCssVarValue(player, type, value) {
+  switch (type) {
+    case "fontFamily":
+      const fontVariant = value === "capitals" ? "small-caps" : "";
+      player.el?.style.setProperty("--media-user-font-variant", fontVariant);
+      return getFontFamilyCSSVarValue(value);
+    case "fontSize":
+    case "textOpacity":
+    case "textBgOpacity":
+    case "displayBgOpacity":
+      return percentToRatio(value);
+    case "textColor":
+      return `rgb(${hexToRgb(value)} / var(--media-user-text-opacity, 1))`;
+    case "textShadow":
+      return getTextShadowCssVarValue(value);
+    case "textBg":
+      return `rgb(${hexToRgb(value)} / var(--media-user-text-bg-opacity, 1))`;
+    case "displayBg":
+      return `rgb(${hexToRgb(value)} / var(--media-user-display-bg-opacity, 1))`;
+  }
+}
+function percentToRatio(value) {
+  return (parseInt(value) / 100).toString();
+}
+function getFontFamilyCSSVarValue(value) {
+  switch (value) {
+    case "mono-serif":
+      return '"Courier New", Courier, "Nimbus Mono L", "Cutive Mono", monospace';
+    case "mono-sans":
+      return '"Deja Vu Sans Mono", "Lucida Console", Monaco, Consolas, "PT Mono", monospace';
+    case "pro-sans":
+      return 'Roboto, "Arial Unicode Ms", Arial, Helvetica, Verdana, "PT Sans Caption", sans-serif';
+    case "casual":
+      return '"Comic Sans MS", Impact, Handlee, fantasy';
+    case "cursive":
+      return '"Monotype Corsiva", "URW Chancery L", "Apple Chancery", "Dancing Script", cursive';
+    case "capitals":
+      return '"Arial Unicode Ms", Arial, Helvetica, Verdana, "Marcellus SC", sans-serif + font-variant=small-caps';
+    default:
+      return '"Times New Roman", Times, Georgia, Cambria, "PT Serif Caption", serif';
+  }
+}
+function getTextShadowCssVarValue(value) {
+  switch (value) {
+    case "drop shadow":
+      return "rgb(34, 34, 34) 1.86389px 1.86389px 2.79583px, rgb(34, 34, 34) 1.86389px 1.86389px 3.72778px, rgb(34, 34, 34) 1.86389px 1.86389px 4.65972px";
+    case "raised":
+      return "rgb(34, 34, 34) 1px 1px, rgb(34, 34, 34) 2px 2px";
+    case "depressed":
+      return "rgb(204, 204, 204) 1px 1px, rgb(34, 34, 34) -1px -1px";
+    case "outline":
+      return "rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px";
+    default:
+      return "";
+  }
+}
+
+function DefaultMenuSection({ label, value, children }) {
+  const id = React.useId();
+  if (!label) {
+    return /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section" }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-body" }, children));
+  }
+  return /* @__PURE__ */ React.createElement("section", { className: "vds-menu-section", role: "group", "aria-labelledby": id }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-title" }, /* @__PURE__ */ React.createElement("header", { id }, label), value ? /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-value" }, value) : null), /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-body" }, children));
+}
+DefaultMenuSection.displayName = "DefaultMenuSection";
+function DefaultMenuButton({ label, hint = "", Icon, disabled = false }) {
+  const { icons: Icons } = React.useContext(DefaultLayoutContext);
+  return /* @__PURE__ */ React.createElement(Button, { className: "vds-menu-item", disabled }, /* @__PURE__ */ React.createElement(Icons.Menu.ArrowLeft, { className: "vds-menu-close-icon vds-icon" }), Icon ? /* @__PURE__ */ React.createElement(Icon, { className: "vds-menu-item-icon vds-icon" }) : null, /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-label" }, label), /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-hint" }, hint), /* @__PURE__ */ React.createElement(Icons.Menu.ArrowRight, { className: "vds-menu-open-icon vds-icon" }));
+}
+DefaultMenuButton.displayName = "DefaultMenuButton";
+function DefaultMenuItem({ label, children }) {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-menu-item" }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-item-label" }, label), children);
+}
+DefaultMenuItem.displayName = "DefaultMenuItem";
+function DefaultMenuRadioGroup({ value, options, onChange }) {
+  const { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$1, { className: "vds-radio-group", value, onChange }, options.map((option) => /* @__PURE__ */ React.createElement(Item, { className: "vds-radio", value: option.value, key: option.value }, /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }), /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label", "data-part": "label" }, option.label))));
+}
+DefaultMenuRadioGroup.displayName = "DefaultMenuRadioGroup";
+function createRadioOptions(entries) {
+  return React.useMemo(
+    () => isArray(entries) ? entries.map((entry) => ({ label: entry, value: entry.toLowerCase() })) : Object.keys(entries).map((label) => ({ label, value: entries[label] })),
+    [entries]
+  );
+}
+
+function DefaultMenuSliderItem({
+  label,
+  value,
+  UpIcon,
+  DownIcon,
+  children,
+  isMin,
+  isMax
+}) {
+  const hasTitle = label || value, Content = /* @__PURE__ */ React.createElement(React.Fragment, null, DownIcon ? /* @__PURE__ */ React.createElement(DownIcon, { className: "vds-icon down" }) : null, children, UpIcon ? /* @__PURE__ */ React.createElement(UpIcon, { className: "vds-icon up" }) : null);
+  return /* @__PURE__ */ React.createElement(
+    "div",
+    {
+      className: `vds-menu-item vds-menu-slider-item${hasTitle ? " group" : ""}`,
+      "data-min": isMin ? "" : null,
+      "data-max": isMax ? "" : null
+    },
+    hasTitle ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-slider-title" }, label ? /* @__PURE__ */ React.createElement("div", null, label) : null, value ? /* @__PURE__ */ React.createElement("div", null, value) : null), /* @__PURE__ */ React.createElement("div", { className: "vds-menu-slider-body" }, Content)) : Content
+  );
+}
+DefaultMenuSliderItem.displayName = "DefaultMenuSliderItem";
+function DefaultSliderParts() {
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }));
+}
+DefaultSliderParts.displayName = "DefaultSliderParts";
+function DefaultSliderSteps() {
+  return /* @__PURE__ */ React.createElement(Steps, { className: "vds-slider-steps" }, (step) => /* @__PURE__ */ React.createElement("div", { className: "vds-slider-step", key: String(step) }));
+}
+DefaultSliderSteps.displayName = "DefaultSliderSteps";
+
+function DefaultFontMenu() {
+  const label = useDefaultLayoutWord("Caption Styles"), $hasCaptions = useMediaState("hasCaptions"), fontSectionLabel = useDefaultLayoutWord("Font"), textSectionLabel = useDefaultLayoutWord("Text"), textBgSectionLabel = useDefaultLayoutWord("Text Background"), displayBgSectionLabel = useDefaultLayoutWord("Display Background");
+  if (!$hasCaptions) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-font-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label }), /* @__PURE__ */ React.createElement(Items, { className: "vds-font-style-items vds-menu-items" }, /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: fontSectionLabel }, /* @__PURE__ */ React.createElement(DefaultFontFamilyMenu, null), /* @__PURE__ */ React.createElement(DefaultFontSizeSlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: textSectionLabel }, /* @__PURE__ */ React.createElement(DefaultTextColorInput, null), /* @__PURE__ */ React.createElement(DefaultTextShadowMenu, null), /* @__PURE__ */ React.createElement(DefaultTextOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: textBgSectionLabel }, /* @__PURE__ */ React.createElement(DefaultTextBgInput, null), /* @__PURE__ */ React.createElement(DefaultTextBgOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: displayBgSectionLabel }, /* @__PURE__ */ React.createElement(DefaultDisplayBgInput, null), /* @__PURE__ */ React.createElement(DefaultDisplayBgOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultResetMenuItem, null))));
+}
+DefaultFontMenu.displayName = "DefaultFontMenu";
+function DefaultFontFamilyMenu() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Family", type: "fontFamily", option: FONT_FAMILY_OPTION });
+}
+DefaultFontFamilyMenu.displayName = "DefaultFontFamilyMenu";
+function DefaultFontSizeSlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_SIZE_OPTION,
+    upIcon: Icons.Menu.FontSizeUp,
+    downIcon: Icons.Menu.FontSizeDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Size", type: "fontSize", option });
+}
+DefaultFontSizeSlider.displayName = "DefaultFontSizeSlider";
+function DefaultTextColorInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "textColor", option: FONT_COLOR_OPTION });
+}
+DefaultTextColorInput.displayName = "DefaultTextColorInput";
+function DefaultTextOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "textOpacity", option });
+}
+DefaultTextOpacitySlider.displayName = "DefaultTextOpacitySlider";
+function DefaultTextShadowMenu() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Shadow", type: "textShadow", option: FONT_TEXT_SHADOW_OPTION });
+}
+DefaultTextShadowMenu.displayName = "DefaultTextShadowMenu";
+function DefaultTextBgInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "textBg", option: FONT_COLOR_OPTION });
+}
+DefaultTextBgInput.displayName = "DefaultTextBgInput";
+function DefaultTextBgOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "textBgOpacity", option });
+}
+DefaultTextBgOpacitySlider.displayName = "DefaultTextBgOpacitySlider";
+function DefaultDisplayBgInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "displayBg", option: FONT_COLOR_OPTION });
+}
+DefaultDisplayBgInput.displayName = "DefaultDisplayBgInput";
+function DefaultDisplayBgOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "displayBgOpacity", option });
+}
+DefaultDisplayBgOpacitySlider.displayName = "DefaultDisplayBgOpacitySlider";
+function DefaultFontSetting({ label, option, type }) {
+  const player = useMediaPlayer(), $currentValue = FONT_SIGNALS[type], $value = useSignal($currentValue), translatedLabel = useDefaultLayoutWord(label);
+  const notify = React.useCallback(() => {
+    player?.dispatchEvent(new Event("vds-font-change"));
+  }, [player]);
+  const onChange = React.useCallback(
+    (newValue) => {
+      $currentValue.set(newValue);
+      notify();
+    },
+    [$currentValue, notify]
+  );
+  if (option.type === "color") {
+    let onColorChange2 = function(event) {
+      onChange(event.target.value);
+    };
+    return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label: translatedLabel }, /* @__PURE__ */ React.createElement("input", { className: "vds-color-picker", type: "color", value: $value, onChange: onColorChange2 }));
+  }
+  if (option.type === "slider") {
+    let onSliderValueChange2 = function(value) {
+      onChange(value + "%");
+    };
+    const { min, max, step, upIcon, downIcon } = option;
+    return /* @__PURE__ */ React.createElement(
+      DefaultMenuSliderItem,
+      {
+        label: translatedLabel,
+        value: $value,
+        UpIcon: upIcon,
+        DownIcon: downIcon,
+        isMin: $value === min + "%",
+        isMax: $value === max + "%"
+      },
+      /* @__PURE__ */ React.createElement(
+        Root$4,
+        {
+          className: "vds-slider",
+          min,
+          max,
+          step,
+          keyStep: step,
+          value: parseInt($value),
+          "aria-label": translatedLabel,
+          onValueChange: onSliderValueChange2,
+          onDragValueChange: onSliderValueChange2
+        },
+        /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+        /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+      )
+    );
+  }
+  if (option.type === "radio") {
+    return /* @__PURE__ */ React.createElement(
+      DefaultFontRadioGroup,
+      {
+        id: camelToKebabCase(type),
+        label: translatedLabel,
+        value: $value,
+        values: option.values,
+        onChange
+      }
+    );
+  }
+  return null;
+}
+DefaultFontSetting.displayName = "DefaultFontSetting";
+function DefaultFontRadioGroup({ id, label, value, values, onChange }) {
+  const radioOptions = createRadioOptions(values), { translations } = useDefaultLayoutContext(), hint = React.useMemo(() => {
+    const label2 = radioOptions.find((radio) => radio.value === value)?.label || "";
+    return i18n(translations, label2);
+  }, [value, radioOptions]);
+  return /* @__PURE__ */ React.createElement(Root$3, { className: `vds-${id}-menu vds-menu` }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, hint }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, /* @__PURE__ */ React.createElement(DefaultMenuRadioGroup, { value, options: radioOptions, onChange })));
+}
+DefaultFontRadioGroup.displayName = "DefaultFontRadioGroup";
+function DefaultResetMenuItem() {
+  const resetText = useDefaultLayoutWord("Reset");
+  return /* @__PURE__ */ React.createElement("button", { className: "vds-menu-item", role: "menuitem", onClick: onFontReset }, /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-label" }, resetText));
+}
+DefaultResetMenuItem.displayName = "DefaultResetMenuItem";
+
+function DefaultMenuCheckbox({
+  label,
+  checked,
+  storageKey,
+  defaultChecked = false,
+  onChange
+}) {
+  const [isChecked, setIsChecked] = React.useState(defaultChecked), [isActive, setIsActive] = React.useState(false);
+  React.useEffect(() => {
+    const savedValue = storageKey ? localStorage.getItem(storageKey) : null, checked2 = !!(savedValue ?? defaultChecked);
+    setIsChecked(checked2);
+    onChange?.(checked2);
+  }, []);
+  React.useEffect(() => {
+    if (isBoolean(checked)) setIsChecked(checked);
+  }, [checked]);
+  function onPress(event) {
+    if (event && "button" in event && event?.button === 1) return;
+    const toggledCheck = !isChecked;
+    setIsChecked(toggledCheck);
+    if (storageKey) localStorage.setItem(storageKey, toggledCheck ? "1" : "");
+    onChange?.(toggledCheck, event?.nativeEvent);
+    setIsActive(false);
+  }
+  function onActive(event) {
+    if (event.button !== 0) return;
+    setIsActive(true);
+  }
+  function onKeyDown(event) {
+    if (isKeyboardClick(event.nativeEvent)) onPress();
+  }
+  return /* @__PURE__ */ React.createElement(
+    "div",
+    {
+      className: "vds-menu-checkbox",
+      role: "menuitemcheckbox",
+      tabIndex: 0,
+      "aria-label": label,
+      "aria-checked": isChecked ? "true" : "false",
+      "data-active": isActive ? "" : null,
+      onPointerUp: onPress,
+      onPointerDown: onActive,
+      onKeyDown
+    }
+  );
+}
+DefaultMenuCheckbox.displayName = "DefaultMenuCheckbox";
+
+function DefaultAccessibilityMenu({ slots }) {
+  const label = useDefaultLayoutWord("Accessibility"), { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-accessibility-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Accessibility }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "accessibilityMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultAnnouncementsMenuCheckbox, null), /* @__PURE__ */ React.createElement(DefaultKeyboardAnimationsMenuCheckbox, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultFontMenu, null)), slot(slots, "accessibilityMenuItemsEnd", null)));
+}
+DefaultAccessibilityMenu.displayName = "DefaultAccessibilityMenu";
+function DefaultAnnouncementsMenuCheckbox() {
+  const { userPrefersAnnouncements } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Announcements");
+  function onChange(checked) {
+    userPrefersAnnouncements.set(checked);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      defaultChecked: true,
+      storageKey: "vds-player::announcements",
+      onChange
+    }
+  ));
+}
+DefaultAnnouncementsMenuCheckbox.displayName = "DefaultAnnouncementsMenuCheckbox";
+function DefaultKeyboardAnimationsMenuCheckbox() {
+  const $viewType = useMediaState("viewType"), { userPrefersKeyboardAnimations, noKeyboardAnimations } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Keyboard Animations");
+  if ($viewType !== "video" || noKeyboardAnimations) return null;
+  function onChange(checked) {
+    userPrefersKeyboardAnimations.set(checked);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      defaultChecked: true,
+      storageKey: "vds-player::keyboard-animations",
+      onChange
+    }
+  ));
+}
+DefaultKeyboardAnimationsMenuCheckbox.displayName = "DefaultKeyboardAnimationsMenuCheckbox";
+
+function DefaultAudioMenu({ slots }) {
+  const label = useDefaultLayoutWord("Audio"), $canSetAudioGain = useMediaState("canSetAudioGain"), $audioTracks = useMediaState("audioTracks"), { noAudioGain, icons: Icons } = useDefaultLayoutContext(), hasGainSlider = $canSetAudioGain && !noAudioGain, $disabled = !hasGainSlider && $audioTracks.length <= 1;
+  if ($disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-audio-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Audio }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "audioMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultAudioTracksMenu, null), hasGainSlider ? /* @__PURE__ */ React.createElement(DefaultAudioBoostMenuSection, null) : null, slot(slots, "audioMenuItemsEnd", null)));
+}
+DefaultAudioMenu.displayName = "DefaultAudioMenu";
+function DefaultAudioBoostMenuSection() {
+  const $audioGain = useMediaState("audioGain"), label = useDefaultLayoutWord("Boost"), value = Math.round((($audioGain ?? 1) - 1) * 100) + "%", $canSetAudioGain = useMediaState("canSetAudioGain"), { noAudioGain, icons: Icons } = useDefaultLayoutContext(), $disabled = !$canSetAudioGain || noAudioGain, min = useGainMin(), max = useGainMax();
+  if ($disabled) return null;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.AudioBoostUp,
+      DownIcon: Icons.Menu.AudioBoostDown,
+      isMin: (($audioGain ?? 1) - 1) * 100 <= min,
+      isMax: (($audioGain ?? 1) - 1) * 100 === max
+    },
+    /* @__PURE__ */ React.createElement(DefaultAudioGainSlider, null)
+  ));
+}
+DefaultAudioBoostMenuSection.displayName = "DefaultAudioBoostMenuSection";
+function useGainMin() {
+  const { audioGains } = useDefaultLayoutContext(), min = isArray(audioGains) ? audioGains[0] : audioGains?.min;
+  return min ?? 0;
+}
+function useGainMax() {
+  const { audioGains } = useDefaultLayoutContext(), max = isArray(audioGains) ? audioGains[audioGains.length - 1] : audioGains?.max;
+  return max ?? 300;
+}
+function useGainStep() {
+  const { audioGains } = useDefaultLayoutContext(), step = isArray(audioGains) ? audioGains[1] - audioGains[0] : audioGains?.step;
+  return step || 25;
+}
+function DefaultAudioGainSlider() {
+  const label = useDefaultLayoutWord("Audio Boost"), min = useGainMin(), max = useGainMax(), step = useGainStep();
+  return /* @__PURE__ */ React.createElement(
+    Root$5,
+    {
+      className: "vds-audio-gain-slider vds-slider",
+      "aria-label": label,
+      min,
+      max,
+      step,
+      keyStep: step
+    },
+    /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+    /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+  );
+}
+DefaultAudioGainSlider.displayName = "DefaultAudioGainSlider";
+function DefaultAudioTracksMenu() {
+  const { icons: Icons } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Track"), defaultText = useDefaultLayoutWord("Default"), $track = useMediaState("audioTrack"), options = useAudioOptions();
+  if (options.disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-audio-track-menu vds-menu" }, /* @__PURE__ */ React.createElement(
+    DefaultMenuButton,
+    {
+      label,
+      hint: $track?.label ?? defaultText,
+      disabled: options.disabled,
+      Icon: Icons.Menu.Audio
+    }
+  ), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, /* @__PURE__ */ React.createElement(
+    Root$1,
+    {
+      className: "vds-audio-radio-group vds-radio-group",
+      value: options.selectedValue
+    },
+    options.map(({ label: label2, value, select }) => /* @__PURE__ */ React.createElement(
+      Item,
+      {
+        className: "vds-audio-radio vds-radio",
+        value,
+        onSelect: select,
+        key: value
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }),
+      /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label" }, label2)
+    ))
+  )));
+}
+DefaultAudioTracksMenu.displayName = "DefaultAudioTracksMenu";
+
+function DefaultCaptionMenu({ slots }) {
+  const { icons: Icons } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Captions"), offText = useDefaultLayoutWord("Off"), options = useCaptionOptions({ off: offText }), hint = options.selectedTrack?.label ?? offText;
+  if (options.disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-captions-menu vds-menu" }, /* @__PURE__ */ React.createElement(
+    DefaultMenuButton,
+    {
+      label,
+      hint,
+      disabled: options.disabled,
+      Icon: Icons.Menu.Captions
+    }
+  ), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "captionsMenuItemsStart", null), /* @__PURE__ */ React.createElement(
+    Root$1,
+    {
+      className: "vds-captions-radio-group vds-radio-group",
+      value: options.selectedValue
+    },
+    options.map(({ label: label2, value, select }) => /* @__PURE__ */ React.createElement(
+      Item,
+      {
+        className: "vds-caption-radio vds-radio",
+        value,
+        onSelect: select,
+        key: value
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }),
+      /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label" }, label2)
+    ))
+  ), slot(slots, "captionsMenuItemsEnd", null)));
+}
+DefaultCaptionMenu.displayName = "DefaultCaptionMenu";
+
+function DefaultPlaybackMenu({ slots }) {
+  const label = useDefaultLayoutWord("Playback"), { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-playback-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Playback }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "playbackMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, slot(slots, "playbackMenuLoop", /* @__PURE__ */ React.createElement(DefaultLoopMenuCheckbox, null))), /* @__PURE__ */ React.createElement(DefaultSpeedMenuSection, null), /* @__PURE__ */ React.createElement(DefaultQualityMenuSection, null), slot(slots, "playbackMenuItemsEnd", null)));
+}
+DefaultPlaybackMenu.displayName = "DefaultPlaybackMenu";
+function DefaultLoopMenuCheckbox() {
+  const { remote } = useMediaContext(), label = useDefaultLayoutWord("Loop");
+  function onChange(checked, trigger) {
+    remote.userPrefersLoopChange(checked, trigger);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(DefaultMenuCheckbox, { label, storageKey: "vds-player::user-loop", onChange }));
+}
+DefaultLoopMenuCheckbox.displayName = "DefaultLoopMenuCheckbox";
+function DefaultAutoQualityMenuCheckbox() {
+  const { remote, qualities } = useMediaContext(), $autoQuality = useMediaState("autoQuality"), label = useDefaultLayoutWord("Auto");
+  function onChange(checked, trigger) {
+    if (checked) {
+      remote.requestAutoQuality(trigger);
+    } else {
+      remote.changeQuality(qualities.selectedIndex, trigger);
+    }
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      checked: $autoQuality,
+      onChange,
+      defaultChecked: $autoQuality
+    }
+  ));
+}
+DefaultAutoQualityMenuCheckbox.displayName = "DefaultAutoQualityMenuCheckbox";
+function DefaultQualityMenuSection() {
+  const { hideQualityBitrate, icons: Icons } = useDefaultLayoutContext(), $canSetQuality = useMediaState("canSetQuality"), $qualities = useMediaState("qualities"), $quality = useMediaState("quality"), label = useDefaultLayoutWord("Quality"), autoText = useDefaultLayoutWord("Auto"), sortedQualities = React.useMemo(() => sortVideoQualities($qualities), [$qualities]);
+  if (!$canSetQuality || $qualities.length <= 1) return null;
+  const height = $quality?.height, bitrate = !hideQualityBitrate ? $quality?.bitrate : null, bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null, value = height ? `${height}p${bitrateText ? ` (${bitrateText})` : ""}` : autoText, isMin = sortedQualities[0] === $quality, isMax = sortedQualities.at(-1) === $quality;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.QualityUp,
+      DownIcon: Icons.Menu.QualityDown,
+      isMin,
+      isMax
+    },
+    /* @__PURE__ */ React.createElement(DefaultQualitySlider, null)
+  ), /* @__PURE__ */ React.createElement(DefaultAutoQualityMenuCheckbox, null));
+}
+DefaultQualityMenuSection.displayName = "DefaultQualityMenuSection";
+function DefaultQualitySlider() {
+  const label = useDefaultLayoutWord("Quality");
+  return /* @__PURE__ */ React.createElement(Root$6, { className: "vds-quality-slider vds-slider", "aria-label": label }, /* @__PURE__ */ React.createElement(DefaultSliderParts, null), /* @__PURE__ */ React.createElement(DefaultSliderSteps, null));
+}
+DefaultQualitySlider.displayName = "DefaultQualitySlider";
+function DefaultSpeedMenuSection() {
+  const { icons: Icons } = useDefaultLayoutContext(), $playbackRate = useMediaState("playbackRate"), $canSetPlaybackRate = useMediaState("canSetPlaybackRate"), label = useDefaultLayoutWord("Speed"), normalText = useDefaultLayoutWord("Normal"), min = useSpeedMin(), max = useSpeedMax(), value = $playbackRate === 1 ? normalText : $playbackRate + "x";
+  if (!$canSetPlaybackRate) return null;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.SpeedUp,
+      DownIcon: Icons.Menu.SpeedDown,
+      isMin: $playbackRate === min,
+      isMax: $playbackRate === max
+    },
+    /* @__PURE__ */ React.createElement(DefaultSpeedSlider, null)
+  ));
+}
+function useSpeedMin() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[0] : rates?.min) ?? 0;
+}
+function useSpeedMax() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[rates.length - 1] : rates?.max) ?? 2;
+}
+function useSpeedStep() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[1] - rates[0] : rates?.step) || 0.25;
+}
+function DefaultSpeedSlider() {
+  const label = useDefaultLayoutWord("Speed"), min = useSpeedMin(), max = useSpeedMax(), step = useSpeedStep();
+  return /* @__PURE__ */ React.createElement(
+    Root$7,
+    {
+      className: "vds-speed-slider vds-slider",
+      "aria-label": label,
+      min,
+      max,
+      step,
+      keyStep: step
+    },
+    /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+    /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+  );
+}
+DefaultSpeedSlider.displayName = "DefaultSpeedSlider";
+
+function DefaultSettingsMenu({
+  tooltip,
+  placement,
+  portalClass = "",
+  slots
+}) {
+  const {
+    showMenuDelay,
+    icons: Icons,
+    isSmallLayout,
+    menuContainer,
+    menuGroup,
+    noModal,
+    colorScheme
+  } = useDefaultLayoutContext(), settingsText = useDefaultLayoutWord("Settings"), $viewType = useMediaState("viewType"), $offset = !isSmallLayout && menuGroup === "bottom" && $viewType === "video" ? 26 : 0, colorSchemeClass = useColorSchemeClass(colorScheme), [isOpen, setIsOpen] = React.useState(false), dialogEl = useParentDialogEl();
+  useScoped(updateFontCssVars);
+  function onOpen() {
+    flushSync(() => {
+      setIsOpen(true);
+    });
+  }
+  function onClose() {
+    setIsOpen(false);
+  }
+  const Content = /* @__PURE__ */ React.createElement(
+    Items,
+    {
+      className: "vds-settings-menu-items vds-menu-items",
+      placement,
+      offset: $offset
+    },
+    isOpen ? /* @__PURE__ */ React.createElement(React.Fragment, null, slot(slots, "settingsMenuItemsStart", null), slot(slots, "settingsMenuStartItems", null), /* @__PURE__ */ React.createElement(DefaultPlaybackMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultAccessibilityMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultAudioMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultCaptionMenu, { slots }), slot(slots, "settingsMenuEndItems", null), slot(slots, "settingsMenuItemsEnd", null)) : null
+  );
+  return /* @__PURE__ */ React.createElement(
+    Root$3,
+    {
+      className: "vds-settings-menu vds-menu",
+      showDelay: showMenuDelay,
+      onOpen,
+      onClose
+    },
+    /* @__PURE__ */ React.createElement(DefaultTooltip, { content: settingsText, placement: tooltip }, /* @__PURE__ */ React.createElement(Button, { className: "vds-menu-button vds-button", "aria-label": settingsText }, /* @__PURE__ */ React.createElement(Icons.Menu.Settings, { className: "vds-icon vds-rotate-icon" }))),
+    noModal || !isSmallLayout ? Content : /* @__PURE__ */ React.createElement(
+      Portal,
+      {
+        className: portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : ""),
+        container: menuContainer ?? dialogEl,
+        disabled: "fullscreen",
+        "data-sm": isSmallLayout ? "" : null,
+        "data-lg": !isSmallLayout ? "" : null,
+        "data-size": isSmallLayout ? "sm" : "lg",
+        "data-view-type": $viewType
+      },
+      Content
+    )
+  );
+}
+DefaultSettingsMenu.displayName = "DefaultSettingsMenu";
+
+function DefaultVolumePopup({ tooltip, orientation, slots }) {
+  const $pointer = useMediaState("pointer"), $muted = useMediaState("muted"), $canSetVolume = useMediaState("canSetVolume"), [rootEl, setRootEl] = React.useState(null), isRootActive = useActive(rootEl), muteButton = slot(slots, "muteButton", /* @__PURE__ */ React.createElement(DefaultMuteButton, { tooltip }));
+  if (!$canSetVolume) {
+    return muteButton;
+  }
+  return $pointer === "coarse" && !$muted ? null : /* @__PURE__ */ React.createElement("div", { className: "vds-volume", "data-active": isRootActive ? "" : null, ref: setRootEl }, muteButton, /* @__PURE__ */ React.createElement("div", { className: "vds-volume-popup" }, slot(slots, "volumeSlider", /* @__PURE__ */ React.createElement(DefaultVolumeSlider, { orientation }))));
+}
+DefaultVolumePopup.displayName = "DefaultVolumePopup";
+function DefaultVolumeSlider(props) {
+  const label = useDefaultLayoutWord("Volume");
+  return /* @__PURE__ */ React.createElement(Root$8, { className: "vds-volume-slider vds-slider", "aria-label": label, ...props }, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }), /* @__PURE__ */ React.createElement(Preview, { className: "vds-slider-preview", noClamp: true }, /* @__PURE__ */ React.createElement(Value, { className: "vds-slider-value" })));
+}
+DefaultVolumeSlider.displayName = "DefaultVolumeSlider";
+function DefaultTimeSlider() {
+  const [instance, setInstance] = React.useState(null), [width, setWidth] = React.useState(0), $src = useMediaState("currentSrc"), { thumbnails, sliderChaptersMinWidth, disableTimeSlider, seekStep, noScrubGesture } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Seek"), $RemotionSliderThumbnail = useSignal(RemotionSliderThumbnail);
+  const onResize = React.useCallback(() => {
+    const el = instance?.el;
+    el && setWidth(el.clientWidth);
+  }, [instance]);
+  useResizeObserver(instance?.el, onResize);
+  return /* @__PURE__ */ React.createElement(
+    Root$9,
+    {
+      className: "vds-time-slider vds-slider",
+      "aria-label": label,
+      disabled: disableTimeSlider,
+      noSwipeGesture: noScrubGesture,
+      keyStep: seekStep,
+      ref: setInstance
+    },
+    /* @__PURE__ */ React.createElement(
+      Chapters,
+      {
+        className: "vds-slider-chapters",
+        disabled: width < sliderChaptersMinWidth
+      },
+      (cues, forwardRef) => cues.map((cue) => /* @__PURE__ */ React.createElement("div", { className: "vds-slider-chapter", key: cue.startTime, ref: forwardRef }, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Progress, { className: "vds-slider-progress vds-slider-track" })))
+    ),
+    /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }),
+    /* @__PURE__ */ React.createElement(Preview, { className: "vds-slider-preview" }, thumbnails ? /* @__PURE__ */ React.createElement(
+      Thumbnail.Root,
+      {
+        src: thumbnails,
+        className: "vds-slider-thumbnail vds-thumbnail"
+      },
+      /* @__PURE__ */ React.createElement(Thumbnail.Img, null)
+    ) : $RemotionSliderThumbnail && isRemotionSrc($src) ? /* @__PURE__ */ React.createElement($RemotionSliderThumbnail, { className: "vds-slider-thumbnail vds-thumbnail" }) : null, /* @__PURE__ */ React.createElement(ChapterTitle, { className: "vds-slider-chapter-title" }), /* @__PURE__ */ React.createElement(Value, { className: "vds-slider-value" }))
+  );
+}
+DefaultTimeSlider.displayName = "DefaultTimeSlider";
+
+function DefaultTimeGroup({ slots }) {
+  const $duration = useMediaState("duration");
+  if (!$duration) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-time-group" }, slot(slots, "currentTime", /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "current" })), slot(slots, "timeSeparator", /* @__PURE__ */ React.createElement("div", { className: "vds-time-divider" }, "/")), slot(slots, "endTime", /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "duration" })));
+}
+DefaultTimeGroup.displayName = "DefaultTimeGroup";
+function DefaultTimeInfo({ slots }) {
+  const $live = useMediaState("live");
+  return $live ? slot(slots, "liveButton", /* @__PURE__ */ React.createElement(DefaultLiveButton, null)) : /* @__PURE__ */ React.createElement(DefaultTimeGroup, { slots });
+}
+DefaultTimeInfo.displayName = "DefaultTimeInfo";
+function DefaultTimeInvert({ slots }) {
+  const $live = useMediaState("live"), $duration = useMediaState("duration");
+  return $live ? slot(slots, "liveButton", /* @__PURE__ */ React.createElement(DefaultLiveButton, null)) : slot(
+    slots,
+    "endTime",
+    $duration ? /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "current", toggle: true, remainder: true }) : null
+  );
+}
+DefaultTimeInvert.displayName = "DefaultTimeInvert";
+
+const MediaLayout$1 = createDefaultMediaLayout({
+  type: "audio",
+  smLayoutWhen({ width }) {
+    return width < 576;
+  },
+  renderLayout: () => /* @__PURE__ */ React.createElement(AudioLayout, null)
+});
+function DefaultAudioLayout(props) {
+  const [scrubbing, setScrubbing] = React.useState(false), $pointer = useMediaState("pointer");
+  const onStartScrubbing = React.useCallback((event) => {
+    const { target } = event, hasTimeSlider = !!(target instanceof HTMLElement && target.closest(".vds-time-slider"));
+    if (!hasTimeSlider) return;
+    event.nativeEvent.stopImmediatePropagation();
+    setScrubbing(true);
+  }, []);
+  const onStopScrubbing = React.useCallback(() => {
+    setScrubbing(false);
+  }, []);
+  React.useEffect(() => {
+    if (scrubbing) return listenEvent(window, "pointerdown", onStopScrubbing);
+  }, [scrubbing, onStopScrubbing]);
+  return /* @__PURE__ */ React.createElement(
+    MediaLayout$1,
+    {
+      ...props,
+      "data-scrubbing": scrubbing ? "" : null,
+      onPointerDown: scrubbing ? (e) => e.stopPropagation() : void 0,
+      onPointerDownCapture: $pointer === "coarse" && !scrubbing ? onStartScrubbing : void 0
+    }
+  );
+}
+DefaultAudioLayout.displayName = "DefaultAudioLayout";
+function AudioLayout() {
+  const slots = useDefaultAudioLayoutSlots();
+  useLayoutName("audio");
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultCaptions, null), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "seekBackwardButton", /* @__PURE__ */ React.createElement(DefaultSeekButton, { backward: true, tooltip: "top start" })), slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top center" })), slot(slots, "seekForwardButton", /* @__PURE__ */ React.createElement(DefaultSeekButton, { tooltip: "top center" })), /* @__PURE__ */ React.createElement(DefaultAudioTitle, null), slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null)), /* @__PURE__ */ React.createElement(DefaultTimeInvert, { slots }), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "vertical", tooltip: "top", slots }), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "top center" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), /* @__PURE__ */ React.createElement(DefaultAudioMenus, { slots }))));
+}
+AudioLayout.displayName = "AudioLayout";
+function DefaultAudioMenus({ slots }) {
+  const { isSmallLayout, noModal } = useDefaultLayoutContext(), placement = noModal ? "top end" : !isSmallLayout ? "top end" : null;
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slot(
+    slots,
+    "chaptersMenu",
+    /* @__PURE__ */ React.createElement(DefaultChaptersMenu, { tooltip: "top", placement, portalClass: "vds-audio-layout" })
+  ), slot(
+    slots,
+    "settingsMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultSettingsMenu,
+      {
+        tooltip: "top end",
+        placement,
+        portalClass: "vds-audio-layout",
+        slots
+      }
+    )
+  ));
+}
+DefaultAudioMenus.displayName = "DefaultAudioMenus";
+function DefaultAudioTitle() {
+  const [rootEl, setRootEl] = React.useState(null), media = useMediaContext(), { translations } = useDefaultLayoutContext(), [isTextOverflowing, setIsTextOverflowing] = React.useState(false);
+  const isContinued = createComputed(() => {
+    const { started, currentTime } = media.$state;
+    return started() || currentTime() > 0;
+  });
+  const $title = useSignal(
+    createComputed(() => {
+      const { title, ended } = media.$state;
+      if (!title()) return "";
+      const word = ended() ? "Replay" : isContinued() ? "Continue" : "Play";
+      return `${i18n(translations, word)}: ${title()}`;
+    })
+  );
+  const chapterTitle = useChapterTitle(), $isContinued = useSignal(isContinued), $chapterTitle = $isContinued ? chapterTitle : "", isTransitionActive = useTransitionActive(rootEl);
+  React.useEffect(() => {
+    if (isTransitionActive && document.activeElement === document.body) {
+      media.player.el?.focus({ preventScroll: true });
+    }
+  }, []);
+  const onResize = React.useCallback(() => {
+    const el = rootEl, isOverflowing = !!el && !isTransitionActive && el.clientWidth < el.children[0].clientWidth;
+    if (el) toggleClass(el, "vds-marquee", isOverflowing);
+    setIsTextOverflowing(isOverflowing);
+  }, [rootEl, isTransitionActive]);
+  useResizeObserver(rootEl, onResize);
+  return $title ? /* @__PURE__ */ React.createElement("span", { className: "vds-title", title: $title, ref: setRootEl }, /* @__PURE__ */ React.createElement(AudioTitle, { title: $title, chapterTitle: $chapterTitle }), isTextOverflowing && !isTransitionActive ? /* @__PURE__ */ React.createElement(AudioTitle, { title: $title, chapterTitle: $chapterTitle }) : null) : /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null);
+}
+DefaultAudioTitle.displayName = "DefaultAudioTitle";
+function AudioTitle({ title, chapterTitle }) {
+  const slots = useDefaultAudioLayoutSlots();
+  return /* @__PURE__ */ React.createElement("span", { className: "vds-title-text" }, slot(slots, "title", title), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-title" }, chapterTitle)));
+}
+AudioTitle.displayName = "AudioTitle";
+
+const DefaultKeyboardDisplay = React.forwardRef(
+  ({ icons: Icons, ...props }, forwardRef) => {
+    const [visible, setVisible] = React.useState(false), [Icon, setIcon] = React.useState(null), [count, setCount] = React.useState(0), $lastKeyboardAction = useMediaState("lastKeyboardAction");
+    React.useEffect(() => {
+      setCount((n) => n + 1);
+    }, [$lastKeyboardAction]);
+    const actionDataAttr = React.useMemo(() => {
+      const action = $lastKeyboardAction?.action;
+      return action && visible ? camelToKebabCase(action) : null;
+    }, [visible, $lastKeyboardAction]);
+    const className = React.useMemo(
+      () => `vds-kb-action${!visible ? " hidden" : ""}${props.className ? ` ${props.className}` : ""}`,
+      [visible]
+    );
+    const $$text = createComputed(getText), $text = useSignal($$text);
+    createEffect(() => {
+      const Icon2 = getIcon(Icons);
+      setIcon(() => Icon2);
+    }, [Icons]);
+    React.useEffect(() => {
+      setVisible(!!$lastKeyboardAction);
+      const id = setTimeout(() => setVisible(false), 500);
+      return () => {
+        setVisible(false);
+        window.clearTimeout(id);
+      };
+    }, [$lastKeyboardAction]);
+    return Icon ? /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props,
+        className,
+        "data-action": actionDataAttr,
+        ref: forwardRef
+      },
+      /* @__PURE__ */ React.createElement("div", { className: "vds-kb-text-wrapper" }, /* @__PURE__ */ React.createElement("div", { className: "vds-kb-text" }, $text)),
+      /* @__PURE__ */ React.createElement("div", { className: "vds-kb-bezel", key: count }, /* @__PURE__ */ React.createElement("div", { className: "vds-kb-icon" }, /* @__PURE__ */ React.createElement(Icon, null)))
+    ) : null;
+  }
+);
+DefaultKeyboardDisplay.displayName = "DefaultKeyboardDisplay";
+function getText() {
+  const { $state } = useContext(mediaContext), action = $state.lastKeyboardAction()?.action, audioGain = $state.audioGain() ?? 1;
+  switch (action) {
+    case "toggleMuted":
+      return $state.muted() ? "0%" : getVolumeText($state.volume(), audioGain);
+    case "volumeUp":
+    case "volumeDown":
+      return getVolumeText($state.volume(), audioGain);
+    default:
+      return "";
+  }
+}
+function getVolumeText(volume, gain) {
+  return `${Math.round(volume * gain * 100)}%`;
+}
+function getIcon(Icons) {
+  const { $state } = useContext(mediaContext), action = $state.lastKeyboardAction()?.action;
+  switch (action) {
+    case "togglePaused":
+      return !$state.paused() ? Icons.Play : Icons.Pause;
+    case "toggleMuted":
+      return $state.muted() || $state.volume() === 0 ? Icons.Mute : $state.volume() >= 0.5 ? Icons.VolumeUp : Icons.VolumeDown;
+    case "toggleFullscreen":
+      return $state.fullscreen() ? Icons.EnterFullscreen : Icons.ExitFullscreen;
+    case "togglePictureInPicture":
+      return $state.pictureInPicture() ? Icons.EnterPiP : Icons.ExitPiP;
+    case "toggleCaptions":
+      return $state.hasCaptions() ? $state.textTrack() ? Icons.CaptionsOn : Icons.CaptionsOff : null;
+    case "volumeUp":
+      return Icons.VolumeUp;
+    case "volumeDown":
+      return Icons.VolumeDown;
+    case "seekForward":
+      return Icons.SeekForward;
+    case "seekBackward":
+      return Icons.SeekBackward;
+    default:
+      return null;
+  }
+}
+
+function DefaultTitle() {
+  const $started = useMediaState("started"), $title = useMediaState("title"), $hasChapters = useActiveTextTrack("chapters");
+  return $hasChapters && ($started || !$title) ? /* @__PURE__ */ React.createElement(ChapterTitle$1, { className: "vds-chapter-title" }) : /* @__PURE__ */ React.createElement(Title, { className: "vds-chapter-title" });
+}
+DefaultTitle.displayName = "DefaultTitle";
+
+const MediaLayout = createDefaultMediaLayout({
+  type: "video",
+  smLayoutWhen({ width, height }) {
+    return width < 576 || height < 380;
+  },
+  renderLayout(props) {
+    return /* @__PURE__ */ React.createElement(VideoLayout, { ...props });
+  }
+});
+function DefaultVideoLayout(props) {
+  return /* @__PURE__ */ React.createElement(MediaLayout, { ...props });
+}
+DefaultVideoLayout.displayName = "DefaultVideoLayout";
+function VideoLayout({ streamType, isLoadLayout, isSmallLayout }) {
+  useLayoutName("video");
+  return isLoadLayout ? /* @__PURE__ */ React.createElement(DefaultVideoLoadLayout, null) : streamType === "unknown" ? /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null) : isSmallLayout ? /* @__PURE__ */ React.createElement(DefaultVideoSmallLayout, null) : /* @__PURE__ */ React.createElement(DefaultVideoLargeLayout, null);
+}
+VideoLayout.displayName = "VideoLayout";
+function DefaultVideoLargeLayout() {
+  const { menuGroup } = useDefaultLayoutContext(), baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.largeLayout };
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultVideoGestures, null), /* @__PURE__ */ React.createElement(DefaultVideoKeyboardDisplay, null), slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "captions", /* @__PURE__ */ React.createElement(DefaultCaptions, null)), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "topControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupEnd", null), menuGroup === "top" && /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "centerControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null))), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top start" })), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "horizontal", tooltip: "top", slots }), /* @__PURE__ */ React.createElement(DefaultTimeInfo, { slots }), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement(DefaultTitle, null)), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "top" })), menuGroup === "bottom" && /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots }), slot(slots, "airPlayButton", /* @__PURE__ */ React.createElement(DefaultAirPlayButton, { tooltip: "top" })), slot(slots, "googleCastButton", /* @__PURE__ */ React.createElement(DefaultGoogleCastButton, { tooltip: "top" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), slot(slots, "pipButton", /* @__PURE__ */ React.createElement(DefaultPIPButton, { tooltip: "top" })), slot(slots, "fullscreenButton", /* @__PURE__ */ React.createElement(DefaultFullscreenButton, { tooltip: "top end" })))));
+}
+DefaultVideoLargeLayout.displayName = "DefaultVideoLargeLayout";
+function DefaultVideoSmallLayout() {
+  const baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.smallLayout };
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultVideoGestures, null), /* @__PURE__ */ React.createElement(DefaultVideoKeyboardDisplay, null), slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "captions", /* @__PURE__ */ React.createElement(DefaultCaptions, null)), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "topControlsGroupStart", null), slot(slots, "airPlayButton", /* @__PURE__ */ React.createElement(DefaultAirPlayButton, { tooltip: "top start" })), slot(slots, "googleCastButton", /* @__PURE__ */ React.createElement(DefaultGoogleCastButton, { tooltip: "top start" })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "bottom" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots }), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "vertical", tooltip: "bottom end", slots }), slot(slots, "topControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group", style: { pointerEvents: "none" } }, slot(slots, "centerControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupCenter", null), slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top" })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, /* @__PURE__ */ React.createElement(DefaultTimeInfo, { slots }), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement(DefaultTitle, null)), slot(slots, "fullscreenButton", /* @__PURE__ */ React.createElement(DefaultFullscreenButton, { tooltip: "top end" }))), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null)))), slot(slots, "startDuration", /* @__PURE__ */ React.createElement(DefaultVideoStartDuration, null)));
+}
+DefaultVideoSmallLayout.displayName = "DefaultVideoSmallLayout";
+function DefaultVideoStartDuration() {
+  const $duration = useMediaState("duration");
+  if ($duration === 0) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-start-duration" }, /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "duration" }));
+}
+DefaultVideoStartDuration.displayName = "DefaultVideoStartDuration";
+function DefaultVideoGestures() {
+  const { noGestures } = useDefaultLayoutContext();
+  if (noGestures) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-gestures" }, /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "pointerup", action: "toggle:paused" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "pointerup", action: "toggle:controls" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "toggle:fullscreen" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "seek:-10" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "seek:10" }));
+}
+DefaultVideoGestures.displayName = "DefaultVideoGestures";
+function DefaultBufferingIndicator() {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-buffering-indicator" }, /* @__PURE__ */ React.createElement(Root$b, { className: "vds-buffering-spinner" }, /* @__PURE__ */ React.createElement(Track$1, { className: "vds-buffering-track" }), /* @__PURE__ */ React.createElement(TrackFill$1, { className: "vds-buffering-track-fill" })));
+}
+DefaultBufferingIndicator.displayName = "DefaultBufferingIndicator";
+function DefaultVideoMenus({ slots }) {
+  const { isSmallLayout, noModal, menuGroup } = useDefaultLayoutContext(), side = menuGroup === "top" || isSmallLayout ? "bottom" : "top", tooltip = `${side} end`, placement = noModal ? `${side} end` : !isSmallLayout ? `${side} end` : null;
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slot(
+    slots,
+    "chaptersMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultChaptersMenu,
+      {
+        tooltip,
+        placement,
+        portalClass: "vds-video-layout"
+      }
+    )
+  ), slot(
+    slots,
+    "settingsMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultSettingsMenu,
+      {
+        tooltip,
+        placement,
+        portalClass: "vds-video-layout",
+        slots
+      }
+    )
+  ));
+}
+DefaultVideoMenus.displayName = "DefaultVideoMenus";
+function DefaultVideoLoadLayout() {
+  const { isSmallLayout } = useDefaultLayoutContext(), baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.[isSmallLayout ? "smallLayout" : "largeLayout"] };
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-load-container" }, slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "loadButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top" })));
+}
+DefaultVideoLoadLayout.displayName = "DefaultVideoLoadLayout";
+function DefaultVideoKeyboardDisplay() {
+  const { noKeyboardAnimations, icons, userPrefersKeyboardAnimations } = useDefaultLayoutContext(), $userPrefersKeyboardAnimations = useSignal(userPrefersKeyboardAnimations), disabled = noKeyboardAnimations || !$userPrefersKeyboardAnimations;
+  if (disabled || !icons.KeyboardDisplay) return null;
+  return /* @__PURE__ */ React.createElement(DefaultKeyboardDisplay, { icons: icons.KeyboardDisplay });
+}
+DefaultVideoKeyboardDisplay.displayName = "DefaultVideoKeyboardDisplay";
+
+export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultLayoutContext, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions, i18n, useDefaultLayoutContext, useDefaultLayoutWord };
diff --git a/prod/chunks/vidstack-BFbyAy5g.js b/prod/chunks/vidstack-CoI7qZrr.js
similarity index 99%
rename from prod/chunks/vidstack-BFbyAy5g.js
rename to prod/chunks/vidstack-CoI7qZrr.js
index 81f57df4b91ea18ce9ca39dc4dd7749e565df320..c95dde16c9dc1ec7f543330f0ed6787ab7879f4f 100644
--- a/prod/chunks/vidstack-BFbyAy5g.js
+++ b/prod/chunks/vidstack-CoI7qZrr.js
@@ -1,8 +1,8 @@
 "use client"
 
 import { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from './vidstack-CNjv_Zem.js';
-import { ListSymbol, TimeRange, RAFLoop } from './vidstack-D6dKrFOZ.js';
-import { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-B-YW57m0.js';
+import { ListSymbol, TimeRange, RAFLoop } from './vidstack-3ABKqYU9.js';
+import { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-BnZ6XdXq.js';
 import 'react';
 import '@floating-ui/dom';
 
diff --git a/prod/chunks/vidstack-CtKPQRKk.js b/prod/chunks/vidstack-CtKPQRKk.js
new file mode 100644
index 0000000000000000000000000000000000000000..a7b59c12f056de2f364b11c36cfe2b0c78ca9ee8
--- /dev/null
+++ b/prod/chunks/vidstack-CtKPQRKk.js
@@ -0,0 +1,663 @@
+"use client"
+
+import * as React from 'react';
+import { useReactContext, createReactComponent, composeRefs, useSignal, noop, useStateContext, signal, effect, isString } from './vidstack-CNjv_Zem.js';
+import { mediaContext, Primitive, AirPlayButtonInstance, PlayButtonInstance, CaptionButtonInstance, FullscreenButtonInstance, MuteButtonInstance, PIPButtonInstance, SeekButtonInstance, LiveButtonInstance, SliderValueInstance, useSliderState, SliderInstance, SliderPreviewInstance, VolumeSliderInstance, IS_SERVER, ThumbnailInstance, TimeSliderInstance, SliderChaptersInstance, SliderThumbnailInstance, SliderVideoInstance, mediaState, RadioGroupInstance, RadioInstance, useMediaState, MenuInstance, MenuButtonInstance, MenuItemsInstance, MenuItemInstance, GestureInstance, TimeInstance, isTrackCaptionKind } from './vidstack-BY07IoHR.js';
+import { createPortal } from 'react-dom';
+
+function useMediaContext() {
+  return useReactContext(mediaContext);
+}
+
+const AirPlayButtonBridge = createReactComponent(AirPlayButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const AirPlayButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(AirPlayButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+AirPlayButton.displayName = "AirPlayButton";
+
+const PlayButtonBridge = createReactComponent(PlayButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const PlayButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PlayButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+PlayButton.displayName = "PlayButton";
+
+const CaptionButtonBridge = createReactComponent(CaptionButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const CaptionButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(CaptionButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+CaptionButton.displayName = "CaptionButton";
+
+const FullscreenButtonBridge = createReactComponent(FullscreenButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const FullscreenButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(FullscreenButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+FullscreenButton.displayName = "FullscreenButton";
+
+const MuteButtonBridge = createReactComponent(MuteButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const MuteButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(MuteButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+MuteButton.displayName = "MuteButton";
+
+const PIPButtonBridge = createReactComponent(PIPButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const PIPButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PIPButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+PIPButton.displayName = "PIPButton";
+
+const SeekButtonBridge = createReactComponent(SeekButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const SeekButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SeekButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+SeekButton.displayName = "SeekButton";
+
+const LiveButtonBridge = createReactComponent(LiveButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const LiveButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(LiveButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+LiveButton.displayName = "LiveButton";
+
+const sliderCallbacks = [
+  "onDragStart",
+  "onDragEnd",
+  "onDragValueChange",
+  "onValueChange",
+  "onPointerValueChange"
+];
+
+const SliderValueBridge = createReactComponent(SliderValueInstance);
+
+const SliderBridge = createReactComponent(SliderInstance, {
+  events: sliderCallbacks
+});
+const Root$5 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(SliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+});
+Root$5.displayName = "Slider";
+const Thumb = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Thumb.displayName = "SliderThumb";
+const Track = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Track.displayName = "SliderTrack";
+const TrackFill = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+TrackFill.displayName = "SliderTrackFill";
+const PreviewBridge = createReactComponent(SliderPreviewInstance);
+const Preview = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(PreviewBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Preview.displayName = "SliderPreview";
+const Value = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(SliderValueBridge, { ...props }, (props2, instance) => {
+    const $text = useSignal(() => instance.getValueText(), instance);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props2, ref: forwardRef }, $text, children);
+  });
+});
+Value.displayName = "SliderValue";
+const Steps = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const $min = useSliderState("min"), $max = useSliderState("max"), $step = useSliderState("step"), steps = ($max - $min) / $step;
+  return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, Array.from({ length: Math.floor(steps) + 1 }).map((_, step) => children(step)));
+});
+Steps.displayName = "SliderSteps";
+
+var slider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$5,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value
+});
+
+const VolumeSliderBridge = createReactComponent(VolumeSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$4 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(VolumeSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$4.displayName = "VolumeSlider";
+
+var volumeSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$4,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value
+});
+
+function createVTTCue(startTime = 0, endTime = 0, text = "") {
+  if (IS_SERVER) {
+    return {
+      startTime,
+      endTime,
+      text,
+      addEventListener: noop,
+      removeEventListener: noop,
+      dispatchEvent: noop
+    };
+  }
+  return new window.VTTCue(startTime, endTime, text);
+}
+function appendParamsToURL(baseUrl, params) {
+  const url = new URL(baseUrl);
+  for (const key of Object.keys(params)) {
+    url.searchParams.set(key, params[key] + "");
+  }
+  return url.toString();
+}
+
+const ThumbnailBridge = createReactComponent(ThumbnailInstance);
+const Root$3 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ThumbnailBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Root$3.displayName = "Thumbnail";
+const Img = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const { src, img, crossOrigin } = useStateContext(ThumbnailInstance.state), $src = useSignal(src), $crossOrigin = useSignal(crossOrigin);
+  return /* @__PURE__ */ React.createElement(
+    Primitive.img,
+    {
+      crossOrigin: $crossOrigin,
+      ...props,
+      src: $src || void 0,
+      ref: composeRefs(img.set, forwardRef)
+    },
+    children
+  );
+});
+Img.displayName = "ThumbnailImg";
+
+var thumbnail = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Img: Img,
+  Root: Root$3
+});
+
+const TimeSliderContext = React.createContext({
+  $chapters: signal(null)
+});
+TimeSliderContext.displayName = "TimeSliderContext";
+const TimeSliderBridge = createReactComponent(TimeSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$2 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    const $chapters = React.useMemo(() => signal(null), []);
+    return /* @__PURE__ */ React.createElement(TimeSliderContext.Provider, { value: { $chapters } }, /* @__PURE__ */ React.createElement(TimeSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children)));
+  }
+);
+Root$2.displayName = "TimeSlider";
+const SliderChaptersBridge = createReactComponent(SliderChaptersInstance);
+const Chapters = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SliderChaptersBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      /* @__PURE__ */ React.createElement(ChapterTracks, { instance }, children)
+    ));
+  }
+);
+Chapters.displayName = "SliderChapters";
+function ChapterTracks({ instance, children }) {
+  const $cues = useSignal(() => instance.cues, instance), refs = React.useRef([]), emptyCue = React.useRef(), { $chapters } = React.useContext(TimeSliderContext);
+  if (!emptyCue.current) {
+    emptyCue.current = createVTTCue();
+  }
+  React.useEffect(() => {
+    $chapters.set(instance);
+    return () => void $chapters.set(null);
+  }, [instance]);
+  React.useEffect(() => {
+    instance.setRefs(refs.current);
+  }, [$cues]);
+  return children($cues.length ? $cues : [emptyCue.current], (el) => {
+    if (!el) {
+      refs.current.length = 0;
+      return;
+    }
+    refs.current.push(el);
+  });
+}
+ChapterTracks.displayName = "SliderChapterTracks";
+const ChapterTitle = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    const { $chapters } = React.useContext(TimeSliderContext), [title, setTitle] = React.useState();
+    React.useEffect(() => {
+      return effect(() => {
+        const chapters = $chapters(), cue = chapters?.activePointerCue || chapters?.activeCue;
+        setTitle(cue?.text || "");
+      });
+    }, []);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, title, children);
+  }
+);
+ChapterTitle.displayName = "SliderChapterTitle";
+const Progress = React.forwardRef((props, forwardRef) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }));
+Progress.displayName = "SliderProgress";
+const SliderThumbnailBridge = createReactComponent(SliderThumbnailInstance);
+const ThumbnailRoot = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SliderThumbnailBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2, ref: composeRefs(props2.ref, forwardRef) }, children));
+  }
+);
+ThumbnailRoot.displayName = "SliderThumbnail";
+const Thumbnail = {
+  Root: ThumbnailRoot,
+  Img: Img
+};
+const VideoBridge = createReactComponent(SliderVideoInstance, {
+  events: ["onCanPlay", "onError"]
+});
+const Video = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(VideoBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+      VideoProvider,
+      {
+        ...props2,
+        instance,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Video.displayName = "SliderVideo";
+const VideoProvider = React.forwardRef(
+  ({ instance, children, ...props }, forwardRef) => {
+    const { canLoad } = useStateContext(mediaState), { src, video, crossOrigin } = instance.$state, $src = useSignal(src), $canLoad = useSignal(canLoad), $crossOrigin = useSignal(crossOrigin);
+    return /* @__PURE__ */ React.createElement(
+      Primitive.video,
+      {
+        style: { maxWidth: "unset" },
+        ...props,
+        src: $src || void 0,
+        muted: true,
+        playsInline: true,
+        preload: $canLoad ? "auto" : "none",
+        crossOrigin: $crossOrigin || void 0,
+        ref: composeRefs(video.set, forwardRef)
+      },
+      children
+    );
+  }
+);
+VideoProvider.displayName = "SliderVideoProvider";
+
+var timeSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  ChapterTitle: ChapterTitle,
+  Chapters: Chapters,
+  Preview: Preview,
+  Progress: Progress,
+  Root: Root$2,
+  Steps: Steps,
+  Thumb: Thumb,
+  Thumbnail: Thumbnail,
+  Track: Track,
+  TrackFill: TrackFill,
+  Value: Value,
+  Video: Video
+});
+
+const RadioGroupBridge = createReactComponent(RadioGroupInstance, {
+  events: ["onChange"]
+});
+const Root$1 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(RadioGroupBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$1.displayName = "RadioGroup";
+const ItemBridge$1 = createReactComponent(RadioInstance, {
+  events: ["onChange", "onSelect"]
+});
+const Item$1 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemBridge$1, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Item$1.displayName = "RadioItem";
+
+var radioGroup = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Item: Item$1,
+  Root: Root$1
+});
+
+const MenuBridge = createReactComponent(MenuInstance, {
+  events: ["onOpen", "onClose"],
+  domEventsRegex: /^onMedia/
+});
+const Root = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(MenuBridge, { ...props, ref: forwardRef }, (props2, instance) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      style: { display: !instance.isSubmenu ? "contents" : void 0, ...props2.style }
+    },
+    children
+  ));
+});
+Root.displayName = "Menu";
+const ButtonBridge = createReactComponent(MenuButtonInstance, {
+  events: ["onSelect"]
+});
+const Button = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(ButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Button.displayName = "MenuButton";
+const Portal = React.forwardRef(
+  ({ container = null, disabled = false, children, ...props }, forwardRef) => {
+    let fullscreen = useMediaState("fullscreen"), shouldPortal = disabled === "fullscreen" ? !fullscreen : !disabled;
+    const target = React.useMemo(() => {
+      if (IS_SERVER) return null;
+      const node = isString(container) ? document.querySelector(container) : container;
+      return node ?? document.body;
+    }, [container]);
+    return !target || !shouldPortal ? children : createPortal(
+      /* @__PURE__ */ React.createElement(
+        Primitive.div,
+        {
+          ...props,
+          style: { display: "contents", ...props.style },
+          ref: forwardRef
+        },
+        children
+      ),
+      target
+    );
+  }
+);
+Portal.displayName = "MenuPortal";
+const ItemsBridge = createReactComponent(MenuItemsInstance);
+const Items = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemsBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Items.displayName = "MenuItems";
+const ItemBridge = createReactComponent(MenuItemInstance);
+const Item = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ItemBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Item.displayName = "MenuItem";
+
+var menu = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Button: Button,
+  Content: Items,
+  Item: Item,
+  Items: Items,
+  Portal: Portal,
+  Radio: Item$1,
+  RadioGroup: Root$1,
+  Root: Root
+});
+
+const GestureBridge = createReactComponent(GestureInstance, {
+  events: ["onWillTrigger", "onTrigger"]
+});
+const Gesture = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(GestureBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Gesture.displayName = "Gesture";
+
+const TimeBridge = createReactComponent(TimeInstance);
+const Time = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(TimeBridge, { ...props }, (props2, instance) => /* @__PURE__ */ React.createElement(
+    TimeText,
+    {
+      ...props2,
+      instance,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Time.displayName = "Time";
+const TimeText = React.forwardRef(
+  ({ instance, children, ...props }, forwardRef) => {
+    const { timeText } = instance.$state, $timeText = useSignal(timeText);
+    return /* @__PURE__ */ React.createElement(Primitive.div, { ...props, ref: forwardRef }, $timeText, children);
+  }
+);
+TimeText.displayName = "TimeText";
+
+function useMediaPlayer() {
+  const context = useMediaContext();
+  return context?.player || null;
+}
+
+function useAudioOptions() {
+  const media = useMediaContext(), { audioTracks, audioTrack } = media.$state, $audioTracks = useSignal(audioTracks);
+  useSignal(audioTrack);
+  return React.useMemo(() => {
+    const options = $audioTracks.map((track) => ({
+      track,
+      label: track.label,
+      value: getTrackValue$1(track),
+      get selected() {
+        return audioTrack() === track;
+      },
+      select(trigger) {
+        const index = audioTracks().indexOf(track);
+        if (index >= 0) media.remote.changeAudioTrack(index, trigger);
+      }
+    }));
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return options.length <= 1;
+      }
+    });
+    Object.defineProperty(options, "selectedTrack", {
+      get() {
+        return audioTrack();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const track = audioTrack();
+        return track ? getTrackValue$1(track) : void 0;
+      }
+    });
+    return options;
+  }, [$audioTracks]);
+}
+function getTrackValue$1(track) {
+  return track.label.toLowerCase();
+}
+
+function useCaptionOptions({ off = true } = {}) {
+  const media = useMediaContext(), { textTracks, textTrack } = media.$state, $textTracks = useSignal(textTracks);
+  useSignal(textTrack);
+  return React.useMemo(() => {
+    const captionTracks = $textTracks.filter(isTrackCaptionKind), options = captionTracks.map((track) => ({
+      track,
+      label: track.label,
+      value: getTrackValue(track),
+      get selected() {
+        return textTrack() === track;
+      },
+      select(trigger) {
+        const index = textTracks().indexOf(track);
+        if (index >= 0) media.remote.changeTextTrackMode(index, "showing", trigger);
+      }
+    }));
+    if (off) {
+      options.unshift({
+        track: null,
+        label: isString(off) ? off : "Off",
+        value: "off",
+        get selected() {
+          return !textTrack();
+        },
+        select(trigger) {
+          media.remote.toggleCaptions(trigger);
+        }
+      });
+    }
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !captionTracks.length;
+      }
+    });
+    Object.defineProperty(options, "selectedTrack", {
+      get() {
+        return textTrack();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const track = textTrack();
+        return track ? getTrackValue(track) : "off";
+      }
+    });
+    return options;
+  }, [$textTracks]);
+}
+function getTrackValue(track) {
+  return track.id + ":" + track.kind + "-" + track.label.toLowerCase();
+}
+
+export { AirPlayButton, Button, CaptionButton, ChapterTitle, Chapters, FullscreenButton, Gesture, Img, Item$1 as Item, Items, LiveButton, MuteButton, PIPButton, PlayButton, Portal, Preview, Progress, Root$3 as Root, Root$2 as Root$1, Root as Root$2, Root$1 as Root$3, Root$4, Root$5, SeekButton, Steps, Thumb, Thumbnail, Time, Track, TrackFill, Value, appendParamsToURL, menu, radioGroup, slider, sliderCallbacks, thumbnail, timeSlider, useAudioOptions, useCaptionOptions, useMediaContext, useMediaPlayer, volumeSlider };
diff --git a/prod/chunks/vidstack-D6dKrFOZ.js b/prod/chunks/vidstack-CwFL6mmL.js
similarity index 99%
rename from prod/chunks/vidstack-D6dKrFOZ.js
rename to prod/chunks/vidstack-CwFL6mmL.js
index 146288188ae11675dc4a7969ed4bd6e267784042..ecf24b9d75b287c27e5169b5e9c80ffede6cc992 100644
--- a/prod/chunks/vidstack-D6dKrFOZ.js
+++ b/prod/chunks/vidstack-CwFL6mmL.js
@@ -1,7 +1,7 @@
 "use client"
 
 import * as React from 'react';
-import { isString, isNumber, isFunction, isUndefined, waitTimeout, isArray, isBoolean, isNull, deferredPromise, listenEvent, scoped, getScope, EventsTarget, DOMEvent, State, fscreen, tick, createContext, useContext, Component, functionThrottle, isTouchEvent, isDOMNode, setAttribute, effect, EventsController, isKeyboardClick, setStyle, onDispose, untrack, functionDebounce, ViewController, signal, peek, isKeyboardEvent, isNil, createScope, camelToKebabCase, waitIdlePeriod, provideContext, animationFrameThrottle, uppercaseFirstChar, computed, prop, method, noop, ariaBool as ariaBool$1, isWriteSignal, hasProvidedContext, isObject, useState, r, wasEnterKeyPressed, isPointerEvent, isMouseEvent, kebabToCamelCase, composeRefs, useStateContext, useSignal, useSignalRecord } from './vidstack-CNjv_Zem.js';
+import { isString, isNumber, isFunction, isUndefined, waitTimeout, isArray, isBoolean, isNull, deferredPromise, listenEvent, scoped, getScope, EventsTarget, DOMEvent, State, fscreen, tick, createContext, useContext, Component, functionThrottle, setAttribute, effect, isTouchEvent, isDOMNode, EventsController, isKeyboardClick, setStyle, onDispose, untrack, functionDebounce, ViewController, signal, peek, isKeyboardEvent, isNil, createScope, camelToKebabCase, waitIdlePeriod, prop, method, provideContext, animationFrameThrottle, uppercaseFirstChar, computed, noop, ariaBool as ariaBool$1, isWriteSignal, hasProvidedContext, isObject, useState, r, wasEnterKeyPressed, isPointerEvent, isMouseEvent, kebabToCamelCase, composeRefs, useStateContext, useSignal, useSignalRecord } from './vidstack-CNjv_Zem.js';
 import { autoUpdate, computePosition, flip, shift } from '@floating-ui/dom';
 
 function isVideoQualitySrc(src) {
@@ -490,6 +490,8 @@ class TextTrack extends EventsTarget {
       });
       if (this.type === "json") {
         this.#parseJSON(await (await response).text(), VTTCue, VTTRegion);
+      } else if (this.type === "lrc") {
+        this.#parseLRC(await (await response).text(), VTTCue, VTTRegion);
       } else {
         const { errors, metadata, regions, cues } = await parseResponse(response, {
           type: this.type,
@@ -524,6 +526,15 @@ class TextTrack extends EventsTarget {
     this[TextTrackSymbol.readyState] = 3;
     this.dispatchEvent(new DOMEvent("error", { detail: error }));
   }
+  #parseLRC(lrc, VTTCue, VTTRegion) {
+    try {
+      const { regions, cues } = parseLRCCaptionsFile(lrc, VTTCue, VTTRegion);
+      this.#regions = regions;
+      this.#cues = cues;
+    } catch (error) {
+      this.#error(error);
+    }
+  }
   #parseJSON(json, VTTCue, VTTRegion) {
     try {
       const { regions, cues } = parseJSONCaptionsFile(json, VTTCue, VTTRegion);
@@ -541,6 +552,30 @@ const captionRE = /captions|subtitles/;
 function isTrackCaptionKind(track) {
   return captionRE.test(track.kind);
 }
+function parseLRCCaptionsFile(lrc, Cue, Region) {
+  const cues = [], regions = [];
+  const lines = lrc.split("\n");
+  let lineIndex = 0;
+  while (lineIndex < lines.length) {
+    const line = lines[lineIndex].trim();
+    if (!line) {
+      lineIndex++;
+      continue;
+    }
+    const cue = new Cue(0, 0, ""), parts = line.split("]");
+    if (parts.length < 2) {
+      lineIndex++;
+      continue;
+    }
+    const times = parts[0].split("[")[1].split("-");
+    cue.startTime = parseFloat(times[0]);
+    cue.endTime = parseFloat(times[1]);
+    cue.text = parts.slice(1).join("]");
+    cues.push(cue);
+    lineIndex++;
+  }
+  return { cues, regions };
+}
 function parseJSONCaptionsFile(json, Cue, Region) {
   const content = isString(json) ? JSON.parse(json) : json;
   let regions = [], cues = [];
@@ -2647,7 +2682,7 @@ class AudioProviderLoader {
     if (IS_SERVER) {
       throw Error("[vidstack] can not load audio provider server-side");
     }
-    return new (await import('./vidstack-CC0Rsbn0.js')).AudioProvider(this.target, ctx);
+    return new (await import('./vidstack-D1OlkkPd.js')).AudioProvider(this.target, ctx);
   }
 }
 
@@ -2679,7 +2714,7 @@ class HLSProviderLoader extends VideoProviderLoader {
     if (IS_SERVER) {
       throw Error("[vidstack] can not load hls provider server-side");
     }
-    return new (await import('./vidstack-Xu8hy52p.js')).HLSProvider(this.target, context);
+    return new (await import('./vidstack-HMgOfN5g.js')).HLSProvider(this.target, context);
   }
 }
 
@@ -4043,7 +4078,7 @@ class VimeoProviderLoader {
     if (IS_SERVER) {
       throw Error("[vidstack] can not load vimeo provider server-side");
     }
-    return new (await import('./vidstack-BGEqnOoX.js')).VimeoProvider(this.target, ctx);
+    return new (await import('./vidstack-DMA1vuPq.js')).VimeoProvider(this.target, ctx);
   }
   async loadPoster(src, ctx, abort) {
     const { resolveVimeoVideoId, getVimeoVideoInfo } = await import('./vidstack-krOAtKMi.js');
@@ -4083,7 +4118,7 @@ class YouTubeProviderLoader {
     if (IS_SERVER) {
       throw Error("[vidstack] can not load youtube provider server-side");
     }
-    return new (await import('./vidstack-D2cUZes0.js')).YouTubeProvider(this.target, ctx);
+    return new (await import('./vidstack-CZ_a5B97.js')).YouTubeProvider(this.target, ctx);
   }
   async loadPoster(src, ctx, abort) {
     const { findYouTubePoster, resolveYouTubeVideoId } = await import('./vidstack-Zc3I7oOd.js');
@@ -4717,7 +4752,7 @@ class MediaRequestManager extends MediaPlayerController {
       }
       preconnect("https://www.gstatic.com");
       if (!this.#googleCastLoader) {
-        const $module = await import('./vidstack-B-YW57m0.js').then(function (n) { return n.loader; });
+        const $module = await import('./vidstack-D6rGR5oE.js').then(function (n) { return n.loader; });
         this.#googleCastLoader = new $module.GoogleCastLoader();
       }
       await this.#googleCastLoader.prompt(this.#media);
@@ -11140,4 +11175,4 @@ function useMediaStore(ref) {
   return useSignalRecord(ref?.current ? ref.current.$state : $state || initialMediaStore);
 }
 
-export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLAirPlayAdapter, HTMLMediaProvider, IS_CHROME, IS_IOS, IS_SERVER, List, ListSymbol, LiveButtonInstance, LocalMediaStorage, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaPlayerInstance, MediaProviderInstance, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, Primitive, QualitySliderInstance, QualitySymbol, RAFLoop, RadioGroupController, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrack, TextTrackList, TextTrackSymbol, ThumbnailInstance, ThumbnailsLoader, TimeInstance, TimeRange, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProvider, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, appendParamsToURL, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, coerceToError, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHLSSupported, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isRemotionProvider, isRemotionSrc, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, loadScript, mediaContext, mediaState, menuContext, normalizeTimeIntervals, parseJSONCaptionsFile, preconnect, sliderState, softResetMediaState, sortVideoQualities, updateSliderPreviewPlacement, updateTimeIntervals, useMediaContext, useMediaState, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange };
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, HTMLAirPlayAdapter, HTMLMediaProvider, IS_CHROME, IS_IOS, IS_SERVER, List, ListSymbol, LiveButtonInstance, LocalMediaStorage, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaPlayerInstance, MediaProviderInstance, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, PosterInstance, Primitive, QualitySliderInstance, QualitySymbol, RAFLoop, RadioGroupController, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrack, TextTrackList, TextTrackSymbol, ThumbnailInstance, ThumbnailsLoader, TimeInstance, TimeRange, TimeSliderInstance, ToggleButtonInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProvider, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, appendParamsToURL, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, coerceToError, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHLSSupported, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isRemotionProvider, isRemotionSrc, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, loadScript, mediaContext, mediaState, menuContext, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, preconnect, sliderState, softResetMediaState, sortVideoQualities, updateSliderPreviewPlacement, updateTimeIntervals, useMediaContext, useMediaState, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange };
diff --git a/prod/chunks/vidstack-CzDPuCjO.js b/prod/chunks/vidstack-CzDPuCjO.js
new file mode 100644
index 0000000000000000000000000000000000000000..157fb0e338437723e7a07ae682208e016d7382d5
--- /dev/null
+++ b/prod/chunks/vidstack-CzDPuCjO.js
@@ -0,0 +1,61 @@
+"use client"
+
+import { appendParamsToURL, IS_SERVER } from './vidstack-CwFL6mmL.js';
+import { signal, listenEvent, effect, peek, isString } from './vidstack-CNjv_Zem.js';
+
+class EmbedProvider {
+  #iframe;
+  src = signal("");
+  /**
+   * Defines which referrer is sent when fetching the resource.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy}
+   */
+  referrerPolicy = null;
+  get iframe() {
+    return this.#iframe;
+  }
+  constructor(iframe) {
+    this.#iframe = iframe;
+    iframe.setAttribute("frameBorder", "0");
+    iframe.setAttribute("aria-hidden", "true");
+    iframe.setAttribute(
+      "allow",
+      "autoplay; fullscreen; encrypted-media; picture-in-picture; accelerometer; gyroscope"
+    );
+    if (this.referrerPolicy !== null) {
+      iframe.setAttribute("referrerpolicy", this.referrerPolicy);
+    }
+  }
+  setup() {
+    listenEvent(window, "message", this.#onWindowMessage.bind(this));
+    listenEvent(this.#iframe, "load", this.onLoad.bind(this));
+    effect(this.#watchSrc.bind(this));
+  }
+  #watchSrc() {
+    const src = this.src();
+    if (!src.length) {
+      this.#iframe.setAttribute("src", "");
+      return;
+    }
+    const params = peek(() => this.buildParams());
+    this.#iframe.setAttribute("src", appendParamsToURL(src, params));
+  }
+  postMessage(message, target) {
+    if (IS_SERVER) return;
+    this.#iframe.contentWindow?.postMessage(JSON.stringify(message), target ?? "*");
+  }
+  #onWindowMessage(event) {
+    const origin = this.getOrigin(), isOriginMatch = (event.source === null || event.source === this.#iframe?.contentWindow) && (!isString(origin) || origin === event.origin);
+    if (!isOriginMatch) return;
+    try {
+      const message = JSON.parse(event.data);
+      if (message) this.onMessage(message, event);
+      return;
+    } catch (e) {
+    }
+    if (event.data) this.onMessage(event.data, event);
+  }
+}
+
+export { EmbedProvider };
diff --git a/prod/chunks/vidstack-D1OlkkPd.js b/prod/chunks/vidstack-D1OlkkPd.js
new file mode 100644
index 0000000000000000000000000000000000000000..e03fd462efbf664ddced9bc693648417ebcd087b
--- /dev/null
+++ b/prod/chunks/vidstack-D1OlkkPd.js
@@ -0,0 +1,34 @@
+"use client"
+
+import { scoped } from './vidstack-CNjv_Zem.js';
+import { HTMLMediaProvider, HTMLAirPlayAdapter } from './vidstack-CwFL6mmL.js';
+import 'react';
+import '@floating-ui/dom';
+
+class AudioProvider extends HTMLMediaProvider {
+  $$PROVIDER_TYPE = "AUDIO";
+  get type() {
+    return "audio";
+  }
+  airPlay;
+  constructor(audio, ctx) {
+    super(audio, ctx);
+    scoped(() => {
+      this.airPlay = new HTMLAirPlayAdapter(this.media, ctx);
+    }, this.scope);
+  }
+  setup() {
+    super.setup();
+    if (this.type === "audio") this.ctx.notify("provider-setup", this);
+  }
+  /**
+   * The native HTML `<audio>` element.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement}
+   */
+  get audio() {
+    return this.media;
+  }
+}
+
+export { AudioProvider };
diff --git a/prod/chunks/vidstack-D3wYtMF7.js b/prod/chunks/vidstack-D3wYtMF7.js
new file mode 100644
index 0000000000000000000000000000000000000000..43cd5c7956a300870b68b96105f79fc20bfc2cac
--- /dev/null
+++ b/prod/chunks/vidstack-D3wYtMF7.js
@@ -0,0 +1,1371 @@
+"use client"
+
+import * as React from 'react';
+import { useSignal, isBoolean, composeRefs, uppercaseFirstChar, isUndefined, isString, signal, camelToKebabCase, onDispose, scoped, keysOf, effect, isArray, isKeyboardClick, listenEvent, toggleClass, useContext } from './vidstack-CNjv_Zem.js';
+import { createComputed, createSignal, MediaAnnouncer, Root, Trigger, Content, GoogleCastButton, Captions, useChapterOptions, Root$1 as Root$5, Root$2 as Root$6, Root$3 as Root$7, useScoped, Root$4 as Root$a, Group, useChapterTitle, createEffect, useActiveTextTrack, ChapterTitle as ChapterTitle$1, Title, Root$5 as Root$b, Track as Track$1, TrackFill as TrackFill$1 } from './vidstack-BBy6wGkT.js';
+import { useColorSchemePreference, useActive, useResizeObserver, useLayoutName, useTransitionActive } from './vidstack-Dbk-FOkv.js';
+import { useMediaContext, MuteButton, PlayButton, CaptionButton, PIPButton, FullscreenButton, SeekButton, AirPlayButton, LiveButton, appendParamsToURL, Items, Root$3 as Root$1, Item, Root as Root$2, Img, Root$2 as Root$3, Button, Portal, Track, TrackFill, Thumb, Steps, useMediaPlayer, Root$5 as Root$4, useAudioOptions, useCaptionOptions, Root$4 as Root$8, Preview, Value, Root$1 as Root$9, Chapters, Progress, Thumbnail, ChapterTitle, Time, Gesture } from './vidstack-BKi5uu_j.js';
+import { useMediaState, isTrackCaptionKind, getDownloadFile, isRemotionSrc, IS_SERVER, useMediaContext as useMediaContext$1, sortVideoQualities, Primitive, mediaContext } from './vidstack-CwFL6mmL.js';
+import { flushSync } from 'react-dom';
+import { RemotionThumbnail, RemotionSliderThumbnail } from './vidstack-CV12ZH4Z.js';
+
+const DefaultLayoutContext = React.createContext({});
+DefaultLayoutContext.displayName = "DefaultLayoutContext";
+function useDefaultLayoutContext() {
+  return React.useContext(DefaultLayoutContext);
+}
+function useDefaultLayoutWord(word) {
+  const { translations } = useDefaultLayoutContext();
+  return i18n(translations, word);
+}
+function i18n(translations, word) {
+  return translations?.[word] ?? word;
+}
+
+function useColorSchemeClass(colorScheme) {
+  const systemColorPreference = useColorSchemePreference();
+  if (colorScheme === "default") {
+    return null;
+  } else if (colorScheme === "system") {
+    return systemColorPreference;
+  } else {
+    return colorScheme;
+  }
+}
+
+function createDefaultMediaLayout({
+  type,
+  smLayoutWhen,
+  renderLayout
+}) {
+  const Layout = React.forwardRef(
+    ({
+      children,
+      className,
+      disableTimeSlider = false,
+      hideQualityBitrate = false,
+      icons,
+      colorScheme = "system",
+      download = null,
+      menuContainer = null,
+      menuGroup = "bottom",
+      noAudioGain = false,
+      audioGains = { min: 0, max: 300, step: 25 },
+      noGestures = false,
+      noKeyboardAnimations = false,
+      noModal = false,
+      noScrubGesture,
+      playbackRates = { min: 0, max: 2, step: 0.25 },
+      seekStep = 10,
+      showMenuDelay,
+      showTooltipDelay = 700,
+      sliderChaptersMinWidth = 325,
+      slots,
+      smallLayoutWhen = smLayoutWhen,
+      thumbnails = null,
+      translations,
+      ...props
+    }, forwardRef) => {
+      const media = useMediaContext(), $load = useSignal(media.$props.load), $canLoad = useMediaState("canLoad"), $viewType = useMediaState("viewType"), $streamType = useMediaState("streamType"), $smallWhen = createComputed(() => {
+        return isBoolean(smallLayoutWhen) ? smallLayoutWhen : smallLayoutWhen(media.player.state);
+      }, [smallLayoutWhen]), userPrefersAnnouncements = createSignal(true), userPrefersKeyboardAnimations = createSignal(true), isMatch = $viewType === type, isSmallLayout = $smallWhen(), isForcedLayout = isBoolean(smallLayoutWhen), isLoadLayout = $load === "play" && !$canLoad, canRender = $canLoad || isForcedLayout || isLoadLayout, colorSchemeClass = useColorSchemeClass(colorScheme), layoutEl = createSignal(null);
+      useSignal($smallWhen);
+      return /* @__PURE__ */ React.createElement(
+        "div",
+        {
+          ...props,
+          className: `vds-${type}-layout` + (colorSchemeClass ? ` ${colorSchemeClass}` : "") + (className ? ` ${className}` : ""),
+          "data-match": isMatch ? "" : null,
+          "data-sm": isSmallLayout ? "" : null,
+          "data-lg": !isSmallLayout ? "" : null,
+          "data-size": isSmallLayout ? "sm" : "lg",
+          "data-no-scrub-gesture": noScrubGesture ? "" : null,
+          ref: composeRefs(layoutEl.set, forwardRef)
+        },
+        canRender && isMatch ? /* @__PURE__ */ React.createElement(
+          DefaultLayoutContext.Provider,
+          {
+            value: {
+              disableTimeSlider,
+              hideQualityBitrate,
+              icons,
+              colorScheme,
+              download,
+              isSmallLayout,
+              menuContainer,
+              menuGroup,
+              noAudioGain,
+              audioGains,
+              layoutEl,
+              noGestures,
+              noKeyboardAnimations,
+              noModal,
+              noScrubGesture,
+              showMenuDelay,
+              showTooltipDelay,
+              sliderChaptersMinWidth,
+              slots,
+              seekStep,
+              playbackRates,
+              thumbnails,
+              translations,
+              userPrefersAnnouncements,
+              userPrefersKeyboardAnimations
+            }
+          },
+          renderLayout({ streamType: $streamType, isSmallLayout, isLoadLayout }),
+          children
+        ) : null
+      );
+    }
+  );
+  Layout.displayName = "DefaultMediaLayout";
+  return Layout;
+}
+
+function useDefaultAudioLayoutSlots() {
+  return React.useContext(DefaultLayoutContext).slots;
+}
+function useDefaultVideoLayoutSlots() {
+  return React.useContext(DefaultLayoutContext).slots;
+}
+function slot(slots, name, defaultValue) {
+  const slot2 = slots?.[name], capitalizedName = uppercaseFirstChar(name);
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slots?.[`before${capitalizedName}`], isUndefined(slot2) ? defaultValue : slot2, slots?.[`after${capitalizedName}`]);
+}
+
+function DefaultAnnouncer() {
+  const { userPrefersAnnouncements, translations } = useDefaultLayoutContext(), $userPrefersAnnouncements = useSignal(userPrefersAnnouncements);
+  if (!$userPrefersAnnouncements) return null;
+  return /* @__PURE__ */ React.createElement(MediaAnnouncer, { translations });
+}
+DefaultAnnouncer.displayName = "DefaultAnnouncer";
+
+function DefaultTooltip({ content, placement, children }) {
+  const { showTooltipDelay } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root, { showDelay: showTooltipDelay }, /* @__PURE__ */ React.createElement(Trigger, { asChild: true }, children), /* @__PURE__ */ React.createElement(Content, { className: "vds-tooltip-content", placement }, content));
+}
+DefaultTooltip.displayName = "DefaultTooltip";
+
+function DefaultPlayButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), playText = useDefaultLayoutWord("Play"), pauseText = useDefaultLayoutWord("Pause"), $paused = useMediaState("paused"), $ended = useMediaState("ended");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $paused ? playText : pauseText, placement: tooltip }, /* @__PURE__ */ React.createElement(PlayButton, { className: "vds-play-button vds-button", "aria-label": playText }, $ended ? /* @__PURE__ */ React.createElement(Icons.PlayButton.Replay, { className: "vds-icon" }) : $paused ? /* @__PURE__ */ React.createElement(Icons.PlayButton.Play, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.PlayButton.Pause, { className: "vds-icon" })));
+}
+DefaultPlayButton.displayName = "DefaultPlayButton";
+const DefaultMuteButton = React.forwardRef(
+  ({ tooltip }, forwardRef) => {
+    const { icons: Icons } = useDefaultLayoutContext(), muteText = useDefaultLayoutWord("Mute"), unmuteText = useDefaultLayoutWord("Unmute"), $muted = useMediaState("muted"), $volume = useMediaState("volume");
+    return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $muted ? unmuteText : muteText, placement: tooltip }, /* @__PURE__ */ React.createElement(MuteButton, { className: "vds-mute-button vds-button", "aria-label": muteText, ref: forwardRef }, $muted || $volume == 0 ? /* @__PURE__ */ React.createElement(Icons.MuteButton.Mute, { className: "vds-icon" }) : $volume < 0.5 ? /* @__PURE__ */ React.createElement(Icons.MuteButton.VolumeLow, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.MuteButton.VolumeHigh, { className: "vds-icon" })));
+  }
+);
+DefaultMuteButton.displayName = "DefaultMuteButton";
+function DefaultCaptionButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), captionsText = useDefaultLayoutWord("Captions"), onText = useDefaultLayoutWord("Closed-Captions On"), offText = useDefaultLayoutWord("Closed-Captions Off"), $track = useMediaState("textTrack"), isOn = $track && isTrackCaptionKind($track);
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: isOn ? onText : offText, placement: tooltip }, /* @__PURE__ */ React.createElement(CaptionButton, { className: "vds-caption-button vds-button", "aria-label": captionsText }, isOn ? /* @__PURE__ */ React.createElement(Icons.CaptionButton.On, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.CaptionButton.Off, { className: "vds-icon" })));
+}
+DefaultCaptionButton.displayName = "DefaultCaptionButton";
+function DefaultPIPButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), pipText = useDefaultLayoutWord("PiP"), enterText = useDefaultLayoutWord("Enter PiP"), exitText = useDefaultLayoutWord("Exit PiP"), $pip = useMediaState("pictureInPicture");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $pip ? exitText : enterText, placement: tooltip }, /* @__PURE__ */ React.createElement(PIPButton, { className: "vds-pip-button vds-button", "aria-label": pipText }, $pip ? /* @__PURE__ */ React.createElement(Icons.PIPButton.Exit, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.PIPButton.Enter, { className: "vds-icon" })));
+}
+DefaultPIPButton.displayName = "DefaultPIPButton";
+function DefaultFullscreenButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), fullscreenText = useDefaultLayoutWord("Fullscreen"), enterText = useDefaultLayoutWord("Enter Fullscreen"), exitText = useDefaultLayoutWord("Exit Fullscreen"), $fullscreen = useMediaState("fullscreen");
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: $fullscreen ? exitText : enterText, placement: tooltip }, /* @__PURE__ */ React.createElement(FullscreenButton, { className: "vds-fullscreen-button vds-button", "aria-label": fullscreenText }, $fullscreen ? /* @__PURE__ */ React.createElement(Icons.FullscreenButton.Exit, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.FullscreenButton.Enter, { className: "vds-icon" })));
+}
+DefaultFullscreenButton.displayName = "DefaultFullscreenButton";
+function DefaultSeekButton({
+  backward,
+  tooltip
+}) {
+  const { icons: Icons, seekStep } = useDefaultLayoutContext(), seekForwardText = useDefaultLayoutWord("Seek Forward"), seekBackwardText = useDefaultLayoutWord("Seek Backward"), seconds = (backward ? -1 : 1) * seekStep, label = seconds >= 0 ? seekForwardText : seekBackwardText;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: label, placement: tooltip }, /* @__PURE__ */ React.createElement(SeekButton, { className: "vds-seek-button vds-button", seconds, "aria-label": label }, seconds >= 0 ? /* @__PURE__ */ React.createElement(Icons.SeekButton.Forward, { className: "vds-icon" }) : /* @__PURE__ */ React.createElement(Icons.SeekButton.Backward, { className: "vds-icon" })));
+}
+DefaultSeekButton.displayName = "DefaultSeekButton";
+function DefaultAirPlayButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), airPlayText = useDefaultLayoutWord("AirPlay"), $state = useMediaState("remotePlaybackState"), stateText = useDefaultLayoutWord(uppercaseFirstChar($state)), label = `${airPlayText} ${stateText}`, Icon = ($state === "connecting" ? Icons.AirPlayButton.Connecting : $state === "connected" ? Icons.AirPlayButton.Connected : null) ?? Icons.AirPlayButton.Default;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: airPlayText, placement: tooltip }, /* @__PURE__ */ React.createElement(AirPlayButton, { className: "vds-airplay-button vds-button", "aria-label": label }, /* @__PURE__ */ React.createElement(Icon, { className: "vds-icon" })));
+}
+DefaultAirPlayButton.displayName = "DefaultAirPlayButton";
+function DefaultGoogleCastButton({ tooltip }) {
+  const { icons: Icons } = useDefaultLayoutContext(), googleCastText = useDefaultLayoutWord("Google Cast"), $state = useMediaState("remotePlaybackState"), stateText = useDefaultLayoutWord(uppercaseFirstChar($state)), label = `${googleCastText} ${stateText}`, Icon = ($state === "connecting" ? Icons.GoogleCastButton.Connecting : $state === "connected" ? Icons.GoogleCastButton.Connected : null) ?? Icons.GoogleCastButton.Default;
+  return /* @__PURE__ */ React.createElement(DefaultTooltip, { content: googleCastText, placement: tooltip }, /* @__PURE__ */ React.createElement(GoogleCastButton, { className: "vds-google-cast-button vds-button", "aria-label": label }, /* @__PURE__ */ React.createElement(Icon, { className: "vds-icon" })));
+}
+DefaultGoogleCastButton.displayName = "DefaultGoogleCastButton";
+function DefaultLiveButton() {
+  const $live = useMediaState("live"), label = useDefaultLayoutWord("Skip To Live"), liveText = useDefaultLayoutWord("LIVE");
+  return $live ? /* @__PURE__ */ React.createElement(LiveButton, { className: "vds-live-button", "aria-label": label }, /* @__PURE__ */ React.createElement("span", { className: "vds-live-button-text" }, liveText)) : null;
+}
+DefaultLiveButton.displayName = "DefaultLiveButton";
+function DefaultDownloadButton() {
+  const { download, icons: Icons } = useDefaultLayoutContext(), $src = useMediaState("source"), $title = useMediaState("title"), file = getDownloadFile({
+    title: $title,
+    src: $src,
+    download
+  }), downloadText = useDefaultLayoutWord("Download");
+  return isString(file?.url) ? /* @__PURE__ */ React.createElement(DefaultTooltip, { content: downloadText, placement: "top" }, /* @__PURE__ */ React.createElement(
+    "a",
+    {
+      role: "button",
+      className: "vds-download-button vds-button",
+      "aria-label": downloadText,
+      href: appendParamsToURL(file.url, { download: file.name }),
+      download: file.name,
+      target: "_blank"
+    },
+    Icons.DownloadButton ? /* @__PURE__ */ React.createElement(Icons.DownloadButton.Default, { className: "vds-icon" }) : null
+  )) : null;
+}
+DefaultDownloadButton.displayName = "DefaultDownloadButton";
+
+function DefaultCaptions() {
+  const exampleText = useDefaultLayoutWord("Captions look like this");
+  return /* @__PURE__ */ React.createElement(Captions, { className: "vds-captions", exampleText });
+}
+DefaultCaptions.displayName = "DefaultCaptions";
+
+function DefaultControlsSpacer() {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-controls-spacer" });
+}
+DefaultControlsSpacer.displayName = "DefaultControlsSpacer";
+
+function useParentDialogEl() {
+  const { layoutEl } = useDefaultLayoutContext(), $layoutEl = useSignal(layoutEl);
+  return React.useMemo(() => $layoutEl?.closest("dialog"), [$layoutEl]);
+}
+
+function DefaultChaptersMenu({ tooltip, placement, portalClass = "" }) {
+  const {
+    showMenuDelay,
+    noModal,
+    isSmallLayout,
+    icons: Icons,
+    menuGroup,
+    menuContainer,
+    colorScheme
+  } = useDefaultLayoutContext(), chaptersText = useDefaultLayoutWord("Chapters"), options = useChapterOptions(), disabled = !options.length, { thumbnails } = useDefaultLayoutContext(), $src = useMediaState("currentSrc"), $viewType = useMediaState("viewType"), $offset = !isSmallLayout && menuGroup === "bottom" && $viewType === "video" ? 26 : 0, $RemotionThumbnail = useSignal(RemotionThumbnail), colorSchemeClass = useColorSchemeClass(colorScheme), [isOpen, setIsOpen] = React.useState(false), dialogEl = useParentDialogEl();
+  if (disabled) return null;
+  function onOpen() {
+    flushSync(() => {
+      setIsOpen(true);
+    });
+  }
+  function onClose() {
+    setIsOpen(false);
+  }
+  const Content = /* @__PURE__ */ React.createElement(
+    Items,
+    {
+      className: "vds-chapters-menu-items vds-menu-items",
+      placement,
+      offset: $offset
+    },
+    isOpen ? /* @__PURE__ */ React.createElement(
+      Root$1,
+      {
+        className: "vds-chapters-radio-group vds-radio-group",
+        value: options.selectedValue,
+        "data-thumbnails": thumbnails ? "" : null
+      },
+      options.map(
+        ({ cue, label, value, startTimeText, durationText, select, setProgressVar }) => /* @__PURE__ */ React.createElement(
+          Item,
+          {
+            className: "vds-chapter-radio vds-radio",
+            value,
+            key: value,
+            onSelect: select,
+            ref: setProgressVar
+          },
+          thumbnails ? /* @__PURE__ */ React.createElement(Root$2, { src: thumbnails, className: "vds-thumbnail", time: cue.startTime }, /* @__PURE__ */ React.createElement(Img, null)) : $RemotionThumbnail && isRemotionSrc($src) ? /* @__PURE__ */ React.createElement($RemotionThumbnail, { className: "vds-thumbnail", frame: cue.startTime * $src.fps }) : null,
+          /* @__PURE__ */ React.createElement("div", { className: "vds-chapter-radio-content" }, /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-label" }, label), /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-start-time" }, startTimeText), /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-radio-duration" }, durationText))
+        )
+      )
+    ) : null
+  );
+  return /* @__PURE__ */ React.createElement(
+    Root$3,
+    {
+      className: "vds-chapters-menu vds-menu",
+      showDelay: showMenuDelay,
+      onOpen,
+      onClose
+    },
+    /* @__PURE__ */ React.createElement(DefaultTooltip, { content: chaptersText, placement: tooltip }, /* @__PURE__ */ React.createElement(
+      Button,
+      {
+        className: "vds-menu-button vds-button",
+        disabled,
+        "aria-label": chaptersText
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.Chapters, { className: "vds-icon" })
+    )),
+    noModal || !isSmallLayout ? Content : /* @__PURE__ */ React.createElement(
+      Portal,
+      {
+        container: menuContainer ?? dialogEl,
+        className: portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : ""),
+        disabled: "fullscreen",
+        "data-sm": isSmallLayout ? "" : null,
+        "data-lg": !isSmallLayout ? "" : null,
+        "data-size": isSmallLayout ? "sm" : "lg"
+      },
+      Content
+    )
+  );
+}
+DefaultChaptersMenu.displayName = "DefaultChaptersMenu";
+
+const FONT_COLOR_OPTION = {
+  type: "color"
+};
+const FONT_FAMILY_OPTION = {
+  type: "radio",
+  values: {
+    "Monospaced Serif": "mono-serif",
+    "Proportional Serif": "pro-serif",
+    "Monospaced Sans-Serif": "mono-sans",
+    "Proportional Sans-Serif": "pro-sans",
+    Casual: "casual",
+    Cursive: "cursive",
+    "Small Capitals": "capitals"
+  }
+};
+const FONT_SIZE_OPTION = {
+  type: "slider",
+  min: 0,
+  max: 400,
+  step: 25,
+  upIcon: null,
+  downIcon: null
+};
+const FONT_OPACITY_OPTION = {
+  type: "slider",
+  min: 0,
+  max: 100,
+  step: 5,
+  upIcon: null,
+  downIcon: null
+};
+const FONT_TEXT_SHADOW_OPTION = {
+  type: "radio",
+  values: ["None", "Drop Shadow", "Raised", "Depressed", "Outline"]
+};
+const FONT_DEFAULTS = {
+  fontFamily: "pro-sans",
+  fontSize: "100%",
+  textColor: "#ffffff",
+  textOpacity: "100%",
+  textShadow: "none",
+  textBg: "#000000",
+  textBgOpacity: "100%",
+  displayBg: "#000000",
+  displayBgOpacity: "0%"
+};
+const FONT_SIGNALS = Object.keys(FONT_DEFAULTS).reduce(
+  (prev, type) => ({
+    ...prev,
+    [type]: signal(FONT_DEFAULTS[type])
+  }),
+  {}
+);
+if (!IS_SERVER) {
+  for (const type of Object.keys(FONT_SIGNALS)) {
+    const value = localStorage.getItem(`vds-player:${camelToKebabCase(type)}`);
+    if (isString(value)) FONT_SIGNALS[type].set(value);
+  }
+}
+function onFontReset() {
+  for (const type of Object.keys(FONT_SIGNALS)) {
+    const defaultValue = FONT_DEFAULTS[type];
+    FONT_SIGNALS[type].set(defaultValue);
+  }
+}
+
+function hexToRgb(hex) {
+  const { style } = new Option();
+  style.color = hex;
+  return style.color.match(/\((.*?)\)/)[1].replace(/,/g, " ");
+}
+
+let isWatchingVars = false, players = /* @__PURE__ */ new Set();
+function updateFontCssVars() {
+  if (IS_SERVER) return;
+  const { player } = useMediaContext$1();
+  players.add(player);
+  onDispose(() => players.delete(player));
+  if (!isWatchingVars) {
+    scoped(() => {
+      for (const type of keysOf(FONT_SIGNALS)) {
+        const $value = FONT_SIGNALS[type], defaultValue = FONT_DEFAULTS[type], varName = `--media-user-${camelToKebabCase(type)}`, storageKey = `vds-player:${camelToKebabCase(type)}`;
+        effect(() => {
+          const value = $value(), isDefaultVarValue = value === defaultValue, varValue = !isDefaultVarValue ? getCssVarValue(player, type, value) : null;
+          for (const player2 of players) {
+            player2.el?.style.setProperty(varName, varValue);
+          }
+          if (isDefaultVarValue) {
+            localStorage.removeItem(storageKey);
+          } else {
+            localStorage.setItem(storageKey, value);
+          }
+        });
+      }
+    }, null);
+    isWatchingVars = true;
+  }
+}
+function getCssVarValue(player, type, value) {
+  switch (type) {
+    case "fontFamily":
+      const fontVariant = value === "capitals" ? "small-caps" : "";
+      player.el?.style.setProperty("--media-user-font-variant", fontVariant);
+      return getFontFamilyCSSVarValue(value);
+    case "fontSize":
+    case "textOpacity":
+    case "textBgOpacity":
+    case "displayBgOpacity":
+      return percentToRatio(value);
+    case "textColor":
+      return `rgb(${hexToRgb(value)} / var(--media-user-text-opacity, 1))`;
+    case "textShadow":
+      return getTextShadowCssVarValue(value);
+    case "textBg":
+      return `rgb(${hexToRgb(value)} / var(--media-user-text-bg-opacity, 1))`;
+    case "displayBg":
+      return `rgb(${hexToRgb(value)} / var(--media-user-display-bg-opacity, 1))`;
+  }
+}
+function percentToRatio(value) {
+  return (parseInt(value) / 100).toString();
+}
+function getFontFamilyCSSVarValue(value) {
+  switch (value) {
+    case "mono-serif":
+      return '"Courier New", Courier, "Nimbus Mono L", "Cutive Mono", monospace';
+    case "mono-sans":
+      return '"Deja Vu Sans Mono", "Lucida Console", Monaco, Consolas, "PT Mono", monospace';
+    case "pro-sans":
+      return 'Roboto, "Arial Unicode Ms", Arial, Helvetica, Verdana, "PT Sans Caption", sans-serif';
+    case "casual":
+      return '"Comic Sans MS", Impact, Handlee, fantasy';
+    case "cursive":
+      return '"Monotype Corsiva", "URW Chancery L", "Apple Chancery", "Dancing Script", cursive';
+    case "capitals":
+      return '"Arial Unicode Ms", Arial, Helvetica, Verdana, "Marcellus SC", sans-serif + font-variant=small-caps';
+    default:
+      return '"Times New Roman", Times, Georgia, Cambria, "PT Serif Caption", serif';
+  }
+}
+function getTextShadowCssVarValue(value) {
+  switch (value) {
+    case "drop shadow":
+      return "rgb(34, 34, 34) 1.86389px 1.86389px 2.79583px, rgb(34, 34, 34) 1.86389px 1.86389px 3.72778px, rgb(34, 34, 34) 1.86389px 1.86389px 4.65972px";
+    case "raised":
+      return "rgb(34, 34, 34) 1px 1px, rgb(34, 34, 34) 2px 2px";
+    case "depressed":
+      return "rgb(204, 204, 204) 1px 1px, rgb(34, 34, 34) -1px -1px";
+    case "outline":
+      return "rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px";
+    default:
+      return "";
+  }
+}
+
+function DefaultMenuSection({ label, value, children }) {
+  const id = React.useId();
+  if (!label) {
+    return /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section" }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-body" }, children));
+  }
+  return /* @__PURE__ */ React.createElement("section", { className: "vds-menu-section", role: "group", "aria-labelledby": id }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-title" }, /* @__PURE__ */ React.createElement("header", { id }, label), value ? /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-value" }, value) : null), /* @__PURE__ */ React.createElement("div", { className: "vds-menu-section-body" }, children));
+}
+DefaultMenuSection.displayName = "DefaultMenuSection";
+function DefaultMenuButton({ label, hint = "", Icon, disabled = false }) {
+  const { icons: Icons } = React.useContext(DefaultLayoutContext);
+  return /* @__PURE__ */ React.createElement(Button, { className: "vds-menu-item", disabled }, /* @__PURE__ */ React.createElement(Icons.Menu.ArrowLeft, { className: "vds-menu-close-icon vds-icon" }), Icon ? /* @__PURE__ */ React.createElement(Icon, { className: "vds-menu-item-icon vds-icon" }) : null, /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-label" }, label), /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-hint" }, hint), /* @__PURE__ */ React.createElement(Icons.Menu.ArrowRight, { className: "vds-menu-open-icon vds-icon" }));
+}
+DefaultMenuButton.displayName = "DefaultMenuButton";
+function DefaultMenuItem({ label, children }) {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-menu-item" }, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-item-label" }, label), children);
+}
+DefaultMenuItem.displayName = "DefaultMenuItem";
+function DefaultMenuRadioGroup({ value, options, onChange }) {
+  const { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$1, { className: "vds-radio-group", value, onChange }, options.map((option) => /* @__PURE__ */ React.createElement(Item, { className: "vds-radio", value: option.value, key: option.value }, /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }), /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label", "data-part": "label" }, option.label))));
+}
+DefaultMenuRadioGroup.displayName = "DefaultMenuRadioGroup";
+function createRadioOptions(entries) {
+  return React.useMemo(
+    () => isArray(entries) ? entries.map((entry) => ({ label: entry, value: entry.toLowerCase() })) : Object.keys(entries).map((label) => ({ label, value: entries[label] })),
+    [entries]
+  );
+}
+
+function DefaultMenuSliderItem({
+  label,
+  value,
+  UpIcon,
+  DownIcon,
+  children,
+  isMin,
+  isMax
+}) {
+  const hasTitle = label || value, Content = /* @__PURE__ */ React.createElement(React.Fragment, null, DownIcon ? /* @__PURE__ */ React.createElement(DownIcon, { className: "vds-icon down" }) : null, children, UpIcon ? /* @__PURE__ */ React.createElement(UpIcon, { className: "vds-icon up" }) : null);
+  return /* @__PURE__ */ React.createElement(
+    "div",
+    {
+      className: `vds-menu-item vds-menu-slider-item${hasTitle ? " group" : ""}`,
+      "data-min": isMin ? "" : null,
+      "data-max": isMax ? "" : null
+    },
+    hasTitle ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: "vds-menu-slider-title" }, label ? /* @__PURE__ */ React.createElement("div", null, label) : null, value ? /* @__PURE__ */ React.createElement("div", null, value) : null), /* @__PURE__ */ React.createElement("div", { className: "vds-menu-slider-body" }, Content)) : Content
+  );
+}
+DefaultMenuSliderItem.displayName = "DefaultMenuSliderItem";
+function DefaultSliderParts() {
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }));
+}
+DefaultSliderParts.displayName = "DefaultSliderParts";
+function DefaultSliderSteps() {
+  return /* @__PURE__ */ React.createElement(Steps, { className: "vds-slider-steps" }, (step) => /* @__PURE__ */ React.createElement("div", { className: "vds-slider-step", key: String(step) }));
+}
+DefaultSliderSteps.displayName = "DefaultSliderSteps";
+
+function DefaultFontMenu() {
+  const label = useDefaultLayoutWord("Caption Styles"), $hasCaptions = useMediaState("hasCaptions"), fontSectionLabel = useDefaultLayoutWord("Font"), textSectionLabel = useDefaultLayoutWord("Text"), textBgSectionLabel = useDefaultLayoutWord("Text Background"), displayBgSectionLabel = useDefaultLayoutWord("Display Background");
+  if (!$hasCaptions) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-font-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label }), /* @__PURE__ */ React.createElement(Items, { className: "vds-font-style-items vds-menu-items" }, /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: fontSectionLabel }, /* @__PURE__ */ React.createElement(DefaultFontFamilyMenu, null), /* @__PURE__ */ React.createElement(DefaultFontSizeSlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: textSectionLabel }, /* @__PURE__ */ React.createElement(DefaultTextColorInput, null), /* @__PURE__ */ React.createElement(DefaultTextShadowMenu, null), /* @__PURE__ */ React.createElement(DefaultTextOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: textBgSectionLabel }, /* @__PURE__ */ React.createElement(DefaultTextBgInput, null), /* @__PURE__ */ React.createElement(DefaultTextBgOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, { label: displayBgSectionLabel }, /* @__PURE__ */ React.createElement(DefaultDisplayBgInput, null), /* @__PURE__ */ React.createElement(DefaultDisplayBgOpacitySlider, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultResetMenuItem, null))));
+}
+DefaultFontMenu.displayName = "DefaultFontMenu";
+function DefaultFontFamilyMenu() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Family", type: "fontFamily", option: FONT_FAMILY_OPTION });
+}
+DefaultFontFamilyMenu.displayName = "DefaultFontFamilyMenu";
+function DefaultFontSizeSlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_SIZE_OPTION,
+    upIcon: Icons.Menu.FontSizeUp,
+    downIcon: Icons.Menu.FontSizeDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Size", type: "fontSize", option });
+}
+DefaultFontSizeSlider.displayName = "DefaultFontSizeSlider";
+function DefaultTextColorInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "textColor", option: FONT_COLOR_OPTION });
+}
+DefaultTextColorInput.displayName = "DefaultTextColorInput";
+function DefaultTextOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "textOpacity", option });
+}
+DefaultTextOpacitySlider.displayName = "DefaultTextOpacitySlider";
+function DefaultTextShadowMenu() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Shadow", type: "textShadow", option: FONT_TEXT_SHADOW_OPTION });
+}
+DefaultTextShadowMenu.displayName = "DefaultTextShadowMenu";
+function DefaultTextBgInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "textBg", option: FONT_COLOR_OPTION });
+}
+DefaultTextBgInput.displayName = "DefaultTextBgInput";
+function DefaultTextBgOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "textBgOpacity", option });
+}
+DefaultTextBgOpacitySlider.displayName = "DefaultTextBgOpacitySlider";
+function DefaultDisplayBgInput() {
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Color", type: "displayBg", option: FONT_COLOR_OPTION });
+}
+DefaultDisplayBgInput.displayName = "DefaultDisplayBgInput";
+function DefaultDisplayBgOpacitySlider() {
+  const { icons: Icons } = useDefaultLayoutContext(), option = {
+    ...FONT_OPACITY_OPTION,
+    upIcon: Icons.Menu.OpacityUp,
+    downIcon: Icons.Menu.OpacityDown
+  };
+  return /* @__PURE__ */ React.createElement(DefaultFontSetting, { label: "Opacity", type: "displayBgOpacity", option });
+}
+DefaultDisplayBgOpacitySlider.displayName = "DefaultDisplayBgOpacitySlider";
+function DefaultFontSetting({ label, option, type }) {
+  const player = useMediaPlayer(), $currentValue = FONT_SIGNALS[type], $value = useSignal($currentValue), translatedLabel = useDefaultLayoutWord(label);
+  const notify = React.useCallback(() => {
+    player?.dispatchEvent(new Event("vds-font-change"));
+  }, [player]);
+  const onChange = React.useCallback(
+    (newValue) => {
+      $currentValue.set(newValue);
+      notify();
+    },
+    [$currentValue, notify]
+  );
+  if (option.type === "color") {
+    let onColorChange2 = function(event) {
+      onChange(event.target.value);
+    };
+    return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label: translatedLabel }, /* @__PURE__ */ React.createElement("input", { className: "vds-color-picker", type: "color", value: $value, onChange: onColorChange2 }));
+  }
+  if (option.type === "slider") {
+    let onSliderValueChange2 = function(value) {
+      onChange(value + "%");
+    };
+    const { min, max, step, upIcon, downIcon } = option;
+    return /* @__PURE__ */ React.createElement(
+      DefaultMenuSliderItem,
+      {
+        label: translatedLabel,
+        value: $value,
+        UpIcon: upIcon,
+        DownIcon: downIcon,
+        isMin: $value === min + "%",
+        isMax: $value === max + "%"
+      },
+      /* @__PURE__ */ React.createElement(
+        Root$4,
+        {
+          className: "vds-slider",
+          min,
+          max,
+          step,
+          keyStep: step,
+          value: parseInt($value),
+          "aria-label": translatedLabel,
+          onValueChange: onSliderValueChange2,
+          onDragValueChange: onSliderValueChange2
+        },
+        /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+        /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+      )
+    );
+  }
+  if (option.type === "radio") {
+    return /* @__PURE__ */ React.createElement(
+      DefaultFontRadioGroup,
+      {
+        id: camelToKebabCase(type),
+        label: translatedLabel,
+        value: $value,
+        values: option.values,
+        onChange
+      }
+    );
+  }
+  return null;
+}
+DefaultFontSetting.displayName = "DefaultFontSetting";
+function DefaultFontRadioGroup({ id, label, value, values, onChange }) {
+  const radioOptions = createRadioOptions(values), { translations } = useDefaultLayoutContext(), hint = React.useMemo(() => {
+    const label2 = radioOptions.find((radio) => radio.value === value)?.label || "";
+    return i18n(translations, label2);
+  }, [value, radioOptions]);
+  return /* @__PURE__ */ React.createElement(Root$3, { className: `vds-${id}-menu vds-menu` }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, hint }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, /* @__PURE__ */ React.createElement(DefaultMenuRadioGroup, { value, options: radioOptions, onChange })));
+}
+DefaultFontRadioGroup.displayName = "DefaultFontRadioGroup";
+function DefaultResetMenuItem() {
+  const resetText = useDefaultLayoutWord("Reset");
+  return /* @__PURE__ */ React.createElement("button", { className: "vds-menu-item", role: "menuitem", onClick: onFontReset }, /* @__PURE__ */ React.createElement("span", { className: "vds-menu-item-label" }, resetText));
+}
+DefaultResetMenuItem.displayName = "DefaultResetMenuItem";
+
+function DefaultMenuCheckbox({
+  label,
+  checked,
+  storageKey,
+  defaultChecked = false,
+  onChange
+}) {
+  const [isChecked, setIsChecked] = React.useState(defaultChecked), [isActive, setIsActive] = React.useState(false);
+  React.useEffect(() => {
+    const savedValue = storageKey ? localStorage.getItem(storageKey) : null, checked2 = !!(savedValue ?? defaultChecked);
+    setIsChecked(checked2);
+    onChange?.(checked2);
+  }, []);
+  React.useEffect(() => {
+    if (isBoolean(checked)) setIsChecked(checked);
+  }, [checked]);
+  function onPress(event) {
+    if (event && "button" in event && event?.button === 1) return;
+    const toggledCheck = !isChecked;
+    setIsChecked(toggledCheck);
+    if (storageKey) localStorage.setItem(storageKey, toggledCheck ? "1" : "");
+    onChange?.(toggledCheck, event?.nativeEvent);
+    setIsActive(false);
+  }
+  function onActive(event) {
+    if (event.button !== 0) return;
+    setIsActive(true);
+  }
+  function onKeyDown(event) {
+    if (isKeyboardClick(event.nativeEvent)) onPress();
+  }
+  return /* @__PURE__ */ React.createElement(
+    "div",
+    {
+      className: "vds-menu-checkbox",
+      role: "menuitemcheckbox",
+      tabIndex: 0,
+      "aria-label": label,
+      "aria-checked": isChecked ? "true" : "false",
+      "data-active": isActive ? "" : null,
+      onPointerUp: onPress,
+      onPointerDown: onActive,
+      onKeyDown
+    }
+  );
+}
+DefaultMenuCheckbox.displayName = "DefaultMenuCheckbox";
+
+function DefaultAccessibilityMenu({ slots }) {
+  const label = useDefaultLayoutWord("Accessibility"), { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-accessibility-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Accessibility }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "accessibilityMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultAnnouncementsMenuCheckbox, null), /* @__PURE__ */ React.createElement(DefaultKeyboardAnimationsMenuCheckbox, null)), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, /* @__PURE__ */ React.createElement(DefaultFontMenu, null)), slot(slots, "accessibilityMenuItemsEnd", null)));
+}
+DefaultAccessibilityMenu.displayName = "DefaultAccessibilityMenu";
+function DefaultAnnouncementsMenuCheckbox() {
+  const { userPrefersAnnouncements } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Announcements");
+  function onChange(checked) {
+    userPrefersAnnouncements.set(checked);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      defaultChecked: true,
+      storageKey: "vds-player::announcements",
+      onChange
+    }
+  ));
+}
+DefaultAnnouncementsMenuCheckbox.displayName = "DefaultAnnouncementsMenuCheckbox";
+function DefaultKeyboardAnimationsMenuCheckbox() {
+  const $viewType = useMediaState("viewType"), { userPrefersKeyboardAnimations, noKeyboardAnimations } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Keyboard Animations");
+  if ($viewType !== "video" || noKeyboardAnimations) return null;
+  function onChange(checked) {
+    userPrefersKeyboardAnimations.set(checked);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      defaultChecked: true,
+      storageKey: "vds-player::keyboard-animations",
+      onChange
+    }
+  ));
+}
+DefaultKeyboardAnimationsMenuCheckbox.displayName = "DefaultKeyboardAnimationsMenuCheckbox";
+
+function DefaultAudioMenu({ slots }) {
+  const label = useDefaultLayoutWord("Audio"), $canSetAudioGain = useMediaState("canSetAudioGain"), $audioTracks = useMediaState("audioTracks"), { noAudioGain, icons: Icons } = useDefaultLayoutContext(), hasGainSlider = $canSetAudioGain && !noAudioGain, $disabled = !hasGainSlider && $audioTracks.length <= 1;
+  if ($disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-audio-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Audio }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "audioMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultAudioTracksMenu, null), hasGainSlider ? /* @__PURE__ */ React.createElement(DefaultAudioBoostMenuSection, null) : null, slot(slots, "audioMenuItemsEnd", null)));
+}
+DefaultAudioMenu.displayName = "DefaultAudioMenu";
+function DefaultAudioBoostMenuSection() {
+  const $audioGain = useMediaState("audioGain"), label = useDefaultLayoutWord("Boost"), value = Math.round((($audioGain ?? 1) - 1) * 100) + "%", $canSetAudioGain = useMediaState("canSetAudioGain"), { noAudioGain, icons: Icons } = useDefaultLayoutContext(), $disabled = !$canSetAudioGain || noAudioGain, min = useGainMin(), max = useGainMax();
+  if ($disabled) return null;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.AudioBoostUp,
+      DownIcon: Icons.Menu.AudioBoostDown,
+      isMin: (($audioGain ?? 1) - 1) * 100 <= min,
+      isMax: (($audioGain ?? 1) - 1) * 100 === max
+    },
+    /* @__PURE__ */ React.createElement(DefaultAudioGainSlider, null)
+  ));
+}
+DefaultAudioBoostMenuSection.displayName = "DefaultAudioBoostMenuSection";
+function useGainMin() {
+  const { audioGains } = useDefaultLayoutContext(), min = isArray(audioGains) ? audioGains[0] : audioGains?.min;
+  return min ?? 0;
+}
+function useGainMax() {
+  const { audioGains } = useDefaultLayoutContext(), max = isArray(audioGains) ? audioGains[audioGains.length - 1] : audioGains?.max;
+  return max ?? 300;
+}
+function useGainStep() {
+  const { audioGains } = useDefaultLayoutContext(), step = isArray(audioGains) ? audioGains[1] - audioGains[0] : audioGains?.step;
+  return step || 25;
+}
+function DefaultAudioGainSlider() {
+  const label = useDefaultLayoutWord("Audio Boost"), min = useGainMin(), max = useGainMax(), step = useGainStep();
+  return /* @__PURE__ */ React.createElement(
+    Root$5,
+    {
+      className: "vds-audio-gain-slider vds-slider",
+      "aria-label": label,
+      min,
+      max,
+      step,
+      keyStep: step
+    },
+    /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+    /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+  );
+}
+DefaultAudioGainSlider.displayName = "DefaultAudioGainSlider";
+function DefaultAudioTracksMenu() {
+  const { icons: Icons } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Track"), defaultText = useDefaultLayoutWord("Default"), $track = useMediaState("audioTrack"), options = useAudioOptions();
+  if (options.disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-audio-track-menu vds-menu" }, /* @__PURE__ */ React.createElement(
+    DefaultMenuButton,
+    {
+      label,
+      hint: $track?.label ?? defaultText,
+      disabled: options.disabled,
+      Icon: Icons.Menu.Audio
+    }
+  ), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, /* @__PURE__ */ React.createElement(
+    Root$1,
+    {
+      className: "vds-audio-radio-group vds-radio-group",
+      value: options.selectedValue
+    },
+    options.map(({ label: label2, value, select }) => /* @__PURE__ */ React.createElement(
+      Item,
+      {
+        className: "vds-audio-radio vds-radio",
+        value,
+        onSelect: select,
+        key: value
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }),
+      /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label" }, label2)
+    ))
+  )));
+}
+DefaultAudioTracksMenu.displayName = "DefaultAudioTracksMenu";
+
+function DefaultCaptionMenu({ slots }) {
+  const { icons: Icons } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Captions"), offText = useDefaultLayoutWord("Off"), options = useCaptionOptions({ off: offText }), hint = options.selectedTrack?.label ?? offText;
+  if (options.disabled) return null;
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-captions-menu vds-menu" }, /* @__PURE__ */ React.createElement(
+    DefaultMenuButton,
+    {
+      label,
+      hint,
+      disabled: options.disabled,
+      Icon: Icons.Menu.Captions
+    }
+  ), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "captionsMenuItemsStart", null), /* @__PURE__ */ React.createElement(
+    Root$1,
+    {
+      className: "vds-captions-radio-group vds-radio-group",
+      value: options.selectedValue
+    },
+    options.map(({ label: label2, value, select }) => /* @__PURE__ */ React.createElement(
+      Item,
+      {
+        className: "vds-caption-radio vds-radio",
+        value,
+        onSelect: select,
+        key: value
+      },
+      /* @__PURE__ */ React.createElement(Icons.Menu.RadioCheck, { className: "vds-icon" }),
+      /* @__PURE__ */ React.createElement("span", { className: "vds-radio-label" }, label2)
+    ))
+  ), slot(slots, "captionsMenuItemsEnd", null)));
+}
+DefaultCaptionMenu.displayName = "DefaultCaptionMenu";
+
+function DefaultPlaybackMenu({ slots }) {
+  const label = useDefaultLayoutWord("Playback"), { icons: Icons } = useDefaultLayoutContext();
+  return /* @__PURE__ */ React.createElement(Root$3, { className: "vds-playback-menu vds-menu" }, /* @__PURE__ */ React.createElement(DefaultMenuButton, { label, Icon: Icons.Menu.Playback }), /* @__PURE__ */ React.createElement(Items, { className: "vds-menu-items" }, slot(slots, "playbackMenuItemsStart", null), /* @__PURE__ */ React.createElement(DefaultMenuSection, null, slot(slots, "playbackMenuLoop", /* @__PURE__ */ React.createElement(DefaultLoopMenuCheckbox, null))), /* @__PURE__ */ React.createElement(DefaultSpeedMenuSection, null), /* @__PURE__ */ React.createElement(DefaultQualityMenuSection, null), slot(slots, "playbackMenuItemsEnd", null)));
+}
+DefaultPlaybackMenu.displayName = "DefaultPlaybackMenu";
+function DefaultLoopMenuCheckbox() {
+  const { remote } = useMediaContext(), label = useDefaultLayoutWord("Loop");
+  function onChange(checked, trigger) {
+    remote.userPrefersLoopChange(checked, trigger);
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(DefaultMenuCheckbox, { label, storageKey: "vds-player::user-loop", onChange }));
+}
+DefaultLoopMenuCheckbox.displayName = "DefaultLoopMenuCheckbox";
+function DefaultAutoQualityMenuCheckbox() {
+  const { remote, qualities } = useMediaContext(), $autoQuality = useMediaState("autoQuality"), label = useDefaultLayoutWord("Auto");
+  function onChange(checked, trigger) {
+    if (checked) {
+      remote.requestAutoQuality(trigger);
+    } else {
+      remote.changeQuality(qualities.selectedIndex, trigger);
+    }
+  }
+  return /* @__PURE__ */ React.createElement(DefaultMenuItem, { label }, /* @__PURE__ */ React.createElement(
+    DefaultMenuCheckbox,
+    {
+      label,
+      checked: $autoQuality,
+      onChange,
+      defaultChecked: $autoQuality
+    }
+  ));
+}
+DefaultAutoQualityMenuCheckbox.displayName = "DefaultAutoQualityMenuCheckbox";
+function DefaultQualityMenuSection() {
+  const { hideQualityBitrate, icons: Icons } = useDefaultLayoutContext(), $canSetQuality = useMediaState("canSetQuality"), $qualities = useMediaState("qualities"), $quality = useMediaState("quality"), label = useDefaultLayoutWord("Quality"), autoText = useDefaultLayoutWord("Auto"), sortedQualities = React.useMemo(() => sortVideoQualities($qualities), [$qualities]);
+  if (!$canSetQuality || $qualities.length <= 1) return null;
+  const height = $quality?.height, bitrate = !hideQualityBitrate ? $quality?.bitrate : null, bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null, value = height ? `${height}p${bitrateText ? ` (${bitrateText})` : ""}` : autoText, isMin = sortedQualities[0] === $quality, isMax = sortedQualities.at(-1) === $quality;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.QualityUp,
+      DownIcon: Icons.Menu.QualityDown,
+      isMin,
+      isMax
+    },
+    /* @__PURE__ */ React.createElement(DefaultQualitySlider, null)
+  ), /* @__PURE__ */ React.createElement(DefaultAutoQualityMenuCheckbox, null));
+}
+DefaultQualityMenuSection.displayName = "DefaultQualityMenuSection";
+function DefaultQualitySlider() {
+  const label = useDefaultLayoutWord("Quality");
+  return /* @__PURE__ */ React.createElement(Root$6, { className: "vds-quality-slider vds-slider", "aria-label": label }, /* @__PURE__ */ React.createElement(DefaultSliderParts, null), /* @__PURE__ */ React.createElement(DefaultSliderSteps, null));
+}
+DefaultQualitySlider.displayName = "DefaultQualitySlider";
+function DefaultSpeedMenuSection() {
+  const { icons: Icons } = useDefaultLayoutContext(), $playbackRate = useMediaState("playbackRate"), $canSetPlaybackRate = useMediaState("canSetPlaybackRate"), label = useDefaultLayoutWord("Speed"), normalText = useDefaultLayoutWord("Normal"), min = useSpeedMin(), max = useSpeedMax(), value = $playbackRate === 1 ? normalText : $playbackRate + "x";
+  if (!$canSetPlaybackRate) return null;
+  return /* @__PURE__ */ React.createElement(DefaultMenuSection, { label, value }, /* @__PURE__ */ React.createElement(
+    DefaultMenuSliderItem,
+    {
+      UpIcon: Icons.Menu.SpeedUp,
+      DownIcon: Icons.Menu.SpeedDown,
+      isMin: $playbackRate === min,
+      isMax: $playbackRate === max
+    },
+    /* @__PURE__ */ React.createElement(DefaultSpeedSlider, null)
+  ));
+}
+function useSpeedMin() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[0] : rates?.min) ?? 0;
+}
+function useSpeedMax() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[rates.length - 1] : rates?.max) ?? 2;
+}
+function useSpeedStep() {
+  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates;
+  return (isArray(rates) ? rates[1] - rates[0] : rates?.step) || 0.25;
+}
+function DefaultSpeedSlider() {
+  const label = useDefaultLayoutWord("Speed"), min = useSpeedMin(), max = useSpeedMax(), step = useSpeedStep();
+  return /* @__PURE__ */ React.createElement(
+    Root$7,
+    {
+      className: "vds-speed-slider vds-slider",
+      "aria-label": label,
+      min,
+      max,
+      step,
+      keyStep: step
+    },
+    /* @__PURE__ */ React.createElement(DefaultSliderParts, null),
+    /* @__PURE__ */ React.createElement(DefaultSliderSteps, null)
+  );
+}
+DefaultSpeedSlider.displayName = "DefaultSpeedSlider";
+
+function DefaultSettingsMenu({
+  tooltip,
+  placement,
+  portalClass = "",
+  slots
+}) {
+  const {
+    showMenuDelay,
+    icons: Icons,
+    isSmallLayout,
+    menuContainer,
+    menuGroup,
+    noModal,
+    colorScheme
+  } = useDefaultLayoutContext(), settingsText = useDefaultLayoutWord("Settings"), $viewType = useMediaState("viewType"), $offset = !isSmallLayout && menuGroup === "bottom" && $viewType === "video" ? 26 : 0, colorSchemeClass = useColorSchemeClass(colorScheme), [isOpen, setIsOpen] = React.useState(false), dialogEl = useParentDialogEl();
+  useScoped(updateFontCssVars);
+  function onOpen() {
+    flushSync(() => {
+      setIsOpen(true);
+    });
+  }
+  function onClose() {
+    setIsOpen(false);
+  }
+  const Content = /* @__PURE__ */ React.createElement(
+    Items,
+    {
+      className: "vds-settings-menu-items vds-menu-items",
+      placement,
+      offset: $offset
+    },
+    isOpen ? /* @__PURE__ */ React.createElement(React.Fragment, null, slot(slots, "settingsMenuItemsStart", null), slot(slots, "settingsMenuStartItems", null), /* @__PURE__ */ React.createElement(DefaultPlaybackMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultAccessibilityMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultAudioMenu, { slots }), /* @__PURE__ */ React.createElement(DefaultCaptionMenu, { slots }), slot(slots, "settingsMenuEndItems", null), slot(slots, "settingsMenuItemsEnd", null)) : null
+  );
+  return /* @__PURE__ */ React.createElement(
+    Root$3,
+    {
+      className: "vds-settings-menu vds-menu",
+      showDelay: showMenuDelay,
+      onOpen,
+      onClose
+    },
+    /* @__PURE__ */ React.createElement(DefaultTooltip, { content: settingsText, placement: tooltip }, /* @__PURE__ */ React.createElement(Button, { className: "vds-menu-button vds-button", "aria-label": settingsText }, /* @__PURE__ */ React.createElement(Icons.Menu.Settings, { className: "vds-icon vds-rotate-icon" }))),
+    noModal || !isSmallLayout ? Content : /* @__PURE__ */ React.createElement(
+      Portal,
+      {
+        className: portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : ""),
+        container: menuContainer ?? dialogEl,
+        disabled: "fullscreen",
+        "data-sm": isSmallLayout ? "" : null,
+        "data-lg": !isSmallLayout ? "" : null,
+        "data-size": isSmallLayout ? "sm" : "lg",
+        "data-view-type": $viewType
+      },
+      Content
+    )
+  );
+}
+DefaultSettingsMenu.displayName = "DefaultSettingsMenu";
+
+function DefaultVolumePopup({ tooltip, orientation, slots }) {
+  const $pointer = useMediaState("pointer"), $muted = useMediaState("muted"), $canSetVolume = useMediaState("canSetVolume"), [rootEl, setRootEl] = React.useState(null), isRootActive = useActive(rootEl), muteButton = slot(slots, "muteButton", /* @__PURE__ */ React.createElement(DefaultMuteButton, { tooltip }));
+  if (!$canSetVolume) {
+    return muteButton;
+  }
+  return $pointer === "coarse" && !$muted ? null : /* @__PURE__ */ React.createElement("div", { className: "vds-volume", "data-active": isRootActive ? "" : null, ref: setRootEl }, muteButton, /* @__PURE__ */ React.createElement("div", { className: "vds-volume-popup" }, slot(slots, "volumeSlider", /* @__PURE__ */ React.createElement(DefaultVolumeSlider, { orientation }))));
+}
+DefaultVolumePopup.displayName = "DefaultVolumePopup";
+function DefaultVolumeSlider(props) {
+  const label = useDefaultLayoutWord("Volume");
+  return /* @__PURE__ */ React.createElement(Root$8, { className: "vds-volume-slider vds-slider", "aria-label": label, ...props }, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }), /* @__PURE__ */ React.createElement(Preview, { className: "vds-slider-preview", noClamp: true }, /* @__PURE__ */ React.createElement(Value, { className: "vds-slider-value" })));
+}
+DefaultVolumeSlider.displayName = "DefaultVolumeSlider";
+function DefaultTimeSlider() {
+  const [instance, setInstance] = React.useState(null), [width, setWidth] = React.useState(0), $src = useMediaState("currentSrc"), { thumbnails, sliderChaptersMinWidth, disableTimeSlider, seekStep, noScrubGesture } = useDefaultLayoutContext(), label = useDefaultLayoutWord("Seek"), $RemotionSliderThumbnail = useSignal(RemotionSliderThumbnail);
+  const onResize = React.useCallback(() => {
+    const el = instance?.el;
+    el && setWidth(el.clientWidth);
+  }, [instance]);
+  useResizeObserver(instance?.el, onResize);
+  return /* @__PURE__ */ React.createElement(
+    Root$9,
+    {
+      className: "vds-time-slider vds-slider",
+      "aria-label": label,
+      disabled: disableTimeSlider,
+      noSwipeGesture: noScrubGesture,
+      keyStep: seekStep,
+      ref: setInstance
+    },
+    /* @__PURE__ */ React.createElement(
+      Chapters,
+      {
+        className: "vds-slider-chapters",
+        disabled: width < sliderChaptersMinWidth
+      },
+      (cues, forwardRef) => cues.map((cue) => /* @__PURE__ */ React.createElement("div", { className: "vds-slider-chapter", key: cue.startTime, ref: forwardRef }, /* @__PURE__ */ React.createElement(Track, { className: "vds-slider-track" }), /* @__PURE__ */ React.createElement(TrackFill, { className: "vds-slider-track-fill vds-slider-track" }), /* @__PURE__ */ React.createElement(Progress, { className: "vds-slider-progress vds-slider-track" })))
+    ),
+    /* @__PURE__ */ React.createElement(Thumb, { className: "vds-slider-thumb" }),
+    /* @__PURE__ */ React.createElement(Preview, { className: "vds-slider-preview" }, thumbnails ? /* @__PURE__ */ React.createElement(
+      Thumbnail.Root,
+      {
+        src: thumbnails,
+        className: "vds-slider-thumbnail vds-thumbnail"
+      },
+      /* @__PURE__ */ React.createElement(Thumbnail.Img, null)
+    ) : $RemotionSliderThumbnail && isRemotionSrc($src) ? /* @__PURE__ */ React.createElement($RemotionSliderThumbnail, { className: "vds-slider-thumbnail vds-thumbnail" }) : null, /* @__PURE__ */ React.createElement(ChapterTitle, { className: "vds-slider-chapter-title" }), /* @__PURE__ */ React.createElement(Value, { className: "vds-slider-value" }))
+  );
+}
+DefaultTimeSlider.displayName = "DefaultTimeSlider";
+
+function DefaultTimeGroup({ slots }) {
+  const $duration = useMediaState("duration");
+  if (!$duration) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-time-group" }, slot(slots, "currentTime", /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "current" })), slot(slots, "timeSeparator", /* @__PURE__ */ React.createElement("div", { className: "vds-time-divider" }, "/")), slot(slots, "endTime", /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "duration" })));
+}
+DefaultTimeGroup.displayName = "DefaultTimeGroup";
+function DefaultTimeInfo({ slots }) {
+  const $live = useMediaState("live");
+  return $live ? slot(slots, "liveButton", /* @__PURE__ */ React.createElement(DefaultLiveButton, null)) : /* @__PURE__ */ React.createElement(DefaultTimeGroup, { slots });
+}
+DefaultTimeInfo.displayName = "DefaultTimeInfo";
+function DefaultTimeInvert({ slots }) {
+  const $live = useMediaState("live"), $duration = useMediaState("duration");
+  return $live ? slot(slots, "liveButton", /* @__PURE__ */ React.createElement(DefaultLiveButton, null)) : slot(
+    slots,
+    "endTime",
+    $duration ? /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "current", toggle: true, remainder: true }) : null
+  );
+}
+DefaultTimeInvert.displayName = "DefaultTimeInvert";
+
+const MediaLayout$1 = createDefaultMediaLayout({
+  type: "audio",
+  smLayoutWhen({ width }) {
+    return width < 576;
+  },
+  renderLayout: () => /* @__PURE__ */ React.createElement(AudioLayout, null)
+});
+function DefaultAudioLayout(props) {
+  const [scrubbing, setScrubbing] = React.useState(false), $pointer = useMediaState("pointer");
+  const onStartScrubbing = React.useCallback((event) => {
+    const { target } = event, hasTimeSlider = !!(target instanceof HTMLElement && target.closest(".vds-time-slider"));
+    if (!hasTimeSlider) return;
+    event.nativeEvent.stopImmediatePropagation();
+    setScrubbing(true);
+  }, []);
+  const onStopScrubbing = React.useCallback(() => {
+    setScrubbing(false);
+  }, []);
+  React.useEffect(() => {
+    if (scrubbing) return listenEvent(window, "pointerdown", onStopScrubbing);
+  }, [scrubbing, onStopScrubbing]);
+  return /* @__PURE__ */ React.createElement(
+    MediaLayout$1,
+    {
+      ...props,
+      "data-scrubbing": scrubbing ? "" : null,
+      onPointerDown: scrubbing ? (e) => e.stopPropagation() : void 0,
+      onPointerDownCapture: $pointer === "coarse" && !scrubbing ? onStartScrubbing : void 0
+    }
+  );
+}
+DefaultAudioLayout.displayName = "DefaultAudioLayout";
+function AudioLayout() {
+  const slots = useDefaultAudioLayoutSlots();
+  useLayoutName("audio");
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultCaptions, null), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "seekBackwardButton", /* @__PURE__ */ React.createElement(DefaultSeekButton, { backward: true, tooltip: "top start" })), slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top center" })), slot(slots, "seekForwardButton", /* @__PURE__ */ React.createElement(DefaultSeekButton, { tooltip: "top center" })), /* @__PURE__ */ React.createElement(DefaultAudioTitle, null), slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null)), /* @__PURE__ */ React.createElement(DefaultTimeInvert, { slots }), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "vertical", tooltip: "top", slots }), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "top center" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), /* @__PURE__ */ React.createElement(DefaultAudioMenus, { slots }))));
+}
+AudioLayout.displayName = "AudioLayout";
+function DefaultAudioMenus({ slots }) {
+  const { isSmallLayout, noModal } = useDefaultLayoutContext(), placement = noModal ? "top end" : !isSmallLayout ? "top end" : null;
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slot(
+    slots,
+    "chaptersMenu",
+    /* @__PURE__ */ React.createElement(DefaultChaptersMenu, { tooltip: "top", placement, portalClass: "vds-audio-layout" })
+  ), slot(
+    slots,
+    "settingsMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultSettingsMenu,
+      {
+        tooltip: "top end",
+        placement,
+        portalClass: "vds-audio-layout",
+        slots
+      }
+    )
+  ));
+}
+DefaultAudioMenus.displayName = "DefaultAudioMenus";
+function DefaultAudioTitle() {
+  const [rootEl, setRootEl] = React.useState(null), media = useMediaContext(), { translations } = useDefaultLayoutContext(), [isTextOverflowing, setIsTextOverflowing] = React.useState(false);
+  const isContinued = createComputed(() => {
+    const { started, currentTime } = media.$state;
+    return started() || currentTime() > 0;
+  });
+  const $title = useSignal(
+    createComputed(() => {
+      const { title, ended } = media.$state;
+      if (!title()) return "";
+      const word = ended() ? "Replay" : isContinued() ? "Continue" : "Play";
+      return `${i18n(translations, word)}: ${title()}`;
+    })
+  );
+  const chapterTitle = useChapterTitle(), $isContinued = useSignal(isContinued), $chapterTitle = $isContinued ? chapterTitle : "", isTransitionActive = useTransitionActive(rootEl);
+  React.useEffect(() => {
+    if (isTransitionActive && document.activeElement === document.body) {
+      media.player.el?.focus({ preventScroll: true });
+    }
+  }, []);
+  const onResize = React.useCallback(() => {
+    const el = rootEl, isOverflowing = !!el && !isTransitionActive && el.clientWidth < el.children[0].clientWidth;
+    if (el) toggleClass(el, "vds-marquee", isOverflowing);
+    setIsTextOverflowing(isOverflowing);
+  }, [rootEl, isTransitionActive]);
+  useResizeObserver(rootEl, onResize);
+  return $title ? /* @__PURE__ */ React.createElement("span", { className: "vds-title", title: $title, ref: setRootEl }, /* @__PURE__ */ React.createElement(AudioTitle, { title: $title, chapterTitle: $chapterTitle }), isTextOverflowing && !isTransitionActive ? /* @__PURE__ */ React.createElement(AudioTitle, { title: $title, chapterTitle: $chapterTitle }) : null) : /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null);
+}
+DefaultAudioTitle.displayName = "DefaultAudioTitle";
+function AudioTitle({ title, chapterTitle }) {
+  const slots = useDefaultAudioLayoutSlots();
+  return /* @__PURE__ */ React.createElement("span", { className: "vds-title-text" }, slot(slots, "title", title), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement("span", { className: "vds-chapter-title" }, chapterTitle)));
+}
+AudioTitle.displayName = "AudioTitle";
+
+const DefaultKeyboardDisplay = React.forwardRef(
+  ({ icons: Icons, ...props }, forwardRef) => {
+    const [visible, setVisible] = React.useState(false), [Icon, setIcon] = React.useState(null), [count, setCount] = React.useState(0), $lastKeyboardAction = useMediaState("lastKeyboardAction");
+    React.useEffect(() => {
+      setCount((n) => n + 1);
+    }, [$lastKeyboardAction]);
+    const actionDataAttr = React.useMemo(() => {
+      const action = $lastKeyboardAction?.action;
+      return action && visible ? camelToKebabCase(action) : null;
+    }, [visible, $lastKeyboardAction]);
+    const className = React.useMemo(
+      () => `vds-kb-action${!visible ? " hidden" : ""}${props.className ? ` ${props.className}` : ""}`,
+      [visible]
+    );
+    const $$text = createComputed(getText), $text = useSignal($$text);
+    createEffect(() => {
+      const Icon2 = getIcon(Icons);
+      setIcon(() => Icon2);
+    }, [Icons]);
+    React.useEffect(() => {
+      setVisible(!!$lastKeyboardAction);
+      const id = setTimeout(() => setVisible(false), 500);
+      return () => {
+        setVisible(false);
+        window.clearTimeout(id);
+      };
+    }, [$lastKeyboardAction]);
+    return Icon ? /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props,
+        className,
+        "data-action": actionDataAttr,
+        ref: forwardRef
+      },
+      /* @__PURE__ */ React.createElement("div", { className: "vds-kb-text-wrapper" }, /* @__PURE__ */ React.createElement("div", { className: "vds-kb-text" }, $text)),
+      /* @__PURE__ */ React.createElement("div", { className: "vds-kb-bezel", key: count }, /* @__PURE__ */ React.createElement("div", { className: "vds-kb-icon" }, /* @__PURE__ */ React.createElement(Icon, null)))
+    ) : null;
+  }
+);
+DefaultKeyboardDisplay.displayName = "DefaultKeyboardDisplay";
+function getText() {
+  const { $state } = useContext(mediaContext), action = $state.lastKeyboardAction()?.action, audioGain = $state.audioGain() ?? 1;
+  switch (action) {
+    case "toggleMuted":
+      return $state.muted() ? "0%" : getVolumeText($state.volume(), audioGain);
+    case "volumeUp":
+    case "volumeDown":
+      return getVolumeText($state.volume(), audioGain);
+    default:
+      return "";
+  }
+}
+function getVolumeText(volume, gain) {
+  return `${Math.round(volume * gain * 100)}%`;
+}
+function getIcon(Icons) {
+  const { $state } = useContext(mediaContext), action = $state.lastKeyboardAction()?.action;
+  switch (action) {
+    case "togglePaused":
+      return !$state.paused() ? Icons.Play : Icons.Pause;
+    case "toggleMuted":
+      return $state.muted() || $state.volume() === 0 ? Icons.Mute : $state.volume() >= 0.5 ? Icons.VolumeUp : Icons.VolumeDown;
+    case "toggleFullscreen":
+      return $state.fullscreen() ? Icons.EnterFullscreen : Icons.ExitFullscreen;
+    case "togglePictureInPicture":
+      return $state.pictureInPicture() ? Icons.EnterPiP : Icons.ExitPiP;
+    case "toggleCaptions":
+      return $state.hasCaptions() ? $state.textTrack() ? Icons.CaptionsOn : Icons.CaptionsOff : null;
+    case "volumeUp":
+      return Icons.VolumeUp;
+    case "volumeDown":
+      return Icons.VolumeDown;
+    case "seekForward":
+      return Icons.SeekForward;
+    case "seekBackward":
+      return Icons.SeekBackward;
+    default:
+      return null;
+  }
+}
+
+function DefaultTitle() {
+  const $started = useMediaState("started"), $title = useMediaState("title"), $hasChapters = useActiveTextTrack("chapters");
+  return $hasChapters && ($started || !$title) ? /* @__PURE__ */ React.createElement(ChapterTitle$1, { className: "vds-chapter-title" }) : /* @__PURE__ */ React.createElement(Title, { className: "vds-chapter-title" });
+}
+DefaultTitle.displayName = "DefaultTitle";
+
+const MediaLayout = createDefaultMediaLayout({
+  type: "video",
+  smLayoutWhen({ width, height }) {
+    return width < 576 || height < 380;
+  },
+  renderLayout(props) {
+    return /* @__PURE__ */ React.createElement(VideoLayout, { ...props });
+  }
+});
+function DefaultVideoLayout(props) {
+  return /* @__PURE__ */ React.createElement(MediaLayout, { ...props });
+}
+DefaultVideoLayout.displayName = "DefaultVideoLayout";
+function VideoLayout({ streamType, isLoadLayout, isSmallLayout }) {
+  useLayoutName("video");
+  return isLoadLayout ? /* @__PURE__ */ React.createElement(DefaultVideoLoadLayout, null) : streamType === "unknown" ? /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null) : isSmallLayout ? /* @__PURE__ */ React.createElement(DefaultVideoSmallLayout, null) : /* @__PURE__ */ React.createElement(DefaultVideoLargeLayout, null);
+}
+VideoLayout.displayName = "VideoLayout";
+function DefaultVideoLargeLayout() {
+  const { menuGroup } = useDefaultLayoutContext(), baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.largeLayout };
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultVideoGestures, null), /* @__PURE__ */ React.createElement(DefaultVideoKeyboardDisplay, null), slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "captions", /* @__PURE__ */ React.createElement(DefaultCaptions, null)), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "topControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupEnd", null), menuGroup === "top" && /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "centerControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null))), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top start" })), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "horizontal", tooltip: "top", slots }), /* @__PURE__ */ React.createElement(DefaultTimeInfo, { slots }), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement(DefaultTitle, null)), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "top" })), menuGroup === "bottom" && /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots }), slot(slots, "airPlayButton", /* @__PURE__ */ React.createElement(DefaultAirPlayButton, { tooltip: "top" })), slot(slots, "googleCastButton", /* @__PURE__ */ React.createElement(DefaultGoogleCastButton, { tooltip: "top" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), slot(slots, "pipButton", /* @__PURE__ */ React.createElement(DefaultPIPButton, { tooltip: "top" })), slot(slots, "fullscreenButton", /* @__PURE__ */ React.createElement(DefaultFullscreenButton, { tooltip: "top end" })))));
+}
+DefaultVideoLargeLayout.displayName = "DefaultVideoLargeLayout";
+function DefaultVideoSmallLayout() {
+  const baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.smallLayout };
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DefaultAnnouncer, null), /* @__PURE__ */ React.createElement(DefaultVideoGestures, null), /* @__PURE__ */ React.createElement(DefaultVideoKeyboardDisplay, null), slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "captions", /* @__PURE__ */ React.createElement(DefaultCaptions, null)), /* @__PURE__ */ React.createElement(Root$a, { className: "vds-controls" }, /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "topControlsGroupStart", null), slot(slots, "airPlayButton", /* @__PURE__ */ React.createElement(DefaultAirPlayButton, { tooltip: "top start" })), slot(slots, "googleCastButton", /* @__PURE__ */ React.createElement(DefaultGoogleCastButton, { tooltip: "top start" })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "topControlsGroupCenter", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "captionButton", /* @__PURE__ */ React.createElement(DefaultCaptionButton, { tooltip: "bottom" })), slot(slots, "downloadButton", /* @__PURE__ */ React.createElement(DefaultDownloadButton, null)), /* @__PURE__ */ React.createElement(DefaultVideoMenus, { slots }), /* @__PURE__ */ React.createElement(DefaultVolumePopup, { orientation: "vertical", tooltip: "bottom end", slots }), slot(slots, "topControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group", style: { pointerEvents: "none" } }, slot(slots, "centerControlsGroupStart", null), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupCenter", null), slot(slots, "playButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top" })), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), slot(slots, "centerControlsGroupEnd", null)), /* @__PURE__ */ React.createElement(DefaultControlsSpacer, null), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, /* @__PURE__ */ React.createElement(DefaultTimeInfo, { slots }), slot(slots, "chapterTitle", /* @__PURE__ */ React.createElement(DefaultTitle, null)), slot(slots, "fullscreenButton", /* @__PURE__ */ React.createElement(DefaultFullscreenButton, { tooltip: "top end" }))), /* @__PURE__ */ React.createElement(Group, { className: "vds-controls-group" }, slot(slots, "timeSlider", /* @__PURE__ */ React.createElement(DefaultTimeSlider, null)))), slot(slots, "startDuration", /* @__PURE__ */ React.createElement(DefaultVideoStartDuration, null)));
+}
+DefaultVideoSmallLayout.displayName = "DefaultVideoSmallLayout";
+function DefaultVideoStartDuration() {
+  const $duration = useMediaState("duration");
+  if ($duration === 0) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-start-duration" }, /* @__PURE__ */ React.createElement(Time, { className: "vds-time", type: "duration" }));
+}
+DefaultVideoStartDuration.displayName = "DefaultVideoStartDuration";
+function DefaultVideoGestures() {
+  const { noGestures } = useDefaultLayoutContext();
+  if (noGestures) return null;
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-gestures" }, /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "pointerup", action: "toggle:paused" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "pointerup", action: "toggle:controls" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "toggle:fullscreen" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "seek:-10" }), /* @__PURE__ */ React.createElement(Gesture, { className: "vds-gesture", event: "dblpointerup", action: "seek:10" }));
+}
+DefaultVideoGestures.displayName = "DefaultVideoGestures";
+function DefaultBufferingIndicator() {
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-buffering-indicator" }, /* @__PURE__ */ React.createElement(Root$b, { className: "vds-buffering-spinner" }, /* @__PURE__ */ React.createElement(Track$1, { className: "vds-buffering-track" }), /* @__PURE__ */ React.createElement(TrackFill$1, { className: "vds-buffering-track-fill" })));
+}
+DefaultBufferingIndicator.displayName = "DefaultBufferingIndicator";
+function DefaultVideoMenus({ slots }) {
+  const { isSmallLayout, noModal, menuGroup } = useDefaultLayoutContext(), side = menuGroup === "top" || isSmallLayout ? "bottom" : "top", tooltip = `${side} end`, placement = noModal ? `${side} end` : !isSmallLayout ? `${side} end` : null;
+  return /* @__PURE__ */ React.createElement(React.Fragment, null, slot(
+    slots,
+    "chaptersMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultChaptersMenu,
+      {
+        tooltip,
+        placement,
+        portalClass: "vds-video-layout"
+      }
+    )
+  ), slot(
+    slots,
+    "settingsMenu",
+    /* @__PURE__ */ React.createElement(
+      DefaultSettingsMenu,
+      {
+        tooltip,
+        placement,
+        portalClass: "vds-video-layout",
+        slots
+      }
+    )
+  ));
+}
+DefaultVideoMenus.displayName = "DefaultVideoMenus";
+function DefaultVideoLoadLayout() {
+  const { isSmallLayout } = useDefaultLayoutContext(), baseSlots = useDefaultVideoLayoutSlots(), slots = { ...baseSlots, ...baseSlots?.[isSmallLayout ? "smallLayout" : "largeLayout"] };
+  return /* @__PURE__ */ React.createElement("div", { className: "vds-load-container" }, slot(slots, "bufferingIndicator", /* @__PURE__ */ React.createElement(DefaultBufferingIndicator, null)), slot(slots, "loadButton", /* @__PURE__ */ React.createElement(DefaultPlayButton, { tooltip: "top" })));
+}
+DefaultVideoLoadLayout.displayName = "DefaultVideoLoadLayout";
+function DefaultVideoKeyboardDisplay() {
+  const { noKeyboardAnimations, icons, userPrefersKeyboardAnimations } = useDefaultLayoutContext(), $userPrefersKeyboardAnimations = useSignal(userPrefersKeyboardAnimations), disabled = noKeyboardAnimations || !$userPrefersKeyboardAnimations;
+  if (disabled || !icons.KeyboardDisplay) return null;
+  return /* @__PURE__ */ React.createElement(DefaultKeyboardDisplay, { icons: icons.KeyboardDisplay });
+}
+DefaultVideoKeyboardDisplay.displayName = "DefaultVideoKeyboardDisplay";
+
+export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultLayoutContext, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions, i18n, useDefaultLayoutContext, useDefaultLayoutWord };
diff --git a/prod/chunks/vidstack-D6rGR5oE.js b/prod/chunks/vidstack-D6rGR5oE.js
new file mode 100644
index 0000000000000000000000000000000000000000..b07b66c052af2af24a6f402f5e298e82d9e832b8
--- /dev/null
+++ b/prod/chunks/vidstack-D6rGR5oE.js
@@ -0,0 +1,159 @@
+"use client"
+
+import { IS_CHROME, IS_IOS, canGoogleCastSrc, IS_SERVER, loadScript } from './vidstack-CwFL6mmL.js';
+import { listenEvent, peek } from './vidstack-CNjv_Zem.js';
+
+function getCastFrameworkURL() {
+  return "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";
+}
+function hasLoadedCastFramework() {
+  return !!window.cast?.framework;
+}
+function isCastAvailable() {
+  return !!window.chrome?.cast?.isAvailable;
+}
+function isCastConnected() {
+  return getCastContext().getCastState() === cast.framework.CastState.CONNECTED;
+}
+function getCastContext() {
+  return window.cast.framework.CastContext.getInstance();
+}
+function getCastSession() {
+  return getCastContext().getCurrentSession();
+}
+function getCastSessionMedia() {
+  return getCastSession()?.getSessionObj().media[0];
+}
+function hasActiveCastSession(src) {
+  const contentId = getCastSessionMedia()?.media.contentId;
+  return contentId === src?.src;
+}
+function getDefaultCastOptions() {
+  return {
+    language: "en-US",
+    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
+    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
+    resumeSavedSession: true,
+    androidReceiverCompatible: true
+  };
+}
+function getCastErrorMessage(code) {
+  const defaultMessage = `Google Cast Error Code: ${code}`;
+  return defaultMessage;
+}
+function listenCastContextEvent(type, handler) {
+  return listenEvent(getCastContext(), type, handler);
+}
+
+class GoogleCastLoader {
+  name = "google-cast";
+  target;
+  #player;
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
+   */
+  get cast() {
+    return getCastContext();
+  }
+  mediaType() {
+    return "video";
+  }
+  canPlay(src) {
+    return IS_CHROME && !IS_IOS && canGoogleCastSrc(src);
+  }
+  async prompt(ctx) {
+    let loadEvent, openEvent, errorEvent;
+    try {
+      loadEvent = await this.#loadCastFramework(ctx);
+      if (!this.#player) {
+        this.#player = new cast.framework.RemotePlayer();
+        new cast.framework.RemotePlayerController(this.#player);
+      }
+      openEvent = ctx.player.createEvent("google-cast-prompt-open", {
+        trigger: loadEvent
+      });
+      ctx.player.dispatchEvent(openEvent);
+      this.#notifyRemoteStateChange(ctx, "connecting", openEvent);
+      await this.#showPrompt(peek(ctx.$props.googleCast));
+      ctx.$state.remotePlaybackInfo.set({
+        deviceName: getCastSession()?.getCastDevice().friendlyName
+      });
+      if (isCastConnected()) this.#notifyRemoteStateChange(ctx, "connected", openEvent);
+    } catch (code) {
+      const error = code instanceof Error ? code : this.#createError(
+        (code + "").toUpperCase(),
+        "Prompt failed."
+      );
+      errorEvent = ctx.player.createEvent("google-cast-prompt-error", {
+        detail: error,
+        trigger: openEvent ?? loadEvent,
+        cancelable: true
+      });
+      ctx.player.dispatch(errorEvent);
+      this.#notifyRemoteStateChange(
+        ctx,
+        isCastConnected() ? "connected" : "disconnected",
+        errorEvent
+      );
+      throw error;
+    } finally {
+      ctx.player.dispatch("google-cast-prompt-close", {
+        trigger: errorEvent ?? openEvent ?? loadEvent
+      });
+    }
+  }
+  async load(ctx) {
+    if (IS_SERVER) {
+      throw Error("[vidstack] can not load google cast provider server-side");
+    }
+    if (!this.#player) {
+      throw Error("[vidstack] google cast player was not initialized");
+    }
+    return new (await import('./vidstack-yqPUabwo.js')).GoogleCastProvider(this.#player, ctx);
+  }
+  async #loadCastFramework(ctx) {
+    if (hasLoadedCastFramework()) return;
+    const loadStartEvent = ctx.player.createEvent("google-cast-load-start");
+    ctx.player.dispatch(loadStartEvent);
+    await loadScript(getCastFrameworkURL());
+    await customElements.whenDefined("google-cast-launcher");
+    const loadedEvent = ctx.player.createEvent("google-cast-loaded", { trigger: loadStartEvent });
+    ctx.player.dispatch(loadedEvent);
+    if (!isCastAvailable()) {
+      throw this.#createError("CAST_NOT_AVAILABLE", "Google Cast not available on this platform.");
+    }
+    return loadedEvent;
+  }
+  async #showPrompt(options) {
+    this.#setOptions(options);
+    const errorCode = await this.cast.requestSession();
+    if (errorCode) {
+      throw this.#createError(
+        errorCode.toUpperCase(),
+        getCastErrorMessage(errorCode)
+      );
+    }
+  }
+  #setOptions(options) {
+    this.cast?.setOptions({
+      ...getDefaultCastOptions(),
+      ...options
+    });
+  }
+  #notifyRemoteStateChange(ctx, state, trigger) {
+    const detail = { type: "google-cast", state };
+    ctx.notify("remote-playback-change", detail, trigger);
+  }
+  #createError(code, message) {
+    const error = Error(message);
+    error.code = code;
+    return error;
+  }
+}
+
+var loader = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  GoogleCastLoader: GoogleCastLoader
+});
+
+export { getCastContext, getCastErrorMessage, getCastSession, getCastSessionMedia, hasActiveCastSession, listenCastContextEvent, loader };
diff --git a/prod/chunks/vidstack-DI1IwIaU.js b/prod/chunks/vidstack-DI1IwIaU.js
new file mode 100644
index 0000000000000000000000000000000000000000..67747f18efe534b0daabbfe692f279d1282ecd22
--- /dev/null
+++ b/prod/chunks/vidstack-DI1IwIaU.js
@@ -0,0 +1,61 @@
+"use client"
+
+import { appendParamsToURL, IS_SERVER } from './vidstack-BY07IoHR.js';
+import { signal, listenEvent, effect, peek, isString } from './vidstack-CNjv_Zem.js';
+
+class EmbedProvider {
+  #iframe;
+  src = signal("");
+  /**
+   * Defines which referrer is sent when fetching the resource.
+   *
+   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy}
+   */
+  referrerPolicy = null;
+  get iframe() {
+    return this.#iframe;
+  }
+  constructor(iframe) {
+    this.#iframe = iframe;
+    iframe.setAttribute("frameBorder", "0");
+    iframe.setAttribute("aria-hidden", "true");
+    iframe.setAttribute(
+      "allow",
+      "autoplay; fullscreen; encrypted-media; picture-in-picture; accelerometer; gyroscope"
+    );
+    if (this.referrerPolicy !== null) {
+      iframe.setAttribute("referrerpolicy", this.referrerPolicy);
+    }
+  }
+  setup() {
+    listenEvent(window, "message", this.#onWindowMessage.bind(this));
+    listenEvent(this.#iframe, "load", this.onLoad.bind(this));
+    effect(this.#watchSrc.bind(this));
+  }
+  #watchSrc() {
+    const src = this.src();
+    if (!src.length) {
+      this.#iframe.setAttribute("src", "");
+      return;
+    }
+    const params = peek(() => this.buildParams());
+    this.#iframe.setAttribute("src", appendParamsToURL(src, params));
+  }
+  postMessage(message, target) {
+    if (IS_SERVER) return;
+    this.#iframe.contentWindow?.postMessage(JSON.stringify(message), target ?? "*");
+  }
+  #onWindowMessage(event) {
+    const origin = this.getOrigin(), isOriginMatch = (event.source === null || event.source === this.#iframe?.contentWindow) && (!isString(origin) || origin === event.origin);
+    if (!isOriginMatch) return;
+    try {
+      const message = JSON.parse(event.data);
+      if (message) this.onMessage(message, event);
+      return;
+    } catch (e) {
+    }
+    if (event.data) this.onMessage(event.data, event);
+  }
+}
+
+export { EmbedProvider };
diff --git a/prod/chunks/vidstack-BGEqnOoX.js b/prod/chunks/vidstack-DLZw-z2Z.js
similarity index 99%
rename from prod/chunks/vidstack-BGEqnOoX.js
rename to prod/chunks/vidstack-DLZw-z2Z.js
index e719ed598f3c26067f093fe9b478945af58b1594..2aabdbc9f36ba01262f80b4dcec989cc9a8097b6 100644
--- a/prod/chunks/vidstack-BGEqnOoX.js
+++ b/prod/chunks/vidstack-DLZw-z2Z.js
@@ -1,8 +1,8 @@
 "use client"
 
 import { createScope, signal, effect, peek, isString, deferredPromise, listenEvent, isArray } from './vidstack-CNjv_Zem.js';
-import { TimeRange, RAFLoop, preconnect, ListSymbol, TextTrack, QualitySymbol } from './vidstack-D6dKrFOZ.js';
-import { EmbedProvider } from './vidstack-CbSFenOv.js';
+import { TimeRange, RAFLoop, preconnect, ListSymbol, TextTrack, QualitySymbol } from './vidstack-3ABKqYU9.js';
+import { EmbedProvider } from './vidstack-BVcvqNg8.js';
 import { resolveVimeoVideoId, getVimeoVideoInfo } from './vidstack-krOAtKMi.js';
 import 'react';
 import '@floating-ui/dom';
diff --git a/prod/chunks/vidstack-DMA1vuPq.js b/prod/chunks/vidstack-DMA1vuPq.js
new file mode 100644
index 0000000000000000000000000000000000000000..e5184bf7de077089f771f1451eee24a1244d81e1
--- /dev/null
+++ b/prod/chunks/vidstack-DMA1vuPq.js
@@ -0,0 +1,542 @@
+"use client"
+
+import { createScope, signal, effect, peek, isString, deferredPromise, listenEvent, isArray } from './vidstack-CNjv_Zem.js';
+import { TimeRange, RAFLoop, preconnect, ListSymbol, TextTrack, QualitySymbol } from './vidstack-CwFL6mmL.js';
+import { EmbedProvider } from './vidstack-CzDPuCjO.js';
+import { resolveVimeoVideoId, getVimeoVideoInfo } from './vidstack-krOAtKMi.js';
+import 'react';
+import '@floating-ui/dom';
+
+const trackedVimeoEvents = [
+  "bufferend",
+  "bufferstart",
+  // 'cuechange',
+  "durationchange",
+  "ended",
+  "enterpictureinpicture",
+  "error",
+  "fullscreenchange",
+  "leavepictureinpicture",
+  "loaded",
+  // 'loadeddata',
+  // 'loadedmetadata',
+  // 'loadstart',
+  "playProgress",
+  "loadProgress",
+  "pause",
+  "play",
+  "playbackratechange",
+  // 'progress',
+  "qualitychange",
+  "seeked",
+  "seeking",
+  // 'texttrackchange',
+  "timeupdate",
+  "volumechange",
+  "waiting"
+  // 'adstarted',
+  // 'adcompleted',
+  // 'aderror',
+  // 'adskipped',
+  // 'adallcompleted',
+  // 'adclicked',
+  // 'chapterchange',
+  // 'chromecastconnected',
+  // 'remoteplaybackavailabilitychange',
+  // 'remoteplaybackconnecting',
+  // 'remoteplaybackconnect',
+  // 'remoteplaybackdisconnect',
+  // 'liveeventended',
+  // 'liveeventstarted',
+  // 'livestreamoffline',
+  // 'livestreamonline',
+];
+
+class VimeoProvider extends EmbedProvider {
+  $$PROVIDER_TYPE = "VIMEO";
+  scope = createScope();
+  fullscreen;
+  #ctx;
+  #videoId = signal("");
+  #pro = signal(false);
+  #hash = null;
+  #currentSrc = null;
+  #fullscreenActive = false;
+  #seekableRange = new TimeRange(0, 0);
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #currentCue = null;
+  #chaptersTrack = null;
+  #promises = /* @__PURE__ */ new Map();
+  #videoInfoPromise = null;
+  constructor(iframe, ctx) {
+    super(iframe);
+    this.#ctx = ctx;
+    const self = this;
+    this.fullscreen = {
+      get active() {
+        return self.#fullscreenActive;
+      },
+      supported: true,
+      enter: () => this.#remote("requestFullscreen"),
+      exit: () => this.#remote("exitFullscreen")
+    };
+  }
+  /**
+   * Whether tracking session data should be enabled on the embed, including cookies and analytics.
+   * This is turned off by default to be GDPR-compliant.
+   *
+   * @defaultValue `false`
+   */
+  cookies = false;
+  title = true;
+  byline = true;
+  portrait = true;
+  color = "00ADEF";
+  get type() {
+    return "vimeo";
+  }
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  get videoId() {
+    return this.#videoId();
+  }
+  get hash() {
+    return this.#hash;
+  }
+  get isPro() {
+    return this.#pro();
+  }
+  preconnect() {
+    preconnect(this.getOrigin());
+  }
+  setup() {
+    super.setup();
+    effect(this.#watchVideoId.bind(this));
+    effect(this.#watchVideoInfo.bind(this));
+    effect(this.#watchPro.bind(this));
+    this.#ctx.notify("provider-setup", this);
+  }
+  destroy() {
+    this.#reset();
+    this.fullscreen = void 0;
+    const message = "provider destroyed";
+    for (const promises of this.#promises.values()) {
+      for (const { reject } of promises) reject(message);
+    }
+    this.#promises.clear();
+    this.#remote("destroy");
+  }
+  async play() {
+    return this.#remote("play");
+  }
+  async pause() {
+    return this.#remote("pause");
+  }
+  setMuted(muted) {
+    this.#remote("setMuted", muted);
+  }
+  setCurrentTime(time) {
+    this.#remote("seekTo", time);
+    this.#ctx.notify("seeking", time);
+  }
+  setVolume(volume) {
+    this.#remote("setVolume", volume);
+    this.#remote("setMuted", peek(this.#ctx.$state.muted));
+  }
+  setPlaybackRate(rate) {
+    this.#remote("setPlaybackRate", rate);
+  }
+  async loadSource(src) {
+    if (!isString(src.src)) {
+      this.#currentSrc = null;
+      this.#hash = null;
+      this.#videoId.set("");
+      return;
+    }
+    const { videoId, hash } = resolveVimeoVideoId(src.src);
+    this.#videoId.set(videoId ?? "");
+    this.#hash = hash ?? null;
+    this.#currentSrc = src;
+  }
+  #watchVideoId() {
+    this.#reset();
+    const videoId = this.#videoId();
+    if (!videoId) {
+      this.src.set("");
+      return;
+    }
+    this.src.set(`${this.getOrigin()}/video/${videoId}`);
+    this.#ctx.notify("load-start");
+  }
+  #watchVideoInfo() {
+    const videoId = this.#videoId();
+    if (!videoId) return;
+    const promise = deferredPromise(), abort = new AbortController();
+    this.#videoInfoPromise = promise;
+    getVimeoVideoInfo(videoId, abort, this.#hash).then((info) => {
+      promise.resolve(info);
+    }).catch((e) => {
+      promise.reject();
+    });
+    return () => {
+      promise.reject();
+      abort.abort();
+    };
+  }
+  #watchPro() {
+    const isPro = this.#pro(), { $state, qualities } = this.#ctx;
+    $state.canSetPlaybackRate.set(isPro);
+    qualities[ListSymbol.setReadonly](!isPro);
+    if (isPro) {
+      return listenEvent(qualities, "change", () => {
+        if (qualities.auto) return;
+        const id = qualities.selected?.id;
+        if (id) this.#remote("setQuality", id);
+      });
+    }
+  }
+  getOrigin() {
+    return "https://player.vimeo.com";
+  }
+  buildParams() {
+    const { keyDisabled } = this.#ctx.$props, { playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
+    return {
+      title: this.title,
+      byline: this.byline,
+      color: this.color,
+      portrait: this.portrait,
+      controls: showControls,
+      h: this.hash,
+      keyboard: showControls && !keyDisabled(),
+      transparent: true,
+      playsinline: playsInline(),
+      dnt: !this.cookies
+    };
+  }
+  #onAnimationFrame() {
+    this.#remote("getCurrentTime");
+  }
+  // Embed will sometimes dispatch 0 at end of playback.
+  #preventTimeUpdates = false;
+  #onTimeUpdate(time, trigger) {
+    if (this.#preventTimeUpdates && time === 0) return;
+    const { realCurrentTime, paused, bufferedEnd, seekableEnd, live } = this.#ctx.$state;
+    if (realCurrentTime() === time) return;
+    const prevTime = realCurrentTime();
+    this.#ctx.notify("time-change", time, trigger);
+    if (Math.abs(prevTime - time) > 1.5) {
+      this.#ctx.notify("seeking", time, trigger);
+      if (!paused() && bufferedEnd() < time) {
+        this.#ctx.notify("waiting", void 0, trigger);
+      }
+    }
+    if (!live() && seekableEnd() - time < 0.01) {
+      this.#ctx.notify("end", void 0, trigger);
+      this.#preventTimeUpdates = true;
+      setTimeout(() => {
+        this.#preventTimeUpdates = false;
+      }, 500);
+    }
+  }
+  #onSeeked(time, trigger) {
+    this.#ctx.notify("seeked", time, trigger);
+  }
+  #onLoaded(trigger) {
+    const videoId = this.#videoId();
+    this.#videoInfoPromise?.promise.then((info) => {
+      if (!info) return;
+      const { title, poster, duration, pro } = info;
+      this.#pro.set(pro);
+      this.#ctx.notify("title-change", title, trigger);
+      this.#ctx.notify("poster-change", poster, trigger);
+      this.#ctx.notify("duration-change", duration, trigger);
+      this.#onReady(duration, trigger);
+    }).catch(() => {
+      if (videoId !== this.#videoId()) return;
+      this.#remote("getVideoTitle");
+      this.#remote("getDuration");
+    });
+  }
+  #onReady(duration, trigger) {
+    const { nativeControls } = this.#ctx.$state, showEmbedControls = nativeControls();
+    this.#seekableRange = new TimeRange(0, duration);
+    const detail = {
+      buffered: new TimeRange(0, 0),
+      seekable: this.#seekableRange,
+      duration
+    };
+    this.#ctx.delegate.ready(detail, trigger);
+    if (!showEmbedControls) {
+      this.#remote("_hideOverlay");
+    }
+    this.#remote("getQualities");
+    this.#remote("getChapters");
+  }
+  #onMethod(method, data, trigger) {
+    switch (method) {
+      case "getVideoTitle":
+        const videoTitle = data;
+        this.#ctx.notify("title-change", videoTitle, trigger);
+        break;
+      case "getDuration":
+        const duration = data;
+        if (!this.#ctx.$state.canPlay()) {
+          this.#onReady(duration, trigger);
+        } else {
+          this.#ctx.notify("duration-change", duration, trigger);
+        }
+        break;
+      case "getCurrentTime":
+        this.#onTimeUpdate(data, trigger);
+        break;
+      case "getBuffered":
+        if (isArray(data) && data.length) {
+          this.#onLoadProgress(data[data.length - 1][1], trigger);
+        }
+        break;
+      case "setMuted":
+        this.#onVolumeChange(peek(this.#ctx.$state.volume), data, trigger);
+        break;
+      // case 'getTextTracks':
+      //   this.#onTextTracksChange(data as VimeoTextTrack[], trigger);
+      //   break;
+      case "getChapters":
+        this.#onChaptersChange(data);
+        break;
+      case "getQualities":
+        this.#onQualitiesChange(data, trigger);
+        break;
+    }
+    this.#getPromise(method)?.resolve();
+  }
+  #attachListeners() {
+    for (const type of trackedVimeoEvents) {
+      this.#remote("addEventListener", type);
+    }
+  }
+  #onPause(trigger) {
+    this.#timeRAF.stop();
+    this.#ctx.notify("pause", void 0, trigger);
+  }
+  #onPlay(trigger) {
+    this.#timeRAF.start();
+    this.#ctx.notify("play", void 0, trigger);
+  }
+  #onPlayProgress(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (!paused() && !this.#preventTimeUpdates) {
+      this.#ctx.notify("playing", void 0, trigger);
+    }
+  }
+  #onLoadProgress(buffered, trigger) {
+    const detail = {
+      buffered: new TimeRange(0, buffered),
+      seekable: this.#seekableRange
+    };
+    this.#ctx.notify("progress", detail, trigger);
+  }
+  #onBufferStart(trigger) {
+    this.#ctx.notify("waiting", void 0, trigger);
+  }
+  #onBufferEnd(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (!paused()) this.#ctx.notify("playing", void 0, trigger);
+  }
+  #onWaiting(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (paused()) {
+      this.#ctx.notify("play", void 0, trigger);
+    }
+    this.#ctx.notify("waiting", void 0, trigger);
+  }
+  #onVolumeChange(volume, muted, trigger) {
+    const detail = { volume, muted };
+    this.#ctx.notify("volume-change", detail, trigger);
+  }
+  // #onTextTrackChange(track: VimeoTextTrack, trigger: Event) {
+  //   const textTrack = this.#ctx.textTracks.toArray().find((t) => t.language === track.language);
+  //   if (textTrack) textTrack.mode = track.mode;
+  // }
+  // #onTextTracksChange(tracks: VimeoTextTrack[], trigger: Event) {
+  //   for (const init of tracks) {
+  //     const textTrack = new TextTrack({
+  //       ...init,
+  //       label: init.label.replace('auto-generated', 'auto'),
+  //     });
+  //     textTrack[TextTrackSymbol.readyState] = 2;
+  //     this.#ctx.textTracks.add(textTrack, trigger);
+  //     textTrack.setMode(init.mode, trigger);
+  //   }
+  // }
+  // #onCueChange(cue: VimeoTextCue, trigger: Event) {
+  //   const { textTracks, $state } = this.#ctx,
+  //     { currentTime } = $state,
+  //     track = textTracks.selected;
+  //   if (this.#currentCue) track?.removeCue(this.#currentCue, trigger);
+  //   this.#currentCue = new window.VTTCue(currentTime(), Number.MAX_SAFE_INTEGER, cue.text);
+  //   track?.addCue(this.#currentCue, trigger);
+  // }
+  #onChaptersChange(chapters) {
+    this.#removeChapters();
+    if (!chapters.length) return;
+    const track = new TextTrack({
+      kind: "chapters",
+      default: true
+    }), { seekableEnd } = this.#ctx.$state;
+    for (let i = 0; i < chapters.length; i++) {
+      const chapter = chapters[i], nextChapter = chapters[i + 1];
+      track.addCue(
+        new window.VTTCue(
+          chapter.startTime,
+          nextChapter?.startTime ?? seekableEnd(),
+          chapter.title
+        )
+      );
+    }
+    this.#chaptersTrack = track;
+    this.#ctx.textTracks.add(track);
+  }
+  #removeChapters() {
+    if (!this.#chaptersTrack) return;
+    this.#ctx.textTracks.remove(this.#chaptersTrack);
+    this.#chaptersTrack = null;
+  }
+  #onQualitiesChange(qualities, trigger) {
+    this.#ctx.qualities[QualitySymbol.enableAuto] = qualities.some((q) => q.id === "auto") ? () => this.#remote("setQuality", "auto") : void 0;
+    for (const quality of qualities) {
+      if (quality.id === "auto") continue;
+      const height = +quality.id.slice(0, -1);
+      if (isNaN(height)) continue;
+      this.#ctx.qualities[ListSymbol.add](
+        {
+          id: quality.id,
+          width: height * (16 / 9),
+          height,
+          codec: "avc1,h.264",
+          bitrate: -1
+        },
+        trigger
+      );
+    }
+    this.#onQualityChange(
+      qualities.find((q) => q.active),
+      trigger
+    );
+  }
+  #onQualityChange({ id } = {}, trigger) {
+    if (!id) return;
+    const isAuto = id === "auto", newQuality = this.#ctx.qualities.getById(id);
+    if (isAuto) {
+      this.#ctx.qualities[QualitySymbol.setAuto](isAuto, trigger);
+      this.#ctx.qualities[ListSymbol.select](void 0, true, trigger);
+    } else {
+      this.#ctx.qualities[ListSymbol.select](newQuality ?? void 0, true, trigger);
+    }
+  }
+  #onEvent(event, payload, trigger) {
+    switch (event) {
+      case "ready":
+        this.#attachListeners();
+        break;
+      case "loaded":
+        this.#onLoaded(trigger);
+        break;
+      case "play":
+        this.#onPlay(trigger);
+        break;
+      case "playProgress":
+        this.#onPlayProgress(trigger);
+        break;
+      case "pause":
+        this.#onPause(trigger);
+        break;
+      case "loadProgress":
+        this.#onLoadProgress(payload.seconds, trigger);
+        break;
+      case "waiting":
+        this.#onWaiting(trigger);
+        break;
+      case "bufferstart":
+        this.#onBufferStart(trigger);
+        break;
+      case "bufferend":
+        this.#onBufferEnd(trigger);
+        break;
+      case "volumechange":
+        this.#onVolumeChange(payload.volume, peek(this.#ctx.$state.muted), trigger);
+        break;
+      case "durationchange":
+        this.#seekableRange = new TimeRange(0, payload.duration);
+        this.#ctx.notify("duration-change", payload.duration, trigger);
+        break;
+      case "playbackratechange":
+        this.#ctx.notify("rate-change", payload.playbackRate, trigger);
+        break;
+      case "qualitychange":
+        this.#onQualityChange(payload, trigger);
+        break;
+      case "fullscreenchange":
+        this.#fullscreenActive = payload.fullscreen;
+        this.#ctx.notify("fullscreen-change", payload.fullscreen, trigger);
+        break;
+      case "enterpictureinpicture":
+        this.#ctx.notify("picture-in-picture-change", true, trigger);
+        break;
+      case "leavepictureinpicture":
+        this.#ctx.notify("picture-in-picture-change", false, trigger);
+        break;
+      case "ended":
+        this.#ctx.notify("end", void 0, trigger);
+        break;
+      case "error":
+        this.#onError(payload, trigger);
+        break;
+      case "seek":
+      case "seeked":
+        this.#onSeeked(payload.seconds, trigger);
+        break;
+    }
+  }
+  #onError(error, trigger) {
+    const { message, method } = error;
+    if (method === "setPlaybackRate") {
+      this.#pro.set(false);
+    }
+    if (method) {
+      this.#getPromise(method)?.reject(message);
+    }
+  }
+  onMessage(message, event) {
+    if (message.event) {
+      this.#onEvent(message.event, message.data, event);
+    } else if (message.method) {
+      this.#onMethod(message.method, message.value, event);
+    }
+  }
+  onLoad() {
+  }
+  async #remote(command, arg) {
+    let promise = deferredPromise(), promises = this.#promises.get(command);
+    if (!promises) this.#promises.set(command, promises = []);
+    promises.push(promise);
+    this.postMessage({
+      method: command,
+      value: arg
+    });
+    return promise.promise;
+  }
+  #reset() {
+    this.#timeRAF.stop();
+    this.#seekableRange = new TimeRange(0, 0);
+    this.#videoInfoPromise = null;
+    this.#currentCue = null;
+    this.#pro.set(false);
+    this.#removeChapters();
+  }
+  #getPromise(command) {
+    return this.#promises.get(command)?.shift();
+  }
+}
+
+export { VimeoProvider };
diff --git a/prod/chunks/vidstack-DShF5mAU.js b/prod/chunks/vidstack-DShF5mAU.js
new file mode 100644
index 0000000000000000000000000000000000000000..72a0dc5ec04c865ec4ca7a1e4b5649b4c623c61c
--- /dev/null
+++ b/prod/chunks/vidstack-DShF5mAU.js
@@ -0,0 +1,542 @@
+"use client"
+
+import { createScope, signal, effect, peek, isString, deferredPromise, listenEvent, isArray } from './vidstack-CNjv_Zem.js';
+import { TimeRange, RAFLoop, preconnect, ListSymbol, TextTrack, QualitySymbol } from './vidstack-BY07IoHR.js';
+import { EmbedProvider } from './vidstack-DI1IwIaU.js';
+import { resolveVimeoVideoId, getVimeoVideoInfo } from './vidstack-krOAtKMi.js';
+import 'react';
+import '@floating-ui/dom';
+
+const trackedVimeoEvents = [
+  "bufferend",
+  "bufferstart",
+  // 'cuechange',
+  "durationchange",
+  "ended",
+  "enterpictureinpicture",
+  "error",
+  "fullscreenchange",
+  "leavepictureinpicture",
+  "loaded",
+  // 'loadeddata',
+  // 'loadedmetadata',
+  // 'loadstart',
+  "playProgress",
+  "loadProgress",
+  "pause",
+  "play",
+  "playbackratechange",
+  // 'progress',
+  "qualitychange",
+  "seeked",
+  "seeking",
+  // 'texttrackchange',
+  "timeupdate",
+  "volumechange",
+  "waiting"
+  // 'adstarted',
+  // 'adcompleted',
+  // 'aderror',
+  // 'adskipped',
+  // 'adallcompleted',
+  // 'adclicked',
+  // 'chapterchange',
+  // 'chromecastconnected',
+  // 'remoteplaybackavailabilitychange',
+  // 'remoteplaybackconnecting',
+  // 'remoteplaybackconnect',
+  // 'remoteplaybackdisconnect',
+  // 'liveeventended',
+  // 'liveeventstarted',
+  // 'livestreamoffline',
+  // 'livestreamonline',
+];
+
+class VimeoProvider extends EmbedProvider {
+  $$PROVIDER_TYPE = "VIMEO";
+  scope = createScope();
+  fullscreen;
+  #ctx;
+  #videoId = signal("");
+  #pro = signal(false);
+  #hash = null;
+  #currentSrc = null;
+  #fullscreenActive = false;
+  #seekableRange = new TimeRange(0, 0);
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #currentCue = null;
+  #chaptersTrack = null;
+  #promises = /* @__PURE__ */ new Map();
+  #videoInfoPromise = null;
+  constructor(iframe, ctx) {
+    super(iframe);
+    this.#ctx = ctx;
+    const self = this;
+    this.fullscreen = {
+      get active() {
+        return self.#fullscreenActive;
+      },
+      supported: true,
+      enter: () => this.#remote("requestFullscreen"),
+      exit: () => this.#remote("exitFullscreen")
+    };
+  }
+  /**
+   * Whether tracking session data should be enabled on the embed, including cookies and analytics.
+   * This is turned off by default to be GDPR-compliant.
+   *
+   * @defaultValue `false`
+   */
+  cookies = false;
+  title = true;
+  byline = true;
+  portrait = true;
+  color = "00ADEF";
+  get type() {
+    return "vimeo";
+  }
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  get videoId() {
+    return this.#videoId();
+  }
+  get hash() {
+    return this.#hash;
+  }
+  get isPro() {
+    return this.#pro();
+  }
+  preconnect() {
+    preconnect(this.getOrigin());
+  }
+  setup() {
+    super.setup();
+    effect(this.#watchVideoId.bind(this));
+    effect(this.#watchVideoInfo.bind(this));
+    effect(this.#watchPro.bind(this));
+    this.#ctx.notify("provider-setup", this);
+  }
+  destroy() {
+    this.#reset();
+    this.fullscreen = void 0;
+    const message = "provider destroyed";
+    for (const promises of this.#promises.values()) {
+      for (const { reject } of promises) reject(message);
+    }
+    this.#promises.clear();
+    this.#remote("destroy");
+  }
+  async play() {
+    return this.#remote("play");
+  }
+  async pause() {
+    return this.#remote("pause");
+  }
+  setMuted(muted) {
+    this.#remote("setMuted", muted);
+  }
+  setCurrentTime(time) {
+    this.#remote("seekTo", time);
+    this.#ctx.notify("seeking", time);
+  }
+  setVolume(volume) {
+    this.#remote("setVolume", volume);
+    this.#remote("setMuted", peek(this.#ctx.$state.muted));
+  }
+  setPlaybackRate(rate) {
+    this.#remote("setPlaybackRate", rate);
+  }
+  async loadSource(src) {
+    if (!isString(src.src)) {
+      this.#currentSrc = null;
+      this.#hash = null;
+      this.#videoId.set("");
+      return;
+    }
+    const { videoId, hash } = resolveVimeoVideoId(src.src);
+    this.#videoId.set(videoId ?? "");
+    this.#hash = hash ?? null;
+    this.#currentSrc = src;
+  }
+  #watchVideoId() {
+    this.#reset();
+    const videoId = this.#videoId();
+    if (!videoId) {
+      this.src.set("");
+      return;
+    }
+    this.src.set(`${this.getOrigin()}/video/${videoId}`);
+    this.#ctx.notify("load-start");
+  }
+  #watchVideoInfo() {
+    const videoId = this.#videoId();
+    if (!videoId) return;
+    const promise = deferredPromise(), abort = new AbortController();
+    this.#videoInfoPromise = promise;
+    getVimeoVideoInfo(videoId, abort, this.#hash).then((info) => {
+      promise.resolve(info);
+    }).catch((e) => {
+      promise.reject();
+    });
+    return () => {
+      promise.reject();
+      abort.abort();
+    };
+  }
+  #watchPro() {
+    const isPro = this.#pro(), { $state, qualities } = this.#ctx;
+    $state.canSetPlaybackRate.set(isPro);
+    qualities[ListSymbol.setReadonly](!isPro);
+    if (isPro) {
+      return listenEvent(qualities, "change", () => {
+        if (qualities.auto) return;
+        const id = qualities.selected?.id;
+        if (id) this.#remote("setQuality", id);
+      });
+    }
+  }
+  getOrigin() {
+    return "https://player.vimeo.com";
+  }
+  buildParams() {
+    const { keyDisabled } = this.#ctx.$props, { playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
+    return {
+      title: this.title,
+      byline: this.byline,
+      color: this.color,
+      portrait: this.portrait,
+      controls: showControls,
+      h: this.hash,
+      keyboard: showControls && !keyDisabled(),
+      transparent: true,
+      playsinline: playsInline(),
+      dnt: !this.cookies
+    };
+  }
+  #onAnimationFrame() {
+    this.#remote("getCurrentTime");
+  }
+  // Embed will sometimes dispatch 0 at end of playback.
+  #preventTimeUpdates = false;
+  #onTimeUpdate(time, trigger) {
+    if (this.#preventTimeUpdates && time === 0) return;
+    const { realCurrentTime, paused, bufferedEnd, seekableEnd, live } = this.#ctx.$state;
+    if (realCurrentTime() === time) return;
+    const prevTime = realCurrentTime();
+    this.#ctx.notify("time-change", time, trigger);
+    if (Math.abs(prevTime - time) > 1.5) {
+      this.#ctx.notify("seeking", time, trigger);
+      if (!paused() && bufferedEnd() < time) {
+        this.#ctx.notify("waiting", void 0, trigger);
+      }
+    }
+    if (!live() && seekableEnd() - time < 0.01) {
+      this.#ctx.notify("end", void 0, trigger);
+      this.#preventTimeUpdates = true;
+      setTimeout(() => {
+        this.#preventTimeUpdates = false;
+      }, 500);
+    }
+  }
+  #onSeeked(time, trigger) {
+    this.#ctx.notify("seeked", time, trigger);
+  }
+  #onLoaded(trigger) {
+    const videoId = this.#videoId();
+    this.#videoInfoPromise?.promise.then((info) => {
+      if (!info) return;
+      const { title, poster, duration, pro } = info;
+      this.#pro.set(pro);
+      this.#ctx.notify("title-change", title, trigger);
+      this.#ctx.notify("poster-change", poster, trigger);
+      this.#ctx.notify("duration-change", duration, trigger);
+      this.#onReady(duration, trigger);
+    }).catch(() => {
+      if (videoId !== this.#videoId()) return;
+      this.#remote("getVideoTitle");
+      this.#remote("getDuration");
+    });
+  }
+  #onReady(duration, trigger) {
+    const { nativeControls } = this.#ctx.$state, showEmbedControls = nativeControls();
+    this.#seekableRange = new TimeRange(0, duration);
+    const detail = {
+      buffered: new TimeRange(0, 0),
+      seekable: this.#seekableRange,
+      duration
+    };
+    this.#ctx.delegate.ready(detail, trigger);
+    if (!showEmbedControls) {
+      this.#remote("_hideOverlay");
+    }
+    this.#remote("getQualities");
+    this.#remote("getChapters");
+  }
+  #onMethod(method, data, trigger) {
+    switch (method) {
+      case "getVideoTitle":
+        const videoTitle = data;
+        this.#ctx.notify("title-change", videoTitle, trigger);
+        break;
+      case "getDuration":
+        const duration = data;
+        if (!this.#ctx.$state.canPlay()) {
+          this.#onReady(duration, trigger);
+        } else {
+          this.#ctx.notify("duration-change", duration, trigger);
+        }
+        break;
+      case "getCurrentTime":
+        this.#onTimeUpdate(data, trigger);
+        break;
+      case "getBuffered":
+        if (isArray(data) && data.length) {
+          this.#onLoadProgress(data[data.length - 1][1], trigger);
+        }
+        break;
+      case "setMuted":
+        this.#onVolumeChange(peek(this.#ctx.$state.volume), data, trigger);
+        break;
+      // case 'getTextTracks':
+      //   this.#onTextTracksChange(data as VimeoTextTrack[], trigger);
+      //   break;
+      case "getChapters":
+        this.#onChaptersChange(data);
+        break;
+      case "getQualities":
+        this.#onQualitiesChange(data, trigger);
+        break;
+    }
+    this.#getPromise(method)?.resolve();
+  }
+  #attachListeners() {
+    for (const type of trackedVimeoEvents) {
+      this.#remote("addEventListener", type);
+    }
+  }
+  #onPause(trigger) {
+    this.#timeRAF.stop();
+    this.#ctx.notify("pause", void 0, trigger);
+  }
+  #onPlay(trigger) {
+    this.#timeRAF.start();
+    this.#ctx.notify("play", void 0, trigger);
+  }
+  #onPlayProgress(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (!paused() && !this.#preventTimeUpdates) {
+      this.#ctx.notify("playing", void 0, trigger);
+    }
+  }
+  #onLoadProgress(buffered, trigger) {
+    const detail = {
+      buffered: new TimeRange(0, buffered),
+      seekable: this.#seekableRange
+    };
+    this.#ctx.notify("progress", detail, trigger);
+  }
+  #onBufferStart(trigger) {
+    this.#ctx.notify("waiting", void 0, trigger);
+  }
+  #onBufferEnd(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (!paused()) this.#ctx.notify("playing", void 0, trigger);
+  }
+  #onWaiting(trigger) {
+    const { paused } = this.#ctx.$state;
+    if (paused()) {
+      this.#ctx.notify("play", void 0, trigger);
+    }
+    this.#ctx.notify("waiting", void 0, trigger);
+  }
+  #onVolumeChange(volume, muted, trigger) {
+    const detail = { volume, muted };
+    this.#ctx.notify("volume-change", detail, trigger);
+  }
+  // #onTextTrackChange(track: VimeoTextTrack, trigger: Event) {
+  //   const textTrack = this.#ctx.textTracks.toArray().find((t) => t.language === track.language);
+  //   if (textTrack) textTrack.mode = track.mode;
+  // }
+  // #onTextTracksChange(tracks: VimeoTextTrack[], trigger: Event) {
+  //   for (const init of tracks) {
+  //     const textTrack = new TextTrack({
+  //       ...init,
+  //       label: init.label.replace('auto-generated', 'auto'),
+  //     });
+  //     textTrack[TextTrackSymbol.readyState] = 2;
+  //     this.#ctx.textTracks.add(textTrack, trigger);
+  //     textTrack.setMode(init.mode, trigger);
+  //   }
+  // }
+  // #onCueChange(cue: VimeoTextCue, trigger: Event) {
+  //   const { textTracks, $state } = this.#ctx,
+  //     { currentTime } = $state,
+  //     track = textTracks.selected;
+  //   if (this.#currentCue) track?.removeCue(this.#currentCue, trigger);
+  //   this.#currentCue = new window.VTTCue(currentTime(), Number.MAX_SAFE_INTEGER, cue.text);
+  //   track?.addCue(this.#currentCue, trigger);
+  // }
+  #onChaptersChange(chapters) {
+    this.#removeChapters();
+    if (!chapters.length) return;
+    const track = new TextTrack({
+      kind: "chapters",
+      default: true
+    }), { seekableEnd } = this.#ctx.$state;
+    for (let i = 0; i < chapters.length; i++) {
+      const chapter = chapters[i], nextChapter = chapters[i + 1];
+      track.addCue(
+        new window.VTTCue(
+          chapter.startTime,
+          nextChapter?.startTime ?? seekableEnd(),
+          chapter.title
+        )
+      );
+    }
+    this.#chaptersTrack = track;
+    this.#ctx.textTracks.add(track);
+  }
+  #removeChapters() {
+    if (!this.#chaptersTrack) return;
+    this.#ctx.textTracks.remove(this.#chaptersTrack);
+    this.#chaptersTrack = null;
+  }
+  #onQualitiesChange(qualities, trigger) {
+    this.#ctx.qualities[QualitySymbol.enableAuto] = qualities.some((q) => q.id === "auto") ? () => this.#remote("setQuality", "auto") : void 0;
+    for (const quality of qualities) {
+      if (quality.id === "auto") continue;
+      const height = +quality.id.slice(0, -1);
+      if (isNaN(height)) continue;
+      this.#ctx.qualities[ListSymbol.add](
+        {
+          id: quality.id,
+          width: height * (16 / 9),
+          height,
+          codec: "avc1,h.264",
+          bitrate: -1
+        },
+        trigger
+      );
+    }
+    this.#onQualityChange(
+      qualities.find((q) => q.active),
+      trigger
+    );
+  }
+  #onQualityChange({ id } = {}, trigger) {
+    if (!id) return;
+    const isAuto = id === "auto", newQuality = this.#ctx.qualities.getById(id);
+    if (isAuto) {
+      this.#ctx.qualities[QualitySymbol.setAuto](isAuto, trigger);
+      this.#ctx.qualities[ListSymbol.select](void 0, true, trigger);
+    } else {
+      this.#ctx.qualities[ListSymbol.select](newQuality ?? void 0, true, trigger);
+    }
+  }
+  #onEvent(event, payload, trigger) {
+    switch (event) {
+      case "ready":
+        this.#attachListeners();
+        break;
+      case "loaded":
+        this.#onLoaded(trigger);
+        break;
+      case "play":
+        this.#onPlay(trigger);
+        break;
+      case "playProgress":
+        this.#onPlayProgress(trigger);
+        break;
+      case "pause":
+        this.#onPause(trigger);
+        break;
+      case "loadProgress":
+        this.#onLoadProgress(payload.seconds, trigger);
+        break;
+      case "waiting":
+        this.#onWaiting(trigger);
+        break;
+      case "bufferstart":
+        this.#onBufferStart(trigger);
+        break;
+      case "bufferend":
+        this.#onBufferEnd(trigger);
+        break;
+      case "volumechange":
+        this.#onVolumeChange(payload.volume, peek(this.#ctx.$state.muted), trigger);
+        break;
+      case "durationchange":
+        this.#seekableRange = new TimeRange(0, payload.duration);
+        this.#ctx.notify("duration-change", payload.duration, trigger);
+        break;
+      case "playbackratechange":
+        this.#ctx.notify("rate-change", payload.playbackRate, trigger);
+        break;
+      case "qualitychange":
+        this.#onQualityChange(payload, trigger);
+        break;
+      case "fullscreenchange":
+        this.#fullscreenActive = payload.fullscreen;
+        this.#ctx.notify("fullscreen-change", payload.fullscreen, trigger);
+        break;
+      case "enterpictureinpicture":
+        this.#ctx.notify("picture-in-picture-change", true, trigger);
+        break;
+      case "leavepictureinpicture":
+        this.#ctx.notify("picture-in-picture-change", false, trigger);
+        break;
+      case "ended":
+        this.#ctx.notify("end", void 0, trigger);
+        break;
+      case "error":
+        this.#onError(payload, trigger);
+        break;
+      case "seek":
+      case "seeked":
+        this.#onSeeked(payload.seconds, trigger);
+        break;
+    }
+  }
+  #onError(error, trigger) {
+    const { message, method } = error;
+    if (method === "setPlaybackRate") {
+      this.#pro.set(false);
+    }
+    if (method) {
+      this.#getPromise(method)?.reject(message);
+    }
+  }
+  onMessage(message, event) {
+    if (message.event) {
+      this.#onEvent(message.event, message.data, event);
+    } else if (message.method) {
+      this.#onMethod(message.method, message.value, event);
+    }
+  }
+  onLoad() {
+  }
+  async #remote(command, arg) {
+    let promise = deferredPromise(), promises = this.#promises.get(command);
+    if (!promises) this.#promises.set(command, promises = []);
+    promises.push(promise);
+    this.postMessage({
+      method: command,
+      value: arg
+    });
+    return promise.promise;
+  }
+  #reset() {
+    this.#timeRAF.stop();
+    this.#seekableRange = new TimeRange(0, 0);
+    this.#videoInfoPromise = null;
+    this.#currentCue = null;
+    this.#pro.set(false);
+    this.#removeChapters();
+  }
+  #getPromise(command) {
+    return this.#promises.get(command)?.shift();
+  }
+}
+
+export { VimeoProvider };
diff --git a/prod/chunks/vidstack-Dbk-FOkv.js b/prod/chunks/vidstack-Dbk-FOkv.js
new file mode 100644
index 0000000000000000000000000000000000000000..2b8f9560000d26f0a1ac262976611b88b943f67f
--- /dev/null
+++ b/prod/chunks/vidstack-Dbk-FOkv.js
@@ -0,0 +1,84 @@
+"use client"
+
+import * as React from 'react';
+import { animationFrameThrottle, EventsController, listenEvent, effect } from './vidstack-CNjv_Zem.js';
+import { useMediaPlayer } from './vidstack-BKi5uu_j.js';
+
+function useClassName(el, className) {
+  React.useEffect(() => {
+    if (!el || !className) return;
+    const tokens = className.split(" ");
+    for (const token of tokens) el.classList.add(token);
+    return () => {
+      for (const token of tokens) el.classList.remove(token);
+    };
+  }, [el, className]);
+}
+function useResizeObserver(el, callback) {
+  React.useEffect(() => {
+    if (!el) return;
+    callback();
+    const observer = new ResizeObserver(animationFrameThrottle(callback));
+    observer.observe(el);
+    return () => observer.disconnect();
+  }, [el, callback]);
+}
+function useTransitionActive(el) {
+  const [isActive, setIsActive] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("transitionstart", () => setIsActive(true)).add("transitionend", () => setIsActive(false));
+    return () => events.abort();
+  }, [el]);
+  return isActive;
+}
+function useMouseEnter(el) {
+  const [isMouseEnter, setIsMouseEnter] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("mouseenter", () => setIsMouseEnter(true)).add("mouseleave", () => setIsMouseEnter(false));
+    return () => events.abort();
+  }, [el]);
+  return isMouseEnter;
+}
+function useFocusIn(el) {
+  const [isFocusIn, setIsFocusIn] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("focusin", () => setIsFocusIn(true)).add("focusout", () => setIsFocusIn(false));
+    return () => events.abort();
+  }, [el]);
+  return isFocusIn;
+}
+function useActive(el) {
+  const isMouseEnter = useMouseEnter(el), isFocusIn = useFocusIn(el), prevMouseEnter = React.useRef(false);
+  if (prevMouseEnter.current && !isMouseEnter) return false;
+  prevMouseEnter.current = isMouseEnter;
+  return isMouseEnter || isFocusIn;
+}
+function useColorSchemePreference() {
+  const [colorScheme, setColorScheme] = React.useState("dark");
+  React.useEffect(() => {
+    const media = window.matchMedia("(prefers-color-scheme: light)");
+    function onChange() {
+      setColorScheme(media.matches ? "light" : "dark");
+    }
+    onChange();
+    return listenEvent(media, "change", onChange);
+  }, []);
+  return colorScheme;
+}
+
+function useLayoutName(name) {
+  const player = useMediaPlayer();
+  React.useEffect(() => {
+    if (!player) return;
+    return effect(() => {
+      const el = player.$el;
+      el?.setAttribute("data-layout", name);
+      return () => el?.removeAttribute("data-layout");
+    });
+  }, [player]);
+}
+
+export { useActive, useClassName, useColorSchemePreference, useLayoutName, useResizeObserver, useTransitionActive };
diff --git a/prod/chunks/vidstack-DgqyxmbK.js b/prod/chunks/vidstack-DgqyxmbK.js
new file mode 100644
index 0000000000000000000000000000000000000000..069752d7e4c343f2d22da6669e7284102001a3d8
--- /dev/null
+++ b/prod/chunks/vidstack-DgqyxmbK.js
@@ -0,0 +1,490 @@
+"use client"
+
+import * as React from 'react';
+import { createDisposalBin, listenEvent, createScope, signal, peek, effect, tick, isFunction, useSignal, deferredPromise } from './vidstack-CNjv_Zem.js';
+import { Internals } from 'remotion';
+import { RemotionLayoutEngine, REMOTION_PROVIDER_ID, RemotionContextProvider, ErrorBoundary } from '../player/vidstack-remotion.js';
+import { isRemotionSrc, TimeRange } from './vidstack-3ABKqYU9.js';
+import { NoReactInternals } from 'remotion/no-react';
+import './vidstack-CV12ZH4Z.js';
+import '@floating-ui/dom';
+
+class RemotionPlaybackEngine {
+  #src;
+  #onFrameChange;
+  #onEnd;
+  #disposal = createDisposalBin();
+  #frame = 0;
+  #framesAdvanced = 0;
+  #playbackRate = 1;
+  #playing = false;
+  #rafId = -1;
+  #timerId = -1;
+  #startedAt = 0;
+  #isRunningInBackground = false;
+  get frame() {
+    return this.#frame;
+  }
+  set frame(frame) {
+    this.#frame = frame;
+    this.#onFrameChange(frame);
+  }
+  constructor(src, onFrameChange, onEnd) {
+    this.#src = src;
+    this.#onFrameChange = onFrameChange;
+    this.#onEnd = onEnd;
+    this.#frame = src.initialFrame ?? 0;
+    this.#disposal.add(
+      listenEvent(document, "visibilitychange", this.#onVisibilityChange.bind(this))
+    );
+  }
+  play() {
+    this.#framesAdvanced = 0;
+    this.#playing = true;
+    this.#startedAt = performance.now();
+    this.#tick();
+  }
+  stop() {
+    this.#playing = false;
+    if (this.#rafId >= 0) {
+      cancelAnimationFrame(this.#rafId);
+      this.#rafId = -1;
+    }
+    if (this.#timerId >= 0) {
+      clearTimeout(this.#timerId);
+      this.#timerId = -1;
+    }
+  }
+  setPlaybackRate(rate) {
+    this.#playbackRate = rate;
+  }
+  destroy() {
+    this.#disposal.empty();
+    this.stop();
+  }
+  #update() {
+    const { nextFrame, framesToAdvance, ended } = this.#calculateNextFrame();
+    this.#framesAdvanced += framesToAdvance;
+    if (nextFrame !== this.#frame) {
+      this.#onFrameChange(nextFrame);
+      this.#frame = nextFrame;
+    }
+    if (ended) {
+      this.#frame = this.#src.outFrame;
+      this.stop();
+      this.#onEnd();
+    }
+  }
+  #tick = () => {
+    this.#update();
+    if (this.#playing) {
+      this.#queueNextFrame(this.#tick);
+    }
+  };
+  #queueNextFrame(callback) {
+    if (this.#isRunningInBackground) {
+      this.#timerId = window.setTimeout(callback, 1e3 / this.#src.fps);
+    } else {
+      this.#rafId = requestAnimationFrame(callback);
+    }
+  }
+  #calculateNextFrame() {
+    const round = this.#playbackRate < 0 ? Math.ceil : Math.floor, time = performance.now() - this.#startedAt, framesToAdvance = round(time * this.#playbackRate / (1e3 / this.#src.fps)) - this.#framesAdvanced, nextFrame = framesToAdvance + this.#frame, isCurrentFrameOutOfBounds = this.#frame > this.#src.outFrame || this.#frame < this.#src.inFrame, isNextFrameOutOfBounds = nextFrame > this.#src.outFrame || nextFrame < this.#src.inFrame, ended = isNextFrameOutOfBounds && !isCurrentFrameOutOfBounds;
+    if (this.#playbackRate > 0 && !ended) {
+      if (isNextFrameOutOfBounds) {
+        return {
+          nextFrame: this.#src.inFrame,
+          framesToAdvance,
+          ended
+        };
+      }
+      return { nextFrame, framesToAdvance, ended };
+    }
+    if (isNextFrameOutOfBounds) {
+      return {
+        nextFrame: this.#src.outFrame,
+        framesToAdvance,
+        ended
+      };
+    }
+    return { nextFrame, framesToAdvance, ended };
+  }
+  #onVisibilityChange() {
+    this.#isRunningInBackground = document.visibilityState === "hidden";
+    if (this.#playing) {
+      this.stop();
+      this.play();
+    }
+  }
+}
+
+NoReactInternals.validateFps;
+NoReactInternals.validateDimension;
+NoReactInternals.validateDurationInFrames;
+
+class RemotionProvider {
+  $$PROVIDER_TYPE = "REMOTION";
+  scope = createScope();
+  #src = signal(null);
+  #setup = false;
+  #loadStart = false;
+  #audio = null;
+  #waiting = signal(false);
+  #waitingPromise = null;
+  #mediaTags = signal([]);
+  #mediaElements = signal([]);
+  #bufferingElements = /* @__PURE__ */ new Set();
+  #timeline = null;
+  #frame = signal({ [REMOTION_PROVIDER_ID]: 0 });
+  #layoutEngine = new RemotionLayoutEngine();
+  #playbackEngine = null;
+  #container;
+  #ctx;
+  #setTimeline;
+  #setMediaVolume = {
+    setMediaMuted: this.setMuted.bind(this),
+    setMediaVolume: this.setVolume.bind(this)
+  };
+  get type() {
+    return "remotion";
+  }
+  get currentSrc() {
+    return peek(this.#src);
+  }
+  get frame() {
+    return this.#frame();
+  }
+  constructor(container, ctx) {
+    this.#container = container;
+    this.#ctx = ctx;
+    this.#setTimeline = {
+      setFrame: this.#setFrame.bind(this),
+      setPlaying: this.#setPlaying.bind(this)
+    };
+    this.#layoutEngine.setContainer(container);
+  }
+  setup() {
+    effect(this.#watchWaiting.bind(this));
+    effect(this.#watchMediaTags.bind(this));
+    effect(this.#watchMediaElements.bind(this));
+  }
+  #watchMediaTags() {
+    this.#mediaTags();
+    this.#discoverMediaElements();
+  }
+  #discoverMediaElements() {
+    const elements = [...this.#container.querySelectorAll("audio,video")];
+    this.#mediaElements.set(elements);
+  }
+  #watchMediaElements() {
+    const elements = this.#mediaElements();
+    for (const tag of elements) {
+      const onWait = this.#onWaitFor.bind(this, tag), onStopWaiting = this.#onStopWaitingFor.bind(this, tag);
+      if (tag.currentSrc && tag.readyState < 4) {
+        this.#onWaitFor(tag);
+        listenEvent(tag, "canplay", onStopWaiting);
+      }
+      listenEvent(tag, "waiting", onWait);
+      listenEvent(tag, "playing", onStopWaiting);
+    }
+    for (const el of this.#bufferingElements) {
+      if (!elements.includes(el)) this.#onStopWaitingFor(el);
+    }
+  }
+  #onFrameChange(frame) {
+    const { inFrame, fps } = this.#src(), { seeking } = this.#ctx.$state, time = Math.max(0, frame - inFrame) / fps;
+    this.#frame.set((record) => ({
+      ...record,
+      [REMOTION_PROVIDER_ID]: frame
+    }));
+    this.#ctx.notify("time-change", time);
+    if (seeking()) {
+      tick();
+      this.#ctx.notify("seeked", time);
+    }
+  }
+  #onFrameEnd() {
+    this.pause();
+    this.#ctx.notify("end");
+  }
+  async play() {
+    const { ended } = this.#ctx.$state;
+    if (peek(ended)) {
+      this.#setFrame({ [REMOTION_PROVIDER_ID]: 0 });
+    }
+    try {
+      const mediaElements = peek(this.#mediaElements);
+      if (mediaElements.length) {
+        await Promise.all(mediaElements.map((media) => media.play()));
+      }
+      this.#ctx.notify("play");
+      tick();
+      if (this.#waitingPromise) {
+        this.#ctx.notify("waiting");
+        return this.#waitingPromise.promise;
+      } else {
+        this.#playbackEngine?.play();
+        this.#ctx.notify("playing");
+      }
+    } catch (error) {
+      throw error;
+    }
+  }
+  async pause() {
+    this.#ctx.$state;
+    this.#playbackEngine?.stop();
+    this.#ctx.notify("pause");
+  }
+  setMuted(value) {
+    if (!this.#ctx) return;
+    const { muted, volume } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.setMuted(value(muted()));
+      return;
+    }
+    this.#ctx.notify("volume-change", {
+      volume: peek(volume),
+      muted: value
+    });
+  }
+  setCurrentTime(time) {
+    const { fps } = this.#src(), frame = time * fps;
+    this.#ctx.notify("seeking", time);
+    this.#setFrame({ [REMOTION_PROVIDER_ID]: frame });
+  }
+  setVolume(value) {
+    if (!this.#ctx) return;
+    const { volume, muted } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.setVolume(value(volume()));
+      return;
+    }
+    this.#ctx.notify("volume-change", {
+      volume: value,
+      muted: peek(muted)
+    });
+  }
+  setPlaybackRate(rate) {
+    if (isFunction(rate)) {
+      const { playbackRate } = this.#ctx.$state;
+      this.setPlaybackRate(rate(peek(playbackRate)));
+      return;
+    }
+    this.#playbackEngine?.setPlaybackRate(rate);
+    this.#ctx.notify("rate-change", rate);
+  }
+  async loadSource(src) {
+    if (!isRemotionSrc(src)) return;
+    const onUserError = src.onError, resolvedSrc = {
+      compositionWidth: 1920,
+      compositionHeight: 1080,
+      fps: 30,
+      initialFrame: 0,
+      inFrame: 0,
+      outFrame: src.durationInFrames,
+      numberOfSharedAudioTags: 5,
+      inputProps: {},
+      ...src,
+      onError: (error) => {
+        this.pause();
+        this.#ctx.notify("error", {
+          message: error.message,
+          code: 1
+        });
+        onUserError?.(error);
+      }
+    };
+    this.#src.set(resolvedSrc);
+    for (const prop of Object.keys(resolvedSrc)) {
+      src[prop] = resolvedSrc[prop];
+    }
+    this.changeSrc(resolvedSrc);
+  }
+  destroy() {
+    this.changeSrc(null);
+  }
+  changeSrc(src) {
+    this.#playbackEngine?.destroy();
+    this.#waiting.set(false);
+    this.#waitingPromise?.reject("src changed");
+    this.#waitingPromise = null;
+    this.#audio = null;
+    this.#timeline = null;
+    this.#playbackEngine = null;
+    this.#mediaTags.set([]);
+    this.#bufferingElements.clear();
+    this.#frame.set({ [REMOTION_PROVIDER_ID]: 0 });
+    this.#layoutEngine.setSrc(src);
+    if (src) {
+      this.#timeline = this.#createTimelineContextValue();
+      this.#playbackEngine = new RemotionPlaybackEngine(
+        src,
+        this.#onFrameChange.bind(this),
+        this.#onFrameEnd.bind(this)
+      );
+    }
+  }
+  render = () => {
+    const $src = useSignal(this.#src);
+    if (!$src) {
+      throw Error(
+        "[vidstack] no src"
+      );
+    }
+    React.useEffect(() => {
+      if (!isRemotionSrc($src)) return;
+      const rafId = requestAnimationFrame(() => {
+        if (!this.#setup) {
+          this.#ctx.notify("provider-setup", this);
+          this.#setup = true;
+        }
+        if (!this.#loadStart) {
+          this.#ctx.notify("load-start");
+          this.#loadStart = true;
+        }
+        this.#discoverMediaElements();
+        tick();
+        if (!this.#waiting()) this.#ready($src);
+      });
+      return () => {
+        cancelAnimationFrame(rafId);
+        this.#loadStart = false;
+      };
+    }, [$src]);
+    const Component = Internals.useLazyComponent({
+      component: $src.src
+    });
+    const { $state } = this.#ctx, $volume = useSignal($state.volume), $isMuted = useSignal($state.muted);
+    const mediaVolume = React.useMemo(() => {
+      const { muted, volume } = this.#ctx.$state;
+      return { mediaMuted: muted(), mediaVolume: volume() };
+    }, [$isMuted, $volume]);
+    return /* @__PURE__ */ React.createElement(
+      RemotionContextProvider,
+      {
+        src: $src,
+        component: Component,
+        timeline: this.#timeline,
+        mediaVolume,
+        setMediaVolume: this.#setMediaVolume
+      },
+      /* @__PURE__ */ React.createElement(Internals.Timeline.SetTimelineContext.Provider, { value: this.#setTimeline }, React.createElement(this.renderVideo, { src: $src }))
+    );
+  };
+  renderVideo = ({ src }) => {
+    const video = Internals.useVideo(), Video = video ? video.component : null, audioContext = React.useContext(Internals.SharedAudioContext);
+    const { $state } = this.#ctx;
+    useSignal(this.#frame);
+    useSignal($state.playing);
+    useSignal($state.playbackRate);
+    React.useEffect(() => {
+      this.#audio = audioContext;
+      return () => {
+        this.#audio = null;
+      };
+    }, [audioContext]);
+    const LoadingContent = React.useMemo(() => src.renderLoading?.(), [src]);
+    const Content = Video ? /* @__PURE__ */ React.createElement(ErrorBoundary, { fallback: src.errorFallback, onError: src.onError }, /* @__PURE__ */ React.createElement(Internals.ClipComposition, null, /* @__PURE__ */ React.createElement(Video, { ...video?.props, ...src.inputProps }))) : null;
+    return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: LoadingContent }, Content);
+  };
+  #ready(src) {
+    if (!src) return;
+    const { outFrame, inFrame, fps } = src, duration = (outFrame - inFrame) / fps;
+    this.#ctx.notify("loaded-metadata");
+    this.#ctx.notify("loaded-data");
+    this.#ctx.delegate.ready({
+      duration,
+      seekable: new TimeRange(0, duration),
+      buffered: new TimeRange(0, duration)
+    });
+    if (src.initialFrame) {
+      this.#setFrame({
+        [REMOTION_PROVIDER_ID]: src.initialFrame
+      });
+    }
+  }
+  #onWaitFor(el) {
+    this.#bufferingElements.add(el);
+    this.#waiting.set(true);
+    if (!this.#waitingPromise) {
+      this.#waitingPromise = deferredPromise();
+    }
+  }
+  #onStopWaitingFor(el) {
+    this.#bufferingElements.delete(el);
+    if (this.#bufferingElements.size) return;
+    this.#waiting.set(false);
+    this.#waitingPromise?.resolve();
+    this.#waitingPromise = null;
+    const { canPlay } = this.#ctx.$state;
+    if (!peek(canPlay)) {
+      this.#ready(peek(this.#src));
+    }
+  }
+  #watchWaiting() {
+    this.#waiting();
+    const { paused } = this.#ctx.$state;
+    if (peek(paused)) return;
+    if (this.#waiting()) {
+      this.#playbackEngine?.stop();
+      this.#ctx.notify("waiting");
+    } else {
+      this.#playbackEngine?.play();
+      this.#ctx.notify("playing");
+    }
+  }
+  #setFrame(value) {
+    if (isFunction(value)) {
+      this.#setFrame(value(this.#frame()));
+      return;
+    }
+    this.#frame.set((record) => ({ ...record, ...value }));
+    const nextFrame = value[REMOTION_PROVIDER_ID];
+    if (this.#playbackEngine && this.#playbackEngine.frame !== nextFrame) {
+      this.#playbackEngine.frame = nextFrame;
+    }
+  }
+  #setPlaying(value) {
+    const { playing } = this.#ctx.$state;
+    if (isFunction(value)) {
+      this.#setPlaying(value(playing()));
+      return;
+    }
+    if (value) {
+      this.play();
+    } else if (!value) {
+      this.pause();
+    }
+  }
+  #createTimelineContextValue() {
+    const { playing, playbackRate } = this.#ctx.$state, frame = this.#frame, mediaTags = this.#mediaTags, setPlaybackRate = this.setPlaybackRate.bind(this);
+    return {
+      rootId: REMOTION_PROVIDER_ID,
+      get frame() {
+        return frame();
+      },
+      get playing() {
+        return playing();
+      },
+      get playbackRate() {
+        return playbackRate();
+      },
+      imperativePlaying: {
+        get current() {
+          return playing();
+        }
+      },
+      setPlaybackRate,
+      audioAndVideoTags: {
+        get current() {
+          return mediaTags();
+        },
+        set current(tags) {
+          mediaTags.set(tags);
+        }
+      }
+    };
+  }
+}
+
+export { RemotionProvider };
diff --git a/prod/chunks/vidstack-DjW7_-Ze.js b/prod/chunks/vidstack-DjW7_-Ze.js
new file mode 100644
index 0000000000000000000000000000000000000000..1fde9b853a8b278d96881d8a116bc99342e0212b
--- /dev/null
+++ b/prod/chunks/vidstack-DjW7_-Ze.js
@@ -0,0 +1,287 @@
+"use client"
+
+import { createScope, signal, effect, isString, deferredPromise, isObject, isNumber, isBoolean } from './vidstack-CNjv_Zem.js';
+import { preconnect, TimeRange } from './vidstack-BY07IoHR.js';
+import { EmbedProvider } from './vidstack-DI1IwIaU.js';
+import { resolveYouTubeVideoId } from './vidstack-Zc3I7oOd.js';
+import 'react';
+import '@floating-ui/dom';
+
+const YouTubePlayerState = {
+  Unstarted: -1,
+  Ended: 0,
+  Playing: 1,
+  Paused: 2,
+  Buffering: 3,
+  Cued: 5
+};
+
+class YouTubeProvider extends EmbedProvider {
+  $$PROVIDER_TYPE = "YOUTUBE";
+  scope = createScope();
+  #ctx;
+  #videoId = signal("");
+  #state = -1;
+  #currentSrc = null;
+  #seekingTimer = -1;
+  #invalidPlay = false;
+  #promises = /* @__PURE__ */ new Map();
+  constructor(iframe, ctx) {
+    super(iframe);
+    this.#ctx = ctx;
+  }
+  /**
+   * Sets the player's interface language. The parameter value is an ISO 639-1 two-letter
+   * language code or a fully specified locale. For example, fr and fr-ca are both valid values.
+   * Other language input codes, such as IETF language tags (BCP 47) might also be handled properly.
+   *
+   * The interface language is used for tooltips in the player and also affects the default caption
+   * track. Note that YouTube might select a different caption track language for a particular
+   * user based on the user's individual language preferences and the availability of caption tracks.
+   *
+   * @defaultValue 'en'
+   */
+  language = "en";
+  color = "red";
+  /**
+   * Whether cookies should be enabled on the embed. This is turned off by default to be
+   * GDPR-compliant.
+   *
+   * @defaultValue `false`
+   */
+  cookies = false;
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  get type() {
+    return "youtube";
+  }
+  get videoId() {
+    return this.#videoId();
+  }
+  preconnect() {
+    preconnect(this.getOrigin());
+  }
+  setup() {
+    super.setup();
+    effect(this.#watchVideoId.bind(this));
+    this.#ctx.notify("provider-setup", this);
+  }
+  destroy() {
+    this.#reset();
+    const message = "provider destroyed";
+    for (const promises of this.#promises.values()) {
+      for (const { reject } of promises) reject(message);
+    }
+    this.#promises.clear();
+  }
+  async play() {
+    return this.#remote("playVideo");
+  }
+  #playFail(message) {
+    this.#getPromise("playVideo")?.reject(message);
+  }
+  async pause() {
+    return this.#remote("pauseVideo");
+  }
+  #pauseFail(message) {
+    this.#getPromise("pauseVideo")?.reject(message);
+  }
+  setMuted(muted) {
+    if (muted) this.#remote("mute");
+    else this.#remote("unMute");
+  }
+  setCurrentTime(time) {
+    this.#remote("seekTo", time);
+    this.#ctx.notify("seeking", time);
+  }
+  setVolume(volume) {
+    this.#remote("setVolume", volume * 100);
+  }
+  setPlaybackRate(rate) {
+    this.#remote("setPlaybackRate", rate);
+  }
+  async loadSource(src) {
+    if (!isString(src.src)) {
+      this.#currentSrc = null;
+      this.#videoId.set("");
+      return;
+    }
+    const videoId = resolveYouTubeVideoId(src.src);
+    this.#videoId.set(videoId ?? "");
+    this.#currentSrc = src;
+  }
+  getOrigin() {
+    return !this.cookies ? "https://www.youtube-nocookie.com" : "https://www.youtube.com";
+  }
+  #watchVideoId() {
+    this.#reset();
+    const videoId = this.#videoId();
+    if (!videoId) {
+      this.src.set("");
+      return;
+    }
+    this.src.set(`${this.getOrigin()}/embed/${videoId}`);
+    this.#ctx.notify("load-start");
+  }
+  buildParams() {
+    const { keyDisabled } = this.#ctx.$props, { muted, playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
+    return {
+      autoplay: 0,
+      cc_lang_pref: this.language,
+      cc_load_policy: showControls ? 1 : void 0,
+      color: this.color,
+      controls: showControls ? 1 : 0,
+      disablekb: !showControls || keyDisabled() ? 1 : 0,
+      enablejsapi: 1,
+      fs: 1,
+      hl: this.language,
+      iv_load_policy: showControls ? 1 : 3,
+      mute: muted() ? 1 : 0,
+      playsinline: playsInline() ? 1 : 0
+    };
+  }
+  #remote(command, arg) {
+    let promise = deferredPromise(), promises = this.#promises.get(command);
+    if (!promises) this.#promises.set(command, promises = []);
+    promises.push(promise);
+    this.postMessage({
+      event: "command",
+      func: command,
+      args: arg ? [arg] : void 0
+    });
+    return promise.promise;
+  }
+  onLoad() {
+    window.setTimeout(() => this.postMessage({ event: "listening" }), 100);
+  }
+  #onReady(trigger) {
+    this.#ctx.notify("loaded-metadata");
+    this.#ctx.notify("loaded-data");
+    this.#ctx.delegate.ready(void 0, trigger);
+  }
+  #onPause(trigger) {
+    this.#getPromise("pauseVideo")?.resolve();
+    this.#ctx.notify("pause", void 0, trigger);
+  }
+  #onTimeUpdate(time, trigger) {
+    const { duration, realCurrentTime } = this.#ctx.$state, hasEnded = this.#state === YouTubePlayerState.Ended, boundTime = hasEnded ? duration() : time;
+    this.#ctx.notify("time-change", boundTime, trigger);
+    if (!hasEnded && Math.abs(boundTime - realCurrentTime()) > 1) {
+      this.#ctx.notify("seeking", boundTime, trigger);
+    }
+  }
+  #onProgress(buffered, seekable, trigger) {
+    const detail = {
+      buffered: new TimeRange(0, buffered),
+      seekable
+    };
+    this.#ctx.notify("progress", detail, trigger);
+    const { seeking, realCurrentTime } = this.#ctx.$state;
+    if (seeking() && buffered > realCurrentTime()) {
+      this.#onSeeked(trigger);
+    }
+  }
+  #onSeeked(trigger) {
+    const { paused, realCurrentTime } = this.#ctx.$state;
+    window.clearTimeout(this.#seekingTimer);
+    this.#seekingTimer = window.setTimeout(
+      () => {
+        this.#ctx.notify("seeked", realCurrentTime(), trigger);
+        this.#seekingTimer = -1;
+      },
+      paused() ? 100 : 0
+    );
+  }
+  #onEnded(trigger) {
+    const { seeking } = this.#ctx.$state;
+    if (seeking()) this.#onSeeked(trigger);
+    this.#ctx.notify("pause", void 0, trigger);
+    this.#ctx.notify("end", void 0, trigger);
+  }
+  #onStateChange(state, trigger) {
+    const { paused, seeking } = this.#ctx.$state, isPlaying = state === YouTubePlayerState.Playing, isBuffering = state === YouTubePlayerState.Buffering, isPendingPlay = this.#isPending("playVideo"), isPlay = paused() && (isBuffering || isPlaying);
+    if (isBuffering) this.#ctx.notify("waiting", void 0, trigger);
+    if (seeking() && isPlaying) {
+      this.#onSeeked(trigger);
+    }
+    if (this.#invalidPlay && isPlaying) {
+      this.pause();
+      this.#invalidPlay = false;
+      this.setMuted(this.#ctx.$state.muted());
+      return;
+    }
+    if (!isPendingPlay && isPlay) {
+      this.#invalidPlay = true;
+      this.setMuted(true);
+      return;
+    }
+    if (isPlay) {
+      this.#getPromise("playVideo")?.resolve();
+      this.#ctx.notify("play", void 0, trigger);
+    }
+    switch (state) {
+      case YouTubePlayerState.Cued:
+        this.#onReady(trigger);
+        break;
+      case YouTubePlayerState.Playing:
+        this.#ctx.notify("playing", void 0, trigger);
+        break;
+      case YouTubePlayerState.Paused:
+        this.#onPause(trigger);
+        break;
+      case YouTubePlayerState.Ended:
+        this.#onEnded(trigger);
+        break;
+    }
+    this.#state = state;
+  }
+  onMessage({ info }, event) {
+    if (!info) return;
+    const { title, intrinsicDuration, playbackRate } = this.#ctx.$state;
+    if (isObject(info.videoData) && info.videoData.title !== title()) {
+      this.#ctx.notify("title-change", info.videoData.title, event);
+    }
+    if (isNumber(info.duration) && info.duration !== intrinsicDuration()) {
+      if (isNumber(info.videoLoadedFraction)) {
+        const buffered = info.progressState?.loaded ?? info.videoLoadedFraction * info.duration, seekable = new TimeRange(0, info.duration);
+        this.#onProgress(buffered, seekable, event);
+      }
+      this.#ctx.notify("duration-change", info.duration, event);
+    }
+    if (isNumber(info.playbackRate) && info.playbackRate !== playbackRate()) {
+      this.#ctx.notify("rate-change", info.playbackRate, event);
+    }
+    if (info.progressState) {
+      const { current, seekableStart, seekableEnd, loaded, duration } = info.progressState;
+      this.#onTimeUpdate(current, event);
+      this.#onProgress(loaded, new TimeRange(seekableStart, seekableEnd), event);
+      if (duration !== intrinsicDuration()) {
+        this.#ctx.notify("duration-change", duration, event);
+      }
+    }
+    if (isNumber(info.volume) && isBoolean(info.muted) && !this.#invalidPlay) {
+      const detail = {
+        muted: info.muted,
+        volume: info.volume / 100
+      };
+      this.#ctx.notify("volume-change", detail, event);
+    }
+    if (isNumber(info.playerState) && info.playerState !== this.#state) {
+      this.#onStateChange(info.playerState, event);
+    }
+  }
+  #reset() {
+    this.#state = -1;
+    this.#seekingTimer = -1;
+    this.#invalidPlay = false;
+  }
+  #getPromise(command) {
+    return this.#promises.get(command)?.shift();
+  }
+  #isPending(command) {
+    return Boolean(this.#promises.get(command)?.length);
+  }
+}
+
+export { YouTubeProvider };
diff --git a/prod/chunks/vidstack-GSrM5t5G.js b/prod/chunks/vidstack-GSrM5t5G.js
new file mode 100644
index 0000000000000000000000000000000000000000..a2dda03d7d355c851f93fdfb274e01b6b9a1d374
--- /dev/null
+++ b/prod/chunks/vidstack-GSrM5t5G.js
@@ -0,0 +1,471 @@
+"use client"
+
+import { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from './vidstack-CNjv_Zem.js';
+import { ListSymbol, TimeRange, RAFLoop } from './vidstack-BY07IoHR.js';
+import { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-BQRr1gez.js';
+import 'react';
+import '@floating-ui/dom';
+
+class GoogleCastMediaInfoBuilder {
+  #info;
+  constructor(src) {
+    this.#info = new chrome.cast.media.MediaInfo(src.src, src.type);
+  }
+  build() {
+    return this.#info;
+  }
+  setStreamType(streamType) {
+    if (streamType.includes("live")) {
+      this.#info.streamType = chrome.cast.media.StreamType.LIVE;
+    } else {
+      this.#info.streamType = chrome.cast.media.StreamType.BUFFERED;
+    }
+    return this;
+  }
+  setTracks(tracks) {
+    this.#info.tracks = tracks.map(this.#buildCastTrack);
+    return this;
+  }
+  setMetadata(title, poster) {
+    this.#info.metadata = new chrome.cast.media.GenericMediaMetadata();
+    this.#info.metadata.title = title;
+    this.#info.metadata.images = [{ url: poster }];
+    return this;
+  }
+  #buildCastTrack(track, trackId) {
+    const castTrack = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);
+    castTrack.name = track.label;
+    castTrack.trackContentId = track.src;
+    castTrack.trackContentType = "text/vtt";
+    castTrack.language = track.language;
+    castTrack.subtype = track.kind.toUpperCase();
+    return castTrack;
+  }
+}
+
+const REMOTE_TRACK_TEXT_TYPE = chrome.cast.media.TrackType.TEXT, REMOTE_TRACK_AUDIO_TYPE = chrome.cast.media.TrackType.AUDIO;
+class GoogleCastTracksManager {
+  #cast;
+  #ctx;
+  #onNewLocalTracks;
+  constructor(cast, ctx, onNewLocalTracks) {
+    this.#cast = cast;
+    this.#ctx = ctx;
+    this.#onNewLocalTracks = onNewLocalTracks;
+  }
+  setup() {
+    const syncRemoteActiveIds = this.syncRemoteActiveIds.bind(this);
+    listenEvent(this.#ctx.audioTracks, "change", syncRemoteActiveIds);
+    listenEvent(this.#ctx.textTracks, "mode-change", syncRemoteActiveIds);
+    effect(this.#syncLocalTracks.bind(this));
+  }
+  getLocalTextTracks() {
+    return this.#ctx.$state.textTracks().filter((track) => track.src && track.type === "vtt");
+  }
+  #getLocalAudioTracks() {
+    return this.#ctx.$state.audioTracks();
+  }
+  #getRemoteTracks(type) {
+    const tracks = this.#cast.mediaInfo?.tracks ?? [];
+    return type ? tracks.filter((track) => track.type === type) : tracks;
+  }
+  #getRemoteActiveIds() {
+    const activeIds = [], activeLocalAudioTrack = this.#getLocalAudioTracks().find((track) => track.selected), activeLocalTextTracks = this.getLocalTextTracks().filter((track) => track.mode === "showing");
+    if (activeLocalAudioTrack) {
+      const remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteAudioTrack = this.#findRemoteTrack(remoteAudioTracks, activeLocalAudioTrack);
+      if (remoteAudioTrack) activeIds.push(remoteAudioTrack.trackId);
+    }
+    if (activeLocalTextTracks?.length) {
+      const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+      if (remoteTextTracks.length) {
+        for (const localTrack of activeLocalTextTracks) {
+          const remoteTextTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
+          if (remoteTextTrack) activeIds.push(remoteTextTrack.trackId);
+        }
+      }
+    }
+    return activeIds;
+  }
+  #syncLocalTracks() {
+    const localTextTracks = this.getLocalTextTracks();
+    if (!this.#cast.isMediaLoaded) return;
+    const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+    for (const localTrack of localTextTracks) {
+      const hasRemoteTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
+      if (!hasRemoteTrack) {
+        untrack(() => this.#onNewLocalTracks?.());
+        break;
+      }
+    }
+  }
+  syncRemoteTracks(event) {
+    if (!this.#cast.isMediaLoaded) return;
+    const localAudioTracks = this.#getLocalAudioTracks(), localTextTracks = this.getLocalTextTracks(), remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+    for (const remoteAudioTrack of remoteAudioTracks) {
+      const hasLocalTrack = this.#findLocalTrack(localAudioTracks, remoteAudioTrack);
+      if (hasLocalTrack) continue;
+      const localAudioTrack = {
+        id: remoteAudioTrack.trackId.toString(),
+        label: remoteAudioTrack.name,
+        language: remoteAudioTrack.language,
+        kind: remoteAudioTrack.subtype ?? "main",
+        selected: false
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localAudioTrack, event);
+    }
+    for (const remoteTextTrack of remoteTextTracks) {
+      const hasLocalTrack = this.#findLocalTrack(localTextTracks, remoteTextTrack);
+      if (hasLocalTrack) continue;
+      const localTextTrack = {
+        id: remoteTextTrack.trackId.toString(),
+        src: remoteTextTrack.trackContentId,
+        label: remoteTextTrack.name,
+        language: remoteTextTrack.language,
+        kind: remoteTextTrack.subtype.toLowerCase()
+      };
+      this.#ctx.textTracks.add(localTextTrack, event);
+    }
+  }
+  syncRemoteActiveIds(event) {
+    if (!this.#cast.isMediaLoaded) return;
+    const activeIds = this.#getRemoteActiveIds(), editRequest = new chrome.cast.media.EditTracksInfoRequest(activeIds);
+    this.#editTracksInfo(editRequest).catch((error) => {
+    });
+  }
+  #editTracksInfo(request) {
+    const media = getCastSessionMedia();
+    return new Promise((resolve, reject) => media?.editTracksInfo(request, resolve, reject));
+  }
+  #findLocalTrack(localTracks, remoteTrack) {
+    return localTracks.find((localTrack) => this.#isMatch(localTrack, remoteTrack));
+  }
+  #findRemoteTrack(remoteTracks, localTrack) {
+    return remoteTracks.find((remoteTrack) => this.#isMatch(localTrack, remoteTrack));
+  }
+  // Note: we can't rely on id matching because they will differ between local/remote. A local
+  // track id might not even exist.
+  #isMatch(localTrack, remoteTrack) {
+    return remoteTrack.name === localTrack.label && remoteTrack.language === localTrack.language && remoteTrack.subtype.toLowerCase() === localTrack.kind.toLowerCase();
+  }
+}
+
+class GoogleCastProvider {
+  $$PROVIDER_TYPE = "GOOGLE_CAST";
+  scope = createScope();
+  #player;
+  #ctx;
+  #tracks;
+  #currentSrc = null;
+  #state = "disconnected";
+  #currentTime = 0;
+  #played = 0;
+  #seekableRange = new TimeRange(0, 0);
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #playerEventHandlers;
+  #reloadInfo = null;
+  #isIdle = false;
+  constructor(player, ctx) {
+    this.#player = player;
+    this.#ctx = ctx;
+    this.#tracks = new GoogleCastTracksManager(player, ctx, this.#onNewLocalTracks.bind(this));
+  }
+  get type() {
+    return "google-cast";
+  }
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  /**
+   * The Google Cast remote player.
+   *
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.RemotePlayer}
+   */
+  get player() {
+    return this.#player;
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
+   */
+  get cast() {
+    return getCastContext();
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastSession}
+   */
+  get session() {
+    return getCastSession();
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media.Media}
+   */
+  get media() {
+    return getCastSessionMedia();
+  }
+  /**
+   * Whether the current Google Cast session belongs to this provider.
+   */
+  get hasActiveSession() {
+    return hasActiveCastSession(this.#currentSrc);
+  }
+  setup() {
+    this.#attachCastContextEventListeners();
+    this.#attachCastPlayerEventListeners();
+    this.#tracks.setup();
+    this.#ctx.notify("provider-setup", this);
+  }
+  #attachCastContextEventListeners() {
+    listenCastContextEvent(
+      cast.framework.CastContextEventType.CAST_STATE_CHANGED,
+      this.#onCastStateChange.bind(this)
+    );
+  }
+  #attachCastPlayerEventListeners() {
+    const Event2 = cast.framework.RemotePlayerEventType, handlers = {
+      [Event2.IS_CONNECTED_CHANGED]: this.#onCastStateChange,
+      [Event2.IS_MEDIA_LOADED_CHANGED]: this.#onMediaLoadedChange,
+      [Event2.CAN_CONTROL_VOLUME_CHANGED]: this.#onCanControlVolumeChange,
+      [Event2.CAN_SEEK_CHANGED]: this.#onCanSeekChange,
+      [Event2.DURATION_CHANGED]: this.#onDurationChange,
+      [Event2.IS_MUTED_CHANGED]: this.#onVolumeChange,
+      [Event2.VOLUME_LEVEL_CHANGED]: this.#onVolumeChange,
+      [Event2.IS_PAUSED_CHANGED]: this.#onPausedChange,
+      [Event2.LIVE_SEEKABLE_RANGE_CHANGED]: this.#onProgress,
+      [Event2.PLAYER_STATE_CHANGED]: this.#onPlayerStateChange
+    };
+    this.#playerEventHandlers = handlers;
+    const handler = this.#onRemotePlayerEvent.bind(this);
+    for (const type of keysOf(handlers)) {
+      this.#player.controller.addEventListener(type, handler);
+    }
+    onDispose(() => {
+      for (const type of keysOf(handlers)) {
+        this.#player.controller.removeEventListener(type, handler);
+      }
+    });
+  }
+  async play() {
+    if (!this.#player.isPaused && !this.#isIdle) return;
+    if (this.#isIdle) {
+      await this.#reload(false, 0);
+      return;
+    }
+    this.#player.controller?.playOrPause();
+  }
+  async pause() {
+    if (this.#player.isPaused) return;
+    this.#player.controller?.playOrPause();
+  }
+  getMediaStatus(request) {
+    return new Promise((resolve, reject) => {
+      this.media?.getStatus(request, resolve, reject);
+    });
+  }
+  setMuted(muted) {
+    const hasChanged = muted && !this.#player.isMuted || !muted && this.#player.isMuted;
+    if (hasChanged) this.#player.controller?.muteOrUnmute();
+  }
+  setCurrentTime(time) {
+    this.#player.currentTime = time;
+    this.#ctx.notify("seeking", time);
+    this.#player.controller?.seek();
+  }
+  setVolume(volume) {
+    this.#player.volumeLevel = volume;
+    this.#player.controller?.setVolumeLevel();
+  }
+  async loadSource(src) {
+    if (this.#reloadInfo?.src !== src) this.#reloadInfo = null;
+    if (hasActiveCastSession(src)) {
+      this.#resumeSession();
+      this.#currentSrc = src;
+      return;
+    }
+    this.#ctx.notify("load-start");
+    const loadRequest = this.#buildLoadRequest(src), errorCode = await this.session.loadMedia(loadRequest);
+    if (errorCode) {
+      this.#currentSrc = null;
+      this.#ctx.notify("error", Error(getCastErrorMessage(errorCode)));
+      return;
+    }
+    this.#currentSrc = src;
+  }
+  destroy() {
+    this.#reset();
+    this.#endSession();
+  }
+  #reset() {
+    if (!this.#reloadInfo) {
+      this.#played = 0;
+      this.#seekableRange = new TimeRange(0, 0);
+    }
+    this.#timeRAF.stop();
+    this.#currentTime = 0;
+    this.#reloadInfo = null;
+  }
+  #resumeSession() {
+    const resumeSessionEvent = new DOMEvent("resume-session", { detail: this.session });
+    this.#onMediaLoadedChange(resumeSessionEvent);
+    const { muted, volume, savedState } = this.#ctx.$state, localState = savedState();
+    this.setCurrentTime(Math.max(this.#player.currentTime, localState?.currentTime ?? 0));
+    this.setMuted(muted());
+    this.setVolume(volume());
+    if (localState?.paused === false) this.play();
+  }
+  #endSession() {
+    this.cast.endCurrentSession(true);
+    const { remotePlaybackLoader } = this.#ctx.$state;
+    remotePlaybackLoader.set(null);
+  }
+  #disconnectFromReceiver() {
+    const { savedState } = this.#ctx.$state;
+    savedState.set({
+      paused: this.#player.isPaused,
+      currentTime: this.#player.currentTime
+    });
+    this.#endSession();
+  }
+  #onAnimationFrame() {
+    this.#onCurrentTimeChange();
+  }
+  #onRemotePlayerEvent(event) {
+    this.#playerEventHandlers[event.type].call(this, event);
+  }
+  #onCastStateChange(data) {
+    const castState = this.cast.getCastState(), state = castState === cast.framework.CastState.CONNECTED ? "connected" : castState === cast.framework.CastState.CONNECTING ? "connecting" : "disconnected";
+    if (this.#state === state) return;
+    const detail = { type: "google-cast", state }, trigger = this.#createEvent(data);
+    this.#state = state;
+    this.#ctx.notify("remote-playback-change", detail, trigger);
+    if (state === "disconnected") {
+      this.#disconnectFromReceiver();
+    }
+  }
+  #onMediaLoadedChange(event) {
+    const hasLoaded = !!this.#player.isMediaLoaded;
+    if (!hasLoaded) return;
+    const src = peek(this.#ctx.$state.source);
+    Promise.resolve().then(() => {
+      if (src !== peek(this.#ctx.$state.source) || !this.#player.isMediaLoaded) return;
+      this.#reset();
+      const duration = this.#player.duration;
+      this.#seekableRange = new TimeRange(0, duration);
+      const detail = {
+        provider: this,
+        duration,
+        buffered: new TimeRange(0, 0),
+        seekable: this.#getSeekableRange()
+      }, trigger = this.#createEvent(event);
+      this.#ctx.notify("loaded-metadata", void 0, trigger);
+      this.#ctx.notify("loaded-data", void 0, trigger);
+      this.#ctx.notify("can-play", detail, trigger);
+      this.#onCanControlVolumeChange();
+      this.#onCanSeekChange(event);
+      const { volume, muted } = this.#ctx.$state;
+      this.setVolume(volume());
+      this.setMuted(muted());
+      this.#timeRAF.start();
+      this.#tracks.syncRemoteTracks(trigger);
+      this.#tracks.syncRemoteActiveIds(trigger);
+    });
+  }
+  #onCanControlVolumeChange() {
+    this.#ctx.$state.canSetVolume.set(this.#player.canControlVolume);
+  }
+  #onCanSeekChange(event) {
+    const trigger = this.#createEvent(event);
+    this.#ctx.notify("stream-type-change", this.#getStreamType(), trigger);
+  }
+  #getStreamType() {
+    const streamType = this.#player.mediaInfo?.streamType;
+    return streamType === chrome.cast.media.StreamType.LIVE ? this.#player.canSeek ? "live:dvr" : "live" : "on-demand";
+  }
+  #onCurrentTimeChange() {
+    if (this.#reloadInfo) return;
+    const currentTime = this.#player.currentTime;
+    if (currentTime === this.#currentTime) return;
+    this.#ctx.notify("time-change", currentTime);
+    if (currentTime > this.#played) {
+      this.#played = currentTime;
+      this.#onProgress();
+    }
+    if (this.#ctx.$state.seeking()) {
+      this.#ctx.notify("seeked", currentTime);
+    }
+    this.#currentTime = currentTime;
+  }
+  #onDurationChange(event) {
+    if (!this.#player.isMediaLoaded || this.#reloadInfo) return;
+    const duration = this.#player.duration, trigger = this.#createEvent(event);
+    this.#seekableRange = new TimeRange(0, duration);
+    this.#ctx.notify("duration-change", duration, trigger);
+  }
+  #onVolumeChange(event) {
+    if (!this.#player.isMediaLoaded) return;
+    const detail = {
+      muted: this.#player.isMuted,
+      volume: this.#player.volumeLevel
+    }, trigger = this.#createEvent(event);
+    this.#ctx.notify("volume-change", detail, trigger);
+  }
+  #onPausedChange(event) {
+    const trigger = this.#createEvent(event);
+    if (this.#player.isPaused) {
+      this.#ctx.notify("pause", void 0, trigger);
+    } else {
+      this.#ctx.notify("play", void 0, trigger);
+    }
+  }
+  #onProgress(event) {
+    const detail = {
+      seekable: this.#getSeekableRange(),
+      buffered: new TimeRange(0, this.#played)
+    }, trigger = event ? this.#createEvent(event) : void 0;
+    this.#ctx.notify("progress", detail, trigger);
+  }
+  #onPlayerStateChange(event) {
+    const state = this.#player.playerState, PlayerState = chrome.cast.media.PlayerState;
+    this.#isIdle = state === PlayerState.IDLE;
+    if (state === PlayerState.PAUSED) return;
+    const trigger = this.#createEvent(event);
+    switch (state) {
+      case PlayerState.PLAYING:
+        this.#ctx.notify("playing", void 0, trigger);
+        break;
+      case PlayerState.BUFFERING:
+        this.#ctx.notify("waiting", void 0, trigger);
+        break;
+      case PlayerState.IDLE:
+        this.#timeRAF.stop();
+        this.#ctx.notify("pause");
+        this.#ctx.notify("end");
+        break;
+    }
+  }
+  #getSeekableRange() {
+    return this.#player.liveSeekableRange ? new TimeRange(this.#player.liveSeekableRange.start, this.#player.liveSeekableRange.end) : this.#seekableRange;
+  }
+  #createEvent(detail) {
+    return detail instanceof Event ? detail : new DOMEvent(detail.type, { detail });
+  }
+  #buildMediaInfo(src) {
+    const { streamType, title, poster } = this.#ctx.$state;
+    return new GoogleCastMediaInfoBuilder(src).setMetadata(title(), poster()).setStreamType(streamType()).setTracks(this.#tracks.getLocalTextTracks()).build();
+  }
+  #buildLoadRequest(src) {
+    const mediaInfo = this.#buildMediaInfo(src), request = new chrome.cast.media.LoadRequest(mediaInfo), savedState = this.#ctx.$state.savedState();
+    request.autoplay = (this.#reloadInfo?.paused ?? savedState?.paused) === false;
+    request.currentTime = this.#reloadInfo?.time ?? savedState?.currentTime ?? 0;
+    return request;
+  }
+  async #reload(paused, time) {
+    const src = peek(this.#ctx.$state.source);
+    this.#reloadInfo = { src, paused, time };
+    await this.loadSource(src);
+  }
+  #onNewLocalTracks() {
+    this.#reload(this.#player.isPaused, this.#player.currentTime).catch((error) => {
+    });
+  }
+}
+
+export { GoogleCastProvider };
diff --git a/prod/chunks/vidstack-HMgOfN5g.js b/prod/chunks/vidstack-HMgOfN5g.js
new file mode 100644
index 0000000000000000000000000000000000000000..587efefda2311f27adf754ed91c4eb363697a42c
--- /dev/null
+++ b/prod/chunks/vidstack-HMgOfN5g.js
@@ -0,0 +1,386 @@
+"use client"
+
+import { peek, listenEvent, effect, DOMEvent, isString, camelToKebabCase, isUndefined, isFunction } from './vidstack-CNjv_Zem.js';
+import { QualitySymbol, RAFLoop, TextTrack, TextTrackSymbol, ListSymbol, IS_CHROME, coerceToError, loadScript, VideoProvider, isHLSSupported, preconnect } from './vidstack-CwFL6mmL.js';
+import 'react';
+import '@floating-ui/dom';
+
+const toDOMEventType = (type) => camelToKebabCase(type);
+class HLSController {
+  #video;
+  #ctx;
+  #instance = null;
+  #stopLiveSync = null;
+  config = {};
+  #callbacks = /* @__PURE__ */ new Set();
+  get instance() {
+    return this.#instance;
+  }
+  constructor(video, ctx) {
+    this.#video = video;
+    this.#ctx = ctx;
+  }
+  setup(ctor) {
+    const { streamType } = this.#ctx.$state;
+    const isLive = peek(streamType).includes("live"), isLiveLowLatency = peek(streamType).includes("ll-");
+    this.#instance = new ctor({
+      lowLatencyMode: isLiveLowLatency,
+      backBufferLength: isLiveLowLatency ? 4 : isLive ? 8 : void 0,
+      renderTextTracksNatively: false,
+      ...this.config
+    });
+    const dispatcher = this.#dispatchHLSEvent.bind(this);
+    for (const event of Object.values(ctor.Events)) this.#instance.on(event, dispatcher);
+    this.#instance.on(ctor.Events.ERROR, this.#onError.bind(this));
+    for (const callback of this.#callbacks) callback(this.#instance);
+    this.#ctx.player.dispatch("hls-instance", {
+      detail: this.#instance
+    });
+    this.#instance.attachMedia(this.#video);
+    this.#instance.on(ctor.Events.AUDIO_TRACK_SWITCHED, this.#onAudioSwitch.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_SWITCHED, this.#onLevelSwitched.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_LOADED, this.#onLevelLoaded.bind(this));
+    this.#instance.on(ctor.Events.LEVEL_UPDATED, this.#onLevelUpdated.bind(this));
+    this.#instance.on(ctor.Events.NON_NATIVE_TEXT_TRACKS_FOUND, this.#onTracksFound.bind(this));
+    this.#instance.on(ctor.Events.CUES_PARSED, this.#onCuesParsed.bind(this));
+    this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
+    listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
+    listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
+    this.#stopLiveSync = effect(this.#liveSync.bind(this));
+  }
+  #createDOMEvent(type, data) {
+    return new DOMEvent(toDOMEventType(type), { detail: data });
+  }
+  #liveSync() {
+    if (!this.#ctx.$state.live()) return;
+    const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
+    raf.start();
+    return raf.stop.bind(raf);
+  }
+  #liveSyncPosition() {
+    this.#ctx.$state.liveSyncPosition.set(this.#instance?.liveSyncPosition ?? Infinity);
+  }
+  #dispatchHLSEvent(type, data) {
+    this.#ctx.player?.dispatch(this.#createDOMEvent(type, data));
+  }
+  #onTracksFound(eventType, data) {
+    const event = this.#createDOMEvent(eventType, data);
+    let currentTrack = -1;
+    for (let i = 0; i < data.tracks.length; i++) {
+      const nonNativeTrack = data.tracks[i], init = nonNativeTrack.subtitleTrack ?? nonNativeTrack.closedCaptions, track = new TextTrack({
+        id: `hls-${nonNativeTrack.kind}-${i}`,
+        src: init?.url,
+        label: nonNativeTrack.label,
+        language: init?.lang,
+        kind: nonNativeTrack.kind,
+        default: nonNativeTrack.default
+      });
+      track[TextTrackSymbol.readyState] = 2;
+      track[TextTrackSymbol.onModeChange] = () => {
+        if (track.mode === "showing") {
+          this.#instance.subtitleTrack = i;
+          currentTrack = i;
+        } else if (currentTrack === i) {
+          this.#instance.subtitleTrack = -1;
+          currentTrack = -1;
+        }
+      };
+      this.#ctx.textTracks.add(track, event);
+    }
+  }
+  #onCuesParsed(eventType, data) {
+    const index = this.#instance?.subtitleTrack, track = this.#ctx.textTracks.getById(`hls-${data.type}-${index}`);
+    if (!track) return;
+    const event = this.#createDOMEvent(eventType, data);
+    for (const cue of data.cues) {
+      cue.positionAlign = "auto";
+      track.addCue(cue, event);
+    }
+  }
+  #onAudioSwitch(eventType, data) {
+    const track = this.#ctx.audioTracks[data.id];
+    if (track) {
+      const trigger = this.#createDOMEvent(eventType, data);
+      this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
+    }
+  }
+  #onLevelSwitched(eventType, data) {
+    const quality = this.#ctx.qualities[data.level];
+    if (quality) {
+      const trigger = this.#createDOMEvent(eventType, data);
+      this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
+    }
+  }
+  #onLevelUpdated(eventType, data) {
+    if (data.details.totalduration > 0) {
+      this.#ctx.$state.inferredLiveDVRWindow.set(data.details.totalduration);
+    }
+  }
+  #onLevelLoaded(eventType, data) {
+    if (this.#ctx.$state.canPlay()) return;
+    const { type, live, totalduration: duration, targetduration } = data.details, trigger = this.#createDOMEvent(eventType, data);
+    this.#ctx.notify(
+      "stream-type-change",
+      live ? type === "EVENT" && Number.isFinite(duration) && targetduration >= 10 ? "live:dvr" : "live" : "on-demand",
+      trigger
+    );
+    this.#ctx.notify("duration-change", duration, trigger);
+    const media = this.#instance.media;
+    if (this.#instance.currentLevel === -1) {
+      this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
+    }
+    for (const remoteTrack of this.#instance.audioTracks) {
+      const localTrack = {
+        id: remoteTrack.id.toString(),
+        label: remoteTrack.name,
+        language: remoteTrack.lang || "",
+        kind: "main"
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
+    }
+    for (const level of this.#instance.levels) {
+      const videoQuality = {
+        id: level.id?.toString() ?? level.height + "p",
+        width: level.width,
+        height: level.height,
+        codec: level.codecSet,
+        bitrate: level.bitrate
+      };
+      this.#ctx.qualities[ListSymbol.add](videoQuality, trigger);
+    }
+    media.dispatchEvent(new DOMEvent("canplay", { trigger }));
+  }
+  #onError(eventType, data) {
+    if (data.fatal) {
+      switch (data.type) {
+        case "mediaError":
+          this.#instance?.recoverMediaError();
+          break;
+        default:
+          this.#onFatalError(data.error);
+          break;
+      }
+    }
+  }
+  #onFatalError(error) {
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 1,
+      error
+    });
+  }
+  #enableAutoQuality() {
+    if (this.#instance) this.#instance.currentLevel = -1;
+  }
+  #onUserQualityChange() {
+    const { qualities } = this.#ctx;
+    if (!this.#instance || qualities.auto) return;
+    this.#instance[qualities.switch + "Level"] = qualities.selectedIndex;
+    if (IS_CHROME) {
+      this.#video.currentTime = this.#video.currentTime;
+    }
+  }
+  #onUserAudioChange() {
+    const { audioTracks } = this.#ctx;
+    if (this.#instance && this.#instance.audioTrack !== audioTracks.selectedIndex) {
+      this.#instance.audioTrack = audioTracks.selectedIndex;
+    }
+  }
+  onInstance(callback) {
+    this.#callbacks.add(callback);
+    return () => this.#callbacks.delete(callback);
+  }
+  loadSource(src) {
+    if (!isString(src.src)) return;
+    this.#instance?.loadSource(src.src);
+  }
+  destroy() {
+    this.#instance?.destroy();
+    this.#instance = null;
+    this.#stopLiveSync?.();
+    this.#stopLiveSync = null;
+  }
+}
+
+class HLSLibLoader {
+  #lib;
+  #ctx;
+  #callback;
+  constructor(lib, ctx, callback) {
+    this.#lib = lib;
+    this.#ctx = ctx;
+    this.#callback = callback;
+    this.#startLoading();
+  }
+  async #startLoading() {
+    const callbacks = {
+      onLoadStart: this.#onLoadStart.bind(this),
+      onLoaded: this.#onLoaded.bind(this),
+      onLoadError: this.#onLoadError.bind(this)
+    };
+    let ctor = await loadHLSScript(this.#lib, callbacks);
+    if (isUndefined(ctor) && !isString(this.#lib)) ctor = await importHLS(this.#lib, callbacks);
+    if (!ctor) return null;
+    if (!ctor.isSupported()) {
+      const message = "[vidstack] `hls.js` is not supported in this environment";
+      this.#ctx.player.dispatch(new DOMEvent("hls-unsupported"));
+      this.#ctx.notify("error", { message, code: 4 });
+      return null;
+    }
+    return ctor;
+  }
+  #onLoadStart() {
+    this.#ctx.player.dispatch(new DOMEvent("hls-lib-load-start"));
+  }
+  #onLoaded(ctor) {
+    this.#ctx.player.dispatch(
+      new DOMEvent("hls-lib-loaded", {
+        detail: ctor
+      })
+    );
+    this.#callback(ctor);
+  }
+  #onLoadError(e) {
+    const error = coerceToError(e);
+    this.#ctx.player.dispatch(
+      new DOMEvent("hls-lib-load-error", {
+        detail: error
+      })
+    );
+    this.#ctx.notify("error", {
+      message: error.message,
+      code: 4,
+      error
+    });
+  }
+}
+async function importHLS(loader, callbacks = {}) {
+  if (isUndefined(loader)) return void 0;
+  callbacks.onLoadStart?.();
+  if (loader.prototype && loader.prototype !== Function) {
+    callbacks.onLoaded?.(loader);
+    return loader;
+  }
+  try {
+    const ctor = (await loader())?.default;
+    if (ctor && !!ctor.isSupported) {
+      callbacks.onLoaded?.(ctor);
+    } else {
+      throw Error(
+        false ? "[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
+      );
+    }
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+async function loadHLSScript(src, callbacks = {}) {
+  if (!isString(src)) return void 0;
+  callbacks.onLoadStart?.();
+  try {
+    await loadScript(src);
+    if (!isFunction(window.Hls)) {
+      throw Error(
+        false ? "[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window" : ""
+      );
+    }
+    const ctor = window.Hls;
+    callbacks.onLoaded?.(ctor);
+    return ctor;
+  } catch (err) {
+    callbacks.onLoadError?.(err);
+  }
+  return void 0;
+}
+
+const JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
+class HLSProvider extends VideoProvider {
+  $$PROVIDER_TYPE = "HLS";
+  #ctor = null;
+  #controller = new HLSController(this.video, this.ctx);
+  /**
+   * The `hls.js` constructor.
+   */
+  get ctor() {
+    return this.#ctor;
+  }
+  /**
+   * The current `hls.js` instance.
+   */
+  get instance() {
+    return this.#controller.instance;
+  }
+  /**
+   * Whether `hls.js` is supported in this environment.
+   */
+  static supported = isHLSSupported();
+  get type() {
+    return "hls";
+  }
+  get canLiveSync() {
+    return true;
+  }
+  #library = `${JS_DELIVR_CDN}/npm/hls.js@^1.5.0/dist/hls${".min.js"}`;
+  /**
+   * The `hls.js` configuration object.
+   *
+   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#fine-tuning}
+   */
+  get config() {
+    return this.#controller.config;
+  }
+  set config(config) {
+    this.#controller.config = config;
+  }
+  /**
+   * The `hls.js` constructor (supports dynamic imports) or a URL of where it can be found.
+   *
+   * @defaultValue `https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.min.js`
+   */
+  get library() {
+    return this.#library;
+  }
+  set library(library) {
+    this.#library = library;
+  }
+  preconnect() {
+    if (!isString(this.#library)) return;
+    preconnect(this.#library);
+  }
+  setup() {
+    super.setup();
+    new HLSLibLoader(this.#library, this.ctx, (ctor) => {
+      this.#ctor = ctor;
+      this.#controller.setup(ctor);
+      this.ctx.notify("provider-setup", this);
+      const src = peek(this.ctx.$state.source);
+      if (src) this.loadSource(src);
+    });
+  }
+  async loadSource(src, preload) {
+    if (!isString(src.src)) {
+      this.removeSource();
+      return;
+    }
+    this.media.preload = preload || "";
+    this.appendSource(src, "application/x-mpegurl");
+    this.#controller.loadSource(src);
+    this.currentSrc = src;
+  }
+  /**
+   * The given callback is invoked when a new `hls.js` instance is created and right before it's
+   * attached to media.
+   */
+  onInstance(callback) {
+    const instance = this.#controller.instance;
+    if (instance) callback(instance);
+    return this.#controller.onInstance(callback);
+  }
+  destroy() {
+    this.#controller.destroy();
+  }
+}
+
+export { HLSProvider };
diff --git a/prod/chunks/vidstack-Rys6rVXI.js b/prod/chunks/vidstack-Rys6rVXI.js
new file mode 100644
index 0000000000000000000000000000000000000000..dde0690e88cf68463589df76c2c55559c14aaaac
--- /dev/null
+++ b/prod/chunks/vidstack-Rys6rVXI.js
@@ -0,0 +1,189 @@
+"use client"
+
+import * as React from 'react';
+import { RadioGroupController, useMediaContext, menuContext, MediaRemoteControl, MediaPlayerInstance, sortVideoQualities } from './vidstack-3ABKqYU9.js';
+import { useMediaContext as useMediaContext$1 } from './vidstack-BZdaxU0-.js';
+import { prop, method, Component, hasProvidedContext, useContext, effect, useSignal, isString } from './vidstack-CNjv_Zem.js';
+
+const DEFAULT_PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
+class SpeedRadioGroup extends Component {
+  static props = {
+    normalLabel: "Normal",
+    rates: DEFAULT_PLAYBACK_RATES
+  };
+  #media;
+  #menu;
+  #controller;
+  get value() {
+    return this.#controller.value;
+  }
+  get disabled() {
+    const { rates } = this.$props, { canSetPlaybackRate } = this.#media.$state;
+    return !canSetPlaybackRate() || rates().length === 0;
+  }
+  constructor() {
+    super();
+    this.#controller = new RadioGroupController();
+    this.#controller.onValueChange = this.#onValueChange.bind(this);
+  }
+  onSetup() {
+    this.#media = useMediaContext();
+    if (hasProvidedContext(menuContext)) {
+      this.#menu = useContext(menuContext);
+    }
+  }
+  onConnect(el) {
+    effect(this.#watchValue.bind(this));
+    effect(this.#watchHintText.bind(this));
+    effect(this.#watchControllerDisabled.bind(this));
+  }
+  getOptions() {
+    const { rates, normalLabel } = this.$props;
+    return rates().map((rate) => ({
+      label: rate === 1 ? normalLabel : rate + "\xD7",
+      value: rate.toString()
+    }));
+  }
+  #watchValue() {
+    this.#controller.value = this.#getValue();
+  }
+  #watchHintText() {
+    const { normalLabel } = this.$props, { playbackRate } = this.#media.$state, rate = playbackRate();
+    this.#menu?.hint.set(rate === 1 ? normalLabel() : rate + "\xD7");
+  }
+  #watchControllerDisabled() {
+    this.#menu?.disable(this.disabled);
+  }
+  #getValue() {
+    const { playbackRate } = this.#media.$state;
+    return playbackRate().toString();
+  }
+  #onValueChange(value, trigger) {
+    if (this.disabled) return;
+    const rate = +value;
+    this.#media.remote.changePlaybackRate(rate, trigger);
+    this.dispatch("change", { detail: rate, trigger });
+  }
+}
+const speedradiogroup__proto = SpeedRadioGroup.prototype;
+prop(speedradiogroup__proto, "value");
+prop(speedradiogroup__proto, "disabled");
+method(speedradiogroup__proto, "getOptions");
+
+function useMediaRemote(target) {
+  const media = useMediaContext$1(), remote = React.useRef();
+  if (!remote.current) {
+    remote.current = new MediaRemoteControl();
+  }
+  React.useEffect(() => {
+    const ref = target && "current" in target ? target.current : target, isPlayerRef = ref instanceof MediaPlayerInstance, player = isPlayerRef ? ref : media?.player;
+    remote.current.setPlayer(player ?? null);
+    remote.current.setTarget(ref ?? null);
+  }, [media, target && "current" in target ? target.current : target]);
+  return remote.current;
+}
+
+function useVideoQualityOptions({
+  auto = true,
+  sort = "descending"
+} = {}) {
+  const media = useMediaContext$1(), { qualities, quality, autoQuality, canSetQuality } = media.$state, $qualities = useSignal(qualities);
+  useSignal(quality);
+  useSignal(autoQuality);
+  useSignal(canSetQuality);
+  return React.useMemo(() => {
+    const sortedQualities = sortVideoQualities($qualities, sort === "descending"), options = sortedQualities.map((q) => {
+      return {
+        quality: q,
+        label: q.height + "p",
+        value: getQualityValue(q),
+        bitrateText: q.bitrate && q.bitrate > 0 ? `${(q.bitrate / 1e6).toFixed(2)} Mbps` : null,
+        get selected() {
+          return q === quality();
+        },
+        get autoSelected() {
+          return autoQuality();
+        },
+        select(trigger) {
+          const index = qualities().indexOf(q);
+          if (index >= 0) media.remote.changeQuality(index, trigger);
+        }
+      };
+    });
+    if (auto) {
+      options.unshift({
+        quality: null,
+        label: isString(auto) ? auto : "Auto",
+        value: "auto",
+        bitrateText: null,
+        get selected() {
+          return autoQuality();
+        },
+        get autoSelected() {
+          return autoQuality();
+        },
+        select(trigger) {
+          media.remote.requestAutoQuality(trigger);
+        }
+      });
+    }
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !canSetQuality() || $qualities.length <= 1;
+      }
+    });
+    Object.defineProperty(options, "selectedQuality", {
+      get() {
+        return quality();
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const $quality = quality();
+        return !autoQuality() && $quality ? getQualityValue($quality) : "auto";
+      }
+    });
+    return options;
+  }, [$qualities, sort]);
+}
+function getQualityValue(quality) {
+  return quality.height + "_" + quality.bitrate;
+}
+
+function usePlaybackRateOptions({
+  rates = DEFAULT_PLAYBACK_RATES,
+  normalLabel = "Normal"
+} = {}) {
+  const media = useMediaContext$1(), { playbackRate, canSetPlaybackRate } = media.$state;
+  useSignal(playbackRate);
+  useSignal(canSetPlaybackRate);
+  return React.useMemo(() => {
+    const options = rates.map((opt) => {
+      const label = typeof opt === "number" ? opt === 1 && normalLabel ? normalLabel : opt + "x" : opt.label, rate = typeof opt === "number" ? opt : opt.rate;
+      return {
+        label,
+        value: rate.toString(),
+        rate,
+        get selected() {
+          return playbackRate() === rate;
+        },
+        select(trigger) {
+          media.remote.changePlaybackRate(rate, trigger);
+        }
+      };
+    });
+    Object.defineProperty(options, "disabled", {
+      get() {
+        return !canSetPlaybackRate() || !options.length;
+      }
+    });
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        return playbackRate().toString();
+      }
+    });
+    return options;
+  }, [rates]);
+}
+
+export { DEFAULT_PLAYBACK_RATES, useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions };
diff --git a/prod/chunks/vidstack-VGRmv787.js b/prod/chunks/vidstack-VGRmv787.js
new file mode 100644
index 0000000000000000000000000000000000000000..1c3968bd867f46e12c4302caa67061e0a60ddcba
--- /dev/null
+++ b/prod/chunks/vidstack-VGRmv787.js
@@ -0,0 +1,375 @@
+"use client"
+
+import * as React from 'react';
+import { createReactComponent, composeRefs, listenEvent, useReactScope, scoped, signal, computed, effect, EventsController, useSignal } from './vidstack-CNjv_Zem.js';
+import { Primitive, MediaAnnouncerInstance, ControlsInstance, ControlsGroupInstance, TooltipInstance, TooltipTriggerInstance, TooltipContentInstance, GoogleCastButtonInstance, QualitySliderInstance, AudioGainSliderInstance, SpeedSliderInstance, useMediaState, watchActiveTextTrack, CaptionsInstance, formatTime, formatSpokenTime } from './vidstack-3ABKqYU9.js';
+import { sliderCallbacks, Preview, Steps, Thumb, Track as Track$1, TrackFill as TrackFill$1, Value, useMediaContext } from './vidstack-BZdaxU0-.js';
+
+const MediaAnnouncerBridge = createReactComponent(MediaAnnouncerInstance, {
+  events: ["onChange"]
+});
+const MediaAnnouncer = React.forwardRef(
+  ({ style, children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(MediaAnnouncerBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        style: { display: "contents", ...style },
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+MediaAnnouncer.displayName = "MediaAnnouncer";
+
+const ControlsBridge = createReactComponent(ControlsInstance);
+const Root$5 = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ControlsBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Root$5.displayName = "Controls";
+const ControlsGroupBridge = createReactComponent(ControlsGroupInstance);
+const Group = React.forwardRef(({ children, ...props }, forwardRef) => {
+  return /* @__PURE__ */ React.createElement(ControlsGroupBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+    Primitive.div,
+    {
+      ...props2,
+      ref: composeRefs(props2.ref, forwardRef)
+    },
+    children
+  ));
+});
+Group.displayName = "ControlsGroup";
+
+var controls = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Group: Group,
+  Root: Root$5
+});
+
+const TooltipBridge = createReactComponent(TooltipInstance);
+function Root$4({ children, ...props }) {
+  return /* @__PURE__ */ React.createElement(TooltipBridge, { ...props }, children);
+}
+Root$4.displayName = "Tooltip";
+const TriggerBridge = createReactComponent(TooltipTriggerInstance);
+const Trigger = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(TriggerBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Trigger.displayName = "TooltipTrigger";
+const ContentBridge = createReactComponent(TooltipContentInstance);
+const Content = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(ContentBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.div,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+Content.displayName = "TooltipContent";
+
+var tooltip = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Content: Content,
+  Root: Root$4,
+  Trigger: Trigger
+});
+
+const GoogleCastButtonBridge = createReactComponent(GoogleCastButtonInstance, {
+  domEventsRegex: /^onMedia/
+});
+const GoogleCastButton = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(GoogleCastButtonBridge, { ...props }, (props2) => /* @__PURE__ */ React.createElement(
+      Primitive.button,
+      {
+        ...props2,
+        ref: composeRefs(props2.ref, forwardRef)
+      },
+      children
+    ));
+  }
+);
+GoogleCastButton.displayName = "GoogleCastButton";
+
+const QualitySliderBridge = createReactComponent(QualitySliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$3 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(QualitySliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$3.displayName = "QualitySlider";
+
+var qualitySlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$3,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const AudioGainSliderBridge = createReactComponent(AudioGainSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$2 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(AudioGainSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$2.displayName = "AudioGainSlider";
+
+var audioGainSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$2,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const SpeedSliderBridge = createReactComponent(SpeedSliderInstance, {
+  events: sliderCallbacks,
+  domEventsRegex: /^onMedia/
+});
+const Root$1 = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(SpeedSliderBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Root$1.displayName = "SpeedSlider";
+
+var speedSlider = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Preview: Preview,
+  Root: Root$1,
+  Steps: Steps,
+  Thumb: Thumb,
+  Track: Track$1,
+  TrackFill: TrackFill$1,
+  Value: Value
+});
+
+const Title = React.forwardRef(({ children, ...props }, forwardRef) => {
+  const $title = useMediaState("title");
+  return /* @__PURE__ */ React.createElement(Primitive.span, { ...props, ref: forwardRef }, $title, children);
+});
+Title.displayName = "Title";
+
+function useActiveTextCues(track) {
+  const [activeCues, setActiveCues] = React.useState([]);
+  React.useEffect(() => {
+    if (!track) {
+      setActiveCues([]);
+      return;
+    }
+    function onCuesChange() {
+      if (track) setActiveCues(track.activeCues);
+    }
+    onCuesChange();
+    return listenEvent(track, "cue-change", onCuesChange);
+  }, [track]);
+  return activeCues;
+}
+
+function useActiveTextTrack(kind) {
+  const media = useMediaContext(), [track, setTrack] = React.useState(null);
+  React.useEffect(() => {
+    return watchActiveTextTrack(media.textTracks, kind, setTrack);
+  }, [kind]);
+  return track;
+}
+
+function useChapterTitle() {
+  const $track = useActiveTextTrack("chapters"), $cues = useActiveTextCues($track);
+  return $cues[0]?.text || "";
+}
+
+const ChapterTitle = React.forwardRef(
+  ({ defaultText = "", children, ...props }, forwardRef) => {
+    const $chapterTitle = useChapterTitle();
+    return /* @__PURE__ */ React.createElement(Primitive.span, { ...props, ref: forwardRef }, $chapterTitle || defaultText, children);
+  }
+);
+ChapterTitle.displayName = "ChapterTitle";
+
+const CaptionsBridge = createReactComponent(CaptionsInstance);
+const Captions = React.forwardRef(
+  ({ children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(CaptionsBridge, { ...props, ref: forwardRef }, (props2) => /* @__PURE__ */ React.createElement(Primitive.div, { ...props2 }, children));
+  }
+);
+Captions.displayName = "Captions";
+
+const Root = React.forwardRef(
+  ({ size = 96, children, ...props }, forwardRef) => {
+    return /* @__PURE__ */ React.createElement(
+      "svg",
+      {
+        width: size,
+        height: size,
+        fill: "none",
+        viewBox: "0 0 120 120",
+        "aria-hidden": "true",
+        "data-part": "root",
+        ...props,
+        ref: forwardRef
+      },
+      children
+    );
+  }
+);
+const Track = React.forwardRef(
+  ({ width = 8, children, ...props }, ref) => /* @__PURE__ */ React.createElement(
+    "circle",
+    {
+      cx: "60",
+      cy: "60",
+      r: "54",
+      stroke: "currentColor",
+      strokeWidth: width,
+      "data-part": "track",
+      ...props,
+      ref
+    },
+    children
+  )
+);
+const TrackFill = React.forwardRef(
+  ({ width = 8, fillPercent = 50, children, ...props }, ref) => /* @__PURE__ */ React.createElement(
+    "circle",
+    {
+      cx: "60",
+      cy: "60",
+      r: "54",
+      stroke: "currentColor",
+      pathLength: "100",
+      strokeWidth: width,
+      strokeDasharray: 100,
+      strokeDashoffset: 100 - fillPercent,
+      "data-part": "track-fill",
+      ...props,
+      ref
+    },
+    children
+  )
+);
+
+var spinner = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Root: Root,
+  Track: Track,
+  TrackFill: TrackFill
+});
+
+function createSignal(initialValue, deps = []) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(() => signal(initialValue), scope), [scope, ...deps]);
+}
+function createComputed(compute, deps = []) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(() => computed(compute), scope), [scope, ...deps]);
+}
+function createEffect(compute, deps = []) {
+  const scope = useReactScope();
+  React.useEffect(() => scoped(() => effect(compute), scope), [scope, ...deps]);
+}
+function useScoped(compute) {
+  const scope = useReactScope();
+  return React.useMemo(() => scoped(compute, scope), [scope]);
+}
+
+function useTextCues(track) {
+  const [cues, setCues] = React.useState([]);
+  React.useEffect(() => {
+    if (!track) return;
+    function onCuesChange() {
+      if (track) setCues([...track.cues]);
+    }
+    const events = new EventsController(track).add("add-cue", onCuesChange).add("remove-cue", onCuesChange);
+    onCuesChange();
+    return () => {
+      setCues([]);
+      events.abort();
+    };
+  }, [track]);
+  return cues;
+}
+
+function useChapterOptions() {
+  const media = useMediaContext(), track = useActiveTextTrack("chapters"), cues = useTextCues(track), $startTime = useSignal(media.$state.seekableStart), $endTime = useSignal(media.$state.seekableEnd);
+  useActiveTextCues(track);
+  return React.useMemo(() => {
+    const options = track ? cues.filter((cue) => cue.startTime <= $endTime && cue.endTime >= $startTime).map((cue, i) => {
+      let currentRef = null, stopProgressEffect;
+      return {
+        cue,
+        label: cue.text,
+        value: i.toString(),
+        startTimeText: formatTime(Math.max(0, cue.startTime - $startTime)),
+        durationText: formatSpokenTime(
+          Math.min($endTime, cue.endTime) - Math.max($startTime, cue.startTime)
+        ),
+        get selected() {
+          return cue === track.activeCues[0];
+        },
+        setProgressVar(ref) {
+          if (!ref || cue !== track.activeCues[0]) {
+            stopProgressEffect?.();
+            stopProgressEffect = void 0;
+            ref?.style.setProperty("--progress", "0%");
+            currentRef = null;
+            return;
+          }
+          if (currentRef === ref) return;
+          currentRef = ref;
+          stopProgressEffect?.();
+          stopProgressEffect = effect(() => {
+            const { realCurrentTime } = media.$state, time = realCurrentTime(), cueStartTime = Math.max($startTime, cue.startTime), duration = Math.min($endTime, cue.endTime) - cueStartTime, progress = Math.max(0, time - cueStartTime) / duration * 100;
+            ref.style.setProperty("--progress", progress.toFixed(3) + "%");
+          });
+        },
+        select(trigger) {
+          media.remote.seek(cue.startTime - $startTime, trigger);
+        }
+      };
+    }) : [];
+    Object.defineProperty(options, "selectedValue", {
+      get() {
+        const index = options.findIndex((option) => option.selected);
+        return (index >= 0 ? index : 0).toString();
+      }
+    });
+    return options;
+  }, [cues, $startTime, $endTime]);
+}
+
+export { Captions, ChapterTitle, Content, GoogleCastButton, Group, MediaAnnouncer, Root$4 as Root, Root$2 as Root$1, Root$3 as Root$2, Root$1 as Root$3, Root$5 as Root$4, Root as Root$5, Title, Track, TrackFill, Trigger, audioGainSlider, controls, createComputed, createEffect, createSignal, qualitySlider, speedSlider, spinner, tooltip, useActiveTextCues, useActiveTextTrack, useChapterOptions, useChapterTitle, useScoped, useTextCues };
diff --git a/prod/chunks/vidstack-VjvZ5CCo.js b/prod/chunks/vidstack-VjvZ5CCo.js
new file mode 100644
index 0000000000000000000000000000000000000000..2af96bd5c66181ab6c889ffbc0305227797b85e2
--- /dev/null
+++ b/prod/chunks/vidstack-VjvZ5CCo.js
@@ -0,0 +1,84 @@
+"use client"
+
+import * as React from 'react';
+import { animationFrameThrottle, EventsController, listenEvent, effect } from './vidstack-CNjv_Zem.js';
+import { useMediaPlayer } from './vidstack-BZdaxU0-.js';
+
+function useClassName(el, className) {
+  React.useEffect(() => {
+    if (!el || !className) return;
+    const tokens = className.split(" ");
+    for (const token of tokens) el.classList.add(token);
+    return () => {
+      for (const token of tokens) el.classList.remove(token);
+    };
+  }, [el, className]);
+}
+function useResizeObserver(el, callback) {
+  React.useEffect(() => {
+    if (!el) return;
+    callback();
+    const observer = new ResizeObserver(animationFrameThrottle(callback));
+    observer.observe(el);
+    return () => observer.disconnect();
+  }, [el, callback]);
+}
+function useTransitionActive(el) {
+  const [isActive, setIsActive] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("transitionstart", () => setIsActive(true)).add("transitionend", () => setIsActive(false));
+    return () => events.abort();
+  }, [el]);
+  return isActive;
+}
+function useMouseEnter(el) {
+  const [isMouseEnter, setIsMouseEnter] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("mouseenter", () => setIsMouseEnter(true)).add("mouseleave", () => setIsMouseEnter(false));
+    return () => events.abort();
+  }, [el]);
+  return isMouseEnter;
+}
+function useFocusIn(el) {
+  const [isFocusIn, setIsFocusIn] = React.useState(false);
+  React.useEffect(() => {
+    if (!el) return;
+    const events = new EventsController(el).add("focusin", () => setIsFocusIn(true)).add("focusout", () => setIsFocusIn(false));
+    return () => events.abort();
+  }, [el]);
+  return isFocusIn;
+}
+function useActive(el) {
+  const isMouseEnter = useMouseEnter(el), isFocusIn = useFocusIn(el), prevMouseEnter = React.useRef(false);
+  if (prevMouseEnter.current && !isMouseEnter) return false;
+  prevMouseEnter.current = isMouseEnter;
+  return isMouseEnter || isFocusIn;
+}
+function useColorSchemePreference() {
+  const [colorScheme, setColorScheme] = React.useState("dark");
+  React.useEffect(() => {
+    const media = window.matchMedia("(prefers-color-scheme: light)");
+    function onChange() {
+      setColorScheme(media.matches ? "light" : "dark");
+    }
+    onChange();
+    return listenEvent(media, "change", onChange);
+  }, []);
+  return colorScheme;
+}
+
+function useLayoutName(name) {
+  const player = useMediaPlayer();
+  React.useEffect(() => {
+    if (!player) return;
+    return effect(() => {
+      const el = player.$el;
+      el?.setAttribute("data-layout", name);
+      return () => el?.removeAttribute("data-layout");
+    });
+  }, [player]);
+}
+
+export { useActive, useClassName, useColorSchemePreference, useLayoutName, useResizeObserver, useTransitionActive };
diff --git a/prod/chunks/vidstack-yqPUabwo.js b/prod/chunks/vidstack-yqPUabwo.js
new file mode 100644
index 0000000000000000000000000000000000000000..6e46b1bcacd112b9b4bf29090de85aef0ba6e3dc
--- /dev/null
+++ b/prod/chunks/vidstack-yqPUabwo.js
@@ -0,0 +1,471 @@
+"use client"
+
+import { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from './vidstack-CNjv_Zem.js';
+import { ListSymbol, TimeRange, RAFLoop } from './vidstack-CwFL6mmL.js';
+import { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-D6rGR5oE.js';
+import 'react';
+import '@floating-ui/dom';
+
+class GoogleCastMediaInfoBuilder {
+  #info;
+  constructor(src) {
+    this.#info = new chrome.cast.media.MediaInfo(src.src, src.type);
+  }
+  build() {
+    return this.#info;
+  }
+  setStreamType(streamType) {
+    if (streamType.includes("live")) {
+      this.#info.streamType = chrome.cast.media.StreamType.LIVE;
+    } else {
+      this.#info.streamType = chrome.cast.media.StreamType.BUFFERED;
+    }
+    return this;
+  }
+  setTracks(tracks) {
+    this.#info.tracks = tracks.map(this.#buildCastTrack);
+    return this;
+  }
+  setMetadata(title, poster) {
+    this.#info.metadata = new chrome.cast.media.GenericMediaMetadata();
+    this.#info.metadata.title = title;
+    this.#info.metadata.images = [{ url: poster }];
+    return this;
+  }
+  #buildCastTrack(track, trackId) {
+    const castTrack = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);
+    castTrack.name = track.label;
+    castTrack.trackContentId = track.src;
+    castTrack.trackContentType = "text/vtt";
+    castTrack.language = track.language;
+    castTrack.subtype = track.kind.toUpperCase();
+    return castTrack;
+  }
+}
+
+const REMOTE_TRACK_TEXT_TYPE = chrome.cast.media.TrackType.TEXT, REMOTE_TRACK_AUDIO_TYPE = chrome.cast.media.TrackType.AUDIO;
+class GoogleCastTracksManager {
+  #cast;
+  #ctx;
+  #onNewLocalTracks;
+  constructor(cast, ctx, onNewLocalTracks) {
+    this.#cast = cast;
+    this.#ctx = ctx;
+    this.#onNewLocalTracks = onNewLocalTracks;
+  }
+  setup() {
+    const syncRemoteActiveIds = this.syncRemoteActiveIds.bind(this);
+    listenEvent(this.#ctx.audioTracks, "change", syncRemoteActiveIds);
+    listenEvent(this.#ctx.textTracks, "mode-change", syncRemoteActiveIds);
+    effect(this.#syncLocalTracks.bind(this));
+  }
+  getLocalTextTracks() {
+    return this.#ctx.$state.textTracks().filter((track) => track.src && track.type === "vtt");
+  }
+  #getLocalAudioTracks() {
+    return this.#ctx.$state.audioTracks();
+  }
+  #getRemoteTracks(type) {
+    const tracks = this.#cast.mediaInfo?.tracks ?? [];
+    return type ? tracks.filter((track) => track.type === type) : tracks;
+  }
+  #getRemoteActiveIds() {
+    const activeIds = [], activeLocalAudioTrack = this.#getLocalAudioTracks().find((track) => track.selected), activeLocalTextTracks = this.getLocalTextTracks().filter((track) => track.mode === "showing");
+    if (activeLocalAudioTrack) {
+      const remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteAudioTrack = this.#findRemoteTrack(remoteAudioTracks, activeLocalAudioTrack);
+      if (remoteAudioTrack) activeIds.push(remoteAudioTrack.trackId);
+    }
+    if (activeLocalTextTracks?.length) {
+      const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+      if (remoteTextTracks.length) {
+        for (const localTrack of activeLocalTextTracks) {
+          const remoteTextTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
+          if (remoteTextTrack) activeIds.push(remoteTextTrack.trackId);
+        }
+      }
+    }
+    return activeIds;
+  }
+  #syncLocalTracks() {
+    const localTextTracks = this.getLocalTextTracks();
+    if (!this.#cast.isMediaLoaded) return;
+    const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+    for (const localTrack of localTextTracks) {
+      const hasRemoteTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
+      if (!hasRemoteTrack) {
+        untrack(() => this.#onNewLocalTracks?.());
+        break;
+      }
+    }
+  }
+  syncRemoteTracks(event) {
+    if (!this.#cast.isMediaLoaded) return;
+    const localAudioTracks = this.#getLocalAudioTracks(), localTextTracks = this.getLocalTextTracks(), remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
+    for (const remoteAudioTrack of remoteAudioTracks) {
+      const hasLocalTrack = this.#findLocalTrack(localAudioTracks, remoteAudioTrack);
+      if (hasLocalTrack) continue;
+      const localAudioTrack = {
+        id: remoteAudioTrack.trackId.toString(),
+        label: remoteAudioTrack.name,
+        language: remoteAudioTrack.language,
+        kind: remoteAudioTrack.subtype ?? "main",
+        selected: false
+      };
+      this.#ctx.audioTracks[ListSymbol.add](localAudioTrack, event);
+    }
+    for (const remoteTextTrack of remoteTextTracks) {
+      const hasLocalTrack = this.#findLocalTrack(localTextTracks, remoteTextTrack);
+      if (hasLocalTrack) continue;
+      const localTextTrack = {
+        id: remoteTextTrack.trackId.toString(),
+        src: remoteTextTrack.trackContentId,
+        label: remoteTextTrack.name,
+        language: remoteTextTrack.language,
+        kind: remoteTextTrack.subtype.toLowerCase()
+      };
+      this.#ctx.textTracks.add(localTextTrack, event);
+    }
+  }
+  syncRemoteActiveIds(event) {
+    if (!this.#cast.isMediaLoaded) return;
+    const activeIds = this.#getRemoteActiveIds(), editRequest = new chrome.cast.media.EditTracksInfoRequest(activeIds);
+    this.#editTracksInfo(editRequest).catch((error) => {
+    });
+  }
+  #editTracksInfo(request) {
+    const media = getCastSessionMedia();
+    return new Promise((resolve, reject) => media?.editTracksInfo(request, resolve, reject));
+  }
+  #findLocalTrack(localTracks, remoteTrack) {
+    return localTracks.find((localTrack) => this.#isMatch(localTrack, remoteTrack));
+  }
+  #findRemoteTrack(remoteTracks, localTrack) {
+    return remoteTracks.find((remoteTrack) => this.#isMatch(localTrack, remoteTrack));
+  }
+  // Note: we can't rely on id matching because they will differ between local/remote. A local
+  // track id might not even exist.
+  #isMatch(localTrack, remoteTrack) {
+    return remoteTrack.name === localTrack.label && remoteTrack.language === localTrack.language && remoteTrack.subtype.toLowerCase() === localTrack.kind.toLowerCase();
+  }
+}
+
+class GoogleCastProvider {
+  $$PROVIDER_TYPE = "GOOGLE_CAST";
+  scope = createScope();
+  #player;
+  #ctx;
+  #tracks;
+  #currentSrc = null;
+  #state = "disconnected";
+  #currentTime = 0;
+  #played = 0;
+  #seekableRange = new TimeRange(0, 0);
+  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
+  #playerEventHandlers;
+  #reloadInfo = null;
+  #isIdle = false;
+  constructor(player, ctx) {
+    this.#player = player;
+    this.#ctx = ctx;
+    this.#tracks = new GoogleCastTracksManager(player, ctx, this.#onNewLocalTracks.bind(this));
+  }
+  get type() {
+    return "google-cast";
+  }
+  get currentSrc() {
+    return this.#currentSrc;
+  }
+  /**
+   * The Google Cast remote player.
+   *
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.RemotePlayer}
+   */
+  get player() {
+    return this.#player;
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
+   */
+  get cast() {
+    return getCastContext();
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastSession}
+   */
+  get session() {
+    return getCastSession();
+  }
+  /**
+   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media.Media}
+   */
+  get media() {
+    return getCastSessionMedia();
+  }
+  /**
+   * Whether the current Google Cast session belongs to this provider.
+   */
+  get hasActiveSession() {
+    return hasActiveCastSession(this.#currentSrc);
+  }
+  setup() {
+    this.#attachCastContextEventListeners();
+    this.#attachCastPlayerEventListeners();
+    this.#tracks.setup();
+    this.#ctx.notify("provider-setup", this);
+  }
+  #attachCastContextEventListeners() {
+    listenCastContextEvent(
+      cast.framework.CastContextEventType.CAST_STATE_CHANGED,
+      this.#onCastStateChange.bind(this)
+    );
+  }
+  #attachCastPlayerEventListeners() {
+    const Event2 = cast.framework.RemotePlayerEventType, handlers = {
+      [Event2.IS_CONNECTED_CHANGED]: this.#onCastStateChange,
+      [Event2.IS_MEDIA_LOADED_CHANGED]: this.#onMediaLoadedChange,
+      [Event2.CAN_CONTROL_VOLUME_CHANGED]: this.#onCanControlVolumeChange,
+      [Event2.CAN_SEEK_CHANGED]: this.#onCanSeekChange,
+      [Event2.DURATION_CHANGED]: this.#onDurationChange,
+      [Event2.IS_MUTED_CHANGED]: this.#onVolumeChange,
+      [Event2.VOLUME_LEVEL_CHANGED]: this.#onVolumeChange,
+      [Event2.IS_PAUSED_CHANGED]: this.#onPausedChange,
+      [Event2.LIVE_SEEKABLE_RANGE_CHANGED]: this.#onProgress,
+      [Event2.PLAYER_STATE_CHANGED]: this.#onPlayerStateChange
+    };
+    this.#playerEventHandlers = handlers;
+    const handler = this.#onRemotePlayerEvent.bind(this);
+    for (const type of keysOf(handlers)) {
+      this.#player.controller.addEventListener(type, handler);
+    }
+    onDispose(() => {
+      for (const type of keysOf(handlers)) {
+        this.#player.controller.removeEventListener(type, handler);
+      }
+    });
+  }
+  async play() {
+    if (!this.#player.isPaused && !this.#isIdle) return;
+    if (this.#isIdle) {
+      await this.#reload(false, 0);
+      return;
+    }
+    this.#player.controller?.playOrPause();
+  }
+  async pause() {
+    if (this.#player.isPaused) return;
+    this.#player.controller?.playOrPause();
+  }
+  getMediaStatus(request) {
+    return new Promise((resolve, reject) => {
+      this.media?.getStatus(request, resolve, reject);
+    });
+  }
+  setMuted(muted) {
+    const hasChanged = muted && !this.#player.isMuted || !muted && this.#player.isMuted;
+    if (hasChanged) this.#player.controller?.muteOrUnmute();
+  }
+  setCurrentTime(time) {
+    this.#player.currentTime = time;
+    this.#ctx.notify("seeking", time);
+    this.#player.controller?.seek();
+  }
+  setVolume(volume) {
+    this.#player.volumeLevel = volume;
+    this.#player.controller?.setVolumeLevel();
+  }
+  async loadSource(src) {
+    if (this.#reloadInfo?.src !== src) this.#reloadInfo = null;
+    if (hasActiveCastSession(src)) {
+      this.#resumeSession();
+      this.#currentSrc = src;
+      return;
+    }
+    this.#ctx.notify("load-start");
+    const loadRequest = this.#buildLoadRequest(src), errorCode = await this.session.loadMedia(loadRequest);
+    if (errorCode) {
+      this.#currentSrc = null;
+      this.#ctx.notify("error", Error(getCastErrorMessage(errorCode)));
+      return;
+    }
+    this.#currentSrc = src;
+  }
+  destroy() {
+    this.#reset();
+    this.#endSession();
+  }
+  #reset() {
+    if (!this.#reloadInfo) {
+      this.#played = 0;
+      this.#seekableRange = new TimeRange(0, 0);
+    }
+    this.#timeRAF.stop();
+    this.#currentTime = 0;
+    this.#reloadInfo = null;
+  }
+  #resumeSession() {
+    const resumeSessionEvent = new DOMEvent("resume-session", { detail: this.session });
+    this.#onMediaLoadedChange(resumeSessionEvent);
+    const { muted, volume, savedState } = this.#ctx.$state, localState = savedState();
+    this.setCurrentTime(Math.max(this.#player.currentTime, localState?.currentTime ?? 0));
+    this.setMuted(muted());
+    this.setVolume(volume());
+    if (localState?.paused === false) this.play();
+  }
+  #endSession() {
+    this.cast.endCurrentSession(true);
+    const { remotePlaybackLoader } = this.#ctx.$state;
+    remotePlaybackLoader.set(null);
+  }
+  #disconnectFromReceiver() {
+    const { savedState } = this.#ctx.$state;
+    savedState.set({
+      paused: this.#player.isPaused,
+      currentTime: this.#player.currentTime
+    });
+    this.#endSession();
+  }
+  #onAnimationFrame() {
+    this.#onCurrentTimeChange();
+  }
+  #onRemotePlayerEvent(event) {
+    this.#playerEventHandlers[event.type].call(this, event);
+  }
+  #onCastStateChange(data) {
+    const castState = this.cast.getCastState(), state = castState === cast.framework.CastState.CONNECTED ? "connected" : castState === cast.framework.CastState.CONNECTING ? "connecting" : "disconnected";
+    if (this.#state === state) return;
+    const detail = { type: "google-cast", state }, trigger = this.#createEvent(data);
+    this.#state = state;
+    this.#ctx.notify("remote-playback-change", detail, trigger);
+    if (state === "disconnected") {
+      this.#disconnectFromReceiver();
+    }
+  }
+  #onMediaLoadedChange(event) {
+    const hasLoaded = !!this.#player.isMediaLoaded;
+    if (!hasLoaded) return;
+    const src = peek(this.#ctx.$state.source);
+    Promise.resolve().then(() => {
+      if (src !== peek(this.#ctx.$state.source) || !this.#player.isMediaLoaded) return;
+      this.#reset();
+      const duration = this.#player.duration;
+      this.#seekableRange = new TimeRange(0, duration);
+      const detail = {
+        provider: this,
+        duration,
+        buffered: new TimeRange(0, 0),
+        seekable: this.#getSeekableRange()
+      }, trigger = this.#createEvent(event);
+      this.#ctx.notify("loaded-metadata", void 0, trigger);
+      this.#ctx.notify("loaded-data", void 0, trigger);
+      this.#ctx.notify("can-play", detail, trigger);
+      this.#onCanControlVolumeChange();
+      this.#onCanSeekChange(event);
+      const { volume, muted } = this.#ctx.$state;
+      this.setVolume(volume());
+      this.setMuted(muted());
+      this.#timeRAF.start();
+      this.#tracks.syncRemoteTracks(trigger);
+      this.#tracks.syncRemoteActiveIds(trigger);
+    });
+  }
+  #onCanControlVolumeChange() {
+    this.#ctx.$state.canSetVolume.set(this.#player.canControlVolume);
+  }
+  #onCanSeekChange(event) {
+    const trigger = this.#createEvent(event);
+    this.#ctx.notify("stream-type-change", this.#getStreamType(), trigger);
+  }
+  #getStreamType() {
+    const streamType = this.#player.mediaInfo?.streamType;
+    return streamType === chrome.cast.media.StreamType.LIVE ? this.#player.canSeek ? "live:dvr" : "live" : "on-demand";
+  }
+  #onCurrentTimeChange() {
+    if (this.#reloadInfo) return;
+    const currentTime = this.#player.currentTime;
+    if (currentTime === this.#currentTime) return;
+    this.#ctx.notify("time-change", currentTime);
+    if (currentTime > this.#played) {
+      this.#played = currentTime;
+      this.#onProgress();
+    }
+    if (this.#ctx.$state.seeking()) {
+      this.#ctx.notify("seeked", currentTime);
+    }
+    this.#currentTime = currentTime;
+  }
+  #onDurationChange(event) {
+    if (!this.#player.isMediaLoaded || this.#reloadInfo) return;
+    const duration = this.#player.duration, trigger = this.#createEvent(event);
+    this.#seekableRange = new TimeRange(0, duration);
+    this.#ctx.notify("duration-change", duration, trigger);
+  }
+  #onVolumeChange(event) {
+    if (!this.#player.isMediaLoaded) return;
+    const detail = {
+      muted: this.#player.isMuted,
+      volume: this.#player.volumeLevel
+    }, trigger = this.#createEvent(event);
+    this.#ctx.notify("volume-change", detail, trigger);
+  }
+  #onPausedChange(event) {
+    const trigger = this.#createEvent(event);
+    if (this.#player.isPaused) {
+      this.#ctx.notify("pause", void 0, trigger);
+    } else {
+      this.#ctx.notify("play", void 0, trigger);
+    }
+  }
+  #onProgress(event) {
+    const detail = {
+      seekable: this.#getSeekableRange(),
+      buffered: new TimeRange(0, this.#played)
+    }, trigger = event ? this.#createEvent(event) : void 0;
+    this.#ctx.notify("progress", detail, trigger);
+  }
+  #onPlayerStateChange(event) {
+    const state = this.#player.playerState, PlayerState = chrome.cast.media.PlayerState;
+    this.#isIdle = state === PlayerState.IDLE;
+    if (state === PlayerState.PAUSED) return;
+    const trigger = this.#createEvent(event);
+    switch (state) {
+      case PlayerState.PLAYING:
+        this.#ctx.notify("playing", void 0, trigger);
+        break;
+      case PlayerState.BUFFERING:
+        this.#ctx.notify("waiting", void 0, trigger);
+        break;
+      case PlayerState.IDLE:
+        this.#timeRAF.stop();
+        this.#ctx.notify("pause");
+        this.#ctx.notify("end");
+        break;
+    }
+  }
+  #getSeekableRange() {
+    return this.#player.liveSeekableRange ? new TimeRange(this.#player.liveSeekableRange.start, this.#player.liveSeekableRange.end) : this.#seekableRange;
+  }
+  #createEvent(detail) {
+    return detail instanceof Event ? detail : new DOMEvent(detail.type, { detail });
+  }
+  #buildMediaInfo(src) {
+    const { streamType, title, poster } = this.#ctx.$state;
+    return new GoogleCastMediaInfoBuilder(src).setMetadata(title(), poster()).setStreamType(streamType()).setTracks(this.#tracks.getLocalTextTracks()).build();
+  }
+  #buildLoadRequest(src) {
+    const mediaInfo = this.#buildMediaInfo(src), request = new chrome.cast.media.LoadRequest(mediaInfo), savedState = this.#ctx.$state.savedState();
+    request.autoplay = (this.#reloadInfo?.paused ?? savedState?.paused) === false;
+    request.currentTime = this.#reloadInfo?.time ?? savedState?.currentTime ?? 0;
+    return request;
+  }
+  async #reload(paused, time) {
+    const src = peek(this.#ctx.$state.source);
+    this.#reloadInfo = { src, paused, time };
+    await this.loadSource(src);
+  }
+  #onNewLocalTracks() {
+    this.#reload(this.#player.isPaused, this.#player.currentTime).catch((error) => {
+    });
+  }
+}
+
+export { GoogleCastProvider };
diff --git a/prod/player/vidstack-default-components.js b/prod/player/vidstack-default-components.js
index 567469b65cff13806ccf9c39a8161f9abb6977d0..8d51bd2649dbb97dba606be079aacc127bac10b3 100644
--- a/prod/player/vidstack-default-components.js
+++ b/prod/player/vidstack-default-components.js
@@ -1,14 +1,14 @@
 "use client"
 
-export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions } from '../chunks/vidstack-B6KLIr71.js';
+export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions } from '../chunks/vidstack-Cn4BWI0O.js';
 export { defaultLayoutIcons } from './vidstack-default-icons.js';
 import 'react';
 import '../chunks/vidstack-CNjv_Zem.js';
-import '../chunks/vidstack-BDYuUZKb.js';
-import '../chunks/vidstack-D6dKrFOZ.js';
+import '../chunks/vidstack-CeHFQcBJ.js';
+import '../chunks/vidstack-BY07IoHR.js';
 import '@floating-ui/dom';
-import '../chunks/vidstack-DP0Brh65.js';
+import '../chunks/vidstack-CtKPQRKk.js';
 import 'react-dom';
-import '../chunks/vidstack-D6LPqXyU.js';
+import '../chunks/vidstack-CiVrFBoK.js';
 import '../chunks/vidstack-CV12ZH4Z.js';
 import '../chunks/vidstack-CBF7iUqu.js';
diff --git a/prod/player/vidstack-default-layout.js b/prod/player/vidstack-default-layout.js
index 16e0a188888a572b89b5dc953113d4415ff31cd0..beeb3759fc3c36867fbcc40e5e79f2221d2df0fc 100644
--- a/prod/player/vidstack-default-layout.js
+++ b/prod/player/vidstack-default-layout.js
@@ -1,14 +1,14 @@
 "use client"
 
-export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultLayoutContext, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions, i18n, useDefaultLayoutContext, useDefaultLayoutWord } from '../chunks/vidstack-B6KLIr71.js';
+export { DefaultAudioLayout, DefaultBufferingIndicator, DefaultKeyboardDisplay, DefaultLayoutContext, DefaultMenuButton, DefaultMenuCheckbox, DefaultMenuItem, DefaultMenuRadioGroup, DefaultMenuSection, DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps, DefaultTooltip, DefaultVideoGestures, DefaultVideoLargeLayout, DefaultVideoLayout, DefaultVideoSmallLayout, createRadioOptions, i18n, useDefaultLayoutContext, useDefaultLayoutWord } from '../chunks/vidstack-Cn4BWI0O.js';
 export { defaultLayoutIcons } from './vidstack-default-icons.js';
 import 'react';
 import '../chunks/vidstack-CNjv_Zem.js';
-import '../chunks/vidstack-BDYuUZKb.js';
-import '../chunks/vidstack-D6dKrFOZ.js';
+import '../chunks/vidstack-CeHFQcBJ.js';
+import '../chunks/vidstack-BY07IoHR.js';
 import '@floating-ui/dom';
-import '../chunks/vidstack-DP0Brh65.js';
+import '../chunks/vidstack-CtKPQRKk.js';
 import 'react-dom';
-import '../chunks/vidstack-D6LPqXyU.js';
+import '../chunks/vidstack-CiVrFBoK.js';
 import '../chunks/vidstack-CV12ZH4Z.js';
 import '../chunks/vidstack-CBF7iUqu.js';
diff --git a/prod/player/vidstack-plyr-layout.js b/prod/player/vidstack-plyr-layout.js
index 2000ec2c06fe3192e5b54729e4e7a3a6e2ffff4a..d54d32dc0b4889152e66817b41e105cc6c53ecab 100644
--- a/prod/player/vidstack-plyr-layout.js
+++ b/prod/player/vidstack-plyr-layout.js
@@ -1,11 +1,11 @@
 "use client"
 
-import { useMediaState, Primitive, IS_SERVER, isRemotionSrc, getDownloadFile } from '../chunks/vidstack-D6dKrFOZ.js';
+import { useMediaState, Primitive, IS_SERVER, isRemotionSrc, getDownloadFile } from '../chunks/vidstack-BY07IoHR.js';
 import * as React from 'react';
 import { effect, createDisposalBin, uppercaseFirstChar, isUndefined, signal, composeRefs, useSignal, isNumber, listenEvent, isString, isKeyboardEvent, isKeyboardClick } from '../chunks/vidstack-CNjv_Zem.js';
-import { useMediaContext, PlayButton, Root, Img, Gesture, AirPlayButton, CaptionButton, FullscreenButton, PIPButton, SeekButton, Root$1, Value, Preview, Thumbnail, LiveButton, Time, appendParamsToURL, Root$2, Button, Items, useAudioOptions, Root$3, Item, useCaptionOptions, MuteButton, Root$4 } from '../chunks/vidstack-DP0Brh65.js';
-import { useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions } from '../chunks/vidstack-glsH_65p.js';
-import { useLayoutName, useClassName } from '../chunks/vidstack-D6LPqXyU.js';
+import { useMediaContext, PlayButton, Root, Img, Gesture, AirPlayButton, CaptionButton, FullscreenButton, PIPButton, SeekButton, Root$1, Value, Preview, Thumbnail, LiveButton, Time, appendParamsToURL, Root$2, Button, Items, useAudioOptions, Root$3, Item, useCaptionOptions, MuteButton, Root$4 } from '../chunks/vidstack-CtKPQRKk.js';
+import { useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions } from '../chunks/vidstack-CI9AxZNe.js';
+import { useLayoutName, useClassName } from '../chunks/vidstack-CiVrFBoK.js';
 import { RemotionThumbnail, RemotionPoster, RemotionSliderThumbnail } from '../chunks/vidstack-CV12ZH4Z.js';
 export { plyrLayoutIcons } from './vidstack-plyr-icons.js';
 import '@floating-ui/dom';
diff --git a/prod/player/vidstack-remotion.js b/prod/player/vidstack-remotion.js
index 8b37cd454b12beb9794153220cee7f8dcd053628..776ba0d1011b2e1107ff4466979b55ba78dad8da 100644
--- a/prod/player/vidstack-remotion.js
+++ b/prod/player/vidstack-remotion.js
@@ -3,8 +3,8 @@
 import * as React from 'react';
 import { createDisposalBin, animationFrameThrottle, noop } from '../chunks/vidstack-CNjv_Zem.js';
 import { Internals, random } from 'remotion';
-import { IS_SERVER, useMediaState, isRemotionSrc, Primitive, useSliderState } from '../chunks/vidstack-D6dKrFOZ.js';
-export { isRemotionProvider } from '../chunks/vidstack-D6dKrFOZ.js';
+import { IS_SERVER, useMediaState, isRemotionSrc, Primitive, useSliderState } from '../chunks/vidstack-BY07IoHR.js';
+export { isRemotionProvider } from '../chunks/vidstack-BY07IoHR.js';
 import { RemotionThumbnail as RemotionThumbnail$1, RemotionSliderThumbnail as RemotionSliderThumbnail$1, RemotionPoster as RemotionPoster$1 } from '../chunks/vidstack-CV12ZH4Z.js';
 import '@floating-ui/dom';
 
@@ -328,7 +328,7 @@ class RemotionProviderLoader {
     return "video";
   }
   async load(ctx) {
-    return new (await import('../chunks/vidstack-MVSQZ19X.js')).RemotionProvider(this.target, ctx);
+    return new (await import('../chunks/vidstack-CkTe59Wi.js')).RemotionProvider(this.target, ctx);
   }
 }
 
diff --git a/prod/vidstack.js b/prod/vidstack.js
index cbab3b76c29659385f188a07a2e75f552b6bf775..b86ad795309b75bfc8254d6621945632272def2b 100644
--- a/prod/vidstack.js
+++ b/prod/vidstack.js
@@ -1,16 +1,16 @@
 "use client"
 
-import { TextTrackSymbol, RadioGroupController, useMediaContext, menuContext, Primitive, MediaPlayerInstance, isRemotionProvider, MediaProviderInstance, mediaState, TextTrack, ToggleButtonInstance, PosterInstance, useMediaState, ThumbnailsLoader, updateSliderPreviewPlacement } from './chunks/vidstack-D6dKrFOZ.js';
-export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, List, LiveButtonInstance, LocalMediaStorage, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, QualitySliderInstance, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrackList, ThumbnailInstance, TimeInstance, TimeRange, TimeSliderInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, mediaContext, normalizeTimeIntervals, parseJSONCaptionsFile, sliderState, softResetMediaState, sortVideoQualities, updateTimeIntervals, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange } from './chunks/vidstack-D6dKrFOZ.js';
+import { TextTrackSymbol, RadioGroupController, useMediaContext, menuContext, Primitive, MediaPlayerInstance, isRemotionProvider, MediaProviderInstance, mediaState, TextTrack, ToggleButtonInstance, PosterInstance, useMediaState, ThumbnailsLoader, updateSliderPreviewPlacement } from './chunks/vidstack-BY07IoHR.js';
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButtonInstance, AudioGainSliderInstance, AudioProviderLoader, AudioTrackList, CaptionButtonInstance, CaptionsInstance, ControlsGroupInstance, ControlsInstance, DASHProviderLoader, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, FullscreenButtonInstance, FullscreenController, GestureInstance, GoogleCastButtonInstance, HLSProviderLoader, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, List, LiveButtonInstance, LocalMediaStorage, MEDIA_KEY_SHORTCUTS, MediaAnnouncerInstance, MediaControls, MediaRemoteControl, MenuButtonInstance, MenuInstance, MenuItemInstance, MenuItemsInstance, MenuPortalInstance, MuteButtonInstance, PIPButtonInstance, PlayButtonInstance, QualitySliderInstance, RadioGroupInstance, RadioInstance, ScreenOrientationController, SeekButtonInstance, SliderChaptersInstance, SliderInstance, SliderPreviewInstance, SliderThumbnailInstance, SliderValueInstance, SliderVideoInstance, SpeedSliderInstance, TextRenderers, TextTrackList, ThumbnailInstance, TimeInstance, TimeRange, TimeSliderInstance, TooltipContentInstance, TooltipInstance, TooltipTriggerInstance, VIDEO_EXTENSIONS, VIDEO_TYPES, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, VolumeSliderInstance, YouTubeProviderLoader, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isMediaStream, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, mediaContext, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, sliderState, softResetMediaState, sortVideoQualities, updateTimeIntervals, useMediaStore, useSliderState, useSliderStore, watchActiveTextTrack, watchCueTextChange } from './chunks/vidstack-BY07IoHR.js';
 import * as React from 'react';
 import { DOMEvent, isString, EventsController, prop, method, Component, hasProvidedContext, useContext, effect, createReactComponent, useStateContext, useSignal, composeRefs, useSignalRecord, useReactScope, signal } from './chunks/vidstack-CNjv_Zem.js';
 export { appendTriggerEvent, findTriggerEvent, hasTriggerEvent, isKeyboardClick, isKeyboardEvent, isPointerEvent, walkTriggerEventChain } from './chunks/vidstack-CNjv_Zem.js';
-import { createSignal, useScoped } from './chunks/vidstack-BDYuUZKb.js';
-export { audioGainSlider as AudioGainSlider, Captions, ChapterTitle, controls as Controls, GoogleCastButton, MediaAnnouncer, qualitySlider as QualitySlider, speedSlider as SpeedSlider, spinner as Spinner, Title, tooltip as Tooltip, useActiveTextCues, useActiveTextTrack, useChapterOptions, useChapterTitle, useTextCues } from './chunks/vidstack-BDYuUZKb.js';
-import { useMediaContext as useMediaContext$1 } from './chunks/vidstack-DP0Brh65.js';
-export { AirPlayButton, CaptionButton, FullscreenButton, Gesture, LiveButton, menu as Menu, MuteButton, PIPButton, PlayButton, radioGroup as RadioGroup, SeekButton, slider as Slider, thumbnail as Thumbnail, Time, timeSlider as TimeSlider, volumeSlider as VolumeSlider, useAudioOptions, useCaptionOptions, useMediaPlayer } from './chunks/vidstack-DP0Brh65.js';
+import { createSignal, useScoped } from './chunks/vidstack-CeHFQcBJ.js';
+export { audioGainSlider as AudioGainSlider, Captions, ChapterTitle, controls as Controls, GoogleCastButton, MediaAnnouncer, qualitySlider as QualitySlider, speedSlider as SpeedSlider, spinner as Spinner, Title, tooltip as Tooltip, useActiveTextCues, useActiveTextTrack, useChapterOptions, useChapterTitle, useTextCues } from './chunks/vidstack-CeHFQcBJ.js';
+import { useMediaContext as useMediaContext$1 } from './chunks/vidstack-CtKPQRKk.js';
+export { AirPlayButton, CaptionButton, FullscreenButton, Gesture, LiveButton, menu as Menu, MuteButton, PIPButton, PlayButton, radioGroup as RadioGroup, SeekButton, slider as Slider, thumbnail as Thumbnail, Time, timeSlider as TimeSlider, volumeSlider as VolumeSlider, useAudioOptions, useCaptionOptions, useMediaPlayer } from './chunks/vidstack-CtKPQRKk.js';
 import { Icon } from './chunks/vidstack-CBF7iUqu.js';
-export { DEFAULT_PLAYBACK_RATES, useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions } from './chunks/vidstack-glsH_65p.js';
+export { DEFAULT_PLAYBACK_RATES, useMediaRemote, usePlaybackRateOptions, useVideoQualityOptions } from './chunks/vidstack-CI9AxZNe.js';
 import '@floating-ui/dom';
 import 'react-dom';
 
diff --git a/types/vidstack-react.d.ts b/types/vidstack-react.d.ts
index 6df0de8a9e4f82d6678209506681a886881ea4c2..c81a43ff34cc1ad9927d3466d0c97ea5747bc62e 100644
--- a/types/vidstack-react.d.ts
+++ b/types/vidstack-react.d.ts
@@ -1344,7 +1344,7 @@ interface RootProps extends React.PropsWithoutRef<React.SVGProps<SVGSVGElement>>
  * </Spinner>
  * ```
  */
-declare const Root: React.ForwardRefExoticComponent<Omit<RootProps, "ref"> & React.RefAttributes<SVGElement | SVGSVGElement>>;
+declare const Root: React.ForwardRefExoticComponent<Omit<RootProps, "ref"> & React.RefAttributes<SVGSVGElement | SVGElement>>;
 interface TrackProps extends React.PropsWithoutRef<React.SVGProps<SVGCircleElement>>, React.RefAttributes<SVGCircleElement> {
 }
 declare const Track: React.ForwardRefExoticComponent<Omit<TrackProps, "ref"> & React.RefAttributes<SVGCircleElement>>;
diff --git a/types/vidstack.d.ts b/types/vidstack.d.ts
index 046e5fd304c3c2d3d24eca599cbb2b249ed97067..ea190e3f3d94892eda42cd8476567e10102d9b36 100644
--- a/types/vidstack.d.ts
+++ b/types/vidstack.d.ts
@@ -2802,6 +2802,10 @@ interface TextTrackInit {
     readonly language?: string;
 }
 declare function isTrackCaptionKind(track: TextTrack): boolean;
+declare function parseLRCCaptionsFile(lrc: string, Cue: typeof VTTCue$1, Region?: typeof VTTRegion): {
+    cues: VTTCue$1[];
+    regions: VTTRegion[];
+};
 declare function parseJSONCaptionsFile(json: string | VTTContent, Cue: typeof VTTCue$1, Region?: typeof VTTRegion): {
     regions: VTTRegion[];
     cues: VTTCue$1[];
@@ -8802,4 +8806,4 @@ type ReactEventCallbacks<E> = {
     [Type in keyof E as `on${PascalCase<Type & string>}`]?: (InferEventDetail<E[Type]> extends void ? (nativeEvent: E[Type]) => void : (detail: InferEventDetail<E[Type]>, nativeEvent: E[Type]) => void) | undefined;
 };
 
-export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButton, type AirPlayButtonEvents, type AnyMediaProvider, type AnyRecord, AudioGainSlider, type AudioGainSliderEvents, type AudioGainSliderState, type AudioMimeType, AudioProvider, AudioProviderLoader, type AudioSrc, type AudioSrcMeta, type AudioTrack, type AudioTrackAddEvent, type AudioTrackChangeEvent, AudioTrackList, type AudioTrackListEvent, type AudioTrackListEvents, type AudioTrackRemoveEvent, CaptionButton, type CaptionButtonEvents, Captions, type ChangeAudioTrackEventDetail, Component, Controls, type ControlsChangeEvent, type ControlsEvents, ControlsGroup, type DASHAdaptationSetRemovedNoCapabilitiesEvent, type DASHAllTextTracksAddedEvent, type DASHAstInFutureEvent, type DASHBaseUrlsUpdatedEvent, type DASHBufferLevelUpdatedEvent, type DASHBufferLoadedEvent, type DASHBufferStalledEvent, type DASHBufferStateChangedEvent, type DASHCanPlayEvent, type DASHCanPlayThroughEvent, type DASHCaptionContainerResizeEvent, type DASHCaptionRenderedEvent, type DASHConformanceViolationEvent, type DASHConstructor, type DASHConstructorLoader, type DASHContentSteeringRequestCompletedEvent, type DASHCueEnterEvent, type DASHCueExitEvent, type DASHDvbFontDownloadAddedEvent, type DASHDvbFontDownloadCompleteEvent, type DASHDvbFontDownloadFailedEvent, type DASHDynamicToStaticEvent, type DASHErrorEvent, type DASHEventModeOnReceiveEvent, type DASHEventModeOnStartEvent, type DASHFragmentLoadingAbandonedEvent, type DASHFragmentLoadingCompletedEvent, type DASHFragmentLoadingProgressEvent, type DASHFragmentLoadingStartedEvent, type DASHInbandPrftEvent, type DASHInstanceCallback, type DASHInstanceEvent, type DASHLibLoadErrorEvent, type DASHLibLoadStartEvent, type DASHLibLoadedEvent, type DASHLibrary, type DASHLogEvent, type DASHManagedMediaSourceEndStreamingEvent, type DASHManagedMediaSourceStartStreamingEvent, type DASHManifestLoadedEvent, type DASHManifestLoadingFinishedEvent, type DASHManifestLoadingStartedEvent, type DASHManifestValidityChangedEvent, type DASHMediaEvent, type DASHMetricAddedEvent, type DASHMetricChangedEvent, type DASHMetricUpdatedEvent, type DASHMetricsChangedEvent, type DASHMimeType, type DASHNamespace, type DASHNamespaceLoader, type DASHPeriodSwitchCompletedEvent, type DASHPeriodSwitchStartedEvent, type DASHPlaybackEndedEvent, type DASHPlaybackErrorEvent, type DASHPlaybackLoadedDataEvent, type DASHPlaybackMetaDataLoadedEvent, type DASHPlaybackNotAllowedEvent, type DASHPlaybackPausedEvent, type DASHPlaybackPlayingEvent, type DASHPlaybackProgressEvent, type DASHPlaybackRateChangedEvent, type DASHPlaybackSeekedEvent, type DASHPlaybackSeekingEvent, type DASHPlaybackStalledEvent, type DASHPlaybackStartedEvent, type DASHPlaybackTimeUpdatedEvent, type DASHPlaybackVolumeChangedEvent, type DASHPlaybackWaitingEvent, DASHProvider, type DASHProviderEvents, DASHProviderLoader, type DASHQualityChangeRenderedEvent, type DASHQualityChangeRequestedEvent, type DASHRepresentationSwitchEvent, type DASHSrc, type DASHStreamActivatedEvent, type DASHStreamDeactivatedEvent, type DASHStreamInitializedEvent, type DASHStreamInitializingEvent, type DASHStreamTeardownCompleteEvent, type DASHStreamUpdatedEvent, type DASHTextTrackAddedEvent, type DASHThroughputMeasurementStoredEvent, type DASHTrackChangeRenderedEvent, type DASHTtmlParsedEvent, type DASHTtmlToParseEvent, type DASHUnsupportedEvent, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, DEFAULT_AUDIO_GAINS, DEFAULT_PLAYBACK_RATES, type DefaultLayoutTranslations, type DefaultLayoutWord, type FileDownloadInfo, type FindMediaPlayerEvent, type FindMediaPlayerEventDetail, type FullscreenAdapter, FullscreenButton, type FullscreenButtonEvents, type FullscreenChangeEvent, FullscreenController, type FullscreenErrorEvent, type FullscreenEvents, Gesture, type GestureAction, type GestureEvent, type GestureEventType, type GestureEvents, type GestureTriggerEvent, type GestureWillTriggerEvent, GoogleCastButton, type GoogleCastButtonEvents, type GoogleCastEvent, type GoogleCastEvents, type GoogleCastLoadStartEvent, type GoogleCastLoadedEvent, GoogleCastLoader, type GoogleCastPromptError, type GoogleCastPromptErrorCode, type GoogleCastPromptErrorEvent, type GoogleCastPromptEvent, GoogleCastProvider, type HLSAudioTrackLoadedEvent, type HLSAudioTrackLoadingEvent, type HLSAudioTrackSwitchedEvent, type HLSAudioTrackSwitchingEvent, type HLSAudioTracksUpdatedEvent, type HLSBackBufferReachedEvent, type HLSBufferAppendedEvent, type HLSBufferAppendingEvent, type HLSBufferCodecsEvent, type HLSBufferCreatedEvent, type HLSBufferEosEvent, type HLSBufferFlushedEvent, type HLSBufferFlushingEvent, type HLSBufferResetEvent, type HLSConstructor, type HLSConstructorLoader, type HLSCuesParsedEvent, type HLSDestroyingEvent, type HLSErrorEvent, type HLSFpsDropEvent, type HLSFpsDropLevelCappingEvent, type HLSFragBufferedDataEvent, type HLSFragChangedEvent, type HLSFragDecryptedEvent, type HLSFragLoadEmergencyAbortedEvent, type HLSFragLoadedEvent, type HLSFragLoadingEvent, type HLSFragParsedEvent, type HLSFragParsingInitSegmentEvent, type HLSFragParsingMetadataEvent, type HLSFragParsingUserdataEvent, type HLSInitPtsFoundEvent, type HLSInstanceCallback, type HLSInstanceEvent, type HLSKeyLoadedEvent, type HLSKeyLoadingEvent, type HLSLevelLoadedEvent, type HLSLevelLoadingEvent, type HLSLevelPtsUpdatedEvent, type HLSLevelSwitchedEvent, type HLSLevelSwitchingEvent, type HLSLevelUpdatedEvent, type HLSLevelsUpdatedEvent, type HLSLibLoadErrorEvent, type HLSLibLoadStartEvent, type HLSLibLoadedEvent, type HLSLibrary, type HLSManifestLoadedEvent, type HLSManifestLoadingEvent, type HLSManifestParsedEvent, type HLSMediaAttachedEvent, type HLSMediaAttachingEvent, type HLSMediaDetachedEvent, type HLSMediaDetachingEvent, type HLSMediaEvent, type HLSMimeType, type HLSNonNativeTextTracksFoundEvent, HLSProvider, type HLSProviderEvents, HLSProviderLoader, type HLSSrc, type HLSSubtitleFragProcessedEvent, type HLSSubtitleTrackLoadedEvent, type HLSSubtitleTrackLoadingEvent, type HLSSubtitleTrackSwitchEvent, type HLSSubtitleTracksClearedEvent, type HLSSubtitleTracksUpdatedEvent, type HLSUnsupportedEvent, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, type HTMLMediaSrc, type LibASSConfig, type LibASSConstructor, type LibASSErrorEvent, type LibASSInstance, type LibASSInstanceEvents, type LibASSModuleLoader, type LibASSReadyEvent, LibASSTextRenderer, List, type ListAddEvent, type ListEvents, type ListItem, type ListReadonlyChangeEvent, type ListRemoveEvent, LiveButton, LocalMediaStorage, type LogEvent, type LogEventDetail, Logger, type LoggerEvents, MEDIA_KEY_SHORTCUTS, type MediaAbortEvent, type MediaAirPlayRequestEvent, MediaAnnouncer, type MediaAnnouncerEvents, type MediaAnnouncerState, type MediaAnnouncerTranslations, type MediaAnnouncerWord, type MediaAudioGainChangeEvent, type MediaAudioGainChangeRequestEvent, type MediaAudioTrackChangeEvent, type MediaAudioTrackChangeRequestEvent, type MediaAudioTracksChangeEvent, type MediaAutoPlayChangeEvent, type MediaAutoPlayEvent, type MediaAutoPlayEventDetail, type MediaAutoPlayFailEvent, type MediaAutoPlayFailEventDetail, type MediaCanLoadEvent, type MediaCanLoadPosterEvent, type MediaCanPlayDetail, type MediaCanPlayEvent, type MediaCanPlayThroughEvent, type MediaClipEndChangeRequestEvent, type MediaClipStartChangeRequestEvent, type MediaContext, MediaControls, type MediaControlsChangeEvent, type MediaCrossOrigin, type MediaDestroyEvent, type MediaDurationChangeEvent, type MediaDurationChangeRequestEvent, type MediaEmptiedEvent, type MediaEndEvent, type MediaEndedEvent, type MediaEnterFullscreenRequestEvent, type MediaEnterPIPRequestEvent, type MediaErrorCode, type MediaErrorDetail, type MediaErrorEvent, type MediaEvent, type MediaEvents, type MediaExitFullscreenRequestEvent, type MediaExitPIPRequestEvent, type MediaFullscreenAdapter, type MediaFullscreenChangeEvent, type MediaFullscreenErrorEvent, type MediaFullscreenRequestTarget, type MediaGoogleCastRequestEvent, type MediaHidePosterRequestEvent, type MediaKeyShortcut, type MediaKeyShortcuts, type MediaKeyTarget, type MediaKeysCallback, type MediaLiveChangeEvent, type MediaLiveEdgeChangeEvent, type MediaLiveEdgeRequestEvent, type MediaLoadStartEvent, type MediaLoadedDataEvent, type MediaLoadedMetadataEvent, type MediaLoadingStrategy, type MediaLoopChangeEvent, type MediaLoopRequestEvent, type MediaMuteRequestEvent, type MediaOrientationChangeEvent, type MediaOrientationLockRequestEvent, type MediaOrientationUnlockRequestEvent, type MediaPIPChangeEvent, type MediaPIPErrorEvent, type MediaPauseControlsRequestEvent, type MediaPauseEvent, type MediaPauseRequestEvent, type MediaPlayEvent, type MediaPlayFailEvent, type MediaPlayRequestEvent, MediaPlayer, type MediaPlayerConnectEvent, type MediaPlayerEvents, type MediaPlayerQuery, type MediaPlayerState, type MediaPlayingEvent, type MediaPlaysInlineChangeEvent, type MediaPosterChangeEvent, type MediaPosterLoadingStrategy, type MediaPosterStartLoadingRequestEvent, type MediaProgressEvent, type MediaProgressEventDetail, MediaProvider, type MediaProviderAdapter, type MediaProviderChangeEvent, type MediaProviderLoader, type MediaProviderLoaderChangeEvent, type MediaProviderSetupEvent, type MediaProviderState, type MediaQualitiesChangeEvent, type MediaQualityChangeEvent, type MediaQualityChangeRequestEvent, type MediaRateChangeEvent, type MediaRateChangeRequestEvent, MediaRemoteControl, type MediaRemotePlaybackChangeEvent, type MediaRemotePlaybackChangeEventDetail, type MediaReplayEvent, type MediaRequestEvents, type MediaResumeControlsRequestEvent, type MediaSeekRequestEvent, type MediaSeekedEvent, type MediaSeekingEvent, type MediaSeekingRequestEvent, type MediaShowPosterRequestEvent, type MediaSourceChangeEvent, type MediaSourcesChangeEvent, type MediaSrc, type MediaSrcObject, type MediaStalledEvent, type MediaStartLoadingRequestEvent, type MediaStartedEvent, type MediaState, type MediaStateAccessors, type MediaStorage, type MediaStore, type MediaStreamType, type MediaStreamTypeChangeEvent, type MediaSuspendEvent, type MediaTextTrackChangeEvent, type MediaTextTrackChangeRequestEvent, type MediaTextTracksChangeEvent, type MediaTimeChangeEvent, type MediaTimeUpdateEvent, type MediaTimeUpdateEventDetail, type MediaTitleChangeEvent, type MediaType, type MediaTypeChangeEvent, type MediaUnmuteRequestEvent, type MediaUserEvents, type MediaUserLoopChangeRequestEvent, type MediaViewType, type MediaViewTypeChangeEvent, type MediaVolumeChange, type MediaVolumeChangeEvent, type MediaVolumeChangeRequestEvent, type MediaWaitingEvent, Menu, MenuButton, MenuItem, MenuItems, type MenuPlacement, type MenuPlacementAlign, type MenuPlacementSide, MenuPortal, MuteButton, type MuteButtonEvents, PIPButton, type PIPButtonEvents, PlayButton, type PlayButtonEvents, type PlayerSrc, type PlayerStore, type PlyrControl, type PlyrLayoutTranslations, type PlyrLayoutWord, type PlyrMarker, Poster, type PosterState, QualitySlider, type QualitySliderEvents, type QualitySliderState, Radio, type RadioChangeEvent, RadioGroup, type RadioSelectEvent, type ReactElementProps, type ReactProps, type ReadSignal, type RemotePlaybackInfo, type RemotePlaybackType, type Scope, type ScreenOrientationChangeEvent, type ScreenOrientationChangeEventDetail, ScreenOrientationController, type ScreenOrientationEvents, type ScreenOrientationLockType, type ScreenOrientationType, SeekButton, type SeekButtonEvents, type SerializedVideoQuality, Slider, type SliderCSSVars, SliderChapters, type SliderDragEndEvent, type SliderDragStartEvent, type SliderDragValueChangeEvent, type SliderEvent, type SliderEvents, type SliderOrientation, type SliderPointerValueChangeEvent, SliderPreview, type SliderState, SliderThumbnail, SliderValue, type SliderValueChangeEvent, SliderVideo, type SliderVideoCanPlayEvent, type SliderVideoErrorEvent, type SliderVideoEvents, type SliderVideoState, SpeedSlider, type SpeedSliderEvents, type SpeedSliderState, type Src, State, type TextRenderer, TextRenderers, TextTrack, type TextTrackAddCueEvent, type TextTrackAddEvent, type TextTrackCueChangeEvent, type TextTrackErrorEvent, type TextTrackEvent, type TextTrackEvents, type TextTrackInit, TextTrackList, type TextTrackListEvent, type TextTrackListEvents, type TextTrackListModeChangeEvent, type TextTrackLoadEvent, type TextTrackLoadStartEvent, type TextTrackModeChangeEvent, type TextTrackReadyState, type TextTrackRemoveCueEvent, type TextTrackRemoveEvent, Thumbnail, type ThumbnailImage, type ThumbnailSrc, type ThumbnailState, Time, type TimeInterval, TimeRange, TimeSlider, type TimeSliderEvents, type TimeSliderState, type TimeState, ToggleButton, Tooltip, TooltipContent, type TooltipPlacement, type TooltipPlacementAlign, type TooltipPlacementSide, TooltipTrigger, VIDEO_EXTENSIONS, VIDEO_TYPES, type VTTContent, type VTTCueInit, type VTTRegionInit, type VideoMimeType, type VideoPresentationChangeEvent, type VideoPresentationEvents, VideoProvider, VideoProviderLoader, type VideoQuality, type VideoQualityAddEvent, type VideoQualityAutoChangeEvent, type VideoQualityChangeEvent, type VideoQualityChangeEventDetail, VideoQualityList, type VideoQualityListEvent, type VideoQualityListEvents, type VideoQualityRemoveEvent, type VideoSrc, type VideoSrcMeta, VimeoProvider, VimeoProviderLoader, type VimeoSrc, VolumeSlider, type VolumeSliderEvents, type VolumeSliderState, type WriteSignal, YouTubeProvider, YouTubeProviderLoader, type YouTubeSrc, appendTriggerEvent, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, findTriggerEvent, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, hasTriggerEvent, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isKeyboardClick, isKeyboardEvent, isMediaStream, isPointerEvent, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, mediaContext, mediaState, normalizeTimeIntervals, parseJSONCaptionsFile, sliderState, softResetMediaState, sortVideoQualities, updateTimeIntervals, walkTriggerEventChain, watchActiveTextTrack, watchCueTextChange };
+export { ARIAKeyShortcuts, AUDIO_EXTENSIONS, AUDIO_TYPES, AirPlayButton, type AirPlayButtonEvents, type AnyMediaProvider, type AnyRecord, AudioGainSlider, type AudioGainSliderEvents, type AudioGainSliderState, type AudioMimeType, AudioProvider, AudioProviderLoader, type AudioSrc, type AudioSrcMeta, type AudioTrack, type AudioTrackAddEvent, type AudioTrackChangeEvent, AudioTrackList, type AudioTrackListEvent, type AudioTrackListEvents, type AudioTrackRemoveEvent, CaptionButton, type CaptionButtonEvents, Captions, type ChangeAudioTrackEventDetail, Component, Controls, type ControlsChangeEvent, type ControlsEvents, ControlsGroup, type DASHAdaptationSetRemovedNoCapabilitiesEvent, type DASHAllTextTracksAddedEvent, type DASHAstInFutureEvent, type DASHBaseUrlsUpdatedEvent, type DASHBufferLevelUpdatedEvent, type DASHBufferLoadedEvent, type DASHBufferStalledEvent, type DASHBufferStateChangedEvent, type DASHCanPlayEvent, type DASHCanPlayThroughEvent, type DASHCaptionContainerResizeEvent, type DASHCaptionRenderedEvent, type DASHConformanceViolationEvent, type DASHConstructor, type DASHConstructorLoader, type DASHContentSteeringRequestCompletedEvent, type DASHCueEnterEvent, type DASHCueExitEvent, type DASHDvbFontDownloadAddedEvent, type DASHDvbFontDownloadCompleteEvent, type DASHDvbFontDownloadFailedEvent, type DASHDynamicToStaticEvent, type DASHErrorEvent, type DASHEventModeOnReceiveEvent, type DASHEventModeOnStartEvent, type DASHFragmentLoadingAbandonedEvent, type DASHFragmentLoadingCompletedEvent, type DASHFragmentLoadingProgressEvent, type DASHFragmentLoadingStartedEvent, type DASHInbandPrftEvent, type DASHInstanceCallback, type DASHInstanceEvent, type DASHLibLoadErrorEvent, type DASHLibLoadStartEvent, type DASHLibLoadedEvent, type DASHLibrary, type DASHLogEvent, type DASHManagedMediaSourceEndStreamingEvent, type DASHManagedMediaSourceStartStreamingEvent, type DASHManifestLoadedEvent, type DASHManifestLoadingFinishedEvent, type DASHManifestLoadingStartedEvent, type DASHManifestValidityChangedEvent, type DASHMediaEvent, type DASHMetricAddedEvent, type DASHMetricChangedEvent, type DASHMetricUpdatedEvent, type DASHMetricsChangedEvent, type DASHMimeType, type DASHNamespace, type DASHNamespaceLoader, type DASHPeriodSwitchCompletedEvent, type DASHPeriodSwitchStartedEvent, type DASHPlaybackEndedEvent, type DASHPlaybackErrorEvent, type DASHPlaybackLoadedDataEvent, type DASHPlaybackMetaDataLoadedEvent, type DASHPlaybackNotAllowedEvent, type DASHPlaybackPausedEvent, type DASHPlaybackPlayingEvent, type DASHPlaybackProgressEvent, type DASHPlaybackRateChangedEvent, type DASHPlaybackSeekedEvent, type DASHPlaybackSeekingEvent, type DASHPlaybackStalledEvent, type DASHPlaybackStartedEvent, type DASHPlaybackTimeUpdatedEvent, type DASHPlaybackVolumeChangedEvent, type DASHPlaybackWaitingEvent, DASHProvider, type DASHProviderEvents, DASHProviderLoader, type DASHQualityChangeRenderedEvent, type DASHQualityChangeRequestedEvent, type DASHRepresentationSwitchEvent, type DASHSrc, type DASHStreamActivatedEvent, type DASHStreamDeactivatedEvent, type DASHStreamInitializedEvent, type DASHStreamInitializingEvent, type DASHStreamTeardownCompleteEvent, type DASHStreamUpdatedEvent, type DASHTextTrackAddedEvent, type DASHThroughputMeasurementStoredEvent, type DASHTrackChangeRenderedEvent, type DASHTtmlParsedEvent, type DASHTtmlToParseEvent, type DASHUnsupportedEvent, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, DEFAULT_AUDIO_GAINS, DEFAULT_PLAYBACK_RATES, type DefaultLayoutTranslations, type DefaultLayoutWord, type FileDownloadInfo, type FindMediaPlayerEvent, type FindMediaPlayerEventDetail, type FullscreenAdapter, FullscreenButton, type FullscreenButtonEvents, type FullscreenChangeEvent, FullscreenController, type FullscreenErrorEvent, type FullscreenEvents, Gesture, type GestureAction, type GestureEvent, type GestureEventType, type GestureEvents, type GestureTriggerEvent, type GestureWillTriggerEvent, GoogleCastButton, type GoogleCastButtonEvents, type GoogleCastEvent, type GoogleCastEvents, type GoogleCastLoadStartEvent, type GoogleCastLoadedEvent, GoogleCastLoader, type GoogleCastPromptError, type GoogleCastPromptErrorCode, type GoogleCastPromptErrorEvent, type GoogleCastPromptEvent, GoogleCastProvider, type HLSAudioTrackLoadedEvent, type HLSAudioTrackLoadingEvent, type HLSAudioTrackSwitchedEvent, type HLSAudioTrackSwitchingEvent, type HLSAudioTracksUpdatedEvent, type HLSBackBufferReachedEvent, type HLSBufferAppendedEvent, type HLSBufferAppendingEvent, type HLSBufferCodecsEvent, type HLSBufferCreatedEvent, type HLSBufferEosEvent, type HLSBufferFlushedEvent, type HLSBufferFlushingEvent, type HLSBufferResetEvent, type HLSConstructor, type HLSConstructorLoader, type HLSCuesParsedEvent, type HLSDestroyingEvent, type HLSErrorEvent, type HLSFpsDropEvent, type HLSFpsDropLevelCappingEvent, type HLSFragBufferedDataEvent, type HLSFragChangedEvent, type HLSFragDecryptedEvent, type HLSFragLoadEmergencyAbortedEvent, type HLSFragLoadedEvent, type HLSFragLoadingEvent, type HLSFragParsedEvent, type HLSFragParsingInitSegmentEvent, type HLSFragParsingMetadataEvent, type HLSFragParsingUserdataEvent, type HLSInitPtsFoundEvent, type HLSInstanceCallback, type HLSInstanceEvent, type HLSKeyLoadedEvent, type HLSKeyLoadingEvent, type HLSLevelLoadedEvent, type HLSLevelLoadingEvent, type HLSLevelPtsUpdatedEvent, type HLSLevelSwitchedEvent, type HLSLevelSwitchingEvent, type HLSLevelUpdatedEvent, type HLSLevelsUpdatedEvent, type HLSLibLoadErrorEvent, type HLSLibLoadStartEvent, type HLSLibLoadedEvent, type HLSLibrary, type HLSManifestLoadedEvent, type HLSManifestLoadingEvent, type HLSManifestParsedEvent, type HLSMediaAttachedEvent, type HLSMediaAttachingEvent, type HLSMediaDetachedEvent, type HLSMediaDetachingEvent, type HLSMediaEvent, type HLSMimeType, type HLSNonNativeTextTracksFoundEvent, HLSProvider, type HLSProviderEvents, HLSProviderLoader, type HLSSrc, type HLSSubtitleFragProcessedEvent, type HLSSubtitleTrackLoadedEvent, type HLSSubtitleTrackLoadingEvent, type HLSSubtitleTrackSwitchEvent, type HLSSubtitleTracksClearedEvent, type HLSSubtitleTracksUpdatedEvent, type HLSUnsupportedEvent, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, type HTMLMediaSrc, type LibASSConfig, type LibASSConstructor, type LibASSErrorEvent, type LibASSInstance, type LibASSInstanceEvents, type LibASSModuleLoader, type LibASSReadyEvent, LibASSTextRenderer, List, type ListAddEvent, type ListEvents, type ListItem, type ListReadonlyChangeEvent, type ListRemoveEvent, LiveButton, LocalMediaStorage, type LogEvent, type LogEventDetail, Logger, type LoggerEvents, MEDIA_KEY_SHORTCUTS, type MediaAbortEvent, type MediaAirPlayRequestEvent, MediaAnnouncer, type MediaAnnouncerEvents, type MediaAnnouncerState, type MediaAnnouncerTranslations, type MediaAnnouncerWord, type MediaAudioGainChangeEvent, type MediaAudioGainChangeRequestEvent, type MediaAudioTrackChangeEvent, type MediaAudioTrackChangeRequestEvent, type MediaAudioTracksChangeEvent, type MediaAutoPlayChangeEvent, type MediaAutoPlayEvent, type MediaAutoPlayEventDetail, type MediaAutoPlayFailEvent, type MediaAutoPlayFailEventDetail, type MediaCanLoadEvent, type MediaCanLoadPosterEvent, type MediaCanPlayDetail, type MediaCanPlayEvent, type MediaCanPlayThroughEvent, type MediaClipEndChangeRequestEvent, type MediaClipStartChangeRequestEvent, type MediaContext, MediaControls, type MediaControlsChangeEvent, type MediaCrossOrigin, type MediaDestroyEvent, type MediaDurationChangeEvent, type MediaDurationChangeRequestEvent, type MediaEmptiedEvent, type MediaEndEvent, type MediaEndedEvent, type MediaEnterFullscreenRequestEvent, type MediaEnterPIPRequestEvent, type MediaErrorCode, type MediaErrorDetail, type MediaErrorEvent, type MediaEvent, type MediaEvents, type MediaExitFullscreenRequestEvent, type MediaExitPIPRequestEvent, type MediaFullscreenAdapter, type MediaFullscreenChangeEvent, type MediaFullscreenErrorEvent, type MediaFullscreenRequestTarget, type MediaGoogleCastRequestEvent, type MediaHidePosterRequestEvent, type MediaKeyShortcut, type MediaKeyShortcuts, type MediaKeyTarget, type MediaKeysCallback, type MediaLiveChangeEvent, type MediaLiveEdgeChangeEvent, type MediaLiveEdgeRequestEvent, type MediaLoadStartEvent, type MediaLoadedDataEvent, type MediaLoadedMetadataEvent, type MediaLoadingStrategy, type MediaLoopChangeEvent, type MediaLoopRequestEvent, type MediaMuteRequestEvent, type MediaOrientationChangeEvent, type MediaOrientationLockRequestEvent, type MediaOrientationUnlockRequestEvent, type MediaPIPChangeEvent, type MediaPIPErrorEvent, type MediaPauseControlsRequestEvent, type MediaPauseEvent, type MediaPauseRequestEvent, type MediaPlayEvent, type MediaPlayFailEvent, type MediaPlayRequestEvent, MediaPlayer, type MediaPlayerConnectEvent, type MediaPlayerEvents, type MediaPlayerQuery, type MediaPlayerState, type MediaPlayingEvent, type MediaPlaysInlineChangeEvent, type MediaPosterChangeEvent, type MediaPosterLoadingStrategy, type MediaPosterStartLoadingRequestEvent, type MediaProgressEvent, type MediaProgressEventDetail, MediaProvider, type MediaProviderAdapter, type MediaProviderChangeEvent, type MediaProviderLoader, type MediaProviderLoaderChangeEvent, type MediaProviderSetupEvent, type MediaProviderState, type MediaQualitiesChangeEvent, type MediaQualityChangeEvent, type MediaQualityChangeRequestEvent, type MediaRateChangeEvent, type MediaRateChangeRequestEvent, MediaRemoteControl, type MediaRemotePlaybackChangeEvent, type MediaRemotePlaybackChangeEventDetail, type MediaReplayEvent, type MediaRequestEvents, type MediaResumeControlsRequestEvent, type MediaSeekRequestEvent, type MediaSeekedEvent, type MediaSeekingEvent, type MediaSeekingRequestEvent, type MediaShowPosterRequestEvent, type MediaSourceChangeEvent, type MediaSourcesChangeEvent, type MediaSrc, type MediaSrcObject, type MediaStalledEvent, type MediaStartLoadingRequestEvent, type MediaStartedEvent, type MediaState, type MediaStateAccessors, type MediaStorage, type MediaStore, type MediaStreamType, type MediaStreamTypeChangeEvent, type MediaSuspendEvent, type MediaTextTrackChangeEvent, type MediaTextTrackChangeRequestEvent, type MediaTextTracksChangeEvent, type MediaTimeChangeEvent, type MediaTimeUpdateEvent, type MediaTimeUpdateEventDetail, type MediaTitleChangeEvent, type MediaType, type MediaTypeChangeEvent, type MediaUnmuteRequestEvent, type MediaUserEvents, type MediaUserLoopChangeRequestEvent, type MediaViewType, type MediaViewTypeChangeEvent, type MediaVolumeChange, type MediaVolumeChangeEvent, type MediaVolumeChangeRequestEvent, type MediaWaitingEvent, Menu, MenuButton, MenuItem, MenuItems, type MenuPlacement, type MenuPlacementAlign, type MenuPlacementSide, MenuPortal, MuteButton, type MuteButtonEvents, PIPButton, type PIPButtonEvents, PlayButton, type PlayButtonEvents, type PlayerSrc, type PlayerStore, type PlyrControl, type PlyrLayoutTranslations, type PlyrLayoutWord, type PlyrMarker, Poster, type PosterState, QualitySlider, type QualitySliderEvents, type QualitySliderState, Radio, type RadioChangeEvent, RadioGroup, type RadioSelectEvent, type ReactElementProps, type ReactProps, type ReadSignal, type RemotePlaybackInfo, type RemotePlaybackType, type Scope, type ScreenOrientationChangeEvent, type ScreenOrientationChangeEventDetail, ScreenOrientationController, type ScreenOrientationEvents, type ScreenOrientationLockType, type ScreenOrientationType, SeekButton, type SeekButtonEvents, type SerializedVideoQuality, Slider, type SliderCSSVars, SliderChapters, type SliderDragEndEvent, type SliderDragStartEvent, type SliderDragValueChangeEvent, type SliderEvent, type SliderEvents, type SliderOrientation, type SliderPointerValueChangeEvent, SliderPreview, type SliderState, SliderThumbnail, SliderValue, type SliderValueChangeEvent, SliderVideo, type SliderVideoCanPlayEvent, type SliderVideoErrorEvent, type SliderVideoEvents, type SliderVideoState, SpeedSlider, type SpeedSliderEvents, type SpeedSliderState, type Src, State, type TextRenderer, TextRenderers, TextTrack, type TextTrackAddCueEvent, type TextTrackAddEvent, type TextTrackCueChangeEvent, type TextTrackErrorEvent, type TextTrackEvent, type TextTrackEvents, type TextTrackInit, TextTrackList, type TextTrackListEvent, type TextTrackListEvents, type TextTrackListModeChangeEvent, type TextTrackLoadEvent, type TextTrackLoadStartEvent, type TextTrackModeChangeEvent, type TextTrackReadyState, type TextTrackRemoveCueEvent, type TextTrackRemoveEvent, Thumbnail, type ThumbnailImage, type ThumbnailSrc, type ThumbnailState, Time, type TimeInterval, TimeRange, TimeSlider, type TimeSliderEvents, type TimeSliderState, type TimeState, ToggleButton, Tooltip, TooltipContent, type TooltipPlacement, type TooltipPlacementAlign, type TooltipPlacementSide, TooltipTrigger, VIDEO_EXTENSIONS, VIDEO_TYPES, type VTTContent, type VTTCueInit, type VTTRegionInit, type VideoMimeType, type VideoPresentationChangeEvent, type VideoPresentationEvents, VideoProvider, VideoProviderLoader, type VideoQuality, type VideoQualityAddEvent, type VideoQualityAutoChangeEvent, type VideoQualityChangeEvent, type VideoQualityChangeEventDetail, VideoQualityList, type VideoQualityListEvent, type VideoQualityListEvents, type VideoQualityRemoveEvent, type VideoSrc, type VideoSrcMeta, VimeoProvider, VimeoProviderLoader, type VimeoSrc, VolumeSlider, type VolumeSliderEvents, type VolumeSliderState, type WriteSignal, YouTubeProvider, YouTubeProviderLoader, type YouTubeSrc, appendTriggerEvent, boundTime, canChangeVolume, canFullscreen, canGoogleCastSrc, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, findTriggerEvent, formatSpokenTime, formatTime, getDownloadFile, getTimeRangesEnd, getTimeRangesStart, hasTriggerEvent, isAudioProvider, isAudioSrc, isCueActive, isDASHProvider, isDASHSrc, isGoogleCastProvider, isHLSProvider, isHLSSrc, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isKeyboardClick, isKeyboardEvent, isMediaStream, isPointerEvent, isTrackCaptionKind, isVideoProvider, isVideoQualitySrc, isVideoSrc, isVimeoProvider, isYouTubeProvider, mediaContext, mediaState, normalizeTimeIntervals, parseJSONCaptionsFile, parseLRCCaptionsFile, sliderState, softResetMediaState, sortVideoQualities, updateTimeIntervals, walkTriggerEventChain, watchActiveTextTrack, watchCueTextChange };
